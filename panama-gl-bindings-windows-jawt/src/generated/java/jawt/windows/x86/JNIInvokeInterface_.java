// Generated by jextract

package jawt.windows.x86;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class JNIInvokeInterface_ {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("reserved0"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved1"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved2"),
        Constants$root.C_POINTER$LAYOUT.withName("DestroyJavaVM"),
        Constants$root.C_POINTER$LAYOUT.withName("AttachCurrentThread"),
        Constants$root.C_POINTER$LAYOUT.withName("DetachCurrentThread"),
        Constants$root.C_POINTER$LAYOUT.withName("GetEnv"),
        Constants$root.C_POINTER$LAYOUT.withName("AttachCurrentThreadAsDaemon")
    ).withName("JNIInvokeInterface_");
    public static MemoryLayout $LAYOUT() {
        return JNIInvokeInterface_.$struct$LAYOUT;
    }
    static final VarHandle reserved0$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved0"));
    public static VarHandle reserved0$VH() {
        return JNIInvokeInterface_.reserved0$VH;
    }
    public static MemoryAddress reserved0$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.reserved0$VH.get(seg);
    }
    public static void reserved0$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.reserved0$VH.set(seg, x);
    }
    public static MemoryAddress reserved0$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.reserved0$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved0$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.reserved0$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle reserved1$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved1"));
    public static VarHandle reserved1$VH() {
        return JNIInvokeInterface_.reserved1$VH;
    }
    public static MemoryAddress reserved1$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.reserved1$VH.get(seg);
    }
    public static void reserved1$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.reserved1$VH.set(seg, x);
    }
    public static MemoryAddress reserved1$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.reserved1$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved1$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.reserved1$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle reserved2$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved2"));
    public static VarHandle reserved2$VH() {
        return JNIInvokeInterface_.reserved2$VH;
    }
    public static MemoryAddress reserved2$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.reserved2$VH.get(seg);
    }
    public static void reserved2$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.reserved2$VH.set(seg, x);
    }
    public static MemoryAddress reserved2$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.reserved2$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved2$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.reserved2$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor DestroyJavaVM$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DestroyJavaVM$MH = RuntimeHelper.downcallHandle(
        JNIInvokeInterface_.DestroyJavaVM$FUNC
    );
    public interface DestroyJavaVM {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(DestroyJavaVM fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DestroyJavaVM.class, fi, JNIInvokeInterface_.DestroyJavaVM$FUNC, session);
        }
        static DestroyJavaVM ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)JNIInvokeInterface_.DestroyJavaVM$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DestroyJavaVM$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DestroyJavaVM"));
    public static VarHandle DestroyJavaVM$VH() {
        return JNIInvokeInterface_.DestroyJavaVM$VH;
    }
    public static MemoryAddress DestroyJavaVM$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.DestroyJavaVM$VH.get(seg);
    }
    public static void DestroyJavaVM$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.DestroyJavaVM$VH.set(seg, x);
    }
    public static MemoryAddress DestroyJavaVM$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.DestroyJavaVM$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DestroyJavaVM$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.DestroyJavaVM$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DestroyJavaVM DestroyJavaVM (MemorySegment segment, MemorySession session) {
        return DestroyJavaVM.ofAddress(DestroyJavaVM$get(segment), session);
    }
    static final FunctionDescriptor AttachCurrentThread$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AttachCurrentThread$MH = RuntimeHelper.downcallHandle(
        JNIInvokeInterface_.AttachCurrentThread$FUNC
    );
    public interface AttachCurrentThread {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(AttachCurrentThread fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AttachCurrentThread.class, fi, JNIInvokeInterface_.AttachCurrentThread$FUNC, session);
        }
        static AttachCurrentThread ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)JNIInvokeInterface_.AttachCurrentThread$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AttachCurrentThread$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AttachCurrentThread"));
    public static VarHandle AttachCurrentThread$VH() {
        return JNIInvokeInterface_.AttachCurrentThread$VH;
    }
    public static MemoryAddress AttachCurrentThread$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.AttachCurrentThread$VH.get(seg);
    }
    public static void AttachCurrentThread$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.AttachCurrentThread$VH.set(seg, x);
    }
    public static MemoryAddress AttachCurrentThread$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.AttachCurrentThread$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AttachCurrentThread$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.AttachCurrentThread$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AttachCurrentThread AttachCurrentThread (MemorySegment segment, MemorySession session) {
        return AttachCurrentThread.ofAddress(AttachCurrentThread$get(segment), session);
    }
    static final FunctionDescriptor DetachCurrentThread$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DetachCurrentThread$MH = RuntimeHelper.downcallHandle(
        JNIInvokeInterface_.DetachCurrentThread$FUNC
    );
    public interface DetachCurrentThread {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(DetachCurrentThread fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DetachCurrentThread.class, fi, JNIInvokeInterface_.DetachCurrentThread$FUNC, session);
        }
        static DetachCurrentThread ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)JNIInvokeInterface_.DetachCurrentThread$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DetachCurrentThread$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DetachCurrentThread"));
    public static VarHandle DetachCurrentThread$VH() {
        return JNIInvokeInterface_.DetachCurrentThread$VH;
    }
    public static MemoryAddress DetachCurrentThread$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.DetachCurrentThread$VH.get(seg);
    }
    public static void DetachCurrentThread$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.DetachCurrentThread$VH.set(seg, x);
    }
    public static MemoryAddress DetachCurrentThread$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.DetachCurrentThread$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DetachCurrentThread$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.DetachCurrentThread$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DetachCurrentThread DetachCurrentThread (MemorySegment segment, MemorySession session) {
        return DetachCurrentThread.ofAddress(DetachCurrentThread$get(segment), session);
    }
    static final FunctionDescriptor GetEnv$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle GetEnv$MH = RuntimeHelper.downcallHandle(
        JNIInvokeInterface_.GetEnv$FUNC
    );
    public interface GetEnv {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2);
        static MemorySegment allocate(GetEnv fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetEnv.class, fi, JNIInvokeInterface_.GetEnv$FUNC, session);
        }
        static GetEnv ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2) -> {
                try {
                    return (int)JNIInvokeInterface_.GetEnv$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetEnv$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetEnv"));
    public static VarHandle GetEnv$VH() {
        return JNIInvokeInterface_.GetEnv$VH;
    }
    public static MemoryAddress GetEnv$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.GetEnv$VH.get(seg);
    }
    public static void GetEnv$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.GetEnv$VH.set(seg, x);
    }
    public static MemoryAddress GetEnv$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.GetEnv$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetEnv$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.GetEnv$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetEnv GetEnv (MemorySegment segment, MemorySession session) {
        return GetEnv.ofAddress(GetEnv$get(segment), session);
    }
    static final FunctionDescriptor AttachCurrentThreadAsDaemon$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AttachCurrentThreadAsDaemon$MH = RuntimeHelper.downcallHandle(
        JNIInvokeInterface_.AttachCurrentThreadAsDaemon$FUNC
    );
    public interface AttachCurrentThreadAsDaemon {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(AttachCurrentThreadAsDaemon fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AttachCurrentThreadAsDaemon.class, fi, JNIInvokeInterface_.AttachCurrentThreadAsDaemon$FUNC, session);
        }
        static AttachCurrentThreadAsDaemon ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)JNIInvokeInterface_.AttachCurrentThreadAsDaemon$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AttachCurrentThreadAsDaemon$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AttachCurrentThreadAsDaemon"));
    public static VarHandle AttachCurrentThreadAsDaemon$VH() {
        return JNIInvokeInterface_.AttachCurrentThreadAsDaemon$VH;
    }
    public static MemoryAddress AttachCurrentThreadAsDaemon$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.AttachCurrentThreadAsDaemon$VH.get(seg);
    }
    public static void AttachCurrentThreadAsDaemon$set( MemorySegment seg, MemoryAddress x) {
        JNIInvokeInterface_.AttachCurrentThreadAsDaemon$VH.set(seg, x);
    }
    public static MemoryAddress AttachCurrentThreadAsDaemon$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNIInvokeInterface_.AttachCurrentThreadAsDaemon$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AttachCurrentThreadAsDaemon$set(MemorySegment seg, long index, MemoryAddress x) {
        JNIInvokeInterface_.AttachCurrentThreadAsDaemon$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AttachCurrentThreadAsDaemon AttachCurrentThreadAsDaemon (MemorySegment segment, MemorySession session) {
        return AttachCurrentThreadAsDaemon.ofAddress(AttachCurrentThreadAsDaemon$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


