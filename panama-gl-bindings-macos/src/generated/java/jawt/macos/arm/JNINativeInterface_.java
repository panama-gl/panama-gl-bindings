// Generated by jextract

package jawt.macos.arm;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class JNINativeInterface_ {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("reserved0"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved1"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved2"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved3"),
        Constants$root.C_POINTER$LAYOUT.withName("GetVersion"),
        Constants$root.C_POINTER$LAYOUT.withName("DefineClass"),
        Constants$root.C_POINTER$LAYOUT.withName("FindClass"),
        Constants$root.C_POINTER$LAYOUT.withName("FromReflectedMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("FromReflectedField"),
        Constants$root.C_POINTER$LAYOUT.withName("ToReflectedMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("GetSuperclass"),
        Constants$root.C_POINTER$LAYOUT.withName("IsAssignableFrom"),
        Constants$root.C_POINTER$LAYOUT.withName("ToReflectedField"),
        Constants$root.C_POINTER$LAYOUT.withName("Throw"),
        Constants$root.C_POINTER$LAYOUT.withName("ThrowNew"),
        Constants$root.C_POINTER$LAYOUT.withName("ExceptionOccurred"),
        Constants$root.C_POINTER$LAYOUT.withName("ExceptionDescribe"),
        Constants$root.C_POINTER$LAYOUT.withName("ExceptionClear"),
        Constants$root.C_POINTER$LAYOUT.withName("FatalError"),
        Constants$root.C_POINTER$LAYOUT.withName("PushLocalFrame"),
        Constants$root.C_POINTER$LAYOUT.withName("PopLocalFrame"),
        Constants$root.C_POINTER$LAYOUT.withName("NewGlobalRef"),
        Constants$root.C_POINTER$LAYOUT.withName("DeleteGlobalRef"),
        Constants$root.C_POINTER$LAYOUT.withName("DeleteLocalRef"),
        Constants$root.C_POINTER$LAYOUT.withName("IsSameObject"),
        Constants$root.C_POINTER$LAYOUT.withName("NewLocalRef"),
        Constants$root.C_POINTER$LAYOUT.withName("EnsureLocalCapacity"),
        Constants$root.C_POINTER$LAYOUT.withName("AllocObject"),
        Constants$root.C_POINTER$LAYOUT.withName("NewObject"),
        Constants$root.C_POINTER$LAYOUT.withName("NewObjectV"),
        Constants$root.C_POINTER$LAYOUT.withName("NewObjectA"),
        Constants$root.C_POINTER$LAYOUT.withName("GetObjectClass"),
        Constants$root.C_POINTER$LAYOUT.withName("IsInstanceOf"),
        Constants$root.C_POINTER$LAYOUT.withName("GetMethodID"),
        Constants$root.C_POINTER$LAYOUT.withName("CallObjectMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallObjectMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallObjectMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallBooleanMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallBooleanMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallBooleanMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallByteMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallByteMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallByteMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallCharMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallCharMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallCharMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallShortMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallShortMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallShortMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallIntMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallIntMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallIntMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallLongMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallLongMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallLongMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallFloatMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallFloatMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallFloatMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallDoubleMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallDoubleMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallDoubleMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallVoidMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallVoidMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallVoidMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualObjectMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualObjectMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualObjectMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualBooleanMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualBooleanMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualBooleanMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualByteMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualByteMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualByteMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualCharMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualCharMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualCharMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualShortMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualShortMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualShortMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualIntMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualIntMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualIntMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualLongMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualLongMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualLongMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualFloatMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualFloatMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualFloatMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualDoubleMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualDoubleMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualDoubleMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualVoidMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualVoidMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallNonvirtualVoidMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFieldID"),
        Constants$root.C_POINTER$LAYOUT.withName("GetObjectField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBooleanField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetByteField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetCharField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetShortField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetIntField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetLongField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFloatField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDoubleField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetObjectField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetBooleanField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetByteField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetCharField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetShortField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetIntField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetLongField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetFloatField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetDoubleField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticMethodID"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticObjectMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticObjectMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticObjectMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticBooleanMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticBooleanMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticBooleanMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticByteMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticByteMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticByteMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticCharMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticCharMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticCharMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticShortMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticShortMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticShortMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticIntMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticIntMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticIntMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticLongMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticLongMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticLongMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticFloatMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticFloatMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticFloatMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticDoubleMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticDoubleMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticDoubleMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticVoidMethod"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticVoidMethodV"),
        Constants$root.C_POINTER$LAYOUT.withName("CallStaticVoidMethodA"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticFieldID"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticObjectField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticBooleanField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticByteField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticCharField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticShortField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticIntField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticLongField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticFloatField"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStaticDoubleField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticObjectField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticBooleanField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticByteField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticCharField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticShortField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticIntField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticLongField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticFloatField"),
        Constants$root.C_POINTER$LAYOUT.withName("SetStaticDoubleField"),
        Constants$root.C_POINTER$LAYOUT.withName("NewString"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStringLength"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStringChars"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseStringChars"),
        Constants$root.C_POINTER$LAYOUT.withName("NewStringUTF"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStringUTFLength"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStringUTFChars"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseStringUTFChars"),
        Constants$root.C_POINTER$LAYOUT.withName("GetArrayLength"),
        Constants$root.C_POINTER$LAYOUT.withName("NewObjectArray"),
        Constants$root.C_POINTER$LAYOUT.withName("GetObjectArrayElement"),
        Constants$root.C_POINTER$LAYOUT.withName("SetObjectArrayElement"),
        Constants$root.C_POINTER$LAYOUT.withName("NewBooleanArray"),
        Constants$root.C_POINTER$LAYOUT.withName("NewByteArray"),
        Constants$root.C_POINTER$LAYOUT.withName("NewCharArray"),
        Constants$root.C_POINTER$LAYOUT.withName("NewShortArray"),
        Constants$root.C_POINTER$LAYOUT.withName("NewIntArray"),
        Constants$root.C_POINTER$LAYOUT.withName("NewLongArray"),
        Constants$root.C_POINTER$LAYOUT.withName("NewFloatArray"),
        Constants$root.C_POINTER$LAYOUT.withName("NewDoubleArray"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBooleanArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetByteArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetCharArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetShortArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetIntArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetLongArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFloatArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDoubleArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseBooleanArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseByteArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseCharArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseShortArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseIntArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseLongArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseFloatArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseDoubleArrayElements"),
        Constants$root.C_POINTER$LAYOUT.withName("GetBooleanArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetByteArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetCharArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetShortArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetIntArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetLongArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetFloatArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDoubleArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetBooleanArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetByteArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetCharArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetShortArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetIntArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetLongArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetFloatArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("SetDoubleArrayRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("RegisterNatives"),
        Constants$root.C_POINTER$LAYOUT.withName("UnregisterNatives"),
        Constants$root.C_POINTER$LAYOUT.withName("MonitorEnter"),
        Constants$root.C_POINTER$LAYOUT.withName("MonitorExit"),
        Constants$root.C_POINTER$LAYOUT.withName("GetJavaVM"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStringRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStringUTFRegion"),
        Constants$root.C_POINTER$LAYOUT.withName("GetPrimitiveArrayCritical"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleasePrimitiveArrayCritical"),
        Constants$root.C_POINTER$LAYOUT.withName("GetStringCritical"),
        Constants$root.C_POINTER$LAYOUT.withName("ReleaseStringCritical"),
        Constants$root.C_POINTER$LAYOUT.withName("NewWeakGlobalRef"),
        Constants$root.C_POINTER$LAYOUT.withName("DeleteWeakGlobalRef"),
        Constants$root.C_POINTER$LAYOUT.withName("ExceptionCheck"),
        Constants$root.C_POINTER$LAYOUT.withName("NewDirectByteBuffer"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDirectBufferAddress"),
        Constants$root.C_POINTER$LAYOUT.withName("GetDirectBufferCapacity"),
        Constants$root.C_POINTER$LAYOUT.withName("GetObjectRefType"),
        Constants$root.C_POINTER$LAYOUT.withName("GetModule"),
        Constants$root.C_POINTER$LAYOUT.withName("IsVirtualThread")
    ).withName("JNINativeInterface_");
    public static MemoryLayout $LAYOUT() {
        return JNINativeInterface_.$struct$LAYOUT;
    }
    static final VarHandle reserved0$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved0"));
    public static VarHandle reserved0$VH() {
        return JNINativeInterface_.reserved0$VH;
    }
    public static MemoryAddress reserved0$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved0$VH.get(seg);
    }
    public static void reserved0$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.reserved0$VH.set(seg, x);
    }
    public static MemoryAddress reserved0$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved0$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved0$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.reserved0$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle reserved1$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved1"));
    public static VarHandle reserved1$VH() {
        return JNINativeInterface_.reserved1$VH;
    }
    public static MemoryAddress reserved1$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved1$VH.get(seg);
    }
    public static void reserved1$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.reserved1$VH.set(seg, x);
    }
    public static MemoryAddress reserved1$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved1$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved1$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.reserved1$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle reserved2$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved2"));
    public static VarHandle reserved2$VH() {
        return JNINativeInterface_.reserved2$VH;
    }
    public static MemoryAddress reserved2$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved2$VH.get(seg);
    }
    public static void reserved2$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.reserved2$VH.set(seg, x);
    }
    public static MemoryAddress reserved2$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved2$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved2$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.reserved2$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle reserved3$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved3"));
    public static VarHandle reserved3$VH() {
        return JNINativeInterface_.reserved3$VH;
    }
    public static MemoryAddress reserved3$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved3$VH.get(seg);
    }
    public static void reserved3$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.reserved3$VH.set(seg, x);
    }
    public static MemoryAddress reserved3$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.reserved3$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved3$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.reserved3$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor GetVersion$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetVersion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetVersion$FUNC
    );
    public interface GetVersion {

        int apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(GetVersion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetVersion.class, fi, JNINativeInterface_.GetVersion$FUNC, session);
        }
        static GetVersion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (int)JNINativeInterface_.GetVersion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetVersion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetVersion"));
    public static VarHandle GetVersion$VH() {
        return JNINativeInterface_.GetVersion$VH;
    }
    public static MemoryAddress GetVersion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetVersion$VH.get(seg);
    }
    public static void GetVersion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetVersion$VH.set(seg, x);
    }
    public static MemoryAddress GetVersion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetVersion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetVersion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetVersion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetVersion GetVersion (MemorySegment segment, MemorySession session) {
        return GetVersion.ofAddress(GetVersion$get(segment), session);
    }
    static final FunctionDescriptor DefineClass$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle DefineClass$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.DefineClass$FUNC
    );
    public interface DefineClass {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, int _x4);
        static MemorySegment allocate(DefineClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DefineClass.class, fi, JNINativeInterface_.DefineClass$FUNC, session);
        }
        static DefineClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, int __x4) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.DefineClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DefineClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DefineClass"));
    public static VarHandle DefineClass$VH() {
        return JNINativeInterface_.DefineClass$VH;
    }
    public static MemoryAddress DefineClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DefineClass$VH.get(seg);
    }
    public static void DefineClass$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.DefineClass$VH.set(seg, x);
    }
    public static MemoryAddress DefineClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DefineClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DefineClass$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.DefineClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DefineClass DefineClass (MemorySegment segment, MemorySession session) {
        return DefineClass.ofAddress(DefineClass$get(segment), session);
    }
    static final FunctionDescriptor FindClass$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle FindClass$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.FindClass$FUNC
    );
    public interface FindClass {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(FindClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(FindClass.class, fi, JNINativeInterface_.FindClass$FUNC, session);
        }
        static FindClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.FindClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle FindClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("FindClass"));
    public static VarHandle FindClass$VH() {
        return JNINativeInterface_.FindClass$VH;
    }
    public static MemoryAddress FindClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FindClass$VH.get(seg);
    }
    public static void FindClass$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.FindClass$VH.set(seg, x);
    }
    public static MemoryAddress FindClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FindClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void FindClass$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.FindClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static FindClass FindClass (MemorySegment segment, MemorySession session) {
        return FindClass.ofAddress(FindClass$get(segment), session);
    }
    static final FunctionDescriptor FromReflectedMethod$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle FromReflectedMethod$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.FromReflectedMethod$FUNC
    );
    public interface FromReflectedMethod {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(FromReflectedMethod fi, MemorySession session) {
            return RuntimeHelper.upcallStub(FromReflectedMethod.class, fi, JNINativeInterface_.FromReflectedMethod$FUNC, session);
        }
        static FromReflectedMethod ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.FromReflectedMethod$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle FromReflectedMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("FromReflectedMethod"));
    public static VarHandle FromReflectedMethod$VH() {
        return JNINativeInterface_.FromReflectedMethod$VH;
    }
    public static MemoryAddress FromReflectedMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FromReflectedMethod$VH.get(seg);
    }
    public static void FromReflectedMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.FromReflectedMethod$VH.set(seg, x);
    }
    public static MemoryAddress FromReflectedMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FromReflectedMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void FromReflectedMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.FromReflectedMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static FromReflectedMethod FromReflectedMethod (MemorySegment segment, MemorySession session) {
        return FromReflectedMethod.ofAddress(FromReflectedMethod$get(segment), session);
    }
    static final FunctionDescriptor FromReflectedField$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle FromReflectedField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.FromReflectedField$FUNC
    );
    public interface FromReflectedField {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(FromReflectedField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(FromReflectedField.class, fi, JNINativeInterface_.FromReflectedField$FUNC, session);
        }
        static FromReflectedField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.FromReflectedField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle FromReflectedField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("FromReflectedField"));
    public static VarHandle FromReflectedField$VH() {
        return JNINativeInterface_.FromReflectedField$VH;
    }
    public static MemoryAddress FromReflectedField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FromReflectedField$VH.get(seg);
    }
    public static void FromReflectedField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.FromReflectedField$VH.set(seg, x);
    }
    public static MemoryAddress FromReflectedField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FromReflectedField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void FromReflectedField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.FromReflectedField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static FromReflectedField FromReflectedField (MemorySegment segment, MemorySession session) {
        return FromReflectedField.ofAddress(FromReflectedField$get(segment), session);
    }
    static final FunctionDescriptor ToReflectedMethod$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ToReflectedMethod$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ToReflectedMethod$FUNC
    );
    public interface ToReflectedMethod {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, byte _x3);
        static MemorySegment allocate(ToReflectedMethod fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ToReflectedMethod.class, fi, JNINativeInterface_.ToReflectedMethod$FUNC, session);
        }
        static ToReflectedMethod ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, byte __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.ToReflectedMethod$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ToReflectedMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ToReflectedMethod"));
    public static VarHandle ToReflectedMethod$VH() {
        return JNINativeInterface_.ToReflectedMethod$VH;
    }
    public static MemoryAddress ToReflectedMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ToReflectedMethod$VH.get(seg);
    }
    public static void ToReflectedMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ToReflectedMethod$VH.set(seg, x);
    }
    public static MemoryAddress ToReflectedMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ToReflectedMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ToReflectedMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ToReflectedMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ToReflectedMethod ToReflectedMethod (MemorySegment segment, MemorySession session) {
        return ToReflectedMethod.ofAddress(ToReflectedMethod$get(segment), session);
    }
    static final FunctionDescriptor GetSuperclass$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetSuperclass$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetSuperclass$FUNC
    );
    public interface GetSuperclass {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetSuperclass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetSuperclass.class, fi, JNINativeInterface_.GetSuperclass$FUNC, session);
        }
        static GetSuperclass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetSuperclass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetSuperclass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetSuperclass"));
    public static VarHandle GetSuperclass$VH() {
        return JNINativeInterface_.GetSuperclass$VH;
    }
    public static MemoryAddress GetSuperclass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetSuperclass$VH.get(seg);
    }
    public static void GetSuperclass$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetSuperclass$VH.set(seg, x);
    }
    public static MemoryAddress GetSuperclass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetSuperclass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetSuperclass$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetSuperclass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetSuperclass GetSuperclass (MemorySegment segment, MemorySession session) {
        return GetSuperclass.ofAddress(GetSuperclass$get(segment), session);
    }
    static final FunctionDescriptor IsAssignableFrom$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsAssignableFrom$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.IsAssignableFrom$FUNC
    );
    public interface IsAssignableFrom {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(IsAssignableFrom fi, MemorySession session) {
            return RuntimeHelper.upcallStub(IsAssignableFrom.class, fi, JNINativeInterface_.IsAssignableFrom$FUNC, session);
        }
        static IsAssignableFrom ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (byte)JNINativeInterface_.IsAssignableFrom$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsAssignableFrom$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsAssignableFrom"));
    public static VarHandle IsAssignableFrom$VH() {
        return JNINativeInterface_.IsAssignableFrom$VH;
    }
    public static MemoryAddress IsAssignableFrom$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsAssignableFrom$VH.get(seg);
    }
    public static void IsAssignableFrom$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.IsAssignableFrom$VH.set(seg, x);
    }
    public static MemoryAddress IsAssignableFrom$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsAssignableFrom$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsAssignableFrom$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.IsAssignableFrom$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsAssignableFrom IsAssignableFrom (MemorySegment segment, MemorySession session) {
        return IsAssignableFrom.ofAddress(IsAssignableFrom$get(segment), session);
    }
    static final FunctionDescriptor ToReflectedField$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle ToReflectedField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ToReflectedField$FUNC
    );
    public interface ToReflectedField {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, byte _x3);
        static MemorySegment allocate(ToReflectedField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ToReflectedField.class, fi, JNINativeInterface_.ToReflectedField$FUNC, session);
        }
        static ToReflectedField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, byte __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.ToReflectedField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ToReflectedField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ToReflectedField"));
    public static VarHandle ToReflectedField$VH() {
        return JNINativeInterface_.ToReflectedField$VH;
    }
    public static MemoryAddress ToReflectedField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ToReflectedField$VH.get(seg);
    }
    public static void ToReflectedField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ToReflectedField$VH.set(seg, x);
    }
    public static MemoryAddress ToReflectedField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ToReflectedField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ToReflectedField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ToReflectedField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ToReflectedField ToReflectedField (MemorySegment segment, MemorySession session) {
        return ToReflectedField.ofAddress(ToReflectedField$get(segment), session);
    }
    static final FunctionDescriptor Throw$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle Throw$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.Throw$FUNC
    );
    public interface Throw {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(Throw fi, MemorySession session) {
            return RuntimeHelper.upcallStub(Throw.class, fi, JNINativeInterface_.Throw$FUNC, session);
        }
        static Throw ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.Throw$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle Throw$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("Throw"));
    public static VarHandle Throw$VH() {
        return JNINativeInterface_.Throw$VH;
    }
    public static MemoryAddress Throw$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.Throw$VH.get(seg);
    }
    public static void Throw$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.Throw$VH.set(seg, x);
    }
    public static MemoryAddress Throw$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.Throw$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void Throw$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.Throw$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static Throw Throw (MemorySegment segment, MemorySession session) {
        return Throw.ofAddress(Throw$get(segment), session);
    }
    static final FunctionDescriptor ThrowNew$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ThrowNew$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ThrowNew$FUNC
    );
    public interface ThrowNew {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ThrowNew fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ThrowNew.class, fi, JNINativeInterface_.ThrowNew$FUNC, session);
        }
        static ThrowNew ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)JNINativeInterface_.ThrowNew$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ThrowNew$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ThrowNew"));
    public static VarHandle ThrowNew$VH() {
        return JNINativeInterface_.ThrowNew$VH;
    }
    public static MemoryAddress ThrowNew$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ThrowNew$VH.get(seg);
    }
    public static void ThrowNew$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ThrowNew$VH.set(seg, x);
    }
    public static MemoryAddress ThrowNew$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ThrowNew$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ThrowNew$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ThrowNew$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ThrowNew ThrowNew (MemorySegment segment, MemorySession session) {
        return ThrowNew.ofAddress(ThrowNew$get(segment), session);
    }
    static final FunctionDescriptor ExceptionOccurred$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ExceptionOccurred$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ExceptionOccurred$FUNC
    );
    public interface ExceptionOccurred {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(ExceptionOccurred fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ExceptionOccurred.class, fi, JNINativeInterface_.ExceptionOccurred$FUNC, session);
        }
        static ExceptionOccurred ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionOccurred$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ExceptionOccurred$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ExceptionOccurred"));
    public static VarHandle ExceptionOccurred$VH() {
        return JNINativeInterface_.ExceptionOccurred$VH;
    }
    public static MemoryAddress ExceptionOccurred$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionOccurred$VH.get(seg);
    }
    public static void ExceptionOccurred$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ExceptionOccurred$VH.set(seg, x);
    }
    public static MemoryAddress ExceptionOccurred$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionOccurred$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ExceptionOccurred$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ExceptionOccurred$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ExceptionOccurred ExceptionOccurred (MemorySegment segment, MemorySession session) {
        return ExceptionOccurred.ofAddress(ExceptionOccurred$get(segment), session);
    }
    static final FunctionDescriptor ExceptionDescribe$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ExceptionDescribe$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ExceptionDescribe$FUNC
    );
    public interface ExceptionDescribe {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(ExceptionDescribe fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ExceptionDescribe.class, fi, JNINativeInterface_.ExceptionDescribe$FUNC, session);
        }
        static ExceptionDescribe ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    JNINativeInterface_.ExceptionDescribe$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ExceptionDescribe$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ExceptionDescribe"));
    public static VarHandle ExceptionDescribe$VH() {
        return JNINativeInterface_.ExceptionDescribe$VH;
    }
    public static MemoryAddress ExceptionDescribe$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionDescribe$VH.get(seg);
    }
    public static void ExceptionDescribe$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ExceptionDescribe$VH.set(seg, x);
    }
    public static MemoryAddress ExceptionDescribe$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionDescribe$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ExceptionDescribe$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ExceptionDescribe$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ExceptionDescribe ExceptionDescribe (MemorySegment segment, MemorySession session) {
        return ExceptionDescribe.ofAddress(ExceptionDescribe$get(segment), session);
    }
    static final FunctionDescriptor ExceptionClear$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ExceptionClear$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ExceptionClear$FUNC
    );
    public interface ExceptionClear {

        void apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(ExceptionClear fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ExceptionClear.class, fi, JNINativeInterface_.ExceptionClear$FUNC, session);
        }
        static ExceptionClear ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    JNINativeInterface_.ExceptionClear$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ExceptionClear$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ExceptionClear"));
    public static VarHandle ExceptionClear$VH() {
        return JNINativeInterface_.ExceptionClear$VH;
    }
    public static MemoryAddress ExceptionClear$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionClear$VH.get(seg);
    }
    public static void ExceptionClear$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ExceptionClear$VH.set(seg, x);
    }
    public static MemoryAddress ExceptionClear$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionClear$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ExceptionClear$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ExceptionClear$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ExceptionClear ExceptionClear (MemorySegment segment, MemorySession session) {
        return ExceptionClear.ofAddress(ExceptionClear$get(segment), session);
    }
    static final FunctionDescriptor FatalError$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle FatalError$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.FatalError$FUNC
    );
    public interface FatalError {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(FatalError fi, MemorySession session) {
            return RuntimeHelper.upcallStub(FatalError.class, fi, JNINativeInterface_.FatalError$FUNC, session);
        }
        static FatalError ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    JNINativeInterface_.FatalError$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle FatalError$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("FatalError"));
    public static VarHandle FatalError$VH() {
        return JNINativeInterface_.FatalError$VH;
    }
    public static MemoryAddress FatalError$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FatalError$VH.get(seg);
    }
    public static void FatalError$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.FatalError$VH.set(seg, x);
    }
    public static MemoryAddress FatalError$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.FatalError$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void FatalError$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.FatalError$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static FatalError FatalError (MemorySegment segment, MemorySession session) {
        return FatalError.ofAddress(FatalError$get(segment), session);
    }
    static final FunctionDescriptor PushLocalFrame$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle PushLocalFrame$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.PushLocalFrame$FUNC
    );
    public interface PushLocalFrame {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(PushLocalFrame fi, MemorySession session) {
            return RuntimeHelper.upcallStub(PushLocalFrame.class, fi, JNINativeInterface_.PushLocalFrame$FUNC, session);
        }
        static PushLocalFrame ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (int)JNINativeInterface_.PushLocalFrame$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PushLocalFrame$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("PushLocalFrame"));
    public static VarHandle PushLocalFrame$VH() {
        return JNINativeInterface_.PushLocalFrame$VH;
    }
    public static MemoryAddress PushLocalFrame$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.PushLocalFrame$VH.get(seg);
    }
    public static void PushLocalFrame$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.PushLocalFrame$VH.set(seg, x);
    }
    public static MemoryAddress PushLocalFrame$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.PushLocalFrame$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PushLocalFrame$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.PushLocalFrame$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PushLocalFrame PushLocalFrame (MemorySegment segment, MemorySession session) {
        return PushLocalFrame.ofAddress(PushLocalFrame$get(segment), session);
    }
    static final FunctionDescriptor PopLocalFrame$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle PopLocalFrame$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.PopLocalFrame$FUNC
    );
    public interface PopLocalFrame {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(PopLocalFrame fi, MemorySession session) {
            return RuntimeHelper.upcallStub(PopLocalFrame.class, fi, JNINativeInterface_.PopLocalFrame$FUNC, session);
        }
        static PopLocalFrame ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.PopLocalFrame$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle PopLocalFrame$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("PopLocalFrame"));
    public static VarHandle PopLocalFrame$VH() {
        return JNINativeInterface_.PopLocalFrame$VH;
    }
    public static MemoryAddress PopLocalFrame$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.PopLocalFrame$VH.get(seg);
    }
    public static void PopLocalFrame$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.PopLocalFrame$VH.set(seg, x);
    }
    public static MemoryAddress PopLocalFrame$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.PopLocalFrame$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void PopLocalFrame$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.PopLocalFrame$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static PopLocalFrame PopLocalFrame (MemorySegment segment, MemorySession session) {
        return PopLocalFrame.ofAddress(PopLocalFrame$get(segment), session);
    }
    static final FunctionDescriptor NewGlobalRef$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle NewGlobalRef$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewGlobalRef$FUNC
    );
    public interface NewGlobalRef {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(NewGlobalRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewGlobalRef.class, fi, JNINativeInterface_.NewGlobalRef$FUNC, session);
        }
        static NewGlobalRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewGlobalRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewGlobalRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewGlobalRef"));
    public static VarHandle NewGlobalRef$VH() {
        return JNINativeInterface_.NewGlobalRef$VH;
    }
    public static MemoryAddress NewGlobalRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewGlobalRef$VH.get(seg);
    }
    public static void NewGlobalRef$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewGlobalRef$VH.set(seg, x);
    }
    public static MemoryAddress NewGlobalRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewGlobalRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewGlobalRef$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewGlobalRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewGlobalRef NewGlobalRef (MemorySegment segment, MemorySession session) {
        return NewGlobalRef.ofAddress(NewGlobalRef$get(segment), session);
    }
    static final FunctionDescriptor DeleteGlobalRef$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DeleteGlobalRef$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.DeleteGlobalRef$FUNC
    );
    public interface DeleteGlobalRef {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(DeleteGlobalRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DeleteGlobalRef.class, fi, JNINativeInterface_.DeleteGlobalRef$FUNC, session);
        }
        static DeleteGlobalRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    JNINativeInterface_.DeleteGlobalRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DeleteGlobalRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DeleteGlobalRef"));
    public static VarHandle DeleteGlobalRef$VH() {
        return JNINativeInterface_.DeleteGlobalRef$VH;
    }
    public static MemoryAddress DeleteGlobalRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DeleteGlobalRef$VH.get(seg);
    }
    public static void DeleteGlobalRef$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.DeleteGlobalRef$VH.set(seg, x);
    }
    public static MemoryAddress DeleteGlobalRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DeleteGlobalRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DeleteGlobalRef$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.DeleteGlobalRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DeleteGlobalRef DeleteGlobalRef (MemorySegment segment, MemorySession session) {
        return DeleteGlobalRef.ofAddress(DeleteGlobalRef$get(segment), session);
    }
    static final FunctionDescriptor DeleteLocalRef$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DeleteLocalRef$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.DeleteLocalRef$FUNC
    );
    public interface DeleteLocalRef {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(DeleteLocalRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DeleteLocalRef.class, fi, JNINativeInterface_.DeleteLocalRef$FUNC, session);
        }
        static DeleteLocalRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    JNINativeInterface_.DeleteLocalRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DeleteLocalRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DeleteLocalRef"));
    public static VarHandle DeleteLocalRef$VH() {
        return JNINativeInterface_.DeleteLocalRef$VH;
    }
    public static MemoryAddress DeleteLocalRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DeleteLocalRef$VH.get(seg);
    }
    public static void DeleteLocalRef$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.DeleteLocalRef$VH.set(seg, x);
    }
    public static MemoryAddress DeleteLocalRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DeleteLocalRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DeleteLocalRef$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.DeleteLocalRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DeleteLocalRef DeleteLocalRef (MemorySegment segment, MemorySession session) {
        return DeleteLocalRef.ofAddress(DeleteLocalRef$get(segment), session);
    }
    static final FunctionDescriptor IsSameObject$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsSameObject$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.IsSameObject$FUNC
    );
    public interface IsSameObject {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(IsSameObject fi, MemorySession session) {
            return RuntimeHelper.upcallStub(IsSameObject.class, fi, JNINativeInterface_.IsSameObject$FUNC, session);
        }
        static IsSameObject ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (byte)JNINativeInterface_.IsSameObject$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsSameObject$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsSameObject"));
    public static VarHandle IsSameObject$VH() {
        return JNINativeInterface_.IsSameObject$VH;
    }
    public static MemoryAddress IsSameObject$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsSameObject$VH.get(seg);
    }
    public static void IsSameObject$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.IsSameObject$VH.set(seg, x);
    }
    public static MemoryAddress IsSameObject$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsSameObject$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsSameObject$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.IsSameObject$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsSameObject IsSameObject (MemorySegment segment, MemorySession session) {
        return IsSameObject.ofAddress(IsSameObject$get(segment), session);
    }
    static final FunctionDescriptor NewLocalRef$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle NewLocalRef$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewLocalRef$FUNC
    );
    public interface NewLocalRef {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(NewLocalRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewLocalRef.class, fi, JNINativeInterface_.NewLocalRef$FUNC, session);
        }
        static NewLocalRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewLocalRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewLocalRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewLocalRef"));
    public static VarHandle NewLocalRef$VH() {
        return JNINativeInterface_.NewLocalRef$VH;
    }
    public static MemoryAddress NewLocalRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewLocalRef$VH.get(seg);
    }
    public static void NewLocalRef$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewLocalRef$VH.set(seg, x);
    }
    public static MemoryAddress NewLocalRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewLocalRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewLocalRef$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewLocalRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewLocalRef NewLocalRef (MemorySegment segment, MemorySession session) {
        return NewLocalRef.ofAddress(NewLocalRef$get(segment), session);
    }
    static final FunctionDescriptor EnsureLocalCapacity$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle EnsureLocalCapacity$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.EnsureLocalCapacity$FUNC
    );
    public interface EnsureLocalCapacity {

        int apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(EnsureLocalCapacity fi, MemorySession session) {
            return RuntimeHelper.upcallStub(EnsureLocalCapacity.class, fi, JNINativeInterface_.EnsureLocalCapacity$FUNC, session);
        }
        static EnsureLocalCapacity ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (int)JNINativeInterface_.EnsureLocalCapacity$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle EnsureLocalCapacity$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("EnsureLocalCapacity"));
    public static VarHandle EnsureLocalCapacity$VH() {
        return JNINativeInterface_.EnsureLocalCapacity$VH;
    }
    public static MemoryAddress EnsureLocalCapacity$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.EnsureLocalCapacity$VH.get(seg);
    }
    public static void EnsureLocalCapacity$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.EnsureLocalCapacity$VH.set(seg, x);
    }
    public static MemoryAddress EnsureLocalCapacity$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.EnsureLocalCapacity$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void EnsureLocalCapacity$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.EnsureLocalCapacity$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static EnsureLocalCapacity EnsureLocalCapacity (MemorySegment segment, MemorySession session) {
        return EnsureLocalCapacity.ofAddress(EnsureLocalCapacity$get(segment), session);
    }
    static final FunctionDescriptor AllocObject$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle AllocObject$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.AllocObject$FUNC
    );
    public interface AllocObject {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(AllocObject fi, MemorySession session) {
            return RuntimeHelper.upcallStub(AllocObject.class, fi, JNINativeInterface_.AllocObject$FUNC, session);
        }
        static AllocObject ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.AllocObject$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle AllocObject$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("AllocObject"));
    public static VarHandle AllocObject$VH() {
        return JNINativeInterface_.AllocObject$VH;
    }
    public static MemoryAddress AllocObject$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.AllocObject$VH.get(seg);
    }
    public static void AllocObject$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.AllocObject$VH.set(seg, x);
    }
    public static MemoryAddress AllocObject$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.AllocObject$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void AllocObject$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.AllocObject$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static AllocObject AllocObject (MemorySegment segment, MemorySession session) {
        return AllocObject.ofAddress(AllocObject$get(segment), session);
    }
    static final VarHandle NewObject$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewObject"));
    public static VarHandle NewObject$VH() {
        return JNINativeInterface_.NewObject$VH;
    }
    public static MemoryAddress NewObject$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObject$VH.get(seg);
    }
    public static void NewObject$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewObject$VH.set(seg, x);
    }
    public static MemoryAddress NewObject$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObject$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewObject$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewObject$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor NewObjectV$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle NewObjectV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewObjectV$FUNC
    );
    public interface NewObjectV {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(NewObjectV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewObjectV.class, fi, JNINativeInterface_.NewObjectV$FUNC, session);
        }
        static NewObjectV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewObjectV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewObjectV"));
    public static VarHandle NewObjectV$VH() {
        return JNINativeInterface_.NewObjectV$VH;
    }
    public static MemoryAddress NewObjectV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectV$VH.get(seg);
    }
    public static void NewObjectV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewObjectV$VH.set(seg, x);
    }
    public static MemoryAddress NewObjectV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewObjectV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewObjectV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewObjectV NewObjectV (MemorySegment segment, MemorySession session) {
        return NewObjectV.ofAddress(NewObjectV$get(segment), session);
    }
    static final FunctionDescriptor NewObjectA$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle NewObjectA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewObjectA$FUNC
    );
    public interface NewObjectA {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(NewObjectA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewObjectA.class, fi, JNINativeInterface_.NewObjectA$FUNC, session);
        }
        static NewObjectA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewObjectA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewObjectA"));
    public static VarHandle NewObjectA$VH() {
        return JNINativeInterface_.NewObjectA$VH;
    }
    public static MemoryAddress NewObjectA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectA$VH.get(seg);
    }
    public static void NewObjectA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewObjectA$VH.set(seg, x);
    }
    public static MemoryAddress NewObjectA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewObjectA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewObjectA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewObjectA NewObjectA (MemorySegment segment, MemorySession session) {
        return NewObjectA.ofAddress(NewObjectA$get(segment), session);
    }
    static final FunctionDescriptor GetObjectClass$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetObjectClass$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetObjectClass$FUNC
    );
    public interface GetObjectClass {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetObjectClass fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetObjectClass.class, fi, JNINativeInterface_.GetObjectClass$FUNC, session);
        }
        static GetObjectClass ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectClass$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetObjectClass$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetObjectClass"));
    public static VarHandle GetObjectClass$VH() {
        return JNINativeInterface_.GetObjectClass$VH;
    }
    public static MemoryAddress GetObjectClass$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectClass$VH.get(seg);
    }
    public static void GetObjectClass$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetObjectClass$VH.set(seg, x);
    }
    public static MemoryAddress GetObjectClass$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectClass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetObjectClass$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetObjectClass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetObjectClass GetObjectClass (MemorySegment segment, MemorySession session) {
        return GetObjectClass.ofAddress(GetObjectClass$get(segment), session);
    }
    static final FunctionDescriptor IsInstanceOf$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsInstanceOf$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.IsInstanceOf$FUNC
    );
    public interface IsInstanceOf {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(IsInstanceOf fi, MemorySession session) {
            return RuntimeHelper.upcallStub(IsInstanceOf.class, fi, JNINativeInterface_.IsInstanceOf$FUNC, session);
        }
        static IsInstanceOf ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (byte)JNINativeInterface_.IsInstanceOf$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsInstanceOf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsInstanceOf"));
    public static VarHandle IsInstanceOf$VH() {
        return JNINativeInterface_.IsInstanceOf$VH;
    }
    public static MemoryAddress IsInstanceOf$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsInstanceOf$VH.get(seg);
    }
    public static void IsInstanceOf$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.IsInstanceOf$VH.set(seg, x);
    }
    public static MemoryAddress IsInstanceOf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsInstanceOf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsInstanceOf$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.IsInstanceOf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsInstanceOf IsInstanceOf (MemorySegment segment, MemorySession session) {
        return IsInstanceOf.ofAddress(IsInstanceOf$get(segment), session);
    }
    static final FunctionDescriptor GetMethodID$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetMethodID$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetMethodID$FUNC
    );
    public interface GetMethodID {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(GetMethodID fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetMethodID.class, fi, JNINativeInterface_.GetMethodID$FUNC, session);
        }
        static GetMethodID ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetMethodID$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetMethodID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetMethodID"));
    public static VarHandle GetMethodID$VH() {
        return JNINativeInterface_.GetMethodID$VH;
    }
    public static MemoryAddress GetMethodID$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetMethodID$VH.get(seg);
    }
    public static void GetMethodID$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetMethodID$VH.set(seg, x);
    }
    public static MemoryAddress GetMethodID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetMethodID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetMethodID$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetMethodID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetMethodID GetMethodID (MemorySegment segment, MemorySession session) {
        return GetMethodID.ofAddress(GetMethodID$get(segment), session);
    }
    static final VarHandle CallObjectMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallObjectMethod"));
    public static VarHandle CallObjectMethod$VH() {
        return JNINativeInterface_.CallObjectMethod$VH;
    }
    public static MemoryAddress CallObjectMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethod$VH.get(seg);
    }
    public static void CallObjectMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallObjectMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallObjectMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallObjectMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallObjectMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallObjectMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallObjectMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallObjectMethodV$FUNC
    );
    public interface CallObjectMethodV {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallObjectMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallObjectMethodV.class, fi, JNINativeInterface_.CallObjectMethodV$FUNC, session);
        }
        static CallObjectMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallObjectMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallObjectMethodV"));
    public static VarHandle CallObjectMethodV$VH() {
        return JNINativeInterface_.CallObjectMethodV$VH;
    }
    public static MemoryAddress CallObjectMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethodV$VH.get(seg);
    }
    public static void CallObjectMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallObjectMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallObjectMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallObjectMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallObjectMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallObjectMethodV CallObjectMethodV (MemorySegment segment, MemorySession session) {
        return CallObjectMethodV.ofAddress(CallObjectMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallObjectMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallObjectMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallObjectMethodA$FUNC
    );
    public interface CallObjectMethodA {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallObjectMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallObjectMethodA.class, fi, JNINativeInterface_.CallObjectMethodA$FUNC, session);
        }
        static CallObjectMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallObjectMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallObjectMethodA"));
    public static VarHandle CallObjectMethodA$VH() {
        return JNINativeInterface_.CallObjectMethodA$VH;
    }
    public static MemoryAddress CallObjectMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethodA$VH.get(seg);
    }
    public static void CallObjectMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallObjectMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallObjectMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallObjectMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallObjectMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallObjectMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallObjectMethodA CallObjectMethodA (MemorySegment segment, MemorySession session) {
        return CallObjectMethodA.ofAddress(CallObjectMethodA$get(segment), session);
    }
    static final VarHandle CallBooleanMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallBooleanMethod"));
    public static VarHandle CallBooleanMethod$VH() {
        return JNINativeInterface_.CallBooleanMethod$VH;
    }
    public static MemoryAddress CallBooleanMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallBooleanMethod$VH.get(seg);
    }
    public static void CallBooleanMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallBooleanMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallBooleanMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallBooleanMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallBooleanMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallBooleanMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallBooleanMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallBooleanMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallBooleanMethodV$FUNC
    );
    public interface CallBooleanMethodV {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallBooleanMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallBooleanMethodV.class, fi, JNINativeInterface_.CallBooleanMethodV$FUNC, session);
        }
        static CallBooleanMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallBooleanMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallBooleanMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallBooleanMethodV"));
    public static VarHandle CallBooleanMethodV$VH() {
        return JNINativeInterface_.CallBooleanMethodV$VH;
    }
    public static MemoryAddress CallBooleanMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallBooleanMethodV$VH.get(seg);
    }
    public static void CallBooleanMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallBooleanMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallBooleanMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallBooleanMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallBooleanMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallBooleanMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallBooleanMethodV CallBooleanMethodV (MemorySegment segment, MemorySession session) {
        return CallBooleanMethodV.ofAddress(CallBooleanMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallBooleanMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallBooleanMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallBooleanMethodA$FUNC
    );
    public interface CallBooleanMethodA {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallBooleanMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallBooleanMethodA.class, fi, JNINativeInterface_.CallBooleanMethodA$FUNC, session);
        }
        static CallBooleanMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallBooleanMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallBooleanMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallBooleanMethodA"));
    public static VarHandle CallBooleanMethodA$VH() {
        return JNINativeInterface_.CallBooleanMethodA$VH;
    }
    public static MemoryAddress CallBooleanMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallBooleanMethodA$VH.get(seg);
    }
    public static void CallBooleanMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallBooleanMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallBooleanMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallBooleanMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallBooleanMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallBooleanMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallBooleanMethodA CallBooleanMethodA (MemorySegment segment, MemorySession session) {
        return CallBooleanMethodA.ofAddress(CallBooleanMethodA$get(segment), session);
    }
    static final VarHandle CallByteMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallByteMethod"));
    public static VarHandle CallByteMethod$VH() {
        return JNINativeInterface_.CallByteMethod$VH;
    }
    public static MemoryAddress CallByteMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallByteMethod$VH.get(seg);
    }
    public static void CallByteMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallByteMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallByteMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallByteMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallByteMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallByteMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallByteMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallByteMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallByteMethodV$FUNC
    );
    public interface CallByteMethodV {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallByteMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallByteMethodV.class, fi, JNINativeInterface_.CallByteMethodV$FUNC, session);
        }
        static CallByteMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallByteMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallByteMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallByteMethodV"));
    public static VarHandle CallByteMethodV$VH() {
        return JNINativeInterface_.CallByteMethodV$VH;
    }
    public static MemoryAddress CallByteMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallByteMethodV$VH.get(seg);
    }
    public static void CallByteMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallByteMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallByteMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallByteMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallByteMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallByteMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallByteMethodV CallByteMethodV (MemorySegment segment, MemorySession session) {
        return CallByteMethodV.ofAddress(CallByteMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallByteMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallByteMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallByteMethodA$FUNC
    );
    public interface CallByteMethodA {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallByteMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallByteMethodA.class, fi, JNINativeInterface_.CallByteMethodA$FUNC, session);
        }
        static CallByteMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallByteMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallByteMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallByteMethodA"));
    public static VarHandle CallByteMethodA$VH() {
        return JNINativeInterface_.CallByteMethodA$VH;
    }
    public static MemoryAddress CallByteMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallByteMethodA$VH.get(seg);
    }
    public static void CallByteMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallByteMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallByteMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallByteMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallByteMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallByteMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallByteMethodA CallByteMethodA (MemorySegment segment, MemorySession session) {
        return CallByteMethodA.ofAddress(CallByteMethodA$get(segment), session);
    }
    static final VarHandle CallCharMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallCharMethod"));
    public static VarHandle CallCharMethod$VH() {
        return JNINativeInterface_.CallCharMethod$VH;
    }
    public static MemoryAddress CallCharMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallCharMethod$VH.get(seg);
    }
    public static void CallCharMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallCharMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallCharMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallCharMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallCharMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallCharMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallCharMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallCharMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallCharMethodV$FUNC
    );
    public interface CallCharMethodV {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallCharMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallCharMethodV.class, fi, JNINativeInterface_.CallCharMethodV$FUNC, session);
        }
        static CallCharMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallCharMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallCharMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallCharMethodV"));
    public static VarHandle CallCharMethodV$VH() {
        return JNINativeInterface_.CallCharMethodV$VH;
    }
    public static MemoryAddress CallCharMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallCharMethodV$VH.get(seg);
    }
    public static void CallCharMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallCharMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallCharMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallCharMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallCharMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallCharMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallCharMethodV CallCharMethodV (MemorySegment segment, MemorySession session) {
        return CallCharMethodV.ofAddress(CallCharMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallCharMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallCharMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallCharMethodA$FUNC
    );
    public interface CallCharMethodA {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallCharMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallCharMethodA.class, fi, JNINativeInterface_.CallCharMethodA$FUNC, session);
        }
        static CallCharMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallCharMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallCharMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallCharMethodA"));
    public static VarHandle CallCharMethodA$VH() {
        return JNINativeInterface_.CallCharMethodA$VH;
    }
    public static MemoryAddress CallCharMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallCharMethodA$VH.get(seg);
    }
    public static void CallCharMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallCharMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallCharMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallCharMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallCharMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallCharMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallCharMethodA CallCharMethodA (MemorySegment segment, MemorySession session) {
        return CallCharMethodA.ofAddress(CallCharMethodA$get(segment), session);
    }
    static final VarHandle CallShortMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallShortMethod"));
    public static VarHandle CallShortMethod$VH() {
        return JNINativeInterface_.CallShortMethod$VH;
    }
    public static MemoryAddress CallShortMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallShortMethod$VH.get(seg);
    }
    public static void CallShortMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallShortMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallShortMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallShortMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallShortMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallShortMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallShortMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallShortMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallShortMethodV$FUNC
    );
    public interface CallShortMethodV {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallShortMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallShortMethodV.class, fi, JNINativeInterface_.CallShortMethodV$FUNC, session);
        }
        static CallShortMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallShortMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallShortMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallShortMethodV"));
    public static VarHandle CallShortMethodV$VH() {
        return JNINativeInterface_.CallShortMethodV$VH;
    }
    public static MemoryAddress CallShortMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallShortMethodV$VH.get(seg);
    }
    public static void CallShortMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallShortMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallShortMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallShortMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallShortMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallShortMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallShortMethodV CallShortMethodV (MemorySegment segment, MemorySession session) {
        return CallShortMethodV.ofAddress(CallShortMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallShortMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallShortMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallShortMethodA$FUNC
    );
    public interface CallShortMethodA {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallShortMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallShortMethodA.class, fi, JNINativeInterface_.CallShortMethodA$FUNC, session);
        }
        static CallShortMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallShortMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallShortMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallShortMethodA"));
    public static VarHandle CallShortMethodA$VH() {
        return JNINativeInterface_.CallShortMethodA$VH;
    }
    public static MemoryAddress CallShortMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallShortMethodA$VH.get(seg);
    }
    public static void CallShortMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallShortMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallShortMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallShortMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallShortMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallShortMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallShortMethodA CallShortMethodA (MemorySegment segment, MemorySession session) {
        return CallShortMethodA.ofAddress(CallShortMethodA$get(segment), session);
    }
    static final VarHandle CallIntMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallIntMethod"));
    public static VarHandle CallIntMethod$VH() {
        return JNINativeInterface_.CallIntMethod$VH;
    }
    public static MemoryAddress CallIntMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallIntMethod$VH.get(seg);
    }
    public static void CallIntMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallIntMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallIntMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallIntMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallIntMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallIntMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallIntMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallIntMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallIntMethodV$FUNC
    );
    public interface CallIntMethodV {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallIntMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallIntMethodV.class, fi, JNINativeInterface_.CallIntMethodV$FUNC, session);
        }
        static CallIntMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)JNINativeInterface_.CallIntMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallIntMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallIntMethodV"));
    public static VarHandle CallIntMethodV$VH() {
        return JNINativeInterface_.CallIntMethodV$VH;
    }
    public static MemoryAddress CallIntMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallIntMethodV$VH.get(seg);
    }
    public static void CallIntMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallIntMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallIntMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallIntMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallIntMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallIntMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallIntMethodV CallIntMethodV (MemorySegment segment, MemorySession session) {
        return CallIntMethodV.ofAddress(CallIntMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallIntMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallIntMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallIntMethodA$FUNC
    );
    public interface CallIntMethodA {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallIntMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallIntMethodA.class, fi, JNINativeInterface_.CallIntMethodA$FUNC, session);
        }
        static CallIntMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)JNINativeInterface_.CallIntMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallIntMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallIntMethodA"));
    public static VarHandle CallIntMethodA$VH() {
        return JNINativeInterface_.CallIntMethodA$VH;
    }
    public static MemoryAddress CallIntMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallIntMethodA$VH.get(seg);
    }
    public static void CallIntMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallIntMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallIntMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallIntMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallIntMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallIntMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallIntMethodA CallIntMethodA (MemorySegment segment, MemorySession session) {
        return CallIntMethodA.ofAddress(CallIntMethodA$get(segment), session);
    }
    static final VarHandle CallLongMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallLongMethod"));
    public static VarHandle CallLongMethod$VH() {
        return JNINativeInterface_.CallLongMethod$VH;
    }
    public static MemoryAddress CallLongMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallLongMethod$VH.get(seg);
    }
    public static void CallLongMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallLongMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallLongMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallLongMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallLongMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallLongMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallLongMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallLongMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallLongMethodV$FUNC
    );
    public interface CallLongMethodV {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallLongMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallLongMethodV.class, fi, JNINativeInterface_.CallLongMethodV$FUNC, session);
        }
        static CallLongMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (long)JNINativeInterface_.CallLongMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallLongMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallLongMethodV"));
    public static VarHandle CallLongMethodV$VH() {
        return JNINativeInterface_.CallLongMethodV$VH;
    }
    public static MemoryAddress CallLongMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallLongMethodV$VH.get(seg);
    }
    public static void CallLongMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallLongMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallLongMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallLongMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallLongMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallLongMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallLongMethodV CallLongMethodV (MemorySegment segment, MemorySession session) {
        return CallLongMethodV.ofAddress(CallLongMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallLongMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallLongMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallLongMethodA$FUNC
    );
    public interface CallLongMethodA {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallLongMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallLongMethodA.class, fi, JNINativeInterface_.CallLongMethodA$FUNC, session);
        }
        static CallLongMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (long)JNINativeInterface_.CallLongMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallLongMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallLongMethodA"));
    public static VarHandle CallLongMethodA$VH() {
        return JNINativeInterface_.CallLongMethodA$VH;
    }
    public static MemoryAddress CallLongMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallLongMethodA$VH.get(seg);
    }
    public static void CallLongMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallLongMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallLongMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallLongMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallLongMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallLongMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallLongMethodA CallLongMethodA (MemorySegment segment, MemorySession session) {
        return CallLongMethodA.ofAddress(CallLongMethodA$get(segment), session);
    }
    static final VarHandle CallFloatMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallFloatMethod"));
    public static VarHandle CallFloatMethod$VH() {
        return JNINativeInterface_.CallFloatMethod$VH;
    }
    public static MemoryAddress CallFloatMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallFloatMethod$VH.get(seg);
    }
    public static void CallFloatMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallFloatMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallFloatMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallFloatMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallFloatMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallFloatMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallFloatMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallFloatMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallFloatMethodV$FUNC
    );
    public interface CallFloatMethodV {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallFloatMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallFloatMethodV.class, fi, JNINativeInterface_.CallFloatMethodV$FUNC, session);
        }
        static CallFloatMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (float)JNINativeInterface_.CallFloatMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallFloatMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallFloatMethodV"));
    public static VarHandle CallFloatMethodV$VH() {
        return JNINativeInterface_.CallFloatMethodV$VH;
    }
    public static MemoryAddress CallFloatMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallFloatMethodV$VH.get(seg);
    }
    public static void CallFloatMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallFloatMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallFloatMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallFloatMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallFloatMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallFloatMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallFloatMethodV CallFloatMethodV (MemorySegment segment, MemorySession session) {
        return CallFloatMethodV.ofAddress(CallFloatMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallFloatMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallFloatMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallFloatMethodA$FUNC
    );
    public interface CallFloatMethodA {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallFloatMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallFloatMethodA.class, fi, JNINativeInterface_.CallFloatMethodA$FUNC, session);
        }
        static CallFloatMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (float)JNINativeInterface_.CallFloatMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallFloatMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallFloatMethodA"));
    public static VarHandle CallFloatMethodA$VH() {
        return JNINativeInterface_.CallFloatMethodA$VH;
    }
    public static MemoryAddress CallFloatMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallFloatMethodA$VH.get(seg);
    }
    public static void CallFloatMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallFloatMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallFloatMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallFloatMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallFloatMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallFloatMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallFloatMethodA CallFloatMethodA (MemorySegment segment, MemorySession session) {
        return CallFloatMethodA.ofAddress(CallFloatMethodA$get(segment), session);
    }
    static final VarHandle CallDoubleMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallDoubleMethod"));
    public static VarHandle CallDoubleMethod$VH() {
        return JNINativeInterface_.CallDoubleMethod$VH;
    }
    public static MemoryAddress CallDoubleMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallDoubleMethod$VH.get(seg);
    }
    public static void CallDoubleMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallDoubleMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallDoubleMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallDoubleMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallDoubleMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallDoubleMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallDoubleMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallDoubleMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallDoubleMethodV$FUNC
    );
    public interface CallDoubleMethodV {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallDoubleMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallDoubleMethodV.class, fi, JNINativeInterface_.CallDoubleMethodV$FUNC, session);
        }
        static CallDoubleMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (double)JNINativeInterface_.CallDoubleMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallDoubleMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallDoubleMethodV"));
    public static VarHandle CallDoubleMethodV$VH() {
        return JNINativeInterface_.CallDoubleMethodV$VH;
    }
    public static MemoryAddress CallDoubleMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallDoubleMethodV$VH.get(seg);
    }
    public static void CallDoubleMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallDoubleMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallDoubleMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallDoubleMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallDoubleMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallDoubleMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallDoubleMethodV CallDoubleMethodV (MemorySegment segment, MemorySession session) {
        return CallDoubleMethodV.ofAddress(CallDoubleMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallDoubleMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallDoubleMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallDoubleMethodA$FUNC
    );
    public interface CallDoubleMethodA {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallDoubleMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallDoubleMethodA.class, fi, JNINativeInterface_.CallDoubleMethodA$FUNC, session);
        }
        static CallDoubleMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (double)JNINativeInterface_.CallDoubleMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallDoubleMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallDoubleMethodA"));
    public static VarHandle CallDoubleMethodA$VH() {
        return JNINativeInterface_.CallDoubleMethodA$VH;
    }
    public static MemoryAddress CallDoubleMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallDoubleMethodA$VH.get(seg);
    }
    public static void CallDoubleMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallDoubleMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallDoubleMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallDoubleMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallDoubleMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallDoubleMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallDoubleMethodA CallDoubleMethodA (MemorySegment segment, MemorySession session) {
        return CallDoubleMethodA.ofAddress(CallDoubleMethodA$get(segment), session);
    }
    static final VarHandle CallVoidMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallVoidMethod"));
    public static VarHandle CallVoidMethod$VH() {
        return JNINativeInterface_.CallVoidMethod$VH;
    }
    public static MemoryAddress CallVoidMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallVoidMethod$VH.get(seg);
    }
    public static void CallVoidMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallVoidMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallVoidMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallVoidMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallVoidMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallVoidMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallVoidMethodV$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallVoidMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallVoidMethodV$FUNC
    );
    public interface CallVoidMethodV {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallVoidMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallVoidMethodV.class, fi, JNINativeInterface_.CallVoidMethodV$FUNC, session);
        }
        static CallVoidMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    JNINativeInterface_.CallVoidMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallVoidMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallVoidMethodV"));
    public static VarHandle CallVoidMethodV$VH() {
        return JNINativeInterface_.CallVoidMethodV$VH;
    }
    public static MemoryAddress CallVoidMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallVoidMethodV$VH.get(seg);
    }
    public static void CallVoidMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallVoidMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallVoidMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallVoidMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallVoidMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallVoidMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallVoidMethodV CallVoidMethodV (MemorySegment segment, MemorySession session) {
        return CallVoidMethodV.ofAddress(CallVoidMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallVoidMethodA$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallVoidMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallVoidMethodA$FUNC
    );
    public interface CallVoidMethodA {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallVoidMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallVoidMethodA.class, fi, JNINativeInterface_.CallVoidMethodA$FUNC, session);
        }
        static CallVoidMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    JNINativeInterface_.CallVoidMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallVoidMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallVoidMethodA"));
    public static VarHandle CallVoidMethodA$VH() {
        return JNINativeInterface_.CallVoidMethodA$VH;
    }
    public static MemoryAddress CallVoidMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallVoidMethodA$VH.get(seg);
    }
    public static void CallVoidMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallVoidMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallVoidMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallVoidMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallVoidMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallVoidMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallVoidMethodA CallVoidMethodA (MemorySegment segment, MemorySession session) {
        return CallVoidMethodA.ofAddress(CallVoidMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualObjectMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualObjectMethod"));
    public static VarHandle CallNonvirtualObjectMethod$VH() {
        return JNINativeInterface_.CallNonvirtualObjectMethod$VH;
    }
    public static MemoryAddress CallNonvirtualObjectMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethod$VH.get(seg);
    }
    public static void CallNonvirtualObjectMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualObjectMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualObjectMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualObjectMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualObjectMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualObjectMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualObjectMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualObjectMethodV$FUNC
    );
    public interface CallNonvirtualObjectMethodV {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualObjectMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualObjectMethodV.class, fi, JNINativeInterface_.CallNonvirtualObjectMethodV$FUNC, session);
        }
        static CallNonvirtualObjectMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualObjectMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualObjectMethodV"));
    public static VarHandle CallNonvirtualObjectMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualObjectMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualObjectMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethodV$VH.get(seg);
    }
    public static void CallNonvirtualObjectMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualObjectMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualObjectMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualObjectMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualObjectMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualObjectMethodV CallNonvirtualObjectMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualObjectMethodV.ofAddress(CallNonvirtualObjectMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualObjectMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualObjectMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualObjectMethodA$FUNC
    );
    public interface CallNonvirtualObjectMethodA {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualObjectMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualObjectMethodA.class, fi, JNINativeInterface_.CallNonvirtualObjectMethodA$FUNC, session);
        }
        static CallNonvirtualObjectMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualObjectMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualObjectMethodA"));
    public static VarHandle CallNonvirtualObjectMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualObjectMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualObjectMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethodA$VH.get(seg);
    }
    public static void CallNonvirtualObjectMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualObjectMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualObjectMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualObjectMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualObjectMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualObjectMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualObjectMethodA CallNonvirtualObjectMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualObjectMethodA.ofAddress(CallNonvirtualObjectMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualBooleanMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualBooleanMethod"));
    public static VarHandle CallNonvirtualBooleanMethod$VH() {
        return JNINativeInterface_.CallNonvirtualBooleanMethod$VH;
    }
    public static MemoryAddress CallNonvirtualBooleanMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualBooleanMethod$VH.get(seg);
    }
    public static void CallNonvirtualBooleanMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualBooleanMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualBooleanMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualBooleanMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualBooleanMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualBooleanMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualBooleanMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualBooleanMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualBooleanMethodV$FUNC
    );
    public interface CallNonvirtualBooleanMethodV {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualBooleanMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualBooleanMethodV.class, fi, JNINativeInterface_.CallNonvirtualBooleanMethodV$FUNC, session);
        }
        static CallNonvirtualBooleanMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (byte)JNINativeInterface_.CallNonvirtualBooleanMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualBooleanMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualBooleanMethodV"));
    public static VarHandle CallNonvirtualBooleanMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualBooleanMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualBooleanMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualBooleanMethodV$VH.get(seg);
    }
    public static void CallNonvirtualBooleanMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualBooleanMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualBooleanMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualBooleanMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualBooleanMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualBooleanMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualBooleanMethodV CallNonvirtualBooleanMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualBooleanMethodV.ofAddress(CallNonvirtualBooleanMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualBooleanMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualBooleanMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualBooleanMethodA$FUNC
    );
    public interface CallNonvirtualBooleanMethodA {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualBooleanMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualBooleanMethodA.class, fi, JNINativeInterface_.CallNonvirtualBooleanMethodA$FUNC, session);
        }
        static CallNonvirtualBooleanMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (byte)JNINativeInterface_.CallNonvirtualBooleanMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualBooleanMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualBooleanMethodA"));
    public static VarHandle CallNonvirtualBooleanMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualBooleanMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualBooleanMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualBooleanMethodA$VH.get(seg);
    }
    public static void CallNonvirtualBooleanMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualBooleanMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualBooleanMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualBooleanMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualBooleanMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualBooleanMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualBooleanMethodA CallNonvirtualBooleanMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualBooleanMethodA.ofAddress(CallNonvirtualBooleanMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualByteMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualByteMethod"));
    public static VarHandle CallNonvirtualByteMethod$VH() {
        return JNINativeInterface_.CallNonvirtualByteMethod$VH;
    }
    public static MemoryAddress CallNonvirtualByteMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualByteMethod$VH.get(seg);
    }
    public static void CallNonvirtualByteMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualByteMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualByteMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualByteMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualByteMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualByteMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualByteMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualByteMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualByteMethodV$FUNC
    );
    public interface CallNonvirtualByteMethodV {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualByteMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualByteMethodV.class, fi, JNINativeInterface_.CallNonvirtualByteMethodV$FUNC, session);
        }
        static CallNonvirtualByteMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (byte)JNINativeInterface_.CallNonvirtualByteMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualByteMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualByteMethodV"));
    public static VarHandle CallNonvirtualByteMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualByteMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualByteMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualByteMethodV$VH.get(seg);
    }
    public static void CallNonvirtualByteMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualByteMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualByteMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualByteMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualByteMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualByteMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualByteMethodV CallNonvirtualByteMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualByteMethodV.ofAddress(CallNonvirtualByteMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualByteMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualByteMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualByteMethodA$FUNC
    );
    public interface CallNonvirtualByteMethodA {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualByteMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualByteMethodA.class, fi, JNINativeInterface_.CallNonvirtualByteMethodA$FUNC, session);
        }
        static CallNonvirtualByteMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (byte)JNINativeInterface_.CallNonvirtualByteMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualByteMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualByteMethodA"));
    public static VarHandle CallNonvirtualByteMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualByteMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualByteMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualByteMethodA$VH.get(seg);
    }
    public static void CallNonvirtualByteMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualByteMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualByteMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualByteMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualByteMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualByteMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualByteMethodA CallNonvirtualByteMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualByteMethodA.ofAddress(CallNonvirtualByteMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualCharMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualCharMethod"));
    public static VarHandle CallNonvirtualCharMethod$VH() {
        return JNINativeInterface_.CallNonvirtualCharMethod$VH;
    }
    public static MemoryAddress CallNonvirtualCharMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualCharMethod$VH.get(seg);
    }
    public static void CallNonvirtualCharMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualCharMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualCharMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualCharMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualCharMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualCharMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualCharMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualCharMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualCharMethodV$FUNC
    );
    public interface CallNonvirtualCharMethodV {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualCharMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualCharMethodV.class, fi, JNINativeInterface_.CallNonvirtualCharMethodV$FUNC, session);
        }
        static CallNonvirtualCharMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (short)JNINativeInterface_.CallNonvirtualCharMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualCharMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualCharMethodV"));
    public static VarHandle CallNonvirtualCharMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualCharMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualCharMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualCharMethodV$VH.get(seg);
    }
    public static void CallNonvirtualCharMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualCharMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualCharMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualCharMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualCharMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualCharMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualCharMethodV CallNonvirtualCharMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualCharMethodV.ofAddress(CallNonvirtualCharMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualCharMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualCharMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualCharMethodA$FUNC
    );
    public interface CallNonvirtualCharMethodA {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualCharMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualCharMethodA.class, fi, JNINativeInterface_.CallNonvirtualCharMethodA$FUNC, session);
        }
        static CallNonvirtualCharMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (short)JNINativeInterface_.CallNonvirtualCharMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualCharMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualCharMethodA"));
    public static VarHandle CallNonvirtualCharMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualCharMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualCharMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualCharMethodA$VH.get(seg);
    }
    public static void CallNonvirtualCharMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualCharMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualCharMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualCharMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualCharMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualCharMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualCharMethodA CallNonvirtualCharMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualCharMethodA.ofAddress(CallNonvirtualCharMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualShortMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualShortMethod"));
    public static VarHandle CallNonvirtualShortMethod$VH() {
        return JNINativeInterface_.CallNonvirtualShortMethod$VH;
    }
    public static MemoryAddress CallNonvirtualShortMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualShortMethod$VH.get(seg);
    }
    public static void CallNonvirtualShortMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualShortMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualShortMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualShortMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualShortMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualShortMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualShortMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualShortMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualShortMethodV$FUNC
    );
    public interface CallNonvirtualShortMethodV {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualShortMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualShortMethodV.class, fi, JNINativeInterface_.CallNonvirtualShortMethodV$FUNC, session);
        }
        static CallNonvirtualShortMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (short)JNINativeInterface_.CallNonvirtualShortMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualShortMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualShortMethodV"));
    public static VarHandle CallNonvirtualShortMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualShortMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualShortMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualShortMethodV$VH.get(seg);
    }
    public static void CallNonvirtualShortMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualShortMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualShortMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualShortMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualShortMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualShortMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualShortMethodV CallNonvirtualShortMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualShortMethodV.ofAddress(CallNonvirtualShortMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualShortMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualShortMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualShortMethodA$FUNC
    );
    public interface CallNonvirtualShortMethodA {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualShortMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualShortMethodA.class, fi, JNINativeInterface_.CallNonvirtualShortMethodA$FUNC, session);
        }
        static CallNonvirtualShortMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (short)JNINativeInterface_.CallNonvirtualShortMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualShortMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualShortMethodA"));
    public static VarHandle CallNonvirtualShortMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualShortMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualShortMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualShortMethodA$VH.get(seg);
    }
    public static void CallNonvirtualShortMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualShortMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualShortMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualShortMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualShortMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualShortMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualShortMethodA CallNonvirtualShortMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualShortMethodA.ofAddress(CallNonvirtualShortMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualIntMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualIntMethod"));
    public static VarHandle CallNonvirtualIntMethod$VH() {
        return JNINativeInterface_.CallNonvirtualIntMethod$VH;
    }
    public static MemoryAddress CallNonvirtualIntMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualIntMethod$VH.get(seg);
    }
    public static void CallNonvirtualIntMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualIntMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualIntMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualIntMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualIntMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualIntMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualIntMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualIntMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualIntMethodV$FUNC
    );
    public interface CallNonvirtualIntMethodV {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualIntMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualIntMethodV.class, fi, JNINativeInterface_.CallNonvirtualIntMethodV$FUNC, session);
        }
        static CallNonvirtualIntMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)JNINativeInterface_.CallNonvirtualIntMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualIntMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualIntMethodV"));
    public static VarHandle CallNonvirtualIntMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualIntMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualIntMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualIntMethodV$VH.get(seg);
    }
    public static void CallNonvirtualIntMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualIntMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualIntMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualIntMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualIntMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualIntMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualIntMethodV CallNonvirtualIntMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualIntMethodV.ofAddress(CallNonvirtualIntMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualIntMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualIntMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualIntMethodA$FUNC
    );
    public interface CallNonvirtualIntMethodA {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualIntMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualIntMethodA.class, fi, JNINativeInterface_.CallNonvirtualIntMethodA$FUNC, session);
        }
        static CallNonvirtualIntMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (int)JNINativeInterface_.CallNonvirtualIntMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualIntMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualIntMethodA"));
    public static VarHandle CallNonvirtualIntMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualIntMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualIntMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualIntMethodA$VH.get(seg);
    }
    public static void CallNonvirtualIntMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualIntMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualIntMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualIntMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualIntMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualIntMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualIntMethodA CallNonvirtualIntMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualIntMethodA.ofAddress(CallNonvirtualIntMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualLongMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualLongMethod"));
    public static VarHandle CallNonvirtualLongMethod$VH() {
        return JNINativeInterface_.CallNonvirtualLongMethod$VH;
    }
    public static MemoryAddress CallNonvirtualLongMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualLongMethod$VH.get(seg);
    }
    public static void CallNonvirtualLongMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualLongMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualLongMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualLongMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualLongMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualLongMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualLongMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualLongMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualLongMethodV$FUNC
    );
    public interface CallNonvirtualLongMethodV {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualLongMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualLongMethodV.class, fi, JNINativeInterface_.CallNonvirtualLongMethodV$FUNC, session);
        }
        static CallNonvirtualLongMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (long)JNINativeInterface_.CallNonvirtualLongMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualLongMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualLongMethodV"));
    public static VarHandle CallNonvirtualLongMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualLongMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualLongMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualLongMethodV$VH.get(seg);
    }
    public static void CallNonvirtualLongMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualLongMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualLongMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualLongMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualLongMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualLongMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualLongMethodV CallNonvirtualLongMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualLongMethodV.ofAddress(CallNonvirtualLongMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualLongMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualLongMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualLongMethodA$FUNC
    );
    public interface CallNonvirtualLongMethodA {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualLongMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualLongMethodA.class, fi, JNINativeInterface_.CallNonvirtualLongMethodA$FUNC, session);
        }
        static CallNonvirtualLongMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (long)JNINativeInterface_.CallNonvirtualLongMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualLongMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualLongMethodA"));
    public static VarHandle CallNonvirtualLongMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualLongMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualLongMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualLongMethodA$VH.get(seg);
    }
    public static void CallNonvirtualLongMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualLongMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualLongMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualLongMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualLongMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualLongMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualLongMethodA CallNonvirtualLongMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualLongMethodA.ofAddress(CallNonvirtualLongMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualFloatMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualFloatMethod"));
    public static VarHandle CallNonvirtualFloatMethod$VH() {
        return JNINativeInterface_.CallNonvirtualFloatMethod$VH;
    }
    public static MemoryAddress CallNonvirtualFloatMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualFloatMethod$VH.get(seg);
    }
    public static void CallNonvirtualFloatMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualFloatMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualFloatMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualFloatMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualFloatMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualFloatMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualFloatMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualFloatMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualFloatMethodV$FUNC
    );
    public interface CallNonvirtualFloatMethodV {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualFloatMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualFloatMethodV.class, fi, JNINativeInterface_.CallNonvirtualFloatMethodV$FUNC, session);
        }
        static CallNonvirtualFloatMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (float)JNINativeInterface_.CallNonvirtualFloatMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualFloatMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualFloatMethodV"));
    public static VarHandle CallNonvirtualFloatMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualFloatMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualFloatMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualFloatMethodV$VH.get(seg);
    }
    public static void CallNonvirtualFloatMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualFloatMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualFloatMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualFloatMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualFloatMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualFloatMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualFloatMethodV CallNonvirtualFloatMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualFloatMethodV.ofAddress(CallNonvirtualFloatMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualFloatMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualFloatMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualFloatMethodA$FUNC
    );
    public interface CallNonvirtualFloatMethodA {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualFloatMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualFloatMethodA.class, fi, JNINativeInterface_.CallNonvirtualFloatMethodA$FUNC, session);
        }
        static CallNonvirtualFloatMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (float)JNINativeInterface_.CallNonvirtualFloatMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualFloatMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualFloatMethodA"));
    public static VarHandle CallNonvirtualFloatMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualFloatMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualFloatMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualFloatMethodA$VH.get(seg);
    }
    public static void CallNonvirtualFloatMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualFloatMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualFloatMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualFloatMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualFloatMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualFloatMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualFloatMethodA CallNonvirtualFloatMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualFloatMethodA.ofAddress(CallNonvirtualFloatMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualDoubleMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualDoubleMethod"));
    public static VarHandle CallNonvirtualDoubleMethod$VH() {
        return JNINativeInterface_.CallNonvirtualDoubleMethod$VH;
    }
    public static MemoryAddress CallNonvirtualDoubleMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualDoubleMethod$VH.get(seg);
    }
    public static void CallNonvirtualDoubleMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualDoubleMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualDoubleMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualDoubleMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualDoubleMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualDoubleMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualDoubleMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualDoubleMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualDoubleMethodV$FUNC
    );
    public interface CallNonvirtualDoubleMethodV {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualDoubleMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualDoubleMethodV.class, fi, JNINativeInterface_.CallNonvirtualDoubleMethodV$FUNC, session);
        }
        static CallNonvirtualDoubleMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (double)JNINativeInterface_.CallNonvirtualDoubleMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualDoubleMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualDoubleMethodV"));
    public static VarHandle CallNonvirtualDoubleMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualDoubleMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualDoubleMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualDoubleMethodV$VH.get(seg);
    }
    public static void CallNonvirtualDoubleMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualDoubleMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualDoubleMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualDoubleMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualDoubleMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualDoubleMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualDoubleMethodV CallNonvirtualDoubleMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualDoubleMethodV.ofAddress(CallNonvirtualDoubleMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualDoubleMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualDoubleMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualDoubleMethodA$FUNC
    );
    public interface CallNonvirtualDoubleMethodA {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualDoubleMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualDoubleMethodA.class, fi, JNINativeInterface_.CallNonvirtualDoubleMethodA$FUNC, session);
        }
        static CallNonvirtualDoubleMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    return (double)JNINativeInterface_.CallNonvirtualDoubleMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualDoubleMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualDoubleMethodA"));
    public static VarHandle CallNonvirtualDoubleMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualDoubleMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualDoubleMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualDoubleMethodA$VH.get(seg);
    }
    public static void CallNonvirtualDoubleMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualDoubleMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualDoubleMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualDoubleMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualDoubleMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualDoubleMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualDoubleMethodA CallNonvirtualDoubleMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualDoubleMethodA.ofAddress(CallNonvirtualDoubleMethodA$get(segment), session);
    }
    static final VarHandle CallNonvirtualVoidMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualVoidMethod"));
    public static VarHandle CallNonvirtualVoidMethod$VH() {
        return JNINativeInterface_.CallNonvirtualVoidMethod$VH;
    }
    public static MemoryAddress CallNonvirtualVoidMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualVoidMethod$VH.get(seg);
    }
    public static void CallNonvirtualVoidMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualVoidMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualVoidMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualVoidMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualVoidMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualVoidMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallNonvirtualVoidMethodV$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualVoidMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualVoidMethodV$FUNC
    );
    public interface CallNonvirtualVoidMethodV {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualVoidMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualVoidMethodV.class, fi, JNINativeInterface_.CallNonvirtualVoidMethodV$FUNC, session);
        }
        static CallNonvirtualVoidMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.CallNonvirtualVoidMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualVoidMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualVoidMethodV"));
    public static VarHandle CallNonvirtualVoidMethodV$VH() {
        return JNINativeInterface_.CallNonvirtualVoidMethodV$VH;
    }
    public static MemoryAddress CallNonvirtualVoidMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualVoidMethodV$VH.get(seg);
    }
    public static void CallNonvirtualVoidMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualVoidMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualVoidMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualVoidMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualVoidMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualVoidMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualVoidMethodV CallNonvirtualVoidMethodV (MemorySegment segment, MemorySession session) {
        return CallNonvirtualVoidMethodV.ofAddress(CallNonvirtualVoidMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallNonvirtualVoidMethodA$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallNonvirtualVoidMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallNonvirtualVoidMethodA$FUNC
    );
    public interface CallNonvirtualVoidMethodA {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(CallNonvirtualVoidMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallNonvirtualVoidMethodA.class, fi, JNINativeInterface_.CallNonvirtualVoidMethodA$FUNC, session);
        }
        static CallNonvirtualVoidMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.CallNonvirtualVoidMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallNonvirtualVoidMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallNonvirtualVoidMethodA"));
    public static VarHandle CallNonvirtualVoidMethodA$VH() {
        return JNINativeInterface_.CallNonvirtualVoidMethodA$VH;
    }
    public static MemoryAddress CallNonvirtualVoidMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualVoidMethodA$VH.get(seg);
    }
    public static void CallNonvirtualVoidMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualVoidMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallNonvirtualVoidMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallNonvirtualVoidMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallNonvirtualVoidMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallNonvirtualVoidMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallNonvirtualVoidMethodA CallNonvirtualVoidMethodA (MemorySegment segment, MemorySession session) {
        return CallNonvirtualVoidMethodA.ofAddress(CallNonvirtualVoidMethodA$get(segment), session);
    }
    static final FunctionDescriptor GetFieldID$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFieldID$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetFieldID$FUNC
    );
    public interface GetFieldID {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(GetFieldID fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFieldID.class, fi, JNINativeInterface_.GetFieldID$FUNC, session);
        }
        static GetFieldID ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFieldID$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFieldID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFieldID"));
    public static VarHandle GetFieldID$VH() {
        return JNINativeInterface_.GetFieldID$VH;
    }
    public static MemoryAddress GetFieldID$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFieldID$VH.get(seg);
    }
    public static void GetFieldID$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetFieldID$VH.set(seg, x);
    }
    public static MemoryAddress GetFieldID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFieldID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFieldID$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetFieldID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFieldID GetFieldID (MemorySegment segment, MemorySession session) {
        return GetFieldID.ofAddress(GetFieldID$get(segment), session);
    }
    static final FunctionDescriptor GetObjectField$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetObjectField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetObjectField$FUNC
    );
    public interface GetObjectField {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetObjectField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetObjectField.class, fi, JNINativeInterface_.GetObjectField$FUNC, session);
        }
        static GetObjectField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetObjectField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetObjectField"));
    public static VarHandle GetObjectField$VH() {
        return JNINativeInterface_.GetObjectField$VH;
    }
    public static MemoryAddress GetObjectField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectField$VH.get(seg);
    }
    public static void GetObjectField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetObjectField$VH.set(seg, x);
    }
    public static MemoryAddress GetObjectField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetObjectField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetObjectField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetObjectField GetObjectField (MemorySegment segment, MemorySession session) {
        return GetObjectField.ofAddress(GetObjectField$get(segment), session);
    }
    static final FunctionDescriptor GetBooleanField$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBooleanField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetBooleanField$FUNC
    );
    public interface GetBooleanField {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetBooleanField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBooleanField.class, fi, JNINativeInterface_.GetBooleanField$FUNC, session);
        }
        static GetBooleanField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (byte)JNINativeInterface_.GetBooleanField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBooleanField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBooleanField"));
    public static VarHandle GetBooleanField$VH() {
        return JNINativeInterface_.GetBooleanField$VH;
    }
    public static MemoryAddress GetBooleanField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetBooleanField$VH.get(seg);
    }
    public static void GetBooleanField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetBooleanField$VH.set(seg, x);
    }
    public static MemoryAddress GetBooleanField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetBooleanField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBooleanField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetBooleanField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBooleanField GetBooleanField (MemorySegment segment, MemorySession session) {
        return GetBooleanField.ofAddress(GetBooleanField$get(segment), session);
    }
    static final FunctionDescriptor GetByteField$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetByteField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetByteField$FUNC
    );
    public interface GetByteField {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetByteField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetByteField.class, fi, JNINativeInterface_.GetByteField$FUNC, session);
        }
        static GetByteField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (byte)JNINativeInterface_.GetByteField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetByteField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetByteField"));
    public static VarHandle GetByteField$VH() {
        return JNINativeInterface_.GetByteField$VH;
    }
    public static MemoryAddress GetByteField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetByteField$VH.get(seg);
    }
    public static void GetByteField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetByteField$VH.set(seg, x);
    }
    public static MemoryAddress GetByteField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetByteField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetByteField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetByteField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetByteField GetByteField (MemorySegment segment, MemorySession session) {
        return GetByteField.ofAddress(GetByteField$get(segment), session);
    }
    static final FunctionDescriptor GetCharField$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetCharField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetCharField$FUNC
    );
    public interface GetCharField {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetCharField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetCharField.class, fi, JNINativeInterface_.GetCharField$FUNC, session);
        }
        static GetCharField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (short)JNINativeInterface_.GetCharField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetCharField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetCharField"));
    public static VarHandle GetCharField$VH() {
        return JNINativeInterface_.GetCharField$VH;
    }
    public static MemoryAddress GetCharField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetCharField$VH.get(seg);
    }
    public static void GetCharField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetCharField$VH.set(seg, x);
    }
    public static MemoryAddress GetCharField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetCharField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetCharField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetCharField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetCharField GetCharField (MemorySegment segment, MemorySession session) {
        return GetCharField.ofAddress(GetCharField$get(segment), session);
    }
    static final FunctionDescriptor GetShortField$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetShortField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetShortField$FUNC
    );
    public interface GetShortField {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetShortField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetShortField.class, fi, JNINativeInterface_.GetShortField$FUNC, session);
        }
        static GetShortField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (short)JNINativeInterface_.GetShortField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetShortField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetShortField"));
    public static VarHandle GetShortField$VH() {
        return JNINativeInterface_.GetShortField$VH;
    }
    public static MemoryAddress GetShortField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetShortField$VH.get(seg);
    }
    public static void GetShortField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetShortField$VH.set(seg, x);
    }
    public static MemoryAddress GetShortField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetShortField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetShortField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetShortField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetShortField GetShortField (MemorySegment segment, MemorySession session) {
        return GetShortField.ofAddress(GetShortField$get(segment), session);
    }
    static final FunctionDescriptor GetIntField$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetIntField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetIntField$FUNC
    );
    public interface GetIntField {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetIntField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetIntField.class, fi, JNINativeInterface_.GetIntField$FUNC, session);
        }
        static GetIntField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)JNINativeInterface_.GetIntField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetIntField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetIntField"));
    public static VarHandle GetIntField$VH() {
        return JNINativeInterface_.GetIntField$VH;
    }
    public static MemoryAddress GetIntField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetIntField$VH.get(seg);
    }
    public static void GetIntField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetIntField$VH.set(seg, x);
    }
    public static MemoryAddress GetIntField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetIntField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetIntField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetIntField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetIntField GetIntField (MemorySegment segment, MemorySession session) {
        return GetIntField.ofAddress(GetIntField$get(segment), session);
    }
    static final FunctionDescriptor GetLongField$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetLongField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetLongField$FUNC
    );
    public interface GetLongField {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetLongField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetLongField.class, fi, JNINativeInterface_.GetLongField$FUNC, session);
        }
        static GetLongField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (long)JNINativeInterface_.GetLongField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetLongField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetLongField"));
    public static VarHandle GetLongField$VH() {
        return JNINativeInterface_.GetLongField$VH;
    }
    public static MemoryAddress GetLongField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetLongField$VH.get(seg);
    }
    public static void GetLongField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetLongField$VH.set(seg, x);
    }
    public static MemoryAddress GetLongField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetLongField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetLongField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetLongField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetLongField GetLongField (MemorySegment segment, MemorySession session) {
        return GetLongField.ofAddress(GetLongField$get(segment), session);
    }
    static final FunctionDescriptor GetFloatField$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFloatField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetFloatField$FUNC
    );
    public interface GetFloatField {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetFloatField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFloatField.class, fi, JNINativeInterface_.GetFloatField$FUNC, session);
        }
        static GetFloatField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (float)JNINativeInterface_.GetFloatField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFloatField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFloatField"));
    public static VarHandle GetFloatField$VH() {
        return JNINativeInterface_.GetFloatField$VH;
    }
    public static MemoryAddress GetFloatField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFloatField$VH.get(seg);
    }
    public static void GetFloatField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetFloatField$VH.set(seg, x);
    }
    public static MemoryAddress GetFloatField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFloatField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFloatField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetFloatField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFloatField GetFloatField (MemorySegment segment, MemorySession session) {
        return GetFloatField.ofAddress(GetFloatField$get(segment), session);
    }
    static final FunctionDescriptor GetDoubleField$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDoubleField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetDoubleField$FUNC
    );
    public interface GetDoubleField {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetDoubleField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDoubleField.class, fi, JNINativeInterface_.GetDoubleField$FUNC, session);
        }
        static GetDoubleField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (double)JNINativeInterface_.GetDoubleField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDoubleField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDoubleField"));
    public static VarHandle GetDoubleField$VH() {
        return JNINativeInterface_.GetDoubleField$VH;
    }
    public static MemoryAddress GetDoubleField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDoubleField$VH.get(seg);
    }
    public static void GetDoubleField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetDoubleField$VH.set(seg, x);
    }
    public static MemoryAddress GetDoubleField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDoubleField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDoubleField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetDoubleField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDoubleField GetDoubleField (MemorySegment segment, MemorySession session) {
        return GetDoubleField.ofAddress(GetDoubleField$get(segment), session);
    }
    static final FunctionDescriptor SetObjectField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetObjectField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetObjectField$FUNC
    );
    public interface SetObjectField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(SetObjectField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetObjectField.class, fi, JNINativeInterface_.SetObjectField$FUNC, session);
        }
        static SetObjectField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    JNINativeInterface_.SetObjectField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetObjectField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetObjectField"));
    public static VarHandle SetObjectField$VH() {
        return JNINativeInterface_.SetObjectField$VH;
    }
    public static MemoryAddress SetObjectField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetObjectField$VH.get(seg);
    }
    public static void SetObjectField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetObjectField$VH.set(seg, x);
    }
    public static MemoryAddress SetObjectField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetObjectField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetObjectField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetObjectField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetObjectField SetObjectField (MemorySegment segment, MemorySession session) {
        return SetObjectField.ofAddress(SetObjectField$get(segment), session);
    }
    static final FunctionDescriptor SetBooleanField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetBooleanField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetBooleanField$FUNC
    );
    public interface SetBooleanField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, byte _x3);
        static MemorySegment allocate(SetBooleanField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetBooleanField.class, fi, JNINativeInterface_.SetBooleanField$FUNC, session);
        }
        static SetBooleanField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, byte __x3) -> {
                try {
                    JNINativeInterface_.SetBooleanField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetBooleanField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetBooleanField"));
    public static VarHandle SetBooleanField$VH() {
        return JNINativeInterface_.SetBooleanField$VH;
    }
    public static MemoryAddress SetBooleanField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetBooleanField$VH.get(seg);
    }
    public static void SetBooleanField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetBooleanField$VH.set(seg, x);
    }
    public static MemoryAddress SetBooleanField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetBooleanField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetBooleanField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetBooleanField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetBooleanField SetBooleanField (MemorySegment segment, MemorySession session) {
        return SetBooleanField.ofAddress(SetBooleanField$get(segment), session);
    }
    static final FunctionDescriptor SetByteField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetByteField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetByteField$FUNC
    );
    public interface SetByteField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, byte _x3);
        static MemorySegment allocate(SetByteField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetByteField.class, fi, JNINativeInterface_.SetByteField$FUNC, session);
        }
        static SetByteField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, byte __x3) -> {
                try {
                    JNINativeInterface_.SetByteField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetByteField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetByteField"));
    public static VarHandle SetByteField$VH() {
        return JNINativeInterface_.SetByteField$VH;
    }
    public static MemoryAddress SetByteField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetByteField$VH.get(seg);
    }
    public static void SetByteField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetByteField$VH.set(seg, x);
    }
    public static MemoryAddress SetByteField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetByteField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetByteField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetByteField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetByteField SetByteField (MemorySegment segment, MemorySession session) {
        return SetByteField.ofAddress(SetByteField$get(segment), session);
    }
    static final FunctionDescriptor SetCharField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_SHORT$LAYOUT
    );
    static final MethodHandle SetCharField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetCharField$FUNC
    );
    public interface SetCharField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, short _x3);
        static MemorySegment allocate(SetCharField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetCharField.class, fi, JNINativeInterface_.SetCharField$FUNC, session);
        }
        static SetCharField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, short __x3) -> {
                try {
                    JNINativeInterface_.SetCharField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetCharField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetCharField"));
    public static VarHandle SetCharField$VH() {
        return JNINativeInterface_.SetCharField$VH;
    }
    public static MemoryAddress SetCharField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetCharField$VH.get(seg);
    }
    public static void SetCharField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetCharField$VH.set(seg, x);
    }
    public static MemoryAddress SetCharField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetCharField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetCharField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetCharField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetCharField SetCharField (MemorySegment segment, MemorySession session) {
        return SetCharField.ofAddress(SetCharField$get(segment), session);
    }
    static final FunctionDescriptor SetShortField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_SHORT$LAYOUT
    );
    static final MethodHandle SetShortField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetShortField$FUNC
    );
    public interface SetShortField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, short _x3);
        static MemorySegment allocate(SetShortField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetShortField.class, fi, JNINativeInterface_.SetShortField$FUNC, session);
        }
        static SetShortField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, short __x3) -> {
                try {
                    JNINativeInterface_.SetShortField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetShortField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetShortField"));
    public static VarHandle SetShortField$VH() {
        return JNINativeInterface_.SetShortField$VH;
    }
    public static MemoryAddress SetShortField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetShortField$VH.get(seg);
    }
    public static void SetShortField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetShortField$VH.set(seg, x);
    }
    public static MemoryAddress SetShortField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetShortField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetShortField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetShortField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetShortField SetShortField (MemorySegment segment, MemorySession session) {
        return SetShortField.ofAddress(SetShortField$get(segment), session);
    }
    static final FunctionDescriptor SetIntField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle SetIntField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetIntField$FUNC
    );
    public interface SetIntField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(SetIntField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetIntField.class, fi, JNINativeInterface_.SetIntField$FUNC, session);
        }
        static SetIntField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.SetIntField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetIntField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetIntField"));
    public static VarHandle SetIntField$VH() {
        return JNINativeInterface_.SetIntField$VH;
    }
    public static MemoryAddress SetIntField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetIntField$VH.get(seg);
    }
    public static void SetIntField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetIntField$VH.set(seg, x);
    }
    public static MemoryAddress SetIntField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetIntField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetIntField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetIntField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetIntField SetIntField (MemorySegment segment, MemorySession session) {
        return SetIntField.ofAddress(SetIntField$get(segment), session);
    }
    static final FunctionDescriptor SetLongField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle SetLongField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetLongField$FUNC
    );
    public interface SetLongField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, long _x3);
        static MemorySegment allocate(SetLongField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetLongField.class, fi, JNINativeInterface_.SetLongField$FUNC, session);
        }
        static SetLongField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, long __x3) -> {
                try {
                    JNINativeInterface_.SetLongField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetLongField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetLongField"));
    public static VarHandle SetLongField$VH() {
        return JNINativeInterface_.SetLongField$VH;
    }
    public static MemoryAddress SetLongField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetLongField$VH.get(seg);
    }
    public static void SetLongField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetLongField$VH.set(seg, x);
    }
    public static MemoryAddress SetLongField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetLongField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetLongField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetLongField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetLongField SetLongField (MemorySegment segment, MemorySession session) {
        return SetLongField.ofAddress(SetLongField$get(segment), session);
    }
    static final FunctionDescriptor SetFloatField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_FLOAT$LAYOUT
    );
    static final MethodHandle SetFloatField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetFloatField$FUNC
    );
    public interface SetFloatField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, float _x3);
        static MemorySegment allocate(SetFloatField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetFloatField.class, fi, JNINativeInterface_.SetFloatField$FUNC, session);
        }
        static SetFloatField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, float __x3) -> {
                try {
                    JNINativeInterface_.SetFloatField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetFloatField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetFloatField"));
    public static VarHandle SetFloatField$VH() {
        return JNINativeInterface_.SetFloatField$VH;
    }
    public static MemoryAddress SetFloatField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetFloatField$VH.get(seg);
    }
    public static void SetFloatField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetFloatField$VH.set(seg, x);
    }
    public static MemoryAddress SetFloatField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetFloatField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetFloatField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetFloatField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetFloatField SetFloatField (MemorySegment segment, MemorySession session) {
        return SetFloatField.ofAddress(SetFloatField$get(segment), session);
    }
    static final FunctionDescriptor SetDoubleField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_DOUBLE$LAYOUT
    );
    static final MethodHandle SetDoubleField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetDoubleField$FUNC
    );
    public interface SetDoubleField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, double _x3);
        static MemorySegment allocate(SetDoubleField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetDoubleField.class, fi, JNINativeInterface_.SetDoubleField$FUNC, session);
        }
        static SetDoubleField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, double __x3) -> {
                try {
                    JNINativeInterface_.SetDoubleField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetDoubleField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetDoubleField"));
    public static VarHandle SetDoubleField$VH() {
        return JNINativeInterface_.SetDoubleField$VH;
    }
    public static MemoryAddress SetDoubleField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetDoubleField$VH.get(seg);
    }
    public static void SetDoubleField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetDoubleField$VH.set(seg, x);
    }
    public static MemoryAddress SetDoubleField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetDoubleField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetDoubleField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetDoubleField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetDoubleField SetDoubleField (MemorySegment segment, MemorySession session) {
        return SetDoubleField.ofAddress(SetDoubleField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticMethodID$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticMethodID$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticMethodID$FUNC
    );
    public interface GetStaticMethodID {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(GetStaticMethodID fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticMethodID.class, fi, JNINativeInterface_.GetStaticMethodID$FUNC, session);
        }
        static GetStaticMethodID ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticMethodID$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticMethodID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticMethodID"));
    public static VarHandle GetStaticMethodID$VH() {
        return JNINativeInterface_.GetStaticMethodID$VH;
    }
    public static MemoryAddress GetStaticMethodID$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticMethodID$VH.get(seg);
    }
    public static void GetStaticMethodID$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticMethodID$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticMethodID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticMethodID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticMethodID$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticMethodID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticMethodID GetStaticMethodID (MemorySegment segment, MemorySession session) {
        return GetStaticMethodID.ofAddress(GetStaticMethodID$get(segment), session);
    }
    static final VarHandle CallStaticObjectMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticObjectMethod"));
    public static VarHandle CallStaticObjectMethod$VH() {
        return JNINativeInterface_.CallStaticObjectMethod$VH;
    }
    public static MemoryAddress CallStaticObjectMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethod$VH.get(seg);
    }
    public static void CallStaticObjectMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticObjectMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticObjectMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticObjectMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticObjectMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticObjectMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticObjectMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticObjectMethodV$FUNC
    );
    public interface CallStaticObjectMethodV {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticObjectMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticObjectMethodV.class, fi, JNINativeInterface_.CallStaticObjectMethodV$FUNC, session);
        }
        static CallStaticObjectMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticObjectMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticObjectMethodV"));
    public static VarHandle CallStaticObjectMethodV$VH() {
        return JNINativeInterface_.CallStaticObjectMethodV$VH;
    }
    public static MemoryAddress CallStaticObjectMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethodV$VH.get(seg);
    }
    public static void CallStaticObjectMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticObjectMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticObjectMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticObjectMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticObjectMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticObjectMethodV CallStaticObjectMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticObjectMethodV.ofAddress(CallStaticObjectMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticObjectMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticObjectMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticObjectMethodA$FUNC
    );
    public interface CallStaticObjectMethodA {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticObjectMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticObjectMethodA.class, fi, JNINativeInterface_.CallStaticObjectMethodA$FUNC, session);
        }
        static CallStaticObjectMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticObjectMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticObjectMethodA"));
    public static VarHandle CallStaticObjectMethodA$VH() {
        return JNINativeInterface_.CallStaticObjectMethodA$VH;
    }
    public static MemoryAddress CallStaticObjectMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethodA$VH.get(seg);
    }
    public static void CallStaticObjectMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticObjectMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticObjectMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticObjectMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticObjectMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticObjectMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticObjectMethodA CallStaticObjectMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticObjectMethodA.ofAddress(CallStaticObjectMethodA$get(segment), session);
    }
    static final VarHandle CallStaticBooleanMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticBooleanMethod"));
    public static VarHandle CallStaticBooleanMethod$VH() {
        return JNINativeInterface_.CallStaticBooleanMethod$VH;
    }
    public static MemoryAddress CallStaticBooleanMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticBooleanMethod$VH.get(seg);
    }
    public static void CallStaticBooleanMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticBooleanMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticBooleanMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticBooleanMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticBooleanMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticBooleanMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticBooleanMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticBooleanMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticBooleanMethodV$FUNC
    );
    public interface CallStaticBooleanMethodV {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticBooleanMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticBooleanMethodV.class, fi, JNINativeInterface_.CallStaticBooleanMethodV$FUNC, session);
        }
        static CallStaticBooleanMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallStaticBooleanMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticBooleanMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticBooleanMethodV"));
    public static VarHandle CallStaticBooleanMethodV$VH() {
        return JNINativeInterface_.CallStaticBooleanMethodV$VH;
    }
    public static MemoryAddress CallStaticBooleanMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticBooleanMethodV$VH.get(seg);
    }
    public static void CallStaticBooleanMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticBooleanMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticBooleanMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticBooleanMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticBooleanMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticBooleanMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticBooleanMethodV CallStaticBooleanMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticBooleanMethodV.ofAddress(CallStaticBooleanMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticBooleanMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticBooleanMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticBooleanMethodA$FUNC
    );
    public interface CallStaticBooleanMethodA {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticBooleanMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticBooleanMethodA.class, fi, JNINativeInterface_.CallStaticBooleanMethodA$FUNC, session);
        }
        static CallStaticBooleanMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallStaticBooleanMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticBooleanMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticBooleanMethodA"));
    public static VarHandle CallStaticBooleanMethodA$VH() {
        return JNINativeInterface_.CallStaticBooleanMethodA$VH;
    }
    public static MemoryAddress CallStaticBooleanMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticBooleanMethodA$VH.get(seg);
    }
    public static void CallStaticBooleanMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticBooleanMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticBooleanMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticBooleanMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticBooleanMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticBooleanMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticBooleanMethodA CallStaticBooleanMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticBooleanMethodA.ofAddress(CallStaticBooleanMethodA$get(segment), session);
    }
    static final VarHandle CallStaticByteMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticByteMethod"));
    public static VarHandle CallStaticByteMethod$VH() {
        return JNINativeInterface_.CallStaticByteMethod$VH;
    }
    public static MemoryAddress CallStaticByteMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticByteMethod$VH.get(seg);
    }
    public static void CallStaticByteMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticByteMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticByteMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticByteMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticByteMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticByteMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticByteMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticByteMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticByteMethodV$FUNC
    );
    public interface CallStaticByteMethodV {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticByteMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticByteMethodV.class, fi, JNINativeInterface_.CallStaticByteMethodV$FUNC, session);
        }
        static CallStaticByteMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallStaticByteMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticByteMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticByteMethodV"));
    public static VarHandle CallStaticByteMethodV$VH() {
        return JNINativeInterface_.CallStaticByteMethodV$VH;
    }
    public static MemoryAddress CallStaticByteMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticByteMethodV$VH.get(seg);
    }
    public static void CallStaticByteMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticByteMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticByteMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticByteMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticByteMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticByteMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticByteMethodV CallStaticByteMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticByteMethodV.ofAddress(CallStaticByteMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticByteMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticByteMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticByteMethodA$FUNC
    );
    public interface CallStaticByteMethodA {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticByteMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticByteMethodA.class, fi, JNINativeInterface_.CallStaticByteMethodA$FUNC, session);
        }
        static CallStaticByteMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (byte)JNINativeInterface_.CallStaticByteMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticByteMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticByteMethodA"));
    public static VarHandle CallStaticByteMethodA$VH() {
        return JNINativeInterface_.CallStaticByteMethodA$VH;
    }
    public static MemoryAddress CallStaticByteMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticByteMethodA$VH.get(seg);
    }
    public static void CallStaticByteMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticByteMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticByteMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticByteMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticByteMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticByteMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticByteMethodA CallStaticByteMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticByteMethodA.ofAddress(CallStaticByteMethodA$get(segment), session);
    }
    static final VarHandle CallStaticCharMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticCharMethod"));
    public static VarHandle CallStaticCharMethod$VH() {
        return JNINativeInterface_.CallStaticCharMethod$VH;
    }
    public static MemoryAddress CallStaticCharMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticCharMethod$VH.get(seg);
    }
    public static void CallStaticCharMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticCharMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticCharMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticCharMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticCharMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticCharMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticCharMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticCharMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticCharMethodV$FUNC
    );
    public interface CallStaticCharMethodV {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticCharMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticCharMethodV.class, fi, JNINativeInterface_.CallStaticCharMethodV$FUNC, session);
        }
        static CallStaticCharMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallStaticCharMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticCharMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticCharMethodV"));
    public static VarHandle CallStaticCharMethodV$VH() {
        return JNINativeInterface_.CallStaticCharMethodV$VH;
    }
    public static MemoryAddress CallStaticCharMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticCharMethodV$VH.get(seg);
    }
    public static void CallStaticCharMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticCharMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticCharMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticCharMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticCharMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticCharMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticCharMethodV CallStaticCharMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticCharMethodV.ofAddress(CallStaticCharMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticCharMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticCharMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticCharMethodA$FUNC
    );
    public interface CallStaticCharMethodA {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticCharMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticCharMethodA.class, fi, JNINativeInterface_.CallStaticCharMethodA$FUNC, session);
        }
        static CallStaticCharMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallStaticCharMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticCharMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticCharMethodA"));
    public static VarHandle CallStaticCharMethodA$VH() {
        return JNINativeInterface_.CallStaticCharMethodA$VH;
    }
    public static MemoryAddress CallStaticCharMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticCharMethodA$VH.get(seg);
    }
    public static void CallStaticCharMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticCharMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticCharMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticCharMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticCharMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticCharMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticCharMethodA CallStaticCharMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticCharMethodA.ofAddress(CallStaticCharMethodA$get(segment), session);
    }
    static final VarHandle CallStaticShortMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticShortMethod"));
    public static VarHandle CallStaticShortMethod$VH() {
        return JNINativeInterface_.CallStaticShortMethod$VH;
    }
    public static MemoryAddress CallStaticShortMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticShortMethod$VH.get(seg);
    }
    public static void CallStaticShortMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticShortMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticShortMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticShortMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticShortMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticShortMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticShortMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticShortMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticShortMethodV$FUNC
    );
    public interface CallStaticShortMethodV {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticShortMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticShortMethodV.class, fi, JNINativeInterface_.CallStaticShortMethodV$FUNC, session);
        }
        static CallStaticShortMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallStaticShortMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticShortMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticShortMethodV"));
    public static VarHandle CallStaticShortMethodV$VH() {
        return JNINativeInterface_.CallStaticShortMethodV$VH;
    }
    public static MemoryAddress CallStaticShortMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticShortMethodV$VH.get(seg);
    }
    public static void CallStaticShortMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticShortMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticShortMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticShortMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticShortMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticShortMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticShortMethodV CallStaticShortMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticShortMethodV.ofAddress(CallStaticShortMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticShortMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticShortMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticShortMethodA$FUNC
    );
    public interface CallStaticShortMethodA {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticShortMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticShortMethodA.class, fi, JNINativeInterface_.CallStaticShortMethodA$FUNC, session);
        }
        static CallStaticShortMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (short)JNINativeInterface_.CallStaticShortMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticShortMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticShortMethodA"));
    public static VarHandle CallStaticShortMethodA$VH() {
        return JNINativeInterface_.CallStaticShortMethodA$VH;
    }
    public static MemoryAddress CallStaticShortMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticShortMethodA$VH.get(seg);
    }
    public static void CallStaticShortMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticShortMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticShortMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticShortMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticShortMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticShortMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticShortMethodA CallStaticShortMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticShortMethodA.ofAddress(CallStaticShortMethodA$get(segment), session);
    }
    static final VarHandle CallStaticIntMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticIntMethod"));
    public static VarHandle CallStaticIntMethod$VH() {
        return JNINativeInterface_.CallStaticIntMethod$VH;
    }
    public static MemoryAddress CallStaticIntMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticIntMethod$VH.get(seg);
    }
    public static void CallStaticIntMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticIntMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticIntMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticIntMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticIntMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticIntMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticIntMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticIntMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticIntMethodV$FUNC
    );
    public interface CallStaticIntMethodV {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticIntMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticIntMethodV.class, fi, JNINativeInterface_.CallStaticIntMethodV$FUNC, session);
        }
        static CallStaticIntMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)JNINativeInterface_.CallStaticIntMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticIntMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticIntMethodV"));
    public static VarHandle CallStaticIntMethodV$VH() {
        return JNINativeInterface_.CallStaticIntMethodV$VH;
    }
    public static MemoryAddress CallStaticIntMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticIntMethodV$VH.get(seg);
    }
    public static void CallStaticIntMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticIntMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticIntMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticIntMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticIntMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticIntMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticIntMethodV CallStaticIntMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticIntMethodV.ofAddress(CallStaticIntMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticIntMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticIntMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticIntMethodA$FUNC
    );
    public interface CallStaticIntMethodA {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticIntMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticIntMethodA.class, fi, JNINativeInterface_.CallStaticIntMethodA$FUNC, session);
        }
        static CallStaticIntMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (int)JNINativeInterface_.CallStaticIntMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticIntMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticIntMethodA"));
    public static VarHandle CallStaticIntMethodA$VH() {
        return JNINativeInterface_.CallStaticIntMethodA$VH;
    }
    public static MemoryAddress CallStaticIntMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticIntMethodA$VH.get(seg);
    }
    public static void CallStaticIntMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticIntMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticIntMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticIntMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticIntMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticIntMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticIntMethodA CallStaticIntMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticIntMethodA.ofAddress(CallStaticIntMethodA$get(segment), session);
    }
    static final VarHandle CallStaticLongMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticLongMethod"));
    public static VarHandle CallStaticLongMethod$VH() {
        return JNINativeInterface_.CallStaticLongMethod$VH;
    }
    public static MemoryAddress CallStaticLongMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticLongMethod$VH.get(seg);
    }
    public static void CallStaticLongMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticLongMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticLongMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticLongMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticLongMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticLongMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticLongMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticLongMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticLongMethodV$FUNC
    );
    public interface CallStaticLongMethodV {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticLongMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticLongMethodV.class, fi, JNINativeInterface_.CallStaticLongMethodV$FUNC, session);
        }
        static CallStaticLongMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (long)JNINativeInterface_.CallStaticLongMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticLongMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticLongMethodV"));
    public static VarHandle CallStaticLongMethodV$VH() {
        return JNINativeInterface_.CallStaticLongMethodV$VH;
    }
    public static MemoryAddress CallStaticLongMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticLongMethodV$VH.get(seg);
    }
    public static void CallStaticLongMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticLongMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticLongMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticLongMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticLongMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticLongMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticLongMethodV CallStaticLongMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticLongMethodV.ofAddress(CallStaticLongMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticLongMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticLongMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticLongMethodA$FUNC
    );
    public interface CallStaticLongMethodA {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticLongMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticLongMethodA.class, fi, JNINativeInterface_.CallStaticLongMethodA$FUNC, session);
        }
        static CallStaticLongMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (long)JNINativeInterface_.CallStaticLongMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticLongMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticLongMethodA"));
    public static VarHandle CallStaticLongMethodA$VH() {
        return JNINativeInterface_.CallStaticLongMethodA$VH;
    }
    public static MemoryAddress CallStaticLongMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticLongMethodA$VH.get(seg);
    }
    public static void CallStaticLongMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticLongMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticLongMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticLongMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticLongMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticLongMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticLongMethodA CallStaticLongMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticLongMethodA.ofAddress(CallStaticLongMethodA$get(segment), session);
    }
    static final VarHandle CallStaticFloatMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticFloatMethod"));
    public static VarHandle CallStaticFloatMethod$VH() {
        return JNINativeInterface_.CallStaticFloatMethod$VH;
    }
    public static MemoryAddress CallStaticFloatMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticFloatMethod$VH.get(seg);
    }
    public static void CallStaticFloatMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticFloatMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticFloatMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticFloatMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticFloatMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticFloatMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticFloatMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticFloatMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticFloatMethodV$FUNC
    );
    public interface CallStaticFloatMethodV {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticFloatMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticFloatMethodV.class, fi, JNINativeInterface_.CallStaticFloatMethodV$FUNC, session);
        }
        static CallStaticFloatMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (float)JNINativeInterface_.CallStaticFloatMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticFloatMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticFloatMethodV"));
    public static VarHandle CallStaticFloatMethodV$VH() {
        return JNINativeInterface_.CallStaticFloatMethodV$VH;
    }
    public static MemoryAddress CallStaticFloatMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticFloatMethodV$VH.get(seg);
    }
    public static void CallStaticFloatMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticFloatMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticFloatMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticFloatMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticFloatMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticFloatMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticFloatMethodV CallStaticFloatMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticFloatMethodV.ofAddress(CallStaticFloatMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticFloatMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticFloatMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticFloatMethodA$FUNC
    );
    public interface CallStaticFloatMethodA {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticFloatMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticFloatMethodA.class, fi, JNINativeInterface_.CallStaticFloatMethodA$FUNC, session);
        }
        static CallStaticFloatMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (float)JNINativeInterface_.CallStaticFloatMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticFloatMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticFloatMethodA"));
    public static VarHandle CallStaticFloatMethodA$VH() {
        return JNINativeInterface_.CallStaticFloatMethodA$VH;
    }
    public static MemoryAddress CallStaticFloatMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticFloatMethodA$VH.get(seg);
    }
    public static void CallStaticFloatMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticFloatMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticFloatMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticFloatMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticFloatMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticFloatMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticFloatMethodA CallStaticFloatMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticFloatMethodA.ofAddress(CallStaticFloatMethodA$get(segment), session);
    }
    static final VarHandle CallStaticDoubleMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticDoubleMethod"));
    public static VarHandle CallStaticDoubleMethod$VH() {
        return JNINativeInterface_.CallStaticDoubleMethod$VH;
    }
    public static MemoryAddress CallStaticDoubleMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticDoubleMethod$VH.get(seg);
    }
    public static void CallStaticDoubleMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticDoubleMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticDoubleMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticDoubleMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticDoubleMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticDoubleMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticDoubleMethodV$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticDoubleMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticDoubleMethodV$FUNC
    );
    public interface CallStaticDoubleMethodV {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticDoubleMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticDoubleMethodV.class, fi, JNINativeInterface_.CallStaticDoubleMethodV$FUNC, session);
        }
        static CallStaticDoubleMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (double)JNINativeInterface_.CallStaticDoubleMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticDoubleMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticDoubleMethodV"));
    public static VarHandle CallStaticDoubleMethodV$VH() {
        return JNINativeInterface_.CallStaticDoubleMethodV$VH;
    }
    public static MemoryAddress CallStaticDoubleMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticDoubleMethodV$VH.get(seg);
    }
    public static void CallStaticDoubleMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticDoubleMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticDoubleMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticDoubleMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticDoubleMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticDoubleMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticDoubleMethodV CallStaticDoubleMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticDoubleMethodV.ofAddress(CallStaticDoubleMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticDoubleMethodA$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticDoubleMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticDoubleMethodA$FUNC
    );
    public interface CallStaticDoubleMethodA {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticDoubleMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticDoubleMethodA.class, fi, JNINativeInterface_.CallStaticDoubleMethodA$FUNC, session);
        }
        static CallStaticDoubleMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (double)JNINativeInterface_.CallStaticDoubleMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticDoubleMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticDoubleMethodA"));
    public static VarHandle CallStaticDoubleMethodA$VH() {
        return JNINativeInterface_.CallStaticDoubleMethodA$VH;
    }
    public static MemoryAddress CallStaticDoubleMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticDoubleMethodA$VH.get(seg);
    }
    public static void CallStaticDoubleMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticDoubleMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticDoubleMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticDoubleMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticDoubleMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticDoubleMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticDoubleMethodA CallStaticDoubleMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticDoubleMethodA.ofAddress(CallStaticDoubleMethodA$get(segment), session);
    }
    static final VarHandle CallStaticVoidMethod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticVoidMethod"));
    public static VarHandle CallStaticVoidMethod$VH() {
        return JNINativeInterface_.CallStaticVoidMethod$VH;
    }
    public static MemoryAddress CallStaticVoidMethod$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticVoidMethod$VH.get(seg);
    }
    public static void CallStaticVoidMethod$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticVoidMethod$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticVoidMethod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticVoidMethod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticVoidMethod$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticVoidMethod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final FunctionDescriptor CallStaticVoidMethodV$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticVoidMethodV$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticVoidMethodV$FUNC
    );
    public interface CallStaticVoidMethodV {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticVoidMethodV fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticVoidMethodV.class, fi, JNINativeInterface_.CallStaticVoidMethodV$FUNC, session);
        }
        static CallStaticVoidMethodV ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    JNINativeInterface_.CallStaticVoidMethodV$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticVoidMethodV$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticVoidMethodV"));
    public static VarHandle CallStaticVoidMethodV$VH() {
        return JNINativeInterface_.CallStaticVoidMethodV$VH;
    }
    public static MemoryAddress CallStaticVoidMethodV$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticVoidMethodV$VH.get(seg);
    }
    public static void CallStaticVoidMethodV$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticVoidMethodV$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticVoidMethodV$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticVoidMethodV$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticVoidMethodV$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticVoidMethodV$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticVoidMethodV CallStaticVoidMethodV (MemorySegment segment, MemorySession session) {
        return CallStaticVoidMethodV.ofAddress(CallStaticVoidMethodV$get(segment), session);
    }
    static final FunctionDescriptor CallStaticVoidMethodA$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle CallStaticVoidMethodA$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.CallStaticVoidMethodA$FUNC
    );
    public interface CallStaticVoidMethodA {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(CallStaticVoidMethodA fi, MemorySession session) {
            return RuntimeHelper.upcallStub(CallStaticVoidMethodA.class, fi, JNINativeInterface_.CallStaticVoidMethodA$FUNC, session);
        }
        static CallStaticVoidMethodA ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    JNINativeInterface_.CallStaticVoidMethodA$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle CallStaticVoidMethodA$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("CallStaticVoidMethodA"));
    public static VarHandle CallStaticVoidMethodA$VH() {
        return JNINativeInterface_.CallStaticVoidMethodA$VH;
    }
    public static MemoryAddress CallStaticVoidMethodA$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticVoidMethodA$VH.get(seg);
    }
    public static void CallStaticVoidMethodA$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.CallStaticVoidMethodA$VH.set(seg, x);
    }
    public static MemoryAddress CallStaticVoidMethodA$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.CallStaticVoidMethodA$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void CallStaticVoidMethodA$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.CallStaticVoidMethodA$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static CallStaticVoidMethodA CallStaticVoidMethodA (MemorySegment segment, MemorySession session) {
        return CallStaticVoidMethodA.ofAddress(CallStaticVoidMethodA$get(segment), session);
    }
    static final FunctionDescriptor GetStaticFieldID$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticFieldID$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticFieldID$FUNC
    );
    public interface GetStaticFieldID {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(GetStaticFieldID fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticFieldID.class, fi, JNINativeInterface_.GetStaticFieldID$FUNC, session);
        }
        static GetStaticFieldID ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticFieldID$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticFieldID$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticFieldID"));
    public static VarHandle GetStaticFieldID$VH() {
        return JNINativeInterface_.GetStaticFieldID$VH;
    }
    public static MemoryAddress GetStaticFieldID$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticFieldID$VH.get(seg);
    }
    public static void GetStaticFieldID$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticFieldID$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticFieldID$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticFieldID$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticFieldID$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticFieldID$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticFieldID GetStaticFieldID (MemorySegment segment, MemorySession session) {
        return GetStaticFieldID.ofAddress(GetStaticFieldID$get(segment), session);
    }
    static final FunctionDescriptor GetStaticObjectField$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticObjectField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticObjectField$FUNC
    );
    public interface GetStaticObjectField {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticObjectField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticObjectField.class, fi, JNINativeInterface_.GetStaticObjectField$FUNC, session);
        }
        static GetStaticObjectField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticObjectField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticObjectField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticObjectField"));
    public static VarHandle GetStaticObjectField$VH() {
        return JNINativeInterface_.GetStaticObjectField$VH;
    }
    public static MemoryAddress GetStaticObjectField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticObjectField$VH.get(seg);
    }
    public static void GetStaticObjectField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticObjectField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticObjectField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticObjectField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticObjectField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticObjectField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticObjectField GetStaticObjectField (MemorySegment segment, MemorySession session) {
        return GetStaticObjectField.ofAddress(GetStaticObjectField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticBooleanField$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticBooleanField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticBooleanField$FUNC
    );
    public interface GetStaticBooleanField {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticBooleanField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticBooleanField.class, fi, JNINativeInterface_.GetStaticBooleanField$FUNC, session);
        }
        static GetStaticBooleanField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (byte)JNINativeInterface_.GetStaticBooleanField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticBooleanField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticBooleanField"));
    public static VarHandle GetStaticBooleanField$VH() {
        return JNINativeInterface_.GetStaticBooleanField$VH;
    }
    public static MemoryAddress GetStaticBooleanField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticBooleanField$VH.get(seg);
    }
    public static void GetStaticBooleanField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticBooleanField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticBooleanField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticBooleanField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticBooleanField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticBooleanField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticBooleanField GetStaticBooleanField (MemorySegment segment, MemorySession session) {
        return GetStaticBooleanField.ofAddress(GetStaticBooleanField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticByteField$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticByteField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticByteField$FUNC
    );
    public interface GetStaticByteField {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticByteField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticByteField.class, fi, JNINativeInterface_.GetStaticByteField$FUNC, session);
        }
        static GetStaticByteField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (byte)JNINativeInterface_.GetStaticByteField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticByteField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticByteField"));
    public static VarHandle GetStaticByteField$VH() {
        return JNINativeInterface_.GetStaticByteField$VH;
    }
    public static MemoryAddress GetStaticByteField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticByteField$VH.get(seg);
    }
    public static void GetStaticByteField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticByteField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticByteField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticByteField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticByteField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticByteField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticByteField GetStaticByteField (MemorySegment segment, MemorySession session) {
        return GetStaticByteField.ofAddress(GetStaticByteField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticCharField$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticCharField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticCharField$FUNC
    );
    public interface GetStaticCharField {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticCharField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticCharField.class, fi, JNINativeInterface_.GetStaticCharField$FUNC, session);
        }
        static GetStaticCharField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (short)JNINativeInterface_.GetStaticCharField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticCharField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticCharField"));
    public static VarHandle GetStaticCharField$VH() {
        return JNINativeInterface_.GetStaticCharField$VH;
    }
    public static MemoryAddress GetStaticCharField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticCharField$VH.get(seg);
    }
    public static void GetStaticCharField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticCharField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticCharField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticCharField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticCharField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticCharField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticCharField GetStaticCharField (MemorySegment segment, MemorySession session) {
        return GetStaticCharField.ofAddress(GetStaticCharField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticShortField$FUNC = FunctionDescriptor.of(Constants$root.C_SHORT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticShortField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticShortField$FUNC
    );
    public interface GetStaticShortField {

        short apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticShortField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticShortField.class, fi, JNINativeInterface_.GetStaticShortField$FUNC, session);
        }
        static GetStaticShortField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (short)JNINativeInterface_.GetStaticShortField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticShortField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticShortField"));
    public static VarHandle GetStaticShortField$VH() {
        return JNINativeInterface_.GetStaticShortField$VH;
    }
    public static MemoryAddress GetStaticShortField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticShortField$VH.get(seg);
    }
    public static void GetStaticShortField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticShortField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticShortField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticShortField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticShortField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticShortField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticShortField GetStaticShortField (MemorySegment segment, MemorySession session) {
        return GetStaticShortField.ofAddress(GetStaticShortField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticIntField$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticIntField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticIntField$FUNC
    );
    public interface GetStaticIntField {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticIntField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticIntField.class, fi, JNINativeInterface_.GetStaticIntField$FUNC, session);
        }
        static GetStaticIntField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (int)JNINativeInterface_.GetStaticIntField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticIntField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticIntField"));
    public static VarHandle GetStaticIntField$VH() {
        return JNINativeInterface_.GetStaticIntField$VH;
    }
    public static MemoryAddress GetStaticIntField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticIntField$VH.get(seg);
    }
    public static void GetStaticIntField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticIntField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticIntField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticIntField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticIntField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticIntField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticIntField GetStaticIntField (MemorySegment segment, MemorySession session) {
        return GetStaticIntField.ofAddress(GetStaticIntField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticLongField$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticLongField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticLongField$FUNC
    );
    public interface GetStaticLongField {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticLongField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticLongField.class, fi, JNINativeInterface_.GetStaticLongField$FUNC, session);
        }
        static GetStaticLongField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (long)JNINativeInterface_.GetStaticLongField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticLongField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticLongField"));
    public static VarHandle GetStaticLongField$VH() {
        return JNINativeInterface_.GetStaticLongField$VH;
    }
    public static MemoryAddress GetStaticLongField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticLongField$VH.get(seg);
    }
    public static void GetStaticLongField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticLongField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticLongField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticLongField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticLongField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticLongField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticLongField GetStaticLongField (MemorySegment segment, MemorySession session) {
        return GetStaticLongField.ofAddress(GetStaticLongField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticFloatField$FUNC = FunctionDescriptor.of(Constants$root.C_FLOAT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticFloatField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticFloatField$FUNC
    );
    public interface GetStaticFloatField {

        float apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticFloatField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticFloatField.class, fi, JNINativeInterface_.GetStaticFloatField$FUNC, session);
        }
        static GetStaticFloatField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (float)JNINativeInterface_.GetStaticFloatField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticFloatField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticFloatField"));
    public static VarHandle GetStaticFloatField$VH() {
        return JNINativeInterface_.GetStaticFloatField$VH;
    }
    public static MemoryAddress GetStaticFloatField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticFloatField$VH.get(seg);
    }
    public static void GetStaticFloatField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticFloatField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticFloatField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticFloatField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticFloatField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticFloatField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticFloatField GetStaticFloatField (MemorySegment segment, MemorySession session) {
        return GetStaticFloatField.ofAddress(GetStaticFloatField$get(segment), session);
    }
    static final FunctionDescriptor GetStaticDoubleField$FUNC = FunctionDescriptor.of(Constants$root.C_DOUBLE$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStaticDoubleField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStaticDoubleField$FUNC
    );
    public interface GetStaticDoubleField {

        double apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStaticDoubleField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStaticDoubleField.class, fi, JNINativeInterface_.GetStaticDoubleField$FUNC, session);
        }
        static GetStaticDoubleField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (double)JNINativeInterface_.GetStaticDoubleField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStaticDoubleField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStaticDoubleField"));
    public static VarHandle GetStaticDoubleField$VH() {
        return JNINativeInterface_.GetStaticDoubleField$VH;
    }
    public static MemoryAddress GetStaticDoubleField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticDoubleField$VH.get(seg);
    }
    public static void GetStaticDoubleField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStaticDoubleField$VH.set(seg, x);
    }
    public static MemoryAddress GetStaticDoubleField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStaticDoubleField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStaticDoubleField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStaticDoubleField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStaticDoubleField GetStaticDoubleField (MemorySegment segment, MemorySession session) {
        return GetStaticDoubleField.ofAddress(GetStaticDoubleField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticObjectField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetStaticObjectField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticObjectField$FUNC
    );
    public interface SetStaticObjectField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(SetStaticObjectField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticObjectField.class, fi, JNINativeInterface_.SetStaticObjectField$FUNC, session);
        }
        static SetStaticObjectField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    JNINativeInterface_.SetStaticObjectField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticObjectField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticObjectField"));
    public static VarHandle SetStaticObjectField$VH() {
        return JNINativeInterface_.SetStaticObjectField$VH;
    }
    public static MemoryAddress SetStaticObjectField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticObjectField$VH.get(seg);
    }
    public static void SetStaticObjectField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticObjectField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticObjectField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticObjectField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticObjectField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticObjectField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticObjectField SetStaticObjectField (MemorySegment segment, MemorySession session) {
        return SetStaticObjectField.ofAddress(SetStaticObjectField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticBooleanField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetStaticBooleanField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticBooleanField$FUNC
    );
    public interface SetStaticBooleanField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, byte _x3);
        static MemorySegment allocate(SetStaticBooleanField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticBooleanField.class, fi, JNINativeInterface_.SetStaticBooleanField$FUNC, session);
        }
        static SetStaticBooleanField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, byte __x3) -> {
                try {
                    JNINativeInterface_.SetStaticBooleanField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticBooleanField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticBooleanField"));
    public static VarHandle SetStaticBooleanField$VH() {
        return JNINativeInterface_.SetStaticBooleanField$VH;
    }
    public static MemoryAddress SetStaticBooleanField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticBooleanField$VH.get(seg);
    }
    public static void SetStaticBooleanField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticBooleanField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticBooleanField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticBooleanField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticBooleanField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticBooleanField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticBooleanField SetStaticBooleanField (MemorySegment segment, MemorySession session) {
        return SetStaticBooleanField.ofAddress(SetStaticBooleanField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticByteField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_CHAR$LAYOUT
    );
    static final MethodHandle SetStaticByteField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticByteField$FUNC
    );
    public interface SetStaticByteField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, byte _x3);
        static MemorySegment allocate(SetStaticByteField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticByteField.class, fi, JNINativeInterface_.SetStaticByteField$FUNC, session);
        }
        static SetStaticByteField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, byte __x3) -> {
                try {
                    JNINativeInterface_.SetStaticByteField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticByteField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticByteField"));
    public static VarHandle SetStaticByteField$VH() {
        return JNINativeInterface_.SetStaticByteField$VH;
    }
    public static MemoryAddress SetStaticByteField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticByteField$VH.get(seg);
    }
    public static void SetStaticByteField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticByteField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticByteField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticByteField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticByteField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticByteField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticByteField SetStaticByteField (MemorySegment segment, MemorySession session) {
        return SetStaticByteField.ofAddress(SetStaticByteField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticCharField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_SHORT$LAYOUT
    );
    static final MethodHandle SetStaticCharField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticCharField$FUNC
    );
    public interface SetStaticCharField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, short _x3);
        static MemorySegment allocate(SetStaticCharField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticCharField.class, fi, JNINativeInterface_.SetStaticCharField$FUNC, session);
        }
        static SetStaticCharField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, short __x3) -> {
                try {
                    JNINativeInterface_.SetStaticCharField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticCharField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticCharField"));
    public static VarHandle SetStaticCharField$VH() {
        return JNINativeInterface_.SetStaticCharField$VH;
    }
    public static MemoryAddress SetStaticCharField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticCharField$VH.get(seg);
    }
    public static void SetStaticCharField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticCharField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticCharField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticCharField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticCharField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticCharField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticCharField SetStaticCharField (MemorySegment segment, MemorySession session) {
        return SetStaticCharField.ofAddress(SetStaticCharField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticShortField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_SHORT$LAYOUT
    );
    static final MethodHandle SetStaticShortField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticShortField$FUNC
    );
    public interface SetStaticShortField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, short _x3);
        static MemorySegment allocate(SetStaticShortField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticShortField.class, fi, JNINativeInterface_.SetStaticShortField$FUNC, session);
        }
        static SetStaticShortField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, short __x3) -> {
                try {
                    JNINativeInterface_.SetStaticShortField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticShortField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticShortField"));
    public static VarHandle SetStaticShortField$VH() {
        return JNINativeInterface_.SetStaticShortField$VH;
    }
    public static MemoryAddress SetStaticShortField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticShortField$VH.get(seg);
    }
    public static void SetStaticShortField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticShortField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticShortField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticShortField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticShortField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticShortField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticShortField SetStaticShortField (MemorySegment segment, MemorySession session) {
        return SetStaticShortField.ofAddress(SetStaticShortField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticIntField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle SetStaticIntField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticIntField$FUNC
    );
    public interface SetStaticIntField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(SetStaticIntField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticIntField.class, fi, JNINativeInterface_.SetStaticIntField$FUNC, session);
        }
        static SetStaticIntField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.SetStaticIntField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticIntField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticIntField"));
    public static VarHandle SetStaticIntField$VH() {
        return JNINativeInterface_.SetStaticIntField$VH;
    }
    public static MemoryAddress SetStaticIntField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticIntField$VH.get(seg);
    }
    public static void SetStaticIntField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticIntField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticIntField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticIntField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticIntField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticIntField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticIntField SetStaticIntField (MemorySegment segment, MemorySession session) {
        return SetStaticIntField.ofAddress(SetStaticIntField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticLongField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle SetStaticLongField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticLongField$FUNC
    );
    public interface SetStaticLongField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, long _x3);
        static MemorySegment allocate(SetStaticLongField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticLongField.class, fi, JNINativeInterface_.SetStaticLongField$FUNC, session);
        }
        static SetStaticLongField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, long __x3) -> {
                try {
                    JNINativeInterface_.SetStaticLongField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticLongField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticLongField"));
    public static VarHandle SetStaticLongField$VH() {
        return JNINativeInterface_.SetStaticLongField$VH;
    }
    public static MemoryAddress SetStaticLongField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticLongField$VH.get(seg);
    }
    public static void SetStaticLongField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticLongField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticLongField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticLongField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticLongField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticLongField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticLongField SetStaticLongField (MemorySegment segment, MemorySession session) {
        return SetStaticLongField.ofAddress(SetStaticLongField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticFloatField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_FLOAT$LAYOUT
    );
    static final MethodHandle SetStaticFloatField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticFloatField$FUNC
    );
    public interface SetStaticFloatField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, float _x3);
        static MemorySegment allocate(SetStaticFloatField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticFloatField.class, fi, JNINativeInterface_.SetStaticFloatField$FUNC, session);
        }
        static SetStaticFloatField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, float __x3) -> {
                try {
                    JNINativeInterface_.SetStaticFloatField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticFloatField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticFloatField"));
    public static VarHandle SetStaticFloatField$VH() {
        return JNINativeInterface_.SetStaticFloatField$VH;
    }
    public static MemoryAddress SetStaticFloatField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticFloatField$VH.get(seg);
    }
    public static void SetStaticFloatField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticFloatField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticFloatField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticFloatField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticFloatField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticFloatField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticFloatField SetStaticFloatField (MemorySegment segment, MemorySession session) {
        return SetStaticFloatField.ofAddress(SetStaticFloatField$get(segment), session);
    }
    static final FunctionDescriptor SetStaticDoubleField$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_DOUBLE$LAYOUT
    );
    static final MethodHandle SetStaticDoubleField$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetStaticDoubleField$FUNC
    );
    public interface SetStaticDoubleField {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, double _x3);
        static MemorySegment allocate(SetStaticDoubleField fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetStaticDoubleField.class, fi, JNINativeInterface_.SetStaticDoubleField$FUNC, session);
        }
        static SetStaticDoubleField ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, double __x3) -> {
                try {
                    JNINativeInterface_.SetStaticDoubleField$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetStaticDoubleField$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetStaticDoubleField"));
    public static VarHandle SetStaticDoubleField$VH() {
        return JNINativeInterface_.SetStaticDoubleField$VH;
    }
    public static MemoryAddress SetStaticDoubleField$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticDoubleField$VH.get(seg);
    }
    public static void SetStaticDoubleField$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetStaticDoubleField$VH.set(seg, x);
    }
    public static MemoryAddress SetStaticDoubleField$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetStaticDoubleField$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetStaticDoubleField$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetStaticDoubleField$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetStaticDoubleField SetStaticDoubleField (MemorySegment segment, MemorySession session) {
        return SetStaticDoubleField.ofAddress(SetStaticDoubleField$get(segment), session);
    }
    static final FunctionDescriptor NewString$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewString$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewString$FUNC
    );
    public interface NewString {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2);
        static MemorySegment allocate(NewString fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewString.class, fi, JNINativeInterface_.NewString$FUNC, session);
        }
        static NewString ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewString$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewString$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewString"));
    public static VarHandle NewString$VH() {
        return JNINativeInterface_.NewString$VH;
    }
    public static MemoryAddress NewString$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewString$VH.get(seg);
    }
    public static void NewString$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewString$VH.set(seg, x);
    }
    public static MemoryAddress NewString$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewString$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewString$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewString$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewString NewString (MemorySegment segment, MemorySession session) {
        return NewString.ofAddress(NewString$get(segment), session);
    }
    static final FunctionDescriptor GetStringLength$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStringLength$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStringLength$FUNC
    );
    public interface GetStringLength {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetStringLength fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStringLength.class, fi, JNINativeInterface_.GetStringLength$FUNC, session);
        }
        static GetStringLength ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.GetStringLength$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStringLength$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStringLength"));
    public static VarHandle GetStringLength$VH() {
        return JNINativeInterface_.GetStringLength$VH;
    }
    public static MemoryAddress GetStringLength$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringLength$VH.get(seg);
    }
    public static void GetStringLength$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStringLength$VH.set(seg, x);
    }
    public static MemoryAddress GetStringLength$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringLength$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStringLength$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStringLength$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStringLength GetStringLength (MemorySegment segment, MemorySession session) {
        return GetStringLength.ofAddress(GetStringLength$get(segment), session);
    }
    static final FunctionDescriptor GetStringChars$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStringChars$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStringChars$FUNC
    );
    public interface GetStringChars {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStringChars fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStringChars.class, fi, JNINativeInterface_.GetStringChars$FUNC, session);
        }
        static GetStringChars ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringChars$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStringChars$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStringChars"));
    public static VarHandle GetStringChars$VH() {
        return JNINativeInterface_.GetStringChars$VH;
    }
    public static MemoryAddress GetStringChars$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringChars$VH.get(seg);
    }
    public static void GetStringChars$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStringChars$VH.set(seg, x);
    }
    public static MemoryAddress GetStringChars$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringChars$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStringChars$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStringChars$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStringChars GetStringChars (MemorySegment segment, MemorySession session) {
        return GetStringChars.ofAddress(GetStringChars$get(segment), session);
    }
    static final FunctionDescriptor ReleaseStringChars$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReleaseStringChars$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseStringChars$FUNC
    );
    public interface ReleaseStringChars {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ReleaseStringChars fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseStringChars.class, fi, JNINativeInterface_.ReleaseStringChars$FUNC, session);
        }
        static ReleaseStringChars ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    JNINativeInterface_.ReleaseStringChars$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseStringChars$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseStringChars"));
    public static VarHandle ReleaseStringChars$VH() {
        return JNINativeInterface_.ReleaseStringChars$VH;
    }
    public static MemoryAddress ReleaseStringChars$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseStringChars$VH.get(seg);
    }
    public static void ReleaseStringChars$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseStringChars$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseStringChars$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseStringChars$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseStringChars$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseStringChars$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseStringChars ReleaseStringChars (MemorySegment segment, MemorySession session) {
        return ReleaseStringChars.ofAddress(ReleaseStringChars$get(segment), session);
    }
    static final FunctionDescriptor NewStringUTF$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle NewStringUTF$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewStringUTF$FUNC
    );
    public interface NewStringUTF {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(NewStringUTF fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewStringUTF.class, fi, JNINativeInterface_.NewStringUTF$FUNC, session);
        }
        static NewStringUTF ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewStringUTF$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewStringUTF$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewStringUTF"));
    public static VarHandle NewStringUTF$VH() {
        return JNINativeInterface_.NewStringUTF$VH;
    }
    public static MemoryAddress NewStringUTF$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewStringUTF$VH.get(seg);
    }
    public static void NewStringUTF$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewStringUTF$VH.set(seg, x);
    }
    public static MemoryAddress NewStringUTF$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewStringUTF$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewStringUTF$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewStringUTF$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewStringUTF NewStringUTF (MemorySegment segment, MemorySession session) {
        return NewStringUTF.ofAddress(NewStringUTF$get(segment), session);
    }
    static final FunctionDescriptor GetStringUTFLength$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStringUTFLength$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStringUTFLength$FUNC
    );
    public interface GetStringUTFLength {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetStringUTFLength fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStringUTFLength.class, fi, JNINativeInterface_.GetStringUTFLength$FUNC, session);
        }
        static GetStringUTFLength ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.GetStringUTFLength$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStringUTFLength$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStringUTFLength"));
    public static VarHandle GetStringUTFLength$VH() {
        return JNINativeInterface_.GetStringUTFLength$VH;
    }
    public static MemoryAddress GetStringUTFLength$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringUTFLength$VH.get(seg);
    }
    public static void GetStringUTFLength$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStringUTFLength$VH.set(seg, x);
    }
    public static MemoryAddress GetStringUTFLength$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringUTFLength$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStringUTFLength$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStringUTFLength$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStringUTFLength GetStringUTFLength (MemorySegment segment, MemorySession session) {
        return GetStringUTFLength.ofAddress(GetStringUTFLength$get(segment), session);
    }
    static final FunctionDescriptor GetStringUTFChars$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStringUTFChars$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStringUTFChars$FUNC
    );
    public interface GetStringUTFChars {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStringUTFChars fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStringUTFChars.class, fi, JNINativeInterface_.GetStringUTFChars$FUNC, session);
        }
        static GetStringUTFChars ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringUTFChars$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStringUTFChars$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStringUTFChars"));
    public static VarHandle GetStringUTFChars$VH() {
        return JNINativeInterface_.GetStringUTFChars$VH;
    }
    public static MemoryAddress GetStringUTFChars$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringUTFChars$VH.get(seg);
    }
    public static void GetStringUTFChars$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStringUTFChars$VH.set(seg, x);
    }
    public static MemoryAddress GetStringUTFChars$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringUTFChars$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStringUTFChars$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStringUTFChars$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStringUTFChars GetStringUTFChars (MemorySegment segment, MemorySession session) {
        return GetStringUTFChars.ofAddress(GetStringUTFChars$get(segment), session);
    }
    static final FunctionDescriptor ReleaseStringUTFChars$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReleaseStringUTFChars$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseStringUTFChars$FUNC
    );
    public interface ReleaseStringUTFChars {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ReleaseStringUTFChars fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseStringUTFChars.class, fi, JNINativeInterface_.ReleaseStringUTFChars$FUNC, session);
        }
        static ReleaseStringUTFChars ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    JNINativeInterface_.ReleaseStringUTFChars$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseStringUTFChars$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseStringUTFChars"));
    public static VarHandle ReleaseStringUTFChars$VH() {
        return JNINativeInterface_.ReleaseStringUTFChars$VH;
    }
    public static MemoryAddress ReleaseStringUTFChars$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseStringUTFChars$VH.get(seg);
    }
    public static void ReleaseStringUTFChars$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseStringUTFChars$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseStringUTFChars$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseStringUTFChars$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseStringUTFChars$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseStringUTFChars$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseStringUTFChars ReleaseStringUTFChars (MemorySegment segment, MemorySession session) {
        return ReleaseStringUTFChars.ofAddress(ReleaseStringUTFChars$get(segment), session);
    }
    static final FunctionDescriptor GetArrayLength$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetArrayLength$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetArrayLength$FUNC
    );
    public interface GetArrayLength {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetArrayLength fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetArrayLength.class, fi, JNINativeInterface_.GetArrayLength$FUNC, session);
        }
        static GetArrayLength ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.GetArrayLength$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetArrayLength$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetArrayLength"));
    public static VarHandle GetArrayLength$VH() {
        return JNINativeInterface_.GetArrayLength$VH;
    }
    public static MemoryAddress GetArrayLength$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetArrayLength$VH.get(seg);
    }
    public static void GetArrayLength$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetArrayLength$VH.set(seg, x);
    }
    public static MemoryAddress GetArrayLength$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetArrayLength$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetArrayLength$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetArrayLength$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetArrayLength GetArrayLength (MemorySegment segment, MemorySession session) {
        return GetArrayLength.ofAddress(GetArrayLength$get(segment), session);
    }
    static final FunctionDescriptor NewObjectArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle NewObjectArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewObjectArray$FUNC
    );
    public interface NewObjectArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1, java.lang.foreign.MemoryAddress _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(NewObjectArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewObjectArray.class, fi, JNINativeInterface_.NewObjectArray$FUNC, session);
        }
        static NewObjectArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1, java.lang.foreign.MemoryAddress __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1, (java.lang.foreign.Addressable)__x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewObjectArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewObjectArray"));
    public static VarHandle NewObjectArray$VH() {
        return JNINativeInterface_.NewObjectArray$VH;
    }
    public static MemoryAddress NewObjectArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectArray$VH.get(seg);
    }
    public static void NewObjectArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewObjectArray$VH.set(seg, x);
    }
    public static MemoryAddress NewObjectArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewObjectArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewObjectArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewObjectArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewObjectArray NewObjectArray (MemorySegment segment, MemorySession session) {
        return NewObjectArray.ofAddress(NewObjectArray$get(segment), session);
    }
    static final FunctionDescriptor GetObjectArrayElement$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle GetObjectArrayElement$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetObjectArrayElement$FUNC
    );
    public interface GetObjectArrayElement {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2);
        static MemorySegment allocate(GetObjectArrayElement fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetObjectArrayElement.class, fi, JNINativeInterface_.GetObjectArrayElement$FUNC, session);
        }
        static GetObjectArrayElement ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectArrayElement$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetObjectArrayElement$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetObjectArrayElement"));
    public static VarHandle GetObjectArrayElement$VH() {
        return JNINativeInterface_.GetObjectArrayElement$VH;
    }
    public static MemoryAddress GetObjectArrayElement$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectArrayElement$VH.get(seg);
    }
    public static void GetObjectArrayElement$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetObjectArrayElement$VH.set(seg, x);
    }
    public static MemoryAddress GetObjectArrayElement$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectArrayElement$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetObjectArrayElement$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetObjectArrayElement$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetObjectArrayElement GetObjectArrayElement (MemorySegment segment, MemorySession session) {
        return GetObjectArrayElement.ofAddress(GetObjectArrayElement$get(segment), session);
    }
    static final FunctionDescriptor SetObjectArrayElement$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetObjectArrayElement$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetObjectArrayElement$FUNC
    );
    public interface SetObjectArrayElement {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, java.lang.foreign.MemoryAddress _x3);
        static MemorySegment allocate(SetObjectArrayElement fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetObjectArrayElement.class, fi, JNINativeInterface_.SetObjectArrayElement$FUNC, session);
        }
        static SetObjectArrayElement ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, java.lang.foreign.MemoryAddress __x3) -> {
                try {
                    JNINativeInterface_.SetObjectArrayElement$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, (java.lang.foreign.Addressable)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetObjectArrayElement$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetObjectArrayElement"));
    public static VarHandle SetObjectArrayElement$VH() {
        return JNINativeInterface_.SetObjectArrayElement$VH;
    }
    public static MemoryAddress SetObjectArrayElement$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetObjectArrayElement$VH.get(seg);
    }
    public static void SetObjectArrayElement$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetObjectArrayElement$VH.set(seg, x);
    }
    public static MemoryAddress SetObjectArrayElement$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetObjectArrayElement$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetObjectArrayElement$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetObjectArrayElement$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetObjectArrayElement SetObjectArrayElement (MemorySegment segment, MemorySession session) {
        return SetObjectArrayElement.ofAddress(SetObjectArrayElement$get(segment), session);
    }
    static final FunctionDescriptor NewBooleanArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewBooleanArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewBooleanArray$FUNC
    );
    public interface NewBooleanArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewBooleanArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewBooleanArray.class, fi, JNINativeInterface_.NewBooleanArray$FUNC, session);
        }
        static NewBooleanArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewBooleanArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewBooleanArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewBooleanArray"));
    public static VarHandle NewBooleanArray$VH() {
        return JNINativeInterface_.NewBooleanArray$VH;
    }
    public static MemoryAddress NewBooleanArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewBooleanArray$VH.get(seg);
    }
    public static void NewBooleanArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewBooleanArray$VH.set(seg, x);
    }
    public static MemoryAddress NewBooleanArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewBooleanArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewBooleanArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewBooleanArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewBooleanArray NewBooleanArray (MemorySegment segment, MemorySession session) {
        return NewBooleanArray.ofAddress(NewBooleanArray$get(segment), session);
    }
    static final FunctionDescriptor NewByteArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewByteArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewByteArray$FUNC
    );
    public interface NewByteArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewByteArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewByteArray.class, fi, JNINativeInterface_.NewByteArray$FUNC, session);
        }
        static NewByteArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewByteArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewByteArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewByteArray"));
    public static VarHandle NewByteArray$VH() {
        return JNINativeInterface_.NewByteArray$VH;
    }
    public static MemoryAddress NewByteArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewByteArray$VH.get(seg);
    }
    public static void NewByteArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewByteArray$VH.set(seg, x);
    }
    public static MemoryAddress NewByteArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewByteArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewByteArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewByteArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewByteArray NewByteArray (MemorySegment segment, MemorySession session) {
        return NewByteArray.ofAddress(NewByteArray$get(segment), session);
    }
    static final FunctionDescriptor NewCharArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewCharArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewCharArray$FUNC
    );
    public interface NewCharArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewCharArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewCharArray.class, fi, JNINativeInterface_.NewCharArray$FUNC, session);
        }
        static NewCharArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewCharArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewCharArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewCharArray"));
    public static VarHandle NewCharArray$VH() {
        return JNINativeInterface_.NewCharArray$VH;
    }
    public static MemoryAddress NewCharArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewCharArray$VH.get(seg);
    }
    public static void NewCharArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewCharArray$VH.set(seg, x);
    }
    public static MemoryAddress NewCharArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewCharArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewCharArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewCharArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewCharArray NewCharArray (MemorySegment segment, MemorySession session) {
        return NewCharArray.ofAddress(NewCharArray$get(segment), session);
    }
    static final FunctionDescriptor NewShortArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewShortArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewShortArray$FUNC
    );
    public interface NewShortArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewShortArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewShortArray.class, fi, JNINativeInterface_.NewShortArray$FUNC, session);
        }
        static NewShortArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewShortArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewShortArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewShortArray"));
    public static VarHandle NewShortArray$VH() {
        return JNINativeInterface_.NewShortArray$VH;
    }
    public static MemoryAddress NewShortArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewShortArray$VH.get(seg);
    }
    public static void NewShortArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewShortArray$VH.set(seg, x);
    }
    public static MemoryAddress NewShortArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewShortArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewShortArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewShortArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewShortArray NewShortArray (MemorySegment segment, MemorySession session) {
        return NewShortArray.ofAddress(NewShortArray$get(segment), session);
    }
    static final FunctionDescriptor NewIntArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewIntArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewIntArray$FUNC
    );
    public interface NewIntArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewIntArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewIntArray.class, fi, JNINativeInterface_.NewIntArray$FUNC, session);
        }
        static NewIntArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewIntArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewIntArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewIntArray"));
    public static VarHandle NewIntArray$VH() {
        return JNINativeInterface_.NewIntArray$VH;
    }
    public static MemoryAddress NewIntArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewIntArray$VH.get(seg);
    }
    public static void NewIntArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewIntArray$VH.set(seg, x);
    }
    public static MemoryAddress NewIntArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewIntArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewIntArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewIntArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewIntArray NewIntArray (MemorySegment segment, MemorySession session) {
        return NewIntArray.ofAddress(NewIntArray$get(segment), session);
    }
    static final FunctionDescriptor NewLongArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewLongArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewLongArray$FUNC
    );
    public interface NewLongArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewLongArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewLongArray.class, fi, JNINativeInterface_.NewLongArray$FUNC, session);
        }
        static NewLongArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewLongArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewLongArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewLongArray"));
    public static VarHandle NewLongArray$VH() {
        return JNINativeInterface_.NewLongArray$VH;
    }
    public static MemoryAddress NewLongArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewLongArray$VH.get(seg);
    }
    public static void NewLongArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewLongArray$VH.set(seg, x);
    }
    public static MemoryAddress NewLongArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewLongArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewLongArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewLongArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewLongArray NewLongArray (MemorySegment segment, MemorySession session) {
        return NewLongArray.ofAddress(NewLongArray$get(segment), session);
    }
    static final FunctionDescriptor NewFloatArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewFloatArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewFloatArray$FUNC
    );
    public interface NewFloatArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewFloatArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewFloatArray.class, fi, JNINativeInterface_.NewFloatArray$FUNC, session);
        }
        static NewFloatArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewFloatArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewFloatArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewFloatArray"));
    public static VarHandle NewFloatArray$VH() {
        return JNINativeInterface_.NewFloatArray$VH;
    }
    public static MemoryAddress NewFloatArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewFloatArray$VH.get(seg);
    }
    public static void NewFloatArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewFloatArray$VH.set(seg, x);
    }
    public static MemoryAddress NewFloatArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewFloatArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewFloatArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewFloatArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewFloatArray NewFloatArray (MemorySegment segment, MemorySession session) {
        return NewFloatArray.ofAddress(NewFloatArray$get(segment), session);
    }
    static final FunctionDescriptor NewDoubleArray$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle NewDoubleArray$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewDoubleArray$FUNC
    );
    public interface NewDoubleArray {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, int _x1);
        static MemorySegment allocate(NewDoubleArray fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewDoubleArray.class, fi, JNINativeInterface_.NewDoubleArray$FUNC, session);
        }
        static NewDoubleArray ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, int __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewDoubleArray$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewDoubleArray$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewDoubleArray"));
    public static VarHandle NewDoubleArray$VH() {
        return JNINativeInterface_.NewDoubleArray$VH;
    }
    public static MemoryAddress NewDoubleArray$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewDoubleArray$VH.get(seg);
    }
    public static void NewDoubleArray$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewDoubleArray$VH.set(seg, x);
    }
    public static MemoryAddress NewDoubleArray$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewDoubleArray$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewDoubleArray$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewDoubleArray$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewDoubleArray NewDoubleArray (MemorySegment segment, MemorySession session) {
        return NewDoubleArray.ofAddress(NewDoubleArray$get(segment), session);
    }
    static final FunctionDescriptor GetBooleanArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBooleanArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetBooleanArrayElements$FUNC
    );
    public interface GetBooleanArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetBooleanArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBooleanArrayElements.class, fi, JNINativeInterface_.GetBooleanArrayElements$FUNC, session);
        }
        static GetBooleanArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetBooleanArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBooleanArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBooleanArrayElements"));
    public static VarHandle GetBooleanArrayElements$VH() {
        return JNINativeInterface_.GetBooleanArrayElements$VH;
    }
    public static MemoryAddress GetBooleanArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetBooleanArrayElements$VH.get(seg);
    }
    public static void GetBooleanArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetBooleanArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetBooleanArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetBooleanArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBooleanArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetBooleanArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBooleanArrayElements GetBooleanArrayElements (MemorySegment segment, MemorySession session) {
        return GetBooleanArrayElements.ofAddress(GetBooleanArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetByteArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetByteArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetByteArrayElements$FUNC
    );
    public interface GetByteArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetByteArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetByteArrayElements.class, fi, JNINativeInterface_.GetByteArrayElements$FUNC, session);
        }
        static GetByteArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetByteArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetByteArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetByteArrayElements"));
    public static VarHandle GetByteArrayElements$VH() {
        return JNINativeInterface_.GetByteArrayElements$VH;
    }
    public static MemoryAddress GetByteArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetByteArrayElements$VH.get(seg);
    }
    public static void GetByteArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetByteArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetByteArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetByteArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetByteArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetByteArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetByteArrayElements GetByteArrayElements (MemorySegment segment, MemorySession session) {
        return GetByteArrayElements.ofAddress(GetByteArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetCharArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetCharArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetCharArrayElements$FUNC
    );
    public interface GetCharArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetCharArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetCharArrayElements.class, fi, JNINativeInterface_.GetCharArrayElements$FUNC, session);
        }
        static GetCharArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetCharArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetCharArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetCharArrayElements"));
    public static VarHandle GetCharArrayElements$VH() {
        return JNINativeInterface_.GetCharArrayElements$VH;
    }
    public static MemoryAddress GetCharArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetCharArrayElements$VH.get(seg);
    }
    public static void GetCharArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetCharArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetCharArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetCharArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetCharArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetCharArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetCharArrayElements GetCharArrayElements (MemorySegment segment, MemorySession session) {
        return GetCharArrayElements.ofAddress(GetCharArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetShortArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetShortArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetShortArrayElements$FUNC
    );
    public interface GetShortArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetShortArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetShortArrayElements.class, fi, JNINativeInterface_.GetShortArrayElements$FUNC, session);
        }
        static GetShortArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetShortArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetShortArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetShortArrayElements"));
    public static VarHandle GetShortArrayElements$VH() {
        return JNINativeInterface_.GetShortArrayElements$VH;
    }
    public static MemoryAddress GetShortArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetShortArrayElements$VH.get(seg);
    }
    public static void GetShortArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetShortArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetShortArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetShortArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetShortArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetShortArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetShortArrayElements GetShortArrayElements (MemorySegment segment, MemorySession session) {
        return GetShortArrayElements.ofAddress(GetShortArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetIntArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetIntArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetIntArrayElements$FUNC
    );
    public interface GetIntArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetIntArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetIntArrayElements.class, fi, JNINativeInterface_.GetIntArrayElements$FUNC, session);
        }
        static GetIntArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetIntArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetIntArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetIntArrayElements"));
    public static VarHandle GetIntArrayElements$VH() {
        return JNINativeInterface_.GetIntArrayElements$VH;
    }
    public static MemoryAddress GetIntArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetIntArrayElements$VH.get(seg);
    }
    public static void GetIntArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetIntArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetIntArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetIntArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetIntArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetIntArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetIntArrayElements GetIntArrayElements (MemorySegment segment, MemorySession session) {
        return GetIntArrayElements.ofAddress(GetIntArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetLongArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetLongArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetLongArrayElements$FUNC
    );
    public interface GetLongArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetLongArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetLongArrayElements.class, fi, JNINativeInterface_.GetLongArrayElements$FUNC, session);
        }
        static GetLongArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetLongArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetLongArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetLongArrayElements"));
    public static VarHandle GetLongArrayElements$VH() {
        return JNINativeInterface_.GetLongArrayElements$VH;
    }
    public static MemoryAddress GetLongArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetLongArrayElements$VH.get(seg);
    }
    public static void GetLongArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetLongArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetLongArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetLongArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetLongArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetLongArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetLongArrayElements GetLongArrayElements (MemorySegment segment, MemorySession session) {
        return GetLongArrayElements.ofAddress(GetLongArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetFloatArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFloatArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetFloatArrayElements$FUNC
    );
    public interface GetFloatArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetFloatArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFloatArrayElements.class, fi, JNINativeInterface_.GetFloatArrayElements$FUNC, session);
        }
        static GetFloatArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFloatArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFloatArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFloatArrayElements"));
    public static VarHandle GetFloatArrayElements$VH() {
        return JNINativeInterface_.GetFloatArrayElements$VH;
    }
    public static MemoryAddress GetFloatArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFloatArrayElements$VH.get(seg);
    }
    public static void GetFloatArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetFloatArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetFloatArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFloatArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFloatArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetFloatArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFloatArrayElements GetFloatArrayElements (MemorySegment segment, MemorySession session) {
        return GetFloatArrayElements.ofAddress(GetFloatArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetDoubleArrayElements$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDoubleArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetDoubleArrayElements$FUNC
    );
    public interface GetDoubleArrayElements {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetDoubleArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDoubleArrayElements.class, fi, JNINativeInterface_.GetDoubleArrayElements$FUNC, session);
        }
        static GetDoubleArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDoubleArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDoubleArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDoubleArrayElements"));
    public static VarHandle GetDoubleArrayElements$VH() {
        return JNINativeInterface_.GetDoubleArrayElements$VH;
    }
    public static MemoryAddress GetDoubleArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDoubleArrayElements$VH.get(seg);
    }
    public static void GetDoubleArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetDoubleArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress GetDoubleArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDoubleArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDoubleArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetDoubleArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDoubleArrayElements GetDoubleArrayElements (MemorySegment segment, MemorySession session) {
        return GetDoubleArrayElements.ofAddress(GetDoubleArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseBooleanArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseBooleanArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseBooleanArrayElements$FUNC
    );
    public interface ReleaseBooleanArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseBooleanArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseBooleanArrayElements.class, fi, JNINativeInterface_.ReleaseBooleanArrayElements$FUNC, session);
        }
        static ReleaseBooleanArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseBooleanArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseBooleanArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseBooleanArrayElements"));
    public static VarHandle ReleaseBooleanArrayElements$VH() {
        return JNINativeInterface_.ReleaseBooleanArrayElements$VH;
    }
    public static MemoryAddress ReleaseBooleanArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseBooleanArrayElements$VH.get(seg);
    }
    public static void ReleaseBooleanArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseBooleanArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseBooleanArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseBooleanArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseBooleanArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseBooleanArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseBooleanArrayElements ReleaseBooleanArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseBooleanArrayElements.ofAddress(ReleaseBooleanArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseByteArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseByteArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseByteArrayElements$FUNC
    );
    public interface ReleaseByteArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseByteArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseByteArrayElements.class, fi, JNINativeInterface_.ReleaseByteArrayElements$FUNC, session);
        }
        static ReleaseByteArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseByteArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseByteArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseByteArrayElements"));
    public static VarHandle ReleaseByteArrayElements$VH() {
        return JNINativeInterface_.ReleaseByteArrayElements$VH;
    }
    public static MemoryAddress ReleaseByteArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseByteArrayElements$VH.get(seg);
    }
    public static void ReleaseByteArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseByteArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseByteArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseByteArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseByteArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseByteArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseByteArrayElements ReleaseByteArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseByteArrayElements.ofAddress(ReleaseByteArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseCharArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseCharArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseCharArrayElements$FUNC
    );
    public interface ReleaseCharArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseCharArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseCharArrayElements.class, fi, JNINativeInterface_.ReleaseCharArrayElements$FUNC, session);
        }
        static ReleaseCharArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseCharArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseCharArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseCharArrayElements"));
    public static VarHandle ReleaseCharArrayElements$VH() {
        return JNINativeInterface_.ReleaseCharArrayElements$VH;
    }
    public static MemoryAddress ReleaseCharArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseCharArrayElements$VH.get(seg);
    }
    public static void ReleaseCharArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseCharArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseCharArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseCharArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseCharArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseCharArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseCharArrayElements ReleaseCharArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseCharArrayElements.ofAddress(ReleaseCharArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseShortArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseShortArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseShortArrayElements$FUNC
    );
    public interface ReleaseShortArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseShortArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseShortArrayElements.class, fi, JNINativeInterface_.ReleaseShortArrayElements$FUNC, session);
        }
        static ReleaseShortArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseShortArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseShortArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseShortArrayElements"));
    public static VarHandle ReleaseShortArrayElements$VH() {
        return JNINativeInterface_.ReleaseShortArrayElements$VH;
    }
    public static MemoryAddress ReleaseShortArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseShortArrayElements$VH.get(seg);
    }
    public static void ReleaseShortArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseShortArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseShortArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseShortArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseShortArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseShortArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseShortArrayElements ReleaseShortArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseShortArrayElements.ofAddress(ReleaseShortArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseIntArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseIntArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseIntArrayElements$FUNC
    );
    public interface ReleaseIntArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseIntArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseIntArrayElements.class, fi, JNINativeInterface_.ReleaseIntArrayElements$FUNC, session);
        }
        static ReleaseIntArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseIntArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseIntArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseIntArrayElements"));
    public static VarHandle ReleaseIntArrayElements$VH() {
        return JNINativeInterface_.ReleaseIntArrayElements$VH;
    }
    public static MemoryAddress ReleaseIntArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseIntArrayElements$VH.get(seg);
    }
    public static void ReleaseIntArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseIntArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseIntArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseIntArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseIntArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseIntArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseIntArrayElements ReleaseIntArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseIntArrayElements.ofAddress(ReleaseIntArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseLongArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseLongArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseLongArrayElements$FUNC
    );
    public interface ReleaseLongArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseLongArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseLongArrayElements.class, fi, JNINativeInterface_.ReleaseLongArrayElements$FUNC, session);
        }
        static ReleaseLongArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseLongArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseLongArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseLongArrayElements"));
    public static VarHandle ReleaseLongArrayElements$VH() {
        return JNINativeInterface_.ReleaseLongArrayElements$VH;
    }
    public static MemoryAddress ReleaseLongArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseLongArrayElements$VH.get(seg);
    }
    public static void ReleaseLongArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseLongArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseLongArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseLongArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseLongArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseLongArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseLongArrayElements ReleaseLongArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseLongArrayElements.ofAddress(ReleaseLongArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseFloatArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseFloatArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseFloatArrayElements$FUNC
    );
    public interface ReleaseFloatArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseFloatArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseFloatArrayElements.class, fi, JNINativeInterface_.ReleaseFloatArrayElements$FUNC, session);
        }
        static ReleaseFloatArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseFloatArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseFloatArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseFloatArrayElements"));
    public static VarHandle ReleaseFloatArrayElements$VH() {
        return JNINativeInterface_.ReleaseFloatArrayElements$VH;
    }
    public static MemoryAddress ReleaseFloatArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseFloatArrayElements$VH.get(seg);
    }
    public static void ReleaseFloatArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseFloatArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseFloatArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseFloatArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseFloatArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseFloatArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseFloatArrayElements ReleaseFloatArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseFloatArrayElements.ofAddress(ReleaseFloatArrayElements$get(segment), session);
    }
    static final FunctionDescriptor ReleaseDoubleArrayElements$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleaseDoubleArrayElements$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseDoubleArrayElements$FUNC
    );
    public interface ReleaseDoubleArrayElements {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleaseDoubleArrayElements fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseDoubleArrayElements.class, fi, JNINativeInterface_.ReleaseDoubleArrayElements$FUNC, session);
        }
        static ReleaseDoubleArrayElements ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleaseDoubleArrayElements$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseDoubleArrayElements$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseDoubleArrayElements"));
    public static VarHandle ReleaseDoubleArrayElements$VH() {
        return JNINativeInterface_.ReleaseDoubleArrayElements$VH;
    }
    public static MemoryAddress ReleaseDoubleArrayElements$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseDoubleArrayElements$VH.get(seg);
    }
    public static void ReleaseDoubleArrayElements$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseDoubleArrayElements$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseDoubleArrayElements$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseDoubleArrayElements$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseDoubleArrayElements$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseDoubleArrayElements$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseDoubleArrayElements ReleaseDoubleArrayElements (MemorySegment segment, MemorySession session) {
        return ReleaseDoubleArrayElements.ofAddress(ReleaseDoubleArrayElements$get(segment), session);
    }
    static final FunctionDescriptor GetBooleanArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetBooleanArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetBooleanArrayRegion$FUNC
    );
    public interface GetBooleanArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetBooleanArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetBooleanArrayRegion.class, fi, JNINativeInterface_.GetBooleanArrayRegion$FUNC, session);
        }
        static GetBooleanArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetBooleanArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetBooleanArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetBooleanArrayRegion"));
    public static VarHandle GetBooleanArrayRegion$VH() {
        return JNINativeInterface_.GetBooleanArrayRegion$VH;
    }
    public static MemoryAddress GetBooleanArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetBooleanArrayRegion$VH.get(seg);
    }
    public static void GetBooleanArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetBooleanArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetBooleanArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetBooleanArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetBooleanArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetBooleanArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetBooleanArrayRegion GetBooleanArrayRegion (MemorySegment segment, MemorySession session) {
        return GetBooleanArrayRegion.ofAddress(GetBooleanArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor GetByteArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetByteArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetByteArrayRegion$FUNC
    );
    public interface GetByteArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetByteArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetByteArrayRegion.class, fi, JNINativeInterface_.GetByteArrayRegion$FUNC, session);
        }
        static GetByteArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetByteArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetByteArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetByteArrayRegion"));
    public static VarHandle GetByteArrayRegion$VH() {
        return JNINativeInterface_.GetByteArrayRegion$VH;
    }
    public static MemoryAddress GetByteArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetByteArrayRegion$VH.get(seg);
    }
    public static void GetByteArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetByteArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetByteArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetByteArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetByteArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetByteArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetByteArrayRegion GetByteArrayRegion (MemorySegment segment, MemorySession session) {
        return GetByteArrayRegion.ofAddress(GetByteArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor GetCharArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetCharArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetCharArrayRegion$FUNC
    );
    public interface GetCharArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetCharArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetCharArrayRegion.class, fi, JNINativeInterface_.GetCharArrayRegion$FUNC, session);
        }
        static GetCharArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetCharArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetCharArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetCharArrayRegion"));
    public static VarHandle GetCharArrayRegion$VH() {
        return JNINativeInterface_.GetCharArrayRegion$VH;
    }
    public static MemoryAddress GetCharArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetCharArrayRegion$VH.get(seg);
    }
    public static void GetCharArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetCharArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetCharArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetCharArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetCharArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetCharArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetCharArrayRegion GetCharArrayRegion (MemorySegment segment, MemorySession session) {
        return GetCharArrayRegion.ofAddress(GetCharArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor GetShortArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetShortArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetShortArrayRegion$FUNC
    );
    public interface GetShortArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetShortArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetShortArrayRegion.class, fi, JNINativeInterface_.GetShortArrayRegion$FUNC, session);
        }
        static GetShortArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetShortArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetShortArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetShortArrayRegion"));
    public static VarHandle GetShortArrayRegion$VH() {
        return JNINativeInterface_.GetShortArrayRegion$VH;
    }
    public static MemoryAddress GetShortArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetShortArrayRegion$VH.get(seg);
    }
    public static void GetShortArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetShortArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetShortArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetShortArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetShortArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetShortArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetShortArrayRegion GetShortArrayRegion (MemorySegment segment, MemorySession session) {
        return GetShortArrayRegion.ofAddress(GetShortArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor GetIntArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetIntArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetIntArrayRegion$FUNC
    );
    public interface GetIntArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetIntArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetIntArrayRegion.class, fi, JNINativeInterface_.GetIntArrayRegion$FUNC, session);
        }
        static GetIntArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetIntArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetIntArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetIntArrayRegion"));
    public static VarHandle GetIntArrayRegion$VH() {
        return JNINativeInterface_.GetIntArrayRegion$VH;
    }
    public static MemoryAddress GetIntArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetIntArrayRegion$VH.get(seg);
    }
    public static void GetIntArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetIntArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetIntArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetIntArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetIntArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetIntArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetIntArrayRegion GetIntArrayRegion (MemorySegment segment, MemorySession session) {
        return GetIntArrayRegion.ofAddress(GetIntArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor GetLongArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetLongArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetLongArrayRegion$FUNC
    );
    public interface GetLongArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetLongArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetLongArrayRegion.class, fi, JNINativeInterface_.GetLongArrayRegion$FUNC, session);
        }
        static GetLongArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetLongArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetLongArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetLongArrayRegion"));
    public static VarHandle GetLongArrayRegion$VH() {
        return JNINativeInterface_.GetLongArrayRegion$VH;
    }
    public static MemoryAddress GetLongArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetLongArrayRegion$VH.get(seg);
    }
    public static void GetLongArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetLongArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetLongArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetLongArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetLongArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetLongArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetLongArrayRegion GetLongArrayRegion (MemorySegment segment, MemorySession session) {
        return GetLongArrayRegion.ofAddress(GetLongArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor GetFloatArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetFloatArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetFloatArrayRegion$FUNC
    );
    public interface GetFloatArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetFloatArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetFloatArrayRegion.class, fi, JNINativeInterface_.GetFloatArrayRegion$FUNC, session);
        }
        static GetFloatArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetFloatArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetFloatArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetFloatArrayRegion"));
    public static VarHandle GetFloatArrayRegion$VH() {
        return JNINativeInterface_.GetFloatArrayRegion$VH;
    }
    public static MemoryAddress GetFloatArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFloatArrayRegion$VH.get(seg);
    }
    public static void GetFloatArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetFloatArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetFloatArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetFloatArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetFloatArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetFloatArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetFloatArrayRegion GetFloatArrayRegion (MemorySegment segment, MemorySession session) {
        return GetFloatArrayRegion.ofAddress(GetFloatArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor GetDoubleArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDoubleArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetDoubleArrayRegion$FUNC
    );
    public interface GetDoubleArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetDoubleArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDoubleArrayRegion.class, fi, JNINativeInterface_.GetDoubleArrayRegion$FUNC, session);
        }
        static GetDoubleArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetDoubleArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDoubleArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDoubleArrayRegion"));
    public static VarHandle GetDoubleArrayRegion$VH() {
        return JNINativeInterface_.GetDoubleArrayRegion$VH;
    }
    public static MemoryAddress GetDoubleArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDoubleArrayRegion$VH.get(seg);
    }
    public static void GetDoubleArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetDoubleArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetDoubleArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDoubleArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDoubleArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetDoubleArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDoubleArrayRegion GetDoubleArrayRegion (MemorySegment segment, MemorySession session) {
        return GetDoubleArrayRegion.ofAddress(GetDoubleArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetBooleanArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetBooleanArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetBooleanArrayRegion$FUNC
    );
    public interface SetBooleanArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetBooleanArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetBooleanArrayRegion.class, fi, JNINativeInterface_.SetBooleanArrayRegion$FUNC, session);
        }
        static SetBooleanArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetBooleanArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetBooleanArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetBooleanArrayRegion"));
    public static VarHandle SetBooleanArrayRegion$VH() {
        return JNINativeInterface_.SetBooleanArrayRegion$VH;
    }
    public static MemoryAddress SetBooleanArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetBooleanArrayRegion$VH.get(seg);
    }
    public static void SetBooleanArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetBooleanArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetBooleanArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetBooleanArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetBooleanArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetBooleanArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetBooleanArrayRegion SetBooleanArrayRegion (MemorySegment segment, MemorySession session) {
        return SetBooleanArrayRegion.ofAddress(SetBooleanArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetByteArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetByteArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetByteArrayRegion$FUNC
    );
    public interface SetByteArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetByteArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetByteArrayRegion.class, fi, JNINativeInterface_.SetByteArrayRegion$FUNC, session);
        }
        static SetByteArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetByteArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetByteArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetByteArrayRegion"));
    public static VarHandle SetByteArrayRegion$VH() {
        return JNINativeInterface_.SetByteArrayRegion$VH;
    }
    public static MemoryAddress SetByteArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetByteArrayRegion$VH.get(seg);
    }
    public static void SetByteArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetByteArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetByteArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetByteArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetByteArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetByteArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetByteArrayRegion SetByteArrayRegion (MemorySegment segment, MemorySession session) {
        return SetByteArrayRegion.ofAddress(SetByteArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetCharArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetCharArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetCharArrayRegion$FUNC
    );
    public interface SetCharArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetCharArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetCharArrayRegion.class, fi, JNINativeInterface_.SetCharArrayRegion$FUNC, session);
        }
        static SetCharArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetCharArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetCharArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetCharArrayRegion"));
    public static VarHandle SetCharArrayRegion$VH() {
        return JNINativeInterface_.SetCharArrayRegion$VH;
    }
    public static MemoryAddress SetCharArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetCharArrayRegion$VH.get(seg);
    }
    public static void SetCharArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetCharArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetCharArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetCharArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetCharArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetCharArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetCharArrayRegion SetCharArrayRegion (MemorySegment segment, MemorySession session) {
        return SetCharArrayRegion.ofAddress(SetCharArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetShortArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetShortArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetShortArrayRegion$FUNC
    );
    public interface SetShortArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetShortArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetShortArrayRegion.class, fi, JNINativeInterface_.SetShortArrayRegion$FUNC, session);
        }
        static SetShortArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetShortArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetShortArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetShortArrayRegion"));
    public static VarHandle SetShortArrayRegion$VH() {
        return JNINativeInterface_.SetShortArrayRegion$VH;
    }
    public static MemoryAddress SetShortArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetShortArrayRegion$VH.get(seg);
    }
    public static void SetShortArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetShortArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetShortArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetShortArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetShortArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetShortArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetShortArrayRegion SetShortArrayRegion (MemorySegment segment, MemorySession session) {
        return SetShortArrayRegion.ofAddress(SetShortArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetIntArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetIntArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetIntArrayRegion$FUNC
    );
    public interface SetIntArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetIntArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetIntArrayRegion.class, fi, JNINativeInterface_.SetIntArrayRegion$FUNC, session);
        }
        static SetIntArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetIntArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetIntArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetIntArrayRegion"));
    public static VarHandle SetIntArrayRegion$VH() {
        return JNINativeInterface_.SetIntArrayRegion$VH;
    }
    public static MemoryAddress SetIntArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetIntArrayRegion$VH.get(seg);
    }
    public static void SetIntArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetIntArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetIntArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetIntArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetIntArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetIntArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetIntArrayRegion SetIntArrayRegion (MemorySegment segment, MemorySession session) {
        return SetIntArrayRegion.ofAddress(SetIntArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetLongArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetLongArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetLongArrayRegion$FUNC
    );
    public interface SetLongArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetLongArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetLongArrayRegion.class, fi, JNINativeInterface_.SetLongArrayRegion$FUNC, session);
        }
        static SetLongArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetLongArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetLongArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetLongArrayRegion"));
    public static VarHandle SetLongArrayRegion$VH() {
        return JNINativeInterface_.SetLongArrayRegion$VH;
    }
    public static MemoryAddress SetLongArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetLongArrayRegion$VH.get(seg);
    }
    public static void SetLongArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetLongArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetLongArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetLongArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetLongArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetLongArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetLongArrayRegion SetLongArrayRegion (MemorySegment segment, MemorySession session) {
        return SetLongArrayRegion.ofAddress(SetLongArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetFloatArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetFloatArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetFloatArrayRegion$FUNC
    );
    public interface SetFloatArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetFloatArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetFloatArrayRegion.class, fi, JNINativeInterface_.SetFloatArrayRegion$FUNC, session);
        }
        static SetFloatArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetFloatArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetFloatArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetFloatArrayRegion"));
    public static VarHandle SetFloatArrayRegion$VH() {
        return JNINativeInterface_.SetFloatArrayRegion$VH;
    }
    public static MemoryAddress SetFloatArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetFloatArrayRegion$VH.get(seg);
    }
    public static void SetFloatArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetFloatArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetFloatArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetFloatArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetFloatArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetFloatArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetFloatArrayRegion SetFloatArrayRegion (MemorySegment segment, MemorySession session) {
        return SetFloatArrayRegion.ofAddress(SetFloatArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor SetDoubleArrayRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle SetDoubleArrayRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.SetDoubleArrayRegion$FUNC
    );
    public interface SetDoubleArrayRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(SetDoubleArrayRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(SetDoubleArrayRegion.class, fi, JNINativeInterface_.SetDoubleArrayRegion$FUNC, session);
        }
        static SetDoubleArrayRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.SetDoubleArrayRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle SetDoubleArrayRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("SetDoubleArrayRegion"));
    public static VarHandle SetDoubleArrayRegion$VH() {
        return JNINativeInterface_.SetDoubleArrayRegion$VH;
    }
    public static MemoryAddress SetDoubleArrayRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetDoubleArrayRegion$VH.get(seg);
    }
    public static void SetDoubleArrayRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.SetDoubleArrayRegion$VH.set(seg, x);
    }
    public static MemoryAddress SetDoubleArrayRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.SetDoubleArrayRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void SetDoubleArrayRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.SetDoubleArrayRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static SetDoubleArrayRegion SetDoubleArrayRegion (MemorySegment segment, MemorySession session) {
        return SetDoubleArrayRegion.ofAddress(SetDoubleArrayRegion$get(segment), session);
    }
    static final FunctionDescriptor RegisterNatives$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle RegisterNatives$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.RegisterNatives$FUNC
    );
    public interface RegisterNatives {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(RegisterNatives fi, MemorySession session) {
            return RuntimeHelper.upcallStub(RegisterNatives.class, fi, JNINativeInterface_.RegisterNatives$FUNC, session);
        }
        static RegisterNatives ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    return (int)JNINativeInterface_.RegisterNatives$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle RegisterNatives$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("RegisterNatives"));
    public static VarHandle RegisterNatives$VH() {
        return JNINativeInterface_.RegisterNatives$VH;
    }
    public static MemoryAddress RegisterNatives$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.RegisterNatives$VH.get(seg);
    }
    public static void RegisterNatives$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.RegisterNatives$VH.set(seg, x);
    }
    public static MemoryAddress RegisterNatives$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.RegisterNatives$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void RegisterNatives$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.RegisterNatives$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static RegisterNatives RegisterNatives (MemorySegment segment, MemorySession session) {
        return RegisterNatives.ofAddress(RegisterNatives$get(segment), session);
    }
    static final FunctionDescriptor UnregisterNatives$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle UnregisterNatives$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.UnregisterNatives$FUNC
    );
    public interface UnregisterNatives {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(UnregisterNatives fi, MemorySession session) {
            return RuntimeHelper.upcallStub(UnregisterNatives.class, fi, JNINativeInterface_.UnregisterNatives$FUNC, session);
        }
        static UnregisterNatives ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.UnregisterNatives$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle UnregisterNatives$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("UnregisterNatives"));
    public static VarHandle UnregisterNatives$VH() {
        return JNINativeInterface_.UnregisterNatives$VH;
    }
    public static MemoryAddress UnregisterNatives$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.UnregisterNatives$VH.get(seg);
    }
    public static void UnregisterNatives$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.UnregisterNatives$VH.set(seg, x);
    }
    public static MemoryAddress UnregisterNatives$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.UnregisterNatives$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void UnregisterNatives$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.UnregisterNatives$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static UnregisterNatives UnregisterNatives (MemorySegment segment, MemorySession session) {
        return UnregisterNatives.ofAddress(UnregisterNatives$get(segment), session);
    }
    static final FunctionDescriptor MonitorEnter$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle MonitorEnter$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.MonitorEnter$FUNC
    );
    public interface MonitorEnter {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(MonitorEnter fi, MemorySession session) {
            return RuntimeHelper.upcallStub(MonitorEnter.class, fi, JNINativeInterface_.MonitorEnter$FUNC, session);
        }
        static MonitorEnter ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.MonitorEnter$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle MonitorEnter$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("MonitorEnter"));
    public static VarHandle MonitorEnter$VH() {
        return JNINativeInterface_.MonitorEnter$VH;
    }
    public static MemoryAddress MonitorEnter$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.MonitorEnter$VH.get(seg);
    }
    public static void MonitorEnter$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.MonitorEnter$VH.set(seg, x);
    }
    public static MemoryAddress MonitorEnter$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.MonitorEnter$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MonitorEnter$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.MonitorEnter$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MonitorEnter MonitorEnter (MemorySegment segment, MemorySession session) {
        return MonitorEnter.ofAddress(MonitorEnter$get(segment), session);
    }
    static final FunctionDescriptor MonitorExit$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle MonitorExit$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.MonitorExit$FUNC
    );
    public interface MonitorExit {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(MonitorExit fi, MemorySession session) {
            return RuntimeHelper.upcallStub(MonitorExit.class, fi, JNINativeInterface_.MonitorExit$FUNC, session);
        }
        static MonitorExit ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.MonitorExit$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle MonitorExit$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("MonitorExit"));
    public static VarHandle MonitorExit$VH() {
        return JNINativeInterface_.MonitorExit$VH;
    }
    public static MemoryAddress MonitorExit$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.MonitorExit$VH.get(seg);
    }
    public static void MonitorExit$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.MonitorExit$VH.set(seg, x);
    }
    public static MemoryAddress MonitorExit$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.MonitorExit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void MonitorExit$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.MonitorExit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MonitorExit MonitorExit (MemorySegment segment, MemorySession session) {
        return MonitorExit.ofAddress(MonitorExit$get(segment), session);
    }
    static final FunctionDescriptor GetJavaVM$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetJavaVM$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetJavaVM$FUNC
    );
    public interface GetJavaVM {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetJavaVM fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetJavaVM.class, fi, JNINativeInterface_.GetJavaVM$FUNC, session);
        }
        static GetJavaVM ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.GetJavaVM$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetJavaVM$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetJavaVM"));
    public static VarHandle GetJavaVM$VH() {
        return JNINativeInterface_.GetJavaVM$VH;
    }
    public static MemoryAddress GetJavaVM$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetJavaVM$VH.get(seg);
    }
    public static void GetJavaVM$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetJavaVM$VH.set(seg, x);
    }
    public static MemoryAddress GetJavaVM$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetJavaVM$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetJavaVM$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetJavaVM$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetJavaVM GetJavaVM (MemorySegment segment, MemorySession session) {
        return GetJavaVM.ofAddress(GetJavaVM$get(segment), session);
    }
    static final FunctionDescriptor GetStringRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStringRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStringRegion$FUNC
    );
    public interface GetStringRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetStringRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStringRegion.class, fi, JNINativeInterface_.GetStringRegion$FUNC, session);
        }
        static GetStringRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetStringRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStringRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStringRegion"));
    public static VarHandle GetStringRegion$VH() {
        return JNINativeInterface_.GetStringRegion$VH;
    }
    public static MemoryAddress GetStringRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringRegion$VH.get(seg);
    }
    public static void GetStringRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStringRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetStringRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStringRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStringRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStringRegion GetStringRegion (MemorySegment segment, MemorySession session) {
        return GetStringRegion.ofAddress(GetStringRegion$get(segment), session);
    }
    static final FunctionDescriptor GetStringUTFRegion$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStringUTFRegion$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStringUTFRegion$FUNC
    );
    public interface GetStringUTFRegion {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, int _x2, int _x3, java.lang.foreign.MemoryAddress _x4);
        static MemorySegment allocate(GetStringUTFRegion fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStringUTFRegion.class, fi, JNINativeInterface_.GetStringUTFRegion$FUNC, session);
        }
        static GetStringUTFRegion ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, int __x2, int __x3, java.lang.foreign.MemoryAddress __x4) -> {
                try {
                    JNINativeInterface_.GetStringUTFRegion$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2, __x3, (java.lang.foreign.Addressable)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStringUTFRegion$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStringUTFRegion"));
    public static VarHandle GetStringUTFRegion$VH() {
        return JNINativeInterface_.GetStringUTFRegion$VH;
    }
    public static MemoryAddress GetStringUTFRegion$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringUTFRegion$VH.get(seg);
    }
    public static void GetStringUTFRegion$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStringUTFRegion$VH.set(seg, x);
    }
    public static MemoryAddress GetStringUTFRegion$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringUTFRegion$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStringUTFRegion$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStringUTFRegion$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStringUTFRegion GetStringUTFRegion (MemorySegment segment, MemorySession session) {
        return GetStringUTFRegion.ofAddress(GetStringUTFRegion$get(segment), session);
    }
    static final FunctionDescriptor GetPrimitiveArrayCritical$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetPrimitiveArrayCritical$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetPrimitiveArrayCritical$FUNC
    );
    public interface GetPrimitiveArrayCritical {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetPrimitiveArrayCritical fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetPrimitiveArrayCritical.class, fi, JNINativeInterface_.GetPrimitiveArrayCritical$FUNC, session);
        }
        static GetPrimitiveArrayCritical ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetPrimitiveArrayCritical$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetPrimitiveArrayCritical$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetPrimitiveArrayCritical"));
    public static VarHandle GetPrimitiveArrayCritical$VH() {
        return JNINativeInterface_.GetPrimitiveArrayCritical$VH;
    }
    public static MemoryAddress GetPrimitiveArrayCritical$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetPrimitiveArrayCritical$VH.get(seg);
    }
    public static void GetPrimitiveArrayCritical$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetPrimitiveArrayCritical$VH.set(seg, x);
    }
    public static MemoryAddress GetPrimitiveArrayCritical$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetPrimitiveArrayCritical$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetPrimitiveArrayCritical$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetPrimitiveArrayCritical$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetPrimitiveArrayCritical GetPrimitiveArrayCritical (MemorySegment segment, MemorySession session) {
        return GetPrimitiveArrayCritical.ofAddress(GetPrimitiveArrayCritical$get(segment), session);
    }
    static final FunctionDescriptor ReleasePrimitiveArrayCritical$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle ReleasePrimitiveArrayCritical$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleasePrimitiveArrayCritical$FUNC
    );
    public interface ReleasePrimitiveArrayCritical {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2, int _x3);
        static MemorySegment allocate(ReleasePrimitiveArrayCritical fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleasePrimitiveArrayCritical.class, fi, JNINativeInterface_.ReleasePrimitiveArrayCritical$FUNC, session);
        }
        static ReleasePrimitiveArrayCritical ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2, int __x3) -> {
                try {
                    JNINativeInterface_.ReleasePrimitiveArrayCritical$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleasePrimitiveArrayCritical$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleasePrimitiveArrayCritical"));
    public static VarHandle ReleasePrimitiveArrayCritical$VH() {
        return JNINativeInterface_.ReleasePrimitiveArrayCritical$VH;
    }
    public static MemoryAddress ReleasePrimitiveArrayCritical$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleasePrimitiveArrayCritical$VH.get(seg);
    }
    public static void ReleasePrimitiveArrayCritical$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleasePrimitiveArrayCritical$VH.set(seg, x);
    }
    public static MemoryAddress ReleasePrimitiveArrayCritical$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleasePrimitiveArrayCritical$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleasePrimitiveArrayCritical$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleasePrimitiveArrayCritical$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleasePrimitiveArrayCritical ReleasePrimitiveArrayCritical (MemorySegment segment, MemorySession session) {
        return ReleasePrimitiveArrayCritical.ofAddress(ReleasePrimitiveArrayCritical$get(segment), session);
    }
    static final FunctionDescriptor GetStringCritical$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetStringCritical$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetStringCritical$FUNC
    );
    public interface GetStringCritical {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(GetStringCritical fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetStringCritical.class, fi, JNINativeInterface_.GetStringCritical$FUNC, session);
        }
        static GetStringCritical ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringCritical$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetStringCritical$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetStringCritical"));
    public static VarHandle GetStringCritical$VH() {
        return JNINativeInterface_.GetStringCritical$VH;
    }
    public static MemoryAddress GetStringCritical$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringCritical$VH.get(seg);
    }
    public static void GetStringCritical$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetStringCritical$VH.set(seg, x);
    }
    public static MemoryAddress GetStringCritical$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetStringCritical$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetStringCritical$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetStringCritical$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetStringCritical GetStringCritical (MemorySegment segment, MemorySession session) {
        return GetStringCritical.ofAddress(GetStringCritical$get(segment), session);
    }
    static final FunctionDescriptor ReleaseStringCritical$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ReleaseStringCritical$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ReleaseStringCritical$FUNC
    );
    public interface ReleaseStringCritical {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, java.lang.foreign.MemoryAddress _x2);
        static MemorySegment allocate(ReleaseStringCritical fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ReleaseStringCritical.class, fi, JNINativeInterface_.ReleaseStringCritical$FUNC, session);
        }
        static ReleaseStringCritical ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, java.lang.foreign.MemoryAddress __x2) -> {
                try {
                    JNINativeInterface_.ReleaseStringCritical$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, (java.lang.foreign.Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ReleaseStringCritical$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ReleaseStringCritical"));
    public static VarHandle ReleaseStringCritical$VH() {
        return JNINativeInterface_.ReleaseStringCritical$VH;
    }
    public static MemoryAddress ReleaseStringCritical$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseStringCritical$VH.get(seg);
    }
    public static void ReleaseStringCritical$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ReleaseStringCritical$VH.set(seg, x);
    }
    public static MemoryAddress ReleaseStringCritical$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ReleaseStringCritical$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ReleaseStringCritical$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ReleaseStringCritical$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ReleaseStringCritical ReleaseStringCritical (MemorySegment segment, MemorySession session) {
        return ReleaseStringCritical.ofAddress(ReleaseStringCritical$get(segment), session);
    }
    static final FunctionDescriptor NewWeakGlobalRef$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle NewWeakGlobalRef$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewWeakGlobalRef$FUNC
    );
    public interface NewWeakGlobalRef {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(NewWeakGlobalRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewWeakGlobalRef.class, fi, JNINativeInterface_.NewWeakGlobalRef$FUNC, session);
        }
        static NewWeakGlobalRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewWeakGlobalRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewWeakGlobalRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewWeakGlobalRef"));
    public static VarHandle NewWeakGlobalRef$VH() {
        return JNINativeInterface_.NewWeakGlobalRef$VH;
    }
    public static MemoryAddress NewWeakGlobalRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewWeakGlobalRef$VH.get(seg);
    }
    public static void NewWeakGlobalRef$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewWeakGlobalRef$VH.set(seg, x);
    }
    public static MemoryAddress NewWeakGlobalRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewWeakGlobalRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewWeakGlobalRef$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewWeakGlobalRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewWeakGlobalRef NewWeakGlobalRef (MemorySegment segment, MemorySession session) {
        return NewWeakGlobalRef.ofAddress(NewWeakGlobalRef$get(segment), session);
    }
    static final FunctionDescriptor DeleteWeakGlobalRef$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle DeleteWeakGlobalRef$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.DeleteWeakGlobalRef$FUNC
    );
    public interface DeleteWeakGlobalRef {

        void apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(DeleteWeakGlobalRef fi, MemorySession session) {
            return RuntimeHelper.upcallStub(DeleteWeakGlobalRef.class, fi, JNINativeInterface_.DeleteWeakGlobalRef$FUNC, session);
        }
        static DeleteWeakGlobalRef ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    JNINativeInterface_.DeleteWeakGlobalRef$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle DeleteWeakGlobalRef$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("DeleteWeakGlobalRef"));
    public static VarHandle DeleteWeakGlobalRef$VH() {
        return JNINativeInterface_.DeleteWeakGlobalRef$VH;
    }
    public static MemoryAddress DeleteWeakGlobalRef$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DeleteWeakGlobalRef$VH.get(seg);
    }
    public static void DeleteWeakGlobalRef$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.DeleteWeakGlobalRef$VH.set(seg, x);
    }
    public static MemoryAddress DeleteWeakGlobalRef$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.DeleteWeakGlobalRef$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void DeleteWeakGlobalRef$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.DeleteWeakGlobalRef$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static DeleteWeakGlobalRef DeleteWeakGlobalRef (MemorySegment segment, MemorySession session) {
        return DeleteWeakGlobalRef.ofAddress(DeleteWeakGlobalRef$get(segment), session);
    }
    static final FunctionDescriptor ExceptionCheck$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ExceptionCheck$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.ExceptionCheck$FUNC
    );
    public interface ExceptionCheck {

        byte apply(java.lang.foreign.MemoryAddress _x0);
        static MemorySegment allocate(ExceptionCheck fi, MemorySession session) {
            return RuntimeHelper.upcallStub(ExceptionCheck.class, fi, JNINativeInterface_.ExceptionCheck$FUNC, session);
        }
        static ExceptionCheck ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0) -> {
                try {
                    return (byte)JNINativeInterface_.ExceptionCheck$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ExceptionCheck$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ExceptionCheck"));
    public static VarHandle ExceptionCheck$VH() {
        return JNINativeInterface_.ExceptionCheck$VH;
    }
    public static MemoryAddress ExceptionCheck$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionCheck$VH.get(seg);
    }
    public static void ExceptionCheck$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.ExceptionCheck$VH.set(seg, x);
    }
    public static MemoryAddress ExceptionCheck$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.ExceptionCheck$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ExceptionCheck$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.ExceptionCheck$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ExceptionCheck ExceptionCheck (MemorySegment segment, MemorySession session) {
        return ExceptionCheck.ofAddress(ExceptionCheck$get(segment), session);
    }
    static final FunctionDescriptor NewDirectByteBuffer$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle NewDirectByteBuffer$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.NewDirectByteBuffer$FUNC
    );
    public interface NewDirectByteBuffer {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1, long _x2);
        static MemorySegment allocate(NewDirectByteBuffer fi, MemorySession session) {
            return RuntimeHelper.upcallStub(NewDirectByteBuffer.class, fi, JNINativeInterface_.NewDirectByteBuffer$FUNC, session);
        }
        static NewDirectByteBuffer ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1, long __x2) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.NewDirectByteBuffer$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle NewDirectByteBuffer$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("NewDirectByteBuffer"));
    public static VarHandle NewDirectByteBuffer$VH() {
        return JNINativeInterface_.NewDirectByteBuffer$VH;
    }
    public static MemoryAddress NewDirectByteBuffer$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewDirectByteBuffer$VH.get(seg);
    }
    public static void NewDirectByteBuffer$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.NewDirectByteBuffer$VH.set(seg, x);
    }
    public static MemoryAddress NewDirectByteBuffer$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.NewDirectByteBuffer$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void NewDirectByteBuffer$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.NewDirectByteBuffer$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static NewDirectByteBuffer NewDirectByteBuffer (MemorySegment segment, MemorySession session) {
        return NewDirectByteBuffer.ofAddress(NewDirectByteBuffer$get(segment), session);
    }
    static final FunctionDescriptor GetDirectBufferAddress$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDirectBufferAddress$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetDirectBufferAddress$FUNC
    );
    public interface GetDirectBufferAddress {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDirectBufferAddress fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDirectBufferAddress.class, fi, JNINativeInterface_.GetDirectBufferAddress$FUNC, session);
        }
        static GetDirectBufferAddress ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDirectBufferAddress$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDirectBufferAddress$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDirectBufferAddress"));
    public static VarHandle GetDirectBufferAddress$VH() {
        return JNINativeInterface_.GetDirectBufferAddress$VH;
    }
    public static MemoryAddress GetDirectBufferAddress$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDirectBufferAddress$VH.get(seg);
    }
    public static void GetDirectBufferAddress$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetDirectBufferAddress$VH.set(seg, x);
    }
    public static MemoryAddress GetDirectBufferAddress$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDirectBufferAddress$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDirectBufferAddress$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetDirectBufferAddress$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDirectBufferAddress GetDirectBufferAddress (MemorySegment segment, MemorySession session) {
        return GetDirectBufferAddress.ofAddress(GetDirectBufferAddress$get(segment), session);
    }
    static final FunctionDescriptor GetDirectBufferCapacity$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetDirectBufferCapacity$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetDirectBufferCapacity$FUNC
    );
    public interface GetDirectBufferCapacity {

        long apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetDirectBufferCapacity fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetDirectBufferCapacity.class, fi, JNINativeInterface_.GetDirectBufferCapacity$FUNC, session);
        }
        static GetDirectBufferCapacity ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (long)JNINativeInterface_.GetDirectBufferCapacity$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetDirectBufferCapacity$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetDirectBufferCapacity"));
    public static VarHandle GetDirectBufferCapacity$VH() {
        return JNINativeInterface_.GetDirectBufferCapacity$VH;
    }
    public static MemoryAddress GetDirectBufferCapacity$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDirectBufferCapacity$VH.get(seg);
    }
    public static void GetDirectBufferCapacity$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetDirectBufferCapacity$VH.set(seg, x);
    }
    public static MemoryAddress GetDirectBufferCapacity$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetDirectBufferCapacity$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetDirectBufferCapacity$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetDirectBufferCapacity$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetDirectBufferCapacity GetDirectBufferCapacity (MemorySegment segment, MemorySession session) {
        return GetDirectBufferCapacity.ofAddress(GetDirectBufferCapacity$get(segment), session);
    }
    static final FunctionDescriptor GetObjectRefType$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetObjectRefType$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetObjectRefType$FUNC
    );
    public interface GetObjectRefType {

        int apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetObjectRefType fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetObjectRefType.class, fi, JNINativeInterface_.GetObjectRefType$FUNC, session);
        }
        static GetObjectRefType ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (int)JNINativeInterface_.GetObjectRefType$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetObjectRefType$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetObjectRefType"));
    public static VarHandle GetObjectRefType$VH() {
        return JNINativeInterface_.GetObjectRefType$VH;
    }
    public static MemoryAddress GetObjectRefType$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectRefType$VH.get(seg);
    }
    public static void GetObjectRefType$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetObjectRefType$VH.set(seg, x);
    }
    public static MemoryAddress GetObjectRefType$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetObjectRefType$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetObjectRefType$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetObjectRefType$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetObjectRefType GetObjectRefType (MemorySegment segment, MemorySession session) {
        return GetObjectRefType.ofAddress(GetObjectRefType$get(segment), session);
    }
    static final FunctionDescriptor GetModule$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle GetModule$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.GetModule$FUNC
    );
    public interface GetModule {

        java.lang.foreign.Addressable apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(GetModule fi, MemorySession session) {
            return RuntimeHelper.upcallStub(GetModule.class, fi, JNINativeInterface_.GetModule$FUNC, session);
        }
        static GetModule ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (java.lang.foreign.Addressable)(java.lang.foreign.MemoryAddress)JNINativeInterface_.GetModule$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle GetModule$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("GetModule"));
    public static VarHandle GetModule$VH() {
        return JNINativeInterface_.GetModule$VH;
    }
    public static MemoryAddress GetModule$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetModule$VH.get(seg);
    }
    public static void GetModule$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.GetModule$VH.set(seg, x);
    }
    public static MemoryAddress GetModule$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.GetModule$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void GetModule$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.GetModule$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static GetModule GetModule (MemorySegment segment, MemorySession session) {
        return GetModule.ofAddress(GetModule$get(segment), session);
    }
    static final FunctionDescriptor IsVirtualThread$FUNC = FunctionDescriptor.of(Constants$root.C_CHAR$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle IsVirtualThread$MH = RuntimeHelper.downcallHandle(
        JNINativeInterface_.IsVirtualThread$FUNC
    );
    public interface IsVirtualThread {

        byte apply(java.lang.foreign.MemoryAddress _x0, java.lang.foreign.MemoryAddress _x1);
        static MemorySegment allocate(IsVirtualThread fi, MemorySession session) {
            return RuntimeHelper.upcallStub(IsVirtualThread.class, fi, JNINativeInterface_.IsVirtualThread$FUNC, session);
        }
        static IsVirtualThread ofAddress(MemoryAddress addr, MemorySession session) {
            MemorySegment symbol = MemorySegment.ofAddress(addr, 0, session);
            return (java.lang.foreign.MemoryAddress __x0, java.lang.foreign.MemoryAddress __x1) -> {
                try {
                    return (byte)JNINativeInterface_.IsVirtualThread$MH.invokeExact((Addressable)symbol, (java.lang.foreign.Addressable)__x0, (java.lang.foreign.Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle IsVirtualThread$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("IsVirtualThread"));
    public static VarHandle IsVirtualThread$VH() {
        return JNINativeInterface_.IsVirtualThread$VH;
    }
    public static MemoryAddress IsVirtualThread$get(MemorySegment seg) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsVirtualThread$VH.get(seg);
    }
    public static void IsVirtualThread$set( MemorySegment seg, MemoryAddress x) {
        JNINativeInterface_.IsVirtualThread$VH.set(seg, x);
    }
    public static MemoryAddress IsVirtualThread$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemoryAddress)JNINativeInterface_.IsVirtualThread$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void IsVirtualThread$set(MemorySegment seg, long index, MemoryAddress x) {
        JNINativeInterface_.IsVirtualThread$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static IsVirtualThread IsVirtualThread (MemorySegment segment, MemorySession session) {
        return IsVirtualThread.ofAddress(IsVirtualThread$get(segment), session);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


