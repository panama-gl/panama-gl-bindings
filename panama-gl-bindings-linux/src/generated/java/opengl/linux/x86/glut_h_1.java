// Generated by jextract

package opengl.linux.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class glut_h_1 extends glut_h_2 {

    glut_h_1() {
        // Should not be called directly
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLenum
     * }
     */
    public static final OfInt GLenum = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLboolean
     * }
     */
    public static final OfByte GLboolean = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLbitfield
     * }
     */
    public static final OfInt GLbitfield = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char GLbyte
     * }
     */
    public static final OfByte GLbyte = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short GLshort
     * }
     */
    public static final OfShort GLshort = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int GLint
     * }
     */
    public static final OfInt GLint = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLubyte
     * }
     */
    public static final OfByte GLubyte = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short GLushort
     * }
     */
    public static final OfShort GLushort = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLuint
     * }
     */
    public static final OfInt GLuint = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int GLsizei
     * }
     */
    public static final OfInt GLsizei = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float GLfloat
     * }
     */
    public static final OfFloat GLfloat = glut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef float GLclampf
     * }
     */
    public static final OfFloat GLclampf = glut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double GLdouble
     * }
     */
    public static final OfDouble GLdouble = glut_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double GLclampd
     * }
     */
    public static final OfDouble GLclampd = glut_h.C_DOUBLE;

    private static class glClearIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClearIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static FunctionDescriptor glClearIndex$descriptor() {
        return glClearIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MethodHandle glClearIndex$handle() {
        return glClearIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MemorySegment glClearIndex$address() {
        return glClearIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static void glClearIndex(float c) {
        var mh$ = glClearIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearIndex", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClearColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glClearColor$descriptor() {
        return glClearColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glClearColor$handle() {
        return glClearColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glClearColor$address() {
        return glClearColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glClearColor(float red, float green, float blue, float alpha) {
        var mh$ = glClearColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glClear$descriptor() {
        return glClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MethodHandle glClear$handle() {
        return glClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MemorySegment glClear$address() {
        return glClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static void glClear(int mask) {
        var mh$ = glClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClear", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glIndexMask$descriptor() {
        return glIndexMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MethodHandle glIndexMask$handle() {
        return glIndexMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MemorySegment glIndexMask$address() {
        return glIndexMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static void glIndexMask(int mask) {
        var mh$ = glIndexMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static FunctionDescriptor glColorMask$descriptor() {
        return glColorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MethodHandle glColorMask$handle() {
        return glColorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MemorySegment glColorMask$address() {
        return glColorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static void glColorMask(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMask", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAlphaFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glAlphaFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static FunctionDescriptor glAlphaFunc$descriptor() {
        return glAlphaFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MethodHandle glAlphaFunc$handle() {
        return glAlphaFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MemorySegment glAlphaFunc$address() {
        return glAlphaFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static void glAlphaFunc(int func, float ref) {
        var mh$ = glAlphaFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAlphaFunc", func, ref);
            }
            mh$.invokeExact(func, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glBlendFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static FunctionDescriptor glBlendFunc$descriptor() {
        return glBlendFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MethodHandle glBlendFunc$handle() {
        return glBlendFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MemorySegment glBlendFunc$address() {
        return glBlendFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static void glBlendFunc(int sfactor, int dfactor) {
        var mh$ = glBlendFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendFunc", sfactor, dfactor);
            }
            mh$.invokeExact(sfactor, dfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLogicOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLogicOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static FunctionDescriptor glLogicOp$descriptor() {
        return glLogicOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MethodHandle glLogicOp$handle() {
        return glLogicOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MemorySegment glLogicOp$address() {
        return glLogicOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static void glLogicOp(int opcode) {
        var mh$ = glLogicOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLogicOp", opcode);
            }
            mh$.invokeExact(opcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCullFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCullFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glCullFace$descriptor() {
        return glCullFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MethodHandle glCullFace$handle() {
        return glCullFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MemorySegment glCullFace$address() {
        return glCullFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static void glCullFace(int mode) {
        var mh$ = glCullFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCullFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrontFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFrontFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glFrontFace$descriptor() {
        return glFrontFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MethodHandle glFrontFace$handle() {
        return glFrontFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MemorySegment glFrontFace$address() {
        return glFrontFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static void glFrontFace(int mode) {
        var mh$ = glFrontFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrontFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPointSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static FunctionDescriptor glPointSize$descriptor() {
        return glPointSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MethodHandle glPointSize$handle() {
        return glPointSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MemorySegment glPointSize$address() {
        return glPointSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static void glPointSize(float size) {
        var mh$ = glPointSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointSize", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static FunctionDescriptor glLineWidth$descriptor() {
        return glLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MethodHandle glLineWidth$handle() {
        return glLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MemorySegment glLineWidth$address() {
        return glLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static void glLineWidth(float width) {
        var mh$ = glLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLineStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static FunctionDescriptor glLineStipple$descriptor() {
        return glLineStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MethodHandle glLineStipple$handle() {
        return glLineStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MemorySegment glLineStipple$address() {
        return glLineStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static void glLineStipple(int factor, short pattern) {
        var mh$ = glLineStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineStipple", factor, pattern);
            }
            mh$.invokeExact(factor, pattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPolygonMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glPolygonMode$descriptor() {
        return glPolygonMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glPolygonMode$handle() {
        return glPolygonMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glPolygonMode$address() {
        return glPolygonMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static void glPolygonMode(int face, int mode) {
        var mh$ = glPolygonMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonMode", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPolygonOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static FunctionDescriptor glPolygonOffset$descriptor() {
        return glPolygonOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MethodHandle glPolygonOffset$handle() {
        return glPolygonOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MemorySegment glPolygonOffset$address() {
        return glPolygonOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static void glPolygonOffset(float factor, float units) {
        var mh$ = glPolygonOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonOffset", factor, units);
            }
            mh$.invokeExact(factor, units);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glPolygonStipple$descriptor() {
        return glPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MethodHandle glPolygonStipple$handle() {
        return glPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MemorySegment glPolygonStipple$address() {
        return glPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static void glPolygonStipple(MemorySegment mask) {
        var mh$ = glPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glGetPolygonStipple$descriptor() {
        return glGetPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MethodHandle glGetPolygonStipple$handle() {
        return glGetPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MemorySegment glGetPolygonStipple$address() {
        return glGetPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static void glGetPolygonStipple(MemorySegment mask) {
        var mh$ = glGetPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEdgeFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlag$descriptor() {
        return glEdgeFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MethodHandle glEdgeFlag$handle() {
        return glEdgeFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MemorySegment glEdgeFlag$address() {
        return glEdgeFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static void glEdgeFlag(byte flag) {
        var mh$ = glEdgeFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlag", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEdgeFlagv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlagv$descriptor() {
        return glEdgeFlagv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MethodHandle glEdgeFlagv$handle() {
        return glEdgeFlagv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MemorySegment glEdgeFlagv$address() {
        return glEdgeFlagv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static void glEdgeFlagv(MemorySegment flag) {
        var mh$ = glEdgeFlagv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagv", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glScissor$descriptor() {
        return glScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glScissor$handle() {
        return glScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glScissor$address() {
        return glScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glScissor(int x, int y, int width, int height) {
        var mh$ = glScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScissor", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glClipPlane$descriptor() {
        return glClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MethodHandle glClipPlane$handle() {
        return glClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MemorySegment glClipPlane$address() {
        return glClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static void glClipPlane(int plane, MemorySegment equation) {
        var mh$ = glClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glGetClipPlane$descriptor() {
        return glGetClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MethodHandle glGetClipPlane$handle() {
        return glGetClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MemorySegment glGetClipPlane$address() {
        return glGetClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static void glGetClipPlane(int plane, MemorySegment equation) {
        var mh$ = glGetClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDrawBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glDrawBuffer$descriptor() {
        return glDrawBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glDrawBuffer$handle() {
        return glDrawBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glDrawBuffer$address() {
        return glDrawBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static void glDrawBuffer(int mode) {
        var mh$ = glDrawBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glReadBuffer$descriptor() {
        return glReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glReadBuffer$handle() {
        return glReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glReadBuffer$address() {
        return glReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static void glReadBuffer(int mode) {
        var mh$ = glReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEnable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glEnable$descriptor() {
        return glEnable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MethodHandle glEnable$handle() {
        return glEnable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MemorySegment glEnable$address() {
        return glEnable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static void glEnable(int cap) {
        var mh$ = glEnable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glDisable$descriptor() {
        return glDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MethodHandle glDisable$handle() {
        return glDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MemorySegment glDisable$address() {
        return glDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static void glDisable(int cap) {
        var mh$ = glDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_CHAR,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static FunctionDescriptor glIsEnabled$descriptor() {
        return glIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MethodHandle glIsEnabled$handle() {
        return glIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MemorySegment glIsEnabled$address() {
        return glIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static byte glIsEnabled(int cap) {
        var mh$ = glIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsEnabled", cap);
            }
            return (byte)mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEnableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static FunctionDescriptor glEnableClientState$descriptor() {
        return glEnableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static MethodHandle glEnableClientState$handle() {
        return glEnableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static MemorySegment glEnableClientState$address() {
        return glEnableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static void glEnableClientState(int cap) {
        var mh$ = glEnableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableClientState", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDisableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static FunctionDescriptor glDisableClientState$descriptor() {
        return glDisableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static MethodHandle glDisableClientState$handle() {
        return glDisableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static MemorySegment glDisableClientState$address() {
        return glDisableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static void glDisableClientState(int cap) {
        var mh$ = glDisableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableClientState", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBooleanv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetBooleanv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static FunctionDescriptor glGetBooleanv$descriptor() {
        return glGetBooleanv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MethodHandle glGetBooleanv$handle() {
        return glGetBooleanv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MemorySegment glGetBooleanv$address() {
        return glGetBooleanv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static void glGetBooleanv(int pname, MemorySegment params) {
        var mh$ = glGetBooleanv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBooleanv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetDoublev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetDoublev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetDoublev$descriptor() {
        return glGetDoublev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetDoublev$handle() {
        return glGetDoublev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetDoublev$address() {
        return glGetDoublev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetDoublev(int pname, MemorySegment params) {
        var mh$ = glGetDoublev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetDoublev", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFloatv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetFloatv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetFloatv$descriptor() {
        return glGetFloatv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetFloatv$handle() {
        return glGetFloatv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetFloatv$address() {
        return glGetFloatv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetFloatv(int pname, MemorySegment params) {
        var mh$ = glGetFloatv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFloatv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetIntegerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetIntegerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetIntegerv$descriptor() {
        return glGetIntegerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetIntegerv$handle() {
        return glGetIntegerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetIntegerv$address() {
        return glGetIntegerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static void glGetIntegerv(int pname, MemorySegment params) {
        var mh$ = glGetIntegerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetIntegerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPushAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushAttrib$descriptor() {
        return glPushAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushAttrib$handle() {
        return glPushAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushAttrib$address() {
        return glPushAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static void glPushAttrib(int mask) {
        var mh$ = glPushAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPopAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static FunctionDescriptor glPopAttrib$descriptor() {
        return glPopAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MethodHandle glPopAttrib$handle() {
        return glPopAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MemorySegment glPopAttrib$address() {
        return glPopAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static void glPopAttrib() {
        var mh$ = glPopAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPushClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushClientAttrib$descriptor() {
        return glPushClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushClientAttrib$handle() {
        return glPushClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushClientAttrib$address() {
        return glPushClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static void glPushClientAttrib(int mask) {
        var mh$ = glPushClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushClientAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPopClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static FunctionDescriptor glPopClientAttrib$descriptor() {
        return glPopClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MethodHandle glPopClientAttrib$handle() {
        return glPopClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MemorySegment glPopClientAttrib$address() {
        return glPopClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static void glPopClientAttrib() {
        var mh$ = glPopClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopClientAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRenderMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glRenderMode$descriptor() {
        return glRenderMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MethodHandle glRenderMode$handle() {
        return glRenderMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MemorySegment glRenderMode$address() {
        return glRenderMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static int glRenderMode(int mode) {
        var mh$ = glRenderMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderMode", mode);
            }
            return (int)mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static FunctionDescriptor glGetError$descriptor() {
        return glGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MethodHandle glGetError$handle() {
        return glGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MemorySegment glGetError$address() {
        return glGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static int glGetError() {
        var mh$ = glGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor glGetString$descriptor() {
        return glGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MethodHandle glGetString$handle() {
        return glGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString$address() {
        return glGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString(int name) {
        var mh$ = glGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static FunctionDescriptor glFinish$descriptor() {
        return glFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MethodHandle glFinish$handle() {
        return glFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MemorySegment glFinish$address() {
        return glFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static void glFinish() {
        var mh$ = glFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinish");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static FunctionDescriptor glFlush$descriptor() {
        return glFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MethodHandle glFlush$handle() {
        return glFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MemorySegment glFlush$address() {
        return glFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static void glFlush() {
        var mh$ = glFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlush");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static FunctionDescriptor glHint$descriptor() {
        return glHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MethodHandle glHint$handle() {
        return glHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MemorySegment glHint$address() {
        return glHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static void glHint(int target, int mode) {
        var mh$ = glHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHint", target, mode);
            }
            mh$.invokeExact(target, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClearDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static FunctionDescriptor glClearDepth$descriptor() {
        return glClearDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MethodHandle glClearDepth$handle() {
        return glClearDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MemorySegment glClearDepth$address() {
        return glClearDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static void glClearDepth(double depth) {
        var mh$ = glClearDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearDepth", depth);
            }
            mh$.invokeExact(depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDepthFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static FunctionDescriptor glDepthFunc$descriptor() {
        return glDepthFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MethodHandle glDepthFunc$handle() {
        return glDepthFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MemorySegment glDepthFunc$address() {
        return glDepthFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static void glDepthFunc(int func) {
        var mh$ = glDepthFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glDepthMask$descriptor() {
        return glDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MethodHandle glDepthMask$handle() {
        return glDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MemorySegment glDepthMask$address() {
        return glDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static void glDepthMask(byte flag) {
        var mh$ = glDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthMask", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDepthRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static FunctionDescriptor glDepthRange$descriptor() {
        return glDepthRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static MethodHandle glDepthRange$handle() {
        return glDepthRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static MemorySegment glDepthRange$address() {
        return glDepthRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static void glDepthRange(double near_val, double far_val) {
        var mh$ = glDepthRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthRange", near_val, far_val);
            }
            mh$.invokeExact(near_val, far_val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClearAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glClearAccum$descriptor() {
        return glClearAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glClearAccum$handle() {
        return glClearAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glClearAccum$address() {
        return glClearAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glClearAccum(float red, float green, float blue, float alpha) {
        var mh$ = glClearAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearAccum", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static FunctionDescriptor glAccum$descriptor() {
        return glAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MethodHandle glAccum$handle() {
        return glAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MemorySegment glAccum$address() {
        return glAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static void glAccum(int op, float value) {
        var mh$ = glAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAccum", op, value);
            }
            mh$.invokeExact(op, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMatrixMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMatrixMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glMatrixMode$descriptor() {
        return glMatrixMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MethodHandle glMatrixMode$handle() {
        return glMatrixMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MemorySegment glMatrixMode$address() {
        return glMatrixMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static void glMatrixMode(int mode) {
        var mh$ = glMatrixMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMatrixMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static FunctionDescriptor glOrtho$descriptor() {
        return glOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MethodHandle glOrtho$handle() {
        return glOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MemorySegment glOrtho$address() {
        return glOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static void glOrtho(double left, double right, double bottom, double top, double near_val, double far_val) {
        var mh$ = glOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glOrtho", left, right, bottom, top, near_val, far_val);
            }
            mh$.invokeExact(left, right, bottom, top, near_val, far_val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static FunctionDescriptor glFrustum$descriptor() {
        return glFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MethodHandle glFrustum$handle() {
        return glFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MemorySegment glFrustum$address() {
        return glFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static void glFrustum(double left, double right, double bottom, double top, double near_val, double far_val) {
        var mh$ = glFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrustum", left, right, bottom, top, near_val, far_val);
            }
            mh$.invokeExact(left, right, bottom, top, near_val, far_val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glViewport$descriptor() {
        return glViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glViewport$handle() {
        return glViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glViewport$address() {
        return glViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glViewport(int x, int y, int width, int height) {
        var mh$ = glViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glViewport", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPushMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static FunctionDescriptor glPushMatrix$descriptor() {
        return glPushMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MethodHandle glPushMatrix$handle() {
        return glPushMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MemorySegment glPushMatrix$address() {
        return glPushMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static void glPushMatrix() {
        var mh$ = glPushMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPopMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static FunctionDescriptor glPopMatrix$descriptor() {
        return glPopMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MethodHandle glPopMatrix$handle() {
        return glPopMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MemorySegment glPopMatrix$address() {
        return glPopMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static void glPopMatrix() {
        var mh$ = glPopMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLoadIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static FunctionDescriptor glLoadIdentity$descriptor() {
        return glLoadIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MethodHandle glLoadIdentity$handle() {
        return glLoadIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MemorySegment glLoadIdentity$address() {
        return glLoadIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static void glLoadIdentity() {
        var mh$ = glLoadIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadIdentity");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLoadMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixd$descriptor() {
        return glLoadMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glLoadMatrixd$handle() {
        return glLoadMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glLoadMatrixd$address() {
        return glLoadMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static void glLoadMatrixd(MemorySegment m) {
        var mh$ = glLoadMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLoadMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixf$descriptor() {
        return glLoadMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glLoadMatrixf$handle() {
        return glLoadMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glLoadMatrixf$address() {
        return glLoadMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static void glLoadMatrixf(MemorySegment m) {
        var mh$ = glLoadMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixd$descriptor() {
        return glMultMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glMultMatrixd$handle() {
        return glMultMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glMultMatrixd$address() {
        return glMultMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static void glMultMatrixd(MemorySegment m) {
        var mh$ = glMultMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixf$descriptor() {
        return glMultMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glMultMatrixf$handle() {
        return glMultMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glMultMatrixf$address() {
        return glMultMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static void glMultMatrixf(MemorySegment m) {
        var mh$ = glMultMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRotated$descriptor() {
        return glRotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRotated$handle() {
        return glRotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRotated$address() {
        return glRotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRotated(double angle, double x, double y, double z) {
        var mh$ = glRotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotated", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRotatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRotatef$descriptor() {
        return glRotatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRotatef$handle() {
        return glRotatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRotatef$address() {
        return glRotatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRotatef(float angle, float x, float y, float z) {
        var mh$ = glRotatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotatef", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glScaled$descriptor() {
        return glScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glScaled$handle() {
        return glScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glScaled$address() {
        return glScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glScaled(double x, double y, double z) {
        var mh$ = glScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScaled", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScalef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glScalef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glScalef$descriptor() {
        return glScalef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glScalef$handle() {
        return glScalef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glScalef$address() {
        return glScalef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glScalef(float x, float y, float z) {
        var mh$ = glScalef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScalef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTranslated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glTranslated$descriptor() {
        return glTranslated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glTranslated$handle() {
        return glTranslated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glTranslated$address() {
        return glTranslated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glTranslated(double x, double y, double z) {
        var mh$ = glTranslated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslated", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTranslatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glTranslatef$descriptor() {
        return glTranslatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glTranslatef$handle() {
        return glTranslatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glTranslatef$address() {
        return glTranslatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glTranslatef(float x, float y, float z) {
        var mh$ = glTranslatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslatef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_CHAR,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIsList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static FunctionDescriptor glIsList$descriptor() {
        return glIsList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MethodHandle glIsList$handle() {
        return glIsList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MemorySegment glIsList$address() {
        return glIsList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static byte glIsList(int list) {
        var mh$ = glIsList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsList", list);
            }
            return (byte)mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDeleteLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static FunctionDescriptor glDeleteLists$descriptor() {
        return glDeleteLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MethodHandle glDeleteLists$handle() {
        return glDeleteLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MemorySegment glDeleteLists$address() {
        return glDeleteLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static void glDeleteLists(int list, int range) {
        var mh$ = glDeleteLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteLists", list, range);
            }
            mh$.invokeExact(list, range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGenLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static FunctionDescriptor glGenLists$descriptor() {
        return glGenLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MethodHandle glGenLists$handle() {
        return glGenLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MemorySegment glGenLists$address() {
        return glGenLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static int glGenLists(int range) {
        var mh$ = glGenLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenLists", range);
            }
            return (int)mh$.invokeExact(range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNewList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNewList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static FunctionDescriptor glNewList$descriptor() {
        return glNewList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MethodHandle glNewList$handle() {
        return glNewList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MemorySegment glNewList$address() {
        return glNewList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static void glNewList(int list, int mode) {
        var mh$ = glNewList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNewList", list, mode);
            }
            mh$.invokeExact(list, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEndList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static FunctionDescriptor glEndList$descriptor() {
        return glEndList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MethodHandle glEndList$handle() {
        return glEndList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MemorySegment glEndList$address() {
        return glEndList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static void glEndList() {
        var mh$ = glEndList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndList");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCallList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static FunctionDescriptor glCallList$descriptor() {
        return glCallList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MethodHandle glCallList$handle() {
        return glCallList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MemorySegment glCallList$address() {
        return glCallList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static void glCallList(int list) {
        var mh$ = glCallList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallList", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCallLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static FunctionDescriptor glCallLists$descriptor() {
        return glCallLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MethodHandle glCallLists$handle() {
        return glCallLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MemorySegment glCallLists$address() {
        return glCallLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static void glCallLists(int n, int type, MemorySegment lists) {
        var mh$ = glCallLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallLists", n, type, lists);
            }
            mh$.invokeExact(n, type, lists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glListBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glListBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static FunctionDescriptor glListBase$descriptor() {
        return glListBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MethodHandle glListBase$handle() {
        return glListBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MemorySegment glListBase$address() {
        return glListBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static void glListBase(int base) {
        var mh$ = glListBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glListBase", base);
            }
            mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBegin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glBegin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBegin$descriptor() {
        return glBegin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MethodHandle glBegin$handle() {
        return glBegin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MemorySegment glBegin$address() {
        return glBegin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static void glBegin(int mode) {
        var mh$ = glBegin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBegin", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static FunctionDescriptor glEnd$descriptor() {
        return glEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MethodHandle glEnd$handle() {
        return glEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MemorySegment glEnd$address() {
        return glEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static void glEnd() {
        var mh$ = glEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnd");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glVertex2d$descriptor() {
        return glVertex2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glVertex2d$handle() {
        return glVertex2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glVertex2d$address() {
        return glVertex2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glVertex2d(double x, double y) {
        var mh$ = glVertex2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glVertex2f$descriptor() {
        return glVertex2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glVertex2f$handle() {
        return glVertex2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glVertex2f$address() {
        return glVertex2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glVertex2f(float x, float y) {
        var mh$ = glVertex2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glVertex2i$descriptor() {
        return glVertex2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glVertex2i$handle() {
        return glVertex2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glVertex2i$address() {
        return glVertex2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static void glVertex2i(int x, int y) {
        var mh$ = glVertex2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glVertex2s$descriptor() {
        return glVertex2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glVertex2s$handle() {
        return glVertex2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glVertex2s$address() {
        return glVertex2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static void glVertex2s(short x, short y) {
        var mh$ = glVertex2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glVertex3d$descriptor() {
        return glVertex3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glVertex3d$handle() {
        return glVertex3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glVertex3d$address() {
        return glVertex3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glVertex3d(double x, double y, double z) {
        var mh$ = glVertex3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glVertex3f$descriptor() {
        return glVertex3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glVertex3f$handle() {
        return glVertex3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glVertex3f$address() {
        return glVertex3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glVertex3f(float x, float y, float z) {
        var mh$ = glVertex3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glVertex3i$descriptor() {
        return glVertex3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glVertex3i$handle() {
        return glVertex3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glVertex3i$address() {
        return glVertex3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glVertex3i(int x, int y, int z) {
        var mh$ = glVertex3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glVertex3s$descriptor() {
        return glVertex3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glVertex3s$handle() {
        return glVertex3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glVertex3s$address() {
        return glVertex3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glVertex3s(short x, short y, short z) {
        var mh$ = glVertex3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glVertex4d$descriptor() {
        return glVertex4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glVertex4d$handle() {
        return glVertex4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glVertex4d$address() {
        return glVertex4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glVertex4d(double x, double y, double z, double w) {
        var mh$ = glVertex4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glVertex4f$descriptor() {
        return glVertex4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glVertex4f$handle() {
        return glVertex4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glVertex4f$address() {
        return glVertex4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glVertex4f(float x, float y, float z, float w) {
        var mh$ = glVertex4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glVertex4i$descriptor() {
        return glVertex4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glVertex4i$handle() {
        return glVertex4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glVertex4i$address() {
        return glVertex4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glVertex4i(int x, int y, int z, int w) {
        var mh$ = glVertex4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glVertex4s$descriptor() {
        return glVertex4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glVertex4s$handle() {
        return glVertex4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glVertex4s$address() {
        return glVertex4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glVertex4s(short x, short y, short z, short w) {
        var mh$ = glVertex4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex2dv$descriptor() {
        return glVertex2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex2dv$handle() {
        return glVertex2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex2dv$address() {
        return glVertex2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static void glVertex2dv(MemorySegment v) {
        var mh$ = glVertex2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex2fv$descriptor() {
        return glVertex2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex2fv$handle() {
        return glVertex2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex2fv$address() {
        return glVertex2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static void glVertex2fv(MemorySegment v) {
        var mh$ = glVertex2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex2iv$descriptor() {
        return glVertex2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex2iv$handle() {
        return glVertex2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex2iv$address() {
        return glVertex2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static void glVertex2iv(MemorySegment v) {
        var mh$ = glVertex2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex2sv$descriptor() {
        return glVertex2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex2sv$handle() {
        return glVertex2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex2sv$address() {
        return glVertex2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static void glVertex2sv(MemorySegment v) {
        var mh$ = glVertex2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex3dv$descriptor() {
        return glVertex3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex3dv$handle() {
        return glVertex3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex3dv$address() {
        return glVertex3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static void glVertex3dv(MemorySegment v) {
        var mh$ = glVertex3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex3fv$descriptor() {
        return glVertex3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex3fv$handle() {
        return glVertex3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex3fv$address() {
        return glVertex3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static void glVertex3fv(MemorySegment v) {
        var mh$ = glVertex3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex3iv$descriptor() {
        return glVertex3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex3iv$handle() {
        return glVertex3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex3iv$address() {
        return glVertex3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static void glVertex3iv(MemorySegment v) {
        var mh$ = glVertex3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex3sv$descriptor() {
        return glVertex3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex3sv$handle() {
        return glVertex3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex3sv$address() {
        return glVertex3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static void glVertex3sv(MemorySegment v) {
        var mh$ = glVertex3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex4dv$descriptor() {
        return glVertex4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex4dv$handle() {
        return glVertex4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex4dv$address() {
        return glVertex4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static void glVertex4dv(MemorySegment v) {
        var mh$ = glVertex4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex4fv$descriptor() {
        return glVertex4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex4fv$handle() {
        return glVertex4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex4fv$address() {
        return glVertex4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static void glVertex4fv(MemorySegment v) {
        var mh$ = glVertex4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex4iv$descriptor() {
        return glVertex4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex4iv$handle() {
        return glVertex4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex4iv$address() {
        return glVertex4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static void glVertex4iv(MemorySegment v) {
        var mh$ = glVertex4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertex4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex4sv$descriptor() {
        return glVertex4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex4sv$handle() {
        return glVertex4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex4sv$address() {
        return glVertex4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static void glVertex4sv(MemorySegment v) {
        var mh$ = glVertex4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static FunctionDescriptor glNormal3b$descriptor() {
        return glNormal3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MethodHandle glNormal3b$handle() {
        return glNormal3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MemorySegment glNormal3b$address() {
        return glNormal3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static void glNormal3b(byte nx, byte ny, byte nz) {
        var mh$ = glNormal3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3b", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static FunctionDescriptor glNormal3d$descriptor() {
        return glNormal3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MethodHandle glNormal3d$handle() {
        return glNormal3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MemorySegment glNormal3d$address() {
        return glNormal3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static void glNormal3d(double nx, double ny, double nz) {
        var mh$ = glNormal3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3d", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static FunctionDescriptor glNormal3f$descriptor() {
        return glNormal3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MethodHandle glNormal3f$handle() {
        return glNormal3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MemorySegment glNormal3f$address() {
        return glNormal3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static void glNormal3f(float nx, float ny, float nz) {
        var mh$ = glNormal3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3f", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static FunctionDescriptor glNormal3i$descriptor() {
        return glNormal3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MethodHandle glNormal3i$handle() {
        return glNormal3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MemorySegment glNormal3i$address() {
        return glNormal3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static void glNormal3i(int nx, int ny, int nz) {
        var mh$ = glNormal3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3i", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static FunctionDescriptor glNormal3s$descriptor() {
        return glNormal3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MethodHandle glNormal3s$handle() {
        return glNormal3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MemorySegment glNormal3s$address() {
        return glNormal3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static void glNormal3s(short nx, short ny, short nz) {
        var mh$ = glNormal3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3s", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glNormal3bv$descriptor() {
        return glNormal3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glNormal3bv$handle() {
        return glNormal3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glNormal3bv$address() {
        return glNormal3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static void glNormal3bv(MemorySegment v) {
        var mh$ = glNormal3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glNormal3dv$descriptor() {
        return glNormal3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glNormal3dv$handle() {
        return glNormal3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glNormal3dv$address() {
        return glNormal3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static void glNormal3dv(MemorySegment v) {
        var mh$ = glNormal3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glNormal3fv$descriptor() {
        return glNormal3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glNormal3fv$handle() {
        return glNormal3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glNormal3fv$address() {
        return glNormal3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static void glNormal3fv(MemorySegment v) {
        var mh$ = glNormal3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glNormal3iv$descriptor() {
        return glNormal3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MethodHandle glNormal3iv$handle() {
        return glNormal3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MemorySegment glNormal3iv$address() {
        return glNormal3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static void glNormal3iv(MemorySegment v) {
        var mh$ = glNormal3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormal3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glNormal3sv$descriptor() {
        return glNormal3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glNormal3sv$handle() {
        return glNormal3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glNormal3sv$address() {
        return glNormal3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static void glNormal3sv(MemorySegment v) {
        var mh$ = glNormal3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static FunctionDescriptor glIndexd$descriptor() {
        return glIndexd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MethodHandle glIndexd$handle() {
        return glIndexd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MemorySegment glIndexd$address() {
        return glIndexd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static void glIndexd(double c) {
        var mh$ = glIndexd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexd", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static FunctionDescriptor glIndexf$descriptor() {
        return glIndexf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MethodHandle glIndexf$handle() {
        return glIndexf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MemorySegment glIndexf$address() {
        return glIndexf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static void glIndexf(float c) {
        var mh$ = glIndexf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexf", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static FunctionDescriptor glIndexi$descriptor() {
        return glIndexi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MethodHandle glIndexi$handle() {
        return glIndexi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MemorySegment glIndexi$address() {
        return glIndexi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static void glIndexi(int c) {
        var mh$ = glIndexi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexi", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static FunctionDescriptor glIndexs$descriptor() {
        return glIndexs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MethodHandle glIndexs$handle() {
        return glIndexs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MemorySegment glIndexs$address() {
        return glIndexs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static void glIndexs(short c) {
        var mh$ = glIndexs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexs", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static FunctionDescriptor glIndexub$descriptor() {
        return glIndexub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MethodHandle glIndexub$handle() {
        return glIndexub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MemorySegment glIndexub$address() {
        return glIndexub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static void glIndexub(byte c) {
        var mh$ = glIndexub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexub", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static FunctionDescriptor glIndexdv$descriptor() {
        return glIndexdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MethodHandle glIndexdv$handle() {
        return glIndexdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MemorySegment glIndexdv$address() {
        return glIndexdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static void glIndexdv(MemorySegment c) {
        var mh$ = glIndexdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexdv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static FunctionDescriptor glIndexfv$descriptor() {
        return glIndexfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MethodHandle glIndexfv$handle() {
        return glIndexfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MemorySegment glIndexfv$address() {
        return glIndexfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static void glIndexfv(MemorySegment c) {
        var mh$ = glIndexfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexfv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static FunctionDescriptor glIndexiv$descriptor() {
        return glIndexiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MethodHandle glIndexiv$handle() {
        return glIndexiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MemorySegment glIndexiv$address() {
        return glIndexiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static void glIndexiv(MemorySegment c) {
        var mh$ = glIndexiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexiv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static FunctionDescriptor glIndexsv$descriptor() {
        return glIndexsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MethodHandle glIndexsv$handle() {
        return glIndexsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MemorySegment glIndexsv$address() {
        return glIndexsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static void glIndexsv(MemorySegment c) {
        var mh$ = glIndexsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexsv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static FunctionDescriptor glIndexubv$descriptor() {
        return glIndexubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MethodHandle glIndexubv$handle() {
        return glIndexubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MemorySegment glIndexubv$address() {
        return glIndexubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static void glIndexubv(MemorySegment c) {
        var mh$ = glIndexubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexubv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glColor3b$descriptor() {
        return glColor3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glColor3b$handle() {
        return glColor3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glColor3b$address() {
        return glColor3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glColor3b(byte red, byte green, byte blue) {
        var mh$ = glColor3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3b", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glColor3d$descriptor() {
        return glColor3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glColor3d$handle() {
        return glColor3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glColor3d$address() {
        return glColor3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glColor3d(double red, double green, double blue) {
        var mh$ = glColor3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3d", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glColor3f$descriptor() {
        return glColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glColor3f$handle() {
        return glColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glColor3f$address() {
        return glColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glColor3f(float red, float green, float blue) {
        var mh$ = glColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3f", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glColor3i$descriptor() {
        return glColor3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glColor3i$handle() {
        return glColor3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glColor3i$address() {
        return glColor3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glColor3i(int red, int green, int blue) {
        var mh$ = glColor3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3i", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glColor3s$descriptor() {
        return glColor3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glColor3s$handle() {
        return glColor3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glColor3s$address() {
        return glColor3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glColor3s(short red, short green, short blue) {
        var mh$ = glColor3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3s", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glColor3ub$descriptor() {
        return glColor3ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glColor3ub$handle() {
        return glColor3ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glColor3ub$address() {
        return glColor3ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glColor3ub(byte red, byte green, byte blue) {
        var mh$ = glColor3ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ub", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glColor3ui$descriptor() {
        return glColor3ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glColor3ui$handle() {
        return glColor3ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glColor3ui$address() {
        return glColor3ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glColor3ui(int red, int green, int blue) {
        var mh$ = glColor3ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ui", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glColor3us$descriptor() {
        return glColor3us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glColor3us$handle() {
        return glColor3us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glColor3us$address() {
        return glColor3us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glColor3us(short red, short green, short blue) {
        var mh$ = glColor3us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3us", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4b$descriptor() {
        return glColor4b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MethodHandle glColor4b$handle() {
        return glColor4b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MemorySegment glColor4b$address() {
        return glColor4b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static void glColor4b(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4b", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static FunctionDescriptor glColor4d$descriptor() {
        return glColor4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MethodHandle glColor4d$handle() {
        return glColor4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MemorySegment glColor4d$address() {
        return glColor4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static void glColor4d(double red, double green, double blue, double alpha) {
        var mh$ = glColor4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4d", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glColor4f$descriptor() {
        return glColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glColor4f$handle() {
        return glColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glColor4f$address() {
        return glColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glColor4f(float red, float green, float blue, float alpha) {
        var mh$ = glColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4f", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static FunctionDescriptor glColor4i$descriptor() {
        return glColor4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MethodHandle glColor4i$handle() {
        return glColor4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MemorySegment glColor4i$address() {
        return glColor4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static void glColor4i(int red, int green, int blue, int alpha) {
        var mh$ = glColor4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4i", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static FunctionDescriptor glColor4s$descriptor() {
        return glColor4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MethodHandle glColor4s$handle() {
        return glColor4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MemorySegment glColor4s$address() {
        return glColor4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static void glColor4s(short red, short green, short blue, short alpha) {
        var mh$ = glColor4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4s", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4ub$descriptor() {
        return glColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MethodHandle glColor4ub$handle() {
        return glColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MemorySegment glColor4ub$address() {
        return glColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ub", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static FunctionDescriptor glColor4ui$descriptor() {
        return glColor4ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MethodHandle glColor4ui$handle() {
        return glColor4ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MemorySegment glColor4ui$address() {
        return glColor4ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static void glColor4ui(int red, int green, int blue, int alpha) {
        var mh$ = glColor4ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ui", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static FunctionDescriptor glColor4us$descriptor() {
        return glColor4us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MethodHandle glColor4us$handle() {
        return glColor4us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MemorySegment glColor4us$address() {
        return glColor4us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static void glColor4us(short red, short green, short blue, short alpha) {
        var mh$ = glColor4us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4us", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor3bv$descriptor() {
        return glColor3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor3bv$handle() {
        return glColor3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor3bv$address() {
        return glColor3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static void glColor3bv(MemorySegment v) {
        var mh$ = glColor3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor3dv$descriptor() {
        return glColor3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor3dv$handle() {
        return glColor3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor3dv$address() {
        return glColor3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static void glColor3dv(MemorySegment v) {
        var mh$ = glColor3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor3fv$descriptor() {
        return glColor3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor3fv$handle() {
        return glColor3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor3fv$address() {
        return glColor3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static void glColor3fv(MemorySegment v) {
        var mh$ = glColor3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor3iv$descriptor() {
        return glColor3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor3iv$handle() {
        return glColor3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor3iv$address() {
        return glColor3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static void glColor3iv(MemorySegment v) {
        var mh$ = glColor3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor3sv$descriptor() {
        return glColor3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor3sv$handle() {
        return glColor3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor3sv$address() {
        return glColor3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static void glColor3sv(MemorySegment v) {
        var mh$ = glColor3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor3ubv$descriptor() {
        return glColor3ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor3ubv$handle() {
        return glColor3ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor3ubv$address() {
        return glColor3ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static void glColor3ubv(MemorySegment v) {
        var mh$ = glColor3ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor3uiv$descriptor() {
        return glColor3uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor3uiv$handle() {
        return glColor3uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor3uiv$address() {
        return glColor3uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static void glColor3uiv(MemorySegment v) {
        var mh$ = glColor3uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor3usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor3usv$descriptor() {
        return glColor3usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor3usv$handle() {
        return glColor3usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor3usv$address() {
        return glColor3usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static void glColor3usv(MemorySegment v) {
        var mh$ = glColor3usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor4bv$descriptor() {
        return glColor4bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor4bv$handle() {
        return glColor4bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor4bv$address() {
        return glColor4bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static void glColor4bv(MemorySegment v) {
        var mh$ = glColor4bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor4dv$descriptor() {
        return glColor4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor4dv$handle() {
        return glColor4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor4dv$address() {
        return glColor4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static void glColor4dv(MemorySegment v) {
        var mh$ = glColor4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor4fv$descriptor() {
        return glColor4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor4fv$handle() {
        return glColor4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor4fv$address() {
        return glColor4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static void glColor4fv(MemorySegment v) {
        var mh$ = glColor4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor4iv$descriptor() {
        return glColor4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor4iv$handle() {
        return glColor4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor4iv$address() {
        return glColor4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static void glColor4iv(MemorySegment v) {
        var mh$ = glColor4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor4sv$descriptor() {
        return glColor4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor4sv$handle() {
        return glColor4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor4sv$address() {
        return glColor4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static void glColor4sv(MemorySegment v) {
        var mh$ = glColor4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor4ubv$descriptor() {
        return glColor4ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor4ubv$handle() {
        return glColor4ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor4ubv$address() {
        return glColor4ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static void glColor4ubv(MemorySegment v) {
        var mh$ = glColor4ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor4uiv$descriptor() {
        return glColor4uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor4uiv$handle() {
        return glColor4uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor4uiv$address() {
        return glColor4uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static void glColor4uiv(MemorySegment v) {
        var mh$ = glColor4uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColor4usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor4usv$descriptor() {
        return glColor4usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor4usv$handle() {
        return glColor4usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor4usv$address() {
        return glColor4usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static void glColor4usv(MemorySegment v) {
        var mh$ = glColor4usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static FunctionDescriptor glTexCoord1d$descriptor() {
        return glTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MethodHandle glTexCoord1d$handle() {
        return glTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MemorySegment glTexCoord1d$address() {
        return glTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static void glTexCoord1d(double s) {
        var mh$ = glTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1d", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static FunctionDescriptor glTexCoord1f$descriptor() {
        return glTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MethodHandle glTexCoord1f$handle() {
        return glTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MemorySegment glTexCoord1f$address() {
        return glTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static void glTexCoord1f(float s) {
        var mh$ = glTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1f", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static FunctionDescriptor glTexCoord1i$descriptor() {
        return glTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MethodHandle glTexCoord1i$handle() {
        return glTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MemorySegment glTexCoord1i$address() {
        return glTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static void glTexCoord1i(int s) {
        var mh$ = glTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1i", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static FunctionDescriptor glTexCoord1s$descriptor() {
        return glTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MethodHandle glTexCoord1s$handle() {
        return glTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MemorySegment glTexCoord1s$address() {
        return glTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static void glTexCoord1s(short s) {
        var mh$ = glTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1s", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glTexCoord2d$descriptor() {
        return glTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glTexCoord2d$handle() {
        return glTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glTexCoord2d$address() {
        return glTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static void glTexCoord2d(double s, double t) {
        var mh$ = glTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2d", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glTexCoord2f$descriptor() {
        return glTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glTexCoord2f$handle() {
        return glTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glTexCoord2f$address() {
        return glTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static void glTexCoord2f(float s, float t) {
        var mh$ = glTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2f", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glTexCoord2i$descriptor() {
        return glTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MethodHandle glTexCoord2i$handle() {
        return glTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MemorySegment glTexCoord2i$address() {
        return glTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static void glTexCoord2i(int s, int t) {
        var mh$ = glTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2i", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glTexCoord2s$descriptor() {
        return glTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glTexCoord2s$handle() {
        return glTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glTexCoord2s$address() {
        return glTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static void glTexCoord2s(short s, short t) {
        var mh$ = glTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2s", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glTexCoord3d$descriptor() {
        return glTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glTexCoord3d$handle() {
        return glTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glTexCoord3d$address() {
        return glTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glTexCoord3d(double s, double t, double r) {
        var mh$ = glTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3d", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glTexCoord3f$descriptor() {
        return glTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glTexCoord3f$handle() {
        return glTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glTexCoord3f$address() {
        return glTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glTexCoord3f(float s, float t, float r) {
        var mh$ = glTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3f", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glTexCoord3i$descriptor() {
        return glTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glTexCoord3i$handle() {
        return glTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glTexCoord3i$address() {
        return glTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static void glTexCoord3i(int s, int t, int r) {
        var mh$ = glTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3i", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glTexCoord3s$descriptor() {
        return glTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glTexCoord3s$handle() {
        return glTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glTexCoord3s$address() {
        return glTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glTexCoord3s(short s, short t, short r) {
        var mh$ = glTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3s", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glTexCoord4d$descriptor() {
        return glTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glTexCoord4d$handle() {
        return glTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glTexCoord4d$address() {
        return glTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glTexCoord4d(double s, double t, double r, double q) {
        var mh$ = glTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4d", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glTexCoord4f$descriptor() {
        return glTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glTexCoord4f$handle() {
        return glTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glTexCoord4f$address() {
        return glTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glTexCoord4f(float s, float t, float r, float q) {
        var mh$ = glTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4f", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glTexCoord4i$descriptor() {
        return glTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glTexCoord4i$handle() {
        return glTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glTexCoord4i$address() {
        return glTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glTexCoord4i(int s, int t, int r, int q) {
        var mh$ = glTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4i", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glTexCoord4s$descriptor() {
        return glTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glTexCoord4s$handle() {
        return glTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glTexCoord4s$address() {
        return glTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glTexCoord4s(short s, short t, short r, short q) {
        var mh$ = glTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4s", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1dv$descriptor() {
        return glTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord1dv$handle() {
        return glTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord1dv$address() {
        return glTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord1dv(MemorySegment v) {
        var mh$ = glTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1fv$descriptor() {
        return glTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord1fv$handle() {
        return glTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord1fv$address() {
        return glTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord1fv(MemorySegment v) {
        var mh$ = glTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1iv$descriptor() {
        return glTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord1iv$handle() {
        return glTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord1iv$address() {
        return glTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static void glTexCoord1iv(MemorySegment v) {
        var mh$ = glTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1sv$descriptor() {
        return glTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord1sv$handle() {
        return glTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord1sv$address() {
        return glTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static void glTexCoord1sv(MemorySegment v) {
        var mh$ = glTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2dv$descriptor() {
        return glTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord2dv$handle() {
        return glTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord2dv$address() {
        return glTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord2dv(MemorySegment v) {
        var mh$ = glTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2fv$descriptor() {
        return glTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord2fv$handle() {
        return glTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord2fv$address() {
        return glTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord2fv(MemorySegment v) {
        var mh$ = glTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2iv$descriptor() {
        return glTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord2iv$handle() {
        return glTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord2iv$address() {
        return glTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static void glTexCoord2iv(MemorySegment v) {
        var mh$ = glTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2sv$descriptor() {
        return glTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord2sv$handle() {
        return glTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord2sv$address() {
        return glTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static void glTexCoord2sv(MemorySegment v) {
        var mh$ = glTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3dv$descriptor() {
        return glTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord3dv$handle() {
        return glTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord3dv$address() {
        return glTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord3dv(MemorySegment v) {
        var mh$ = glTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3fv$descriptor() {
        return glTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord3fv$handle() {
        return glTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord3fv$address() {
        return glTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord3fv(MemorySegment v) {
        var mh$ = glTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3iv$descriptor() {
        return glTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord3iv$handle() {
        return glTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord3iv$address() {
        return glTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static void glTexCoord3iv(MemorySegment v) {
        var mh$ = glTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3sv$descriptor() {
        return glTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord3sv$handle() {
        return glTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord3sv$address() {
        return glTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static void glTexCoord3sv(MemorySegment v) {
        var mh$ = glTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4dv$descriptor() {
        return glTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord4dv$handle() {
        return glTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord4dv$address() {
        return glTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord4dv(MemorySegment v) {
        var mh$ = glTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4fv$descriptor() {
        return glTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord4fv$handle() {
        return glTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord4fv$address() {
        return glTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord4fv(MemorySegment v) {
        var mh$ = glTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4iv$descriptor() {
        return glTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord4iv$handle() {
        return glTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord4iv$address() {
        return glTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static void glTexCoord4iv(MemorySegment v) {
        var mh$ = glTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4sv$descriptor() {
        return glTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord4sv$handle() {
        return glTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord4sv$address() {
        return glTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static void glTexCoord4sv(MemorySegment v) {
        var mh$ = glTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glRasterPos2d$descriptor() {
        return glRasterPos2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glRasterPos2d$handle() {
        return glRasterPos2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glRasterPos2d$address() {
        return glRasterPos2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glRasterPos2d(double x, double y) {
        var mh$ = glRasterPos2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glRasterPos2f$descriptor() {
        return glRasterPos2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glRasterPos2f$handle() {
        return glRasterPos2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glRasterPos2f$address() {
        return glRasterPos2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glRasterPos2f(float x, float y) {
        var mh$ = glRasterPos2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glRasterPos2i$descriptor() {
        return glRasterPos2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glRasterPos2i$handle() {
        return glRasterPos2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glRasterPos2i$address() {
        return glRasterPos2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static void glRasterPos2i(int x, int y) {
        var mh$ = glRasterPos2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glRasterPos2s$descriptor() {
        return glRasterPos2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glRasterPos2s$handle() {
        return glRasterPos2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glRasterPos2s$address() {
        return glRasterPos2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static void glRasterPos2s(short x, short y) {
        var mh$ = glRasterPos2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRasterPos3d$descriptor() {
        return glRasterPos3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRasterPos3d$handle() {
        return glRasterPos3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRasterPos3d$address() {
        return glRasterPos3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRasterPos3d(double x, double y, double z) {
        var mh$ = glRasterPos3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRasterPos3f$descriptor() {
        return glRasterPos3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRasterPos3f$handle() {
        return glRasterPos3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRasterPos3f$address() {
        return glRasterPos3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRasterPos3f(float x, float y, float z) {
        var mh$ = glRasterPos3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glRasterPos3i$descriptor() {
        return glRasterPos3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glRasterPos3i$handle() {
        return glRasterPos3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glRasterPos3i$address() {
        return glRasterPos3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glRasterPos3i(int x, int y, int z) {
        var mh$ = glRasterPos3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glRasterPos3s$descriptor() {
        return glRasterPos3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glRasterPos3s$handle() {
        return glRasterPos3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glRasterPos3s$address() {
        return glRasterPos3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glRasterPos3s(short x, short y, short z) {
        var mh$ = glRasterPos3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glRasterPos4d$descriptor() {
        return glRasterPos4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glRasterPos4d$handle() {
        return glRasterPos4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glRasterPos4d$address() {
        return glRasterPos4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glRasterPos4d(double x, double y, double z, double w) {
        var mh$ = glRasterPos4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glRasterPos4f$descriptor() {
        return glRasterPos4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glRasterPos4f$handle() {
        return glRasterPos4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glRasterPos4f$address() {
        return glRasterPos4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glRasterPos4f(float x, float y, float z, float w) {
        var mh$ = glRasterPos4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glRasterPos4i$descriptor() {
        return glRasterPos4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glRasterPos4i$handle() {
        return glRasterPos4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glRasterPos4i$address() {
        return glRasterPos4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glRasterPos4i(int x, int y, int z, int w) {
        var mh$ = glRasterPos4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glRasterPos4s$descriptor() {
        return glRasterPos4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glRasterPos4s$handle() {
        return glRasterPos4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glRasterPos4s$address() {
        return glRasterPos4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glRasterPos4s(short x, short y, short z, short w) {
        var mh$ = glRasterPos4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2dv$descriptor() {
        return glRasterPos2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos2dv$handle() {
        return glRasterPos2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos2dv$address() {
        return glRasterPos2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos2dv(MemorySegment v) {
        var mh$ = glRasterPos2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2fv$descriptor() {
        return glRasterPos2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos2fv$handle() {
        return glRasterPos2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos2fv$address() {
        return glRasterPos2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos2fv(MemorySegment v) {
        var mh$ = glRasterPos2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2iv$descriptor() {
        return glRasterPos2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos2iv$handle() {
        return glRasterPos2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos2iv$address() {
        return glRasterPos2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static void glRasterPos2iv(MemorySegment v) {
        var mh$ = glRasterPos2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2sv$descriptor() {
        return glRasterPos2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos2sv$handle() {
        return glRasterPos2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos2sv$address() {
        return glRasterPos2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static void glRasterPos2sv(MemorySegment v) {
        var mh$ = glRasterPos2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3dv$descriptor() {
        return glRasterPos3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos3dv$handle() {
        return glRasterPos3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos3dv$address() {
        return glRasterPos3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos3dv(MemorySegment v) {
        var mh$ = glRasterPos3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3fv$descriptor() {
        return glRasterPos3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos3fv$handle() {
        return glRasterPos3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos3fv$address() {
        return glRasterPos3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos3fv(MemorySegment v) {
        var mh$ = glRasterPos3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3iv$descriptor() {
        return glRasterPos3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos3iv$handle() {
        return glRasterPos3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos3iv$address() {
        return glRasterPos3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static void glRasterPos3iv(MemorySegment v) {
        var mh$ = glRasterPos3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3sv$descriptor() {
        return glRasterPos3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos3sv$handle() {
        return glRasterPos3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos3sv$address() {
        return glRasterPos3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static void glRasterPos3sv(MemorySegment v) {
        var mh$ = glRasterPos3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4dv$descriptor() {
        return glRasterPos4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos4dv$handle() {
        return glRasterPos4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos4dv$address() {
        return glRasterPos4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos4dv(MemorySegment v) {
        var mh$ = glRasterPos4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4fv$descriptor() {
        return glRasterPos4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos4fv$handle() {
        return glRasterPos4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos4fv$address() {
        return glRasterPos4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos4fv(MemorySegment v) {
        var mh$ = glRasterPos4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4iv$descriptor() {
        return glRasterPos4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos4iv$handle() {
        return glRasterPos4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos4iv$address() {
        return glRasterPos4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static void glRasterPos4iv(MemorySegment v) {
        var mh$ = glRasterPos4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRasterPos4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4sv$descriptor() {
        return glRasterPos4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos4sv$handle() {
        return glRasterPos4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos4sv$address() {
        return glRasterPos4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static void glRasterPos4sv(MemorySegment v) {
        var mh$ = glRasterPos4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRectd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static FunctionDescriptor glRectd$descriptor() {
        return glRectd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MethodHandle glRectd$handle() {
        return glRectd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MemorySegment glRectd$address() {
        return glRectd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static void glRectd(double x1, double y1, double x2, double y2) {
        var mh$ = glRectd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectd", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRectf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static FunctionDescriptor glRectf$descriptor() {
        return glRectf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MethodHandle glRectf$handle() {
        return glRectf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MemorySegment glRectf$address() {
        return glRectf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static void glRectf(float x1, float y1, float x2, float y2) {
        var mh$ = glRectf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectf", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRecti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRecti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static FunctionDescriptor glRecti$descriptor() {
        return glRecti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MethodHandle glRecti$handle() {
        return glRecti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MemorySegment glRecti$address() {
        return glRecti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static void glRecti(int x1, int y1, int x2, int y2) {
        var mh$ = glRecti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRecti", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static FunctionDescriptor glRects$descriptor() {
        return glRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MethodHandle glRects$handle() {
        return glRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MemorySegment glRects$address() {
        return glRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static void glRects(short x1, short y1, short x2, short y2) {
        var mh$ = glRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRects", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRectdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static FunctionDescriptor glRectdv$descriptor() {
        return glRectdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MethodHandle glRectdv$handle() {
        return glRectdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MemorySegment glRectdv$address() {
        return glRectdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static void glRectdv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectdv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRectfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static FunctionDescriptor glRectfv$descriptor() {
        return glRectfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MethodHandle glRectfv$handle() {
        return glRectfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MemorySegment glRectfv$address() {
        return glRectfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static void glRectfv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectfv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRectiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static FunctionDescriptor glRectiv$descriptor() {
        return glRectiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MethodHandle glRectiv$handle() {
        return glRectiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MemorySegment glRectiv$address() {
        return glRectiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static void glRectiv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectiv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glRectsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static FunctionDescriptor glRectsv$descriptor() {
        return glRectsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MethodHandle glRectsv$handle() {
        return glRectsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MemorySegment glRectsv$address() {
        return glRectsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static void glRectsv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectsv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glVertexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glVertexPointer$descriptor() {
        return glVertexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glVertexPointer$handle() {
        return glVertexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glVertexPointer$address() {
        return glVertexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glVertexPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glVertexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormalPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glNormalPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glNormalPointer$descriptor() {
        return glNormalPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glNormalPointer$handle() {
        return glNormalPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glNormalPointer$address() {
        return glNormalPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glNormalPointer(int type, int stride, MemorySegment ptr) {
        var mh$ = glNormalPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormalPointer", type, stride, ptr);
            }
            mh$.invokeExact(type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColorPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glColorPointer$descriptor() {
        return glColorPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glColorPointer$handle() {
        return glColorPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glColorPointer$address() {
        return glColorPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glColorPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glColorPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIndexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glIndexPointer$descriptor() {
        return glIndexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glIndexPointer$handle() {
        return glIndexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glIndexPointer$address() {
        return glIndexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glIndexPointer(int type, int stride, MemorySegment ptr) {
        var mh$ = glIndexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexPointer", type, stride, ptr);
            }
            mh$.invokeExact(type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoordPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexCoordPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glTexCoordPointer$descriptor() {
        return glTexCoordPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glTexCoordPointer$handle() {
        return glTexCoordPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glTexCoordPointer$address() {
        return glTexCoordPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glTexCoordPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glTexCoordPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoordPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEdgeFlagPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glEdgeFlagPointer$descriptor() {
        return glEdgeFlagPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glEdgeFlagPointer$handle() {
        return glEdgeFlagPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glEdgeFlagPointer$address() {
        return glEdgeFlagPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glEdgeFlagPointer(int stride, MemorySegment ptr) {
        var mh$ = glEdgeFlagPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagPointer", stride, ptr);
            }
            mh$.invokeExact(stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetPointerv$descriptor() {
        return glGetPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetPointerv$handle() {
        return glGetPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetPointerv$address() {
        return glGetPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetPointerv(int pname, MemorySegment params) {
        var mh$ = glGetPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPointerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glArrayElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glArrayElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static FunctionDescriptor glArrayElement$descriptor() {
        return glArrayElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MethodHandle glArrayElement$handle() {
        return glArrayElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MemorySegment glArrayElement$address() {
        return glArrayElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static void glArrayElement(int i) {
        var mh$ = glArrayElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glArrayElement", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDrawArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawArrays$descriptor() {
        return glDrawArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawArrays$handle() {
        return glDrawArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawArrays$address() {
        return glDrawArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static void glDrawArrays(int mode, int first, int count) {
        var mh$ = glDrawArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawArrays", mode, first, count);
            }
            mh$.invokeExact(mode, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDrawElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawElements$descriptor() {
        return glDrawElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawElements$handle() {
        return glDrawElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawElements$address() {
        return glDrawElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawElements(int mode, int count, int type, MemorySegment indices) {
        var mh$ = glDrawElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElements", mode, count, type, indices);
            }
            mh$.invokeExact(mode, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInterleavedArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glInterleavedArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glInterleavedArrays$descriptor() {
        return glInterleavedArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glInterleavedArrays$handle() {
        return glInterleavedArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glInterleavedArrays$address() {
        return glInterleavedArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glInterleavedArrays(int format, int stride, MemorySegment pointer) {
        var mh$ = glInterleavedArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInterleavedArrays", format, stride, pointer);
            }
            mh$.invokeExact(format, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShadeModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glShadeModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static FunctionDescriptor glShadeModel$descriptor() {
        return glShadeModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MethodHandle glShadeModel$handle() {
        return glShadeModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MemorySegment glShadeModel$address() {
        return glShadeModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static void glShadeModel(int mode) {
        var mh$ = glShadeModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShadeModel", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLightf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightf$descriptor() {
        return glLightf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightf$handle() {
        return glLightf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightf$address() {
        return glLightf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static void glLightf(int light, int pname, float param) {
        var mh$ = glLightf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightf", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLighti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLighti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLighti$descriptor() {
        return glLighti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLighti$handle() {
        return glLighti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLighti$address() {
        return glLighti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static void glLighti(int light, int pname, int param) {
        var mh$ = glLighti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLighti", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightfv$descriptor() {
        return glLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightfv$handle() {
        return glLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightfv$address() {
        return glLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightiv$descriptor() {
        return glLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightiv$handle() {
        return glLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightiv$address() {
        return glLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static void glLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetLightfv$descriptor() {
        return glGetLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetLightfv$handle() {
        return glGetLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetLightfv$address() {
        return glGetLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetLightiv$descriptor() {
        return glGetLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetLightiv$handle() {
        return glGetLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetLightiv$address() {
        return glGetLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static void glGetLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLightModelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightModelf$descriptor() {
        return glLightModelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightModelf$handle() {
        return glLightModelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightModelf$address() {
        return glLightModelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static void glLightModelf(int pname, float param) {
        var mh$ = glLightModelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeli {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLightModeli");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLightModeli$descriptor() {
        return glLightModeli.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLightModeli$handle() {
        return glLightModeli.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLightModeli$address() {
        return glLightModeli.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static void glLightModeli(int pname, int param) {
        var mh$ = glLightModeli.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeli", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLightModelfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightModelfv$descriptor() {
        return glLightModelfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightModelfv$handle() {
        return glLightModelfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightModelfv$address() {
        return glLightModelfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightModelfv(int pname, MemorySegment params) {
        var mh$ = glLightModelfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeliv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLightModeliv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightModeliv$descriptor() {
        return glLightModeliv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightModeliv$handle() {
        return glLightModeliv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightModeliv$address() {
        return glLightModeliv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static void glLightModeliv(int pname, MemorySegment params) {
        var mh$ = glLightModeliv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeliv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMaterialf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glMaterialf$descriptor() {
        return glMaterialf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glMaterialf$handle() {
        return glMaterialf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glMaterialf$address() {
        return glMaterialf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static void glMaterialf(int face, int pname, float param) {
        var mh$ = glMaterialf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialf", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMateriali {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMateriali");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glMateriali$descriptor() {
        return glMateriali.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glMateriali$handle() {
        return glMateriali.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glMateriali$address() {
        return glMateriali.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static void glMateriali(int face, int pname, int param) {
        var mh$ = glMateriali.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMateriali", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glMaterialfv$descriptor() {
        return glMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glMaterialfv$handle() {
        return glMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glMaterialfv$address() {
        return glMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glMaterialiv$descriptor() {
        return glMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glMaterialiv$handle() {
        return glMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glMaterialiv$address() {
        return glMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static void glMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialfv$descriptor() {
        return glGetMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMaterialfv$handle() {
        return glGetMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMaterialfv$address() {
        return glGetMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialiv$descriptor() {
        return glGetMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMaterialiv$handle() {
        return glGetMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMaterialiv$address() {
        return glGetMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColorMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glColorMaterial$descriptor() {
        return glColorMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glColorMaterial$handle() {
        return glColorMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glColorMaterial$address() {
        return glColorMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static void glColorMaterial(int face, int mode) {
        var mh$ = glColorMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMaterial", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static FunctionDescriptor glPixelZoom$descriptor() {
        return glPixelZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MethodHandle glPixelZoom$handle() {
        return glPixelZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MemorySegment glPixelZoom$address() {
        return glPixelZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static void glPixelZoom(float xfactor, float yfactor) {
        var mh$ = glPixelZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelZoom", xfactor, yfactor);
            }
            mh$.invokeExact(xfactor, yfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStoref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelStoref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelStoref$descriptor() {
        return glPixelStoref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelStoref$handle() {
        return glPixelStoref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelStoref$address() {
        return glPixelStoref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelStoref(int pname, float param) {
        var mh$ = glPixelStoref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStoref", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStorei {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelStorei");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelStorei$descriptor() {
        return glPixelStorei.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelStorei$handle() {
        return glPixelStorei.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelStorei$address() {
        return glPixelStorei.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static void glPixelStorei(int pname, int param) {
        var mh$ = glPixelStorei.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStorei", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelTransferf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelTransferf$descriptor() {
        return glPixelTransferf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelTransferf$handle() {
        return glPixelTransferf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelTransferf$address() {
        return glPixelTransferf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelTransferf(int pname, float param) {
        var mh$ = glPixelTransferf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelTransferi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelTransferi$descriptor() {
        return glPixelTransferi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelTransferi$handle() {
        return glPixelTransferi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelTransferi$address() {
        return glPixelTransferi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static void glPixelTransferi(int pname, int param) {
        var mh$ = glPixelTransferi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static FunctionDescriptor glPixelMapfv$descriptor() {
        return glPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MethodHandle glPixelMapfv$handle() {
        return glPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MemorySegment glPixelMapfv$address() {
        return glPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static void glPixelMapfv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapfv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static FunctionDescriptor glPixelMapuiv$descriptor() {
        return glPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MethodHandle glPixelMapuiv$handle() {
        return glPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MemorySegment glPixelMapuiv$address() {
        return glPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static void glPixelMapuiv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapuiv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static FunctionDescriptor glPixelMapusv$descriptor() {
        return glPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MethodHandle glPixelMapusv$handle() {
        return glPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MemorySegment glPixelMapusv$address() {
        return glPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static void glPixelMapusv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapusv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapfv$descriptor() {
        return glGetPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MethodHandle glGetPixelMapfv$handle() {
        return glGetPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MemorySegment glGetPixelMapfv$address() {
        return glGetPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static void glGetPixelMapfv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapfv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapuiv$descriptor() {
        return glGetPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MethodHandle glGetPixelMapuiv$handle() {
        return glGetPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MemorySegment glGetPixelMapuiv$address() {
        return glGetPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static void glGetPixelMapuiv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapuiv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapusv$descriptor() {
        return glGetPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MethodHandle glGetPixelMapusv$handle() {
        return glGetPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MemorySegment glGetPixelMapusv$address() {
        return glGetPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static void glGetPixelMapusv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapusv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static FunctionDescriptor glBitmap$descriptor() {
        return glBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MethodHandle glBitmap$handle() {
        return glBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MemorySegment glBitmap$address() {
        return glBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, MemorySegment bitmap) {
        var mh$ = glBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBitmap", width, height, xorig, yorig, xmove, ymove, bitmap);
            }
            mh$.invokeExact(width, height, xorig, yorig, xmove, ymove, bitmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glReadPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glReadPixels$descriptor() {
        return glReadPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glReadPixels$handle() {
        return glReadPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glReadPixels$address() {
        return glReadPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glReadPixels(int x, int y, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glReadPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadPixels", x, y, width, height, format, type, pixels);
            }
            mh$.invokeExact(x, y, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDrawPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glDrawPixels$descriptor() {
        return glDrawPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glDrawPixels$handle() {
        return glDrawPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glDrawPixels$address() {
        return glDrawPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glDrawPixels(int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glDrawPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawPixels", width, height, format, type, pixels);
            }
            mh$.invokeExact(width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static FunctionDescriptor glCopyPixels$descriptor() {
        return glCopyPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MethodHandle glCopyPixels$handle() {
        return glCopyPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MemorySegment glCopyPixels$address() {
        return glCopyPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static void glCopyPixels(int x, int y, int width, int height, int type) {
        var mh$ = glCopyPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyPixels", x, y, width, height, type);
            }
            mh$.invokeExact(x, y, width, height, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glStencilFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFunc$descriptor() {
        return glStencilFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFunc$handle() {
        return glStencilFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFunc$address() {
        return glStencilFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFunc(int func, int ref, int mask) {
        var mh$ = glStencilFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFunc", func, ref, mask);
            }
            mh$.invokeExact(func, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glStencilMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilMask$descriptor() {
        return glStencilMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MethodHandle glStencilMask$handle() {
        return glStencilMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MemorySegment glStencilMask$address() {
        return glStencilMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static void glStencilMask(int mask) {
        var mh$ = glStencilMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glStencilOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static FunctionDescriptor glStencilOp$descriptor() {
        return glStencilOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MethodHandle glStencilOp$handle() {
        return glStencilOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MemorySegment glStencilOp$address() {
        return glStencilOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static void glStencilOp(int fail, int zfail, int zpass) {
        var mh$ = glStencilOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOp", fail, zfail, zpass);
            }
            mh$.invokeExact(fail, zfail, zpass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearStencil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClearStencil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static FunctionDescriptor glClearStencil$descriptor() {
        return glClearStencil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MethodHandle glClearStencil$handle() {
        return glClearStencil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MemorySegment glClearStencil$address() {
        return glClearStencil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static void glClearStencil(int s) {
        var mh$ = glClearStencil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearStencil", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexGend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static FunctionDescriptor glTexGend$descriptor() {
        return glTexGend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MethodHandle glTexGend$handle() {
        return glTexGend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MemorySegment glTexGend$address() {
        return glTexGend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static void glTexGend(int coord, int pname, double param) {
        var mh$ = glTexGend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGend", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexGenf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexGenf$descriptor() {
        return glTexGenf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexGenf$handle() {
        return glTexGenf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexGenf$address() {
        return glTexGenf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexGenf(int coord, int pname, float param) {
        var mh$ = glTexGenf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenf", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexGeni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexGeni$descriptor() {
        return glTexGeni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexGeni$handle() {
        return glTexGeni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexGeni$address() {
        return glTexGeni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static void glTexGeni(int coord, int pname, int param) {
        var mh$ = glTexGeni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeni", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glTexGendv$descriptor() {
        return glTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MethodHandle glTexGendv$handle() {
        return glTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MemorySegment glTexGendv$address() {
        return glTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static void glTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexGenfv$descriptor() {
        return glTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexGenfv$handle() {
        return glTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexGenfv$address() {
        return glTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexGeniv$descriptor() {
        return glTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexGeniv$handle() {
        return glTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexGeniv$address() {
        return glTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetTexGendv$descriptor() {
        return glGetTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetTexGendv$handle() {
        return glGetTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetTexGendv$address() {
        return glGetTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexGenfv$descriptor() {
        return glGetTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexGenfv$handle() {
        return glGetTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexGenfv$address() {
        return glGetTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexGeniv$descriptor() {
        return glGetTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexGeniv$handle() {
        return glGetTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexGeniv$address() {
        return glGetTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexEnvf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexEnvf$descriptor() {
        return glTexEnvf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexEnvf$handle() {
        return glTexEnvf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexEnvf$address() {
        return glTexEnvf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexEnvf(int target, int pname, float param) {
        var mh$ = glTexEnvf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexEnvi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexEnvi$descriptor() {
        return glTexEnvi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexEnvi$handle() {
        return glTexEnvi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexEnvi$address() {
        return glTexEnvi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexEnvi(int target, int pname, int param) {
        var mh$ = glTexEnvi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvi", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexEnvfv$descriptor() {
        return glTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexEnvfv$handle() {
        return glTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexEnvfv$address() {
        return glTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexEnviv$descriptor() {
        return glTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexEnviv$handle() {
        return glTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexEnviv$address() {
        return glTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnvfv$descriptor() {
        return glGetTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexEnvfv$handle() {
        return glGetTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexEnvfv$address() {
        return glGetTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnviv$descriptor() {
        return glGetTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexEnviv$handle() {
        return glGetTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexEnviv$address() {
        return glGetTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexParameterf$descriptor() {
        return glTexParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexParameterf$handle() {
        return glTexParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexParameterf$address() {
        return glTexParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexParameterf(int target, int pname, float param) {
        var mh$ = glTexParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexParameteri$descriptor() {
        return glTexParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexParameteri$handle() {
        return glTexParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexParameteri$address() {
        return glTexParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexParameteri(int target, int pname, int param) {
        var mh$ = glTexParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteri", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexParameterfv$descriptor() {
        return glTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexParameterfv$handle() {
        return glTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexParameterfv$address() {
        return glTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexParameteriv$descriptor() {
        return glTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexParameteriv$handle() {
        return glTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexParameteriv$address() {
        return glTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterfv$descriptor() {
        return glGetTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexParameterfv$handle() {
        return glGetTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexParameterfv$address() {
        return glGetTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameteriv$descriptor() {
        return glGetTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexParameteriv$handle() {
        return glGetTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexParameteriv$address() {
        return glGetTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexLevelParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameterfv$descriptor() {
        return glGetTexLevelParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameterfv$handle() {
        return glGetTexLevelParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameterfv$address() {
        return glGetTexLevelParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexLevelParameterfv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameterfv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexLevelParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameteriv$descriptor() {
        return glGetTexLevelParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameteriv$handle() {
        return glGetTexLevelParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameteriv$address() {
        return glGetTexLevelParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexLevelParameteriv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameteriv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage1D$descriptor() {
        return glTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage1D$handle() {
        return glTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage1D$address() {
        return glTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage1D(int target, int level, int internalFormat, int width, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage1D", target, level, internalFormat, width, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage2D$descriptor() {
        return glTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage2D$handle() {
        return glTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage2D$address() {
        return glTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage2D", target, level, internalFormat, width, height, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, height, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glGetTexImage$descriptor() {
        return glGetTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glGetTexImage$handle() {
        return glGetTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glGetTexImage$address() {
        return glGetTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glGetTexImage(int target, int level, int format, int type, MemorySegment pixels) {
        var mh$ = glGetTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexImage", target, level, format, type, pixels);
            }
            mh$.invokeExact(target, level, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGenTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static FunctionDescriptor glGenTextures$descriptor() {
        return glGenTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MethodHandle glGenTextures$handle() {
        return glGenTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MemorySegment glGenTextures$address() {
        return glGenTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static void glGenTextures(int n, MemorySegment textures) {
        var mh$ = glGenTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDeleteTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static FunctionDescriptor glDeleteTextures$descriptor() {
        return glDeleteTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MethodHandle glDeleteTextures$handle() {
        return glDeleteTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MemorySegment glDeleteTextures$address() {
        return glDeleteTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static void glDeleteTextures(int n, MemorySegment textures) {
        var mh$ = glDeleteTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glBindTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static FunctionDescriptor glBindTexture$descriptor() {
        return glBindTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MethodHandle glBindTexture$handle() {
        return glBindTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MemorySegment glBindTexture$address() {
        return glBindTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static void glBindTexture(int target, int texture) {
        var mh$ = glBindTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindTexture", target, texture);
            }
            mh$.invokeExact(target, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPrioritizeTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPrioritizeTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static FunctionDescriptor glPrioritizeTextures$descriptor() {
        return glPrioritizeTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MethodHandle glPrioritizeTextures$handle() {
        return glPrioritizeTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MemorySegment glPrioritizeTextures$address() {
        return glPrioritizeTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static void glPrioritizeTextures(int n, MemorySegment textures, MemorySegment priorities) {
        var mh$ = glPrioritizeTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPrioritizeTextures", n, textures, priorities);
            }
            mh$.invokeExact(n, textures, priorities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAreTexturesResident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_CHAR,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glAreTexturesResident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static FunctionDescriptor glAreTexturesResident$descriptor() {
        return glAreTexturesResident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MethodHandle glAreTexturesResident$handle() {
        return glAreTexturesResident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MemorySegment glAreTexturesResident$address() {
        return glAreTexturesResident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static byte glAreTexturesResident(int n, MemorySegment textures, MemorySegment residences) {
        var mh$ = glAreTexturesResident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAreTexturesResident", n, textures, residences);
            }
            return (byte)mh$.invokeExact(n, textures, residences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_CHAR,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glIsTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static FunctionDescriptor glIsTexture$descriptor() {
        return glIsTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MethodHandle glIsTexture$handle() {
        return glIsTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MemorySegment glIsTexture$address() {
        return glIsTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static byte glIsTexture(int texture) {
        var mh$ = glIsTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsTexture", texture);
            }
            return (byte)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage1D$descriptor() {
        return glTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage1D$handle() {
        return glTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage1D$address() {
        return glTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage1D", target, level, xoffset, width, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, width, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage2D$descriptor() {
        return glTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage2D$handle() {
        return glTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage2D$address() {
        return glTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage2D", target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage1D$descriptor() {
        return glCopyTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage1D$handle() {
        return glCopyTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage1D$address() {
        return glCopyTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static void glCopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border) {
        var mh$ = glCopyTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage1D", target, level, internalformat, x, y, width, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage2D$descriptor() {
        return glCopyTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage2D$handle() {
        return glCopyTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage2D$address() {
        return glCopyTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
        var mh$ = glCopyTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage2D", target, level, internalformat, x, y, width, height, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, height, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage1D$descriptor() {
        return glCopyTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyTexSubImage1D$handle() {
        return glCopyTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyTexSubImage1D$address() {
        return glCopyTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width) {
        var mh$ = glCopyTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage1D", target, level, xoffset, x, y, width);
            }
            mh$.invokeExact(target, level, xoffset, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage2D$descriptor() {
        return glCopyTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage2D$handle() {
        return glCopyTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage2D$address() {
        return glCopyTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage2D", target, level, xoffset, yoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMap1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap1d$descriptor() {
        return glMap1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap1d$handle() {
        return glMap1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap1d$address() {
        return glMap1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static void glMap1d(int target, double u1, double u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1d", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMap1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap1f$descriptor() {
        return glMap1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap1f$handle() {
        return glMap1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap1f$address() {
        return glMap1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static void glMap1f(int target, float u1, float u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1f", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMap2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap2d$descriptor() {
        return glMap2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap2d$handle() {
        return glMap2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap2d$address() {
        return glMap2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2d", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMap2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap2f$descriptor() {
        return glMap2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap2f$handle() {
        return glMap2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap2f$address() {
        return glMap2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2f", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMapdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static FunctionDescriptor glGetMapdv$descriptor() {
        return glGetMapdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MethodHandle glGetMapdv$handle() {
        return glGetMapdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MemorySegment glGetMapdv$address() {
        return glGetMapdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static void glGetMapdv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapdv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static FunctionDescriptor glGetMapfv$descriptor() {
        return glGetMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MethodHandle glGetMapfv$handle() {
        return glGetMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MemorySegment glGetMapfv$address() {
        return glGetMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static void glGetMapfv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapfv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMapiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static FunctionDescriptor glGetMapiv$descriptor() {
        return glGetMapiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MethodHandle glGetMapiv$handle() {
        return glGetMapiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MemorySegment glGetMapiv$address() {
        return glGetMapiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static void glGetMapiv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapiv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1d$descriptor() {
        return glEvalCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MethodHandle glEvalCoord1d$handle() {
        return glEvalCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MemorySegment glEvalCoord1d$address() {
        return glEvalCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static void glEvalCoord1d(double u) {
        var mh$ = glEvalCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1d", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1f$descriptor() {
        return glEvalCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MethodHandle glEvalCoord1f$handle() {
        return glEvalCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MemorySegment glEvalCoord1f$address() {
        return glEvalCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static void glEvalCoord1f(float u) {
        var mh$ = glEvalCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1f", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1dv$descriptor() {
        return glEvalCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord1dv$handle() {
        return glEvalCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord1dv$address() {
        return glEvalCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord1dv(MemorySegment u) {
        var mh$ = glEvalCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1fv$descriptor() {
        return glEvalCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord1fv$handle() {
        return glEvalCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord1fv$address() {
        return glEvalCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord1fv(MemorySegment u) {
        var mh$ = glEvalCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2d$descriptor() {
        return glEvalCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MethodHandle glEvalCoord2d$handle() {
        return glEvalCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MemorySegment glEvalCoord2d$address() {
        return glEvalCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static void glEvalCoord2d(double u, double v) {
        var mh$ = glEvalCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2d", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2f$descriptor() {
        return glEvalCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MethodHandle glEvalCoord2f$handle() {
        return glEvalCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MemorySegment glEvalCoord2f$address() {
        return glEvalCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static void glEvalCoord2f(float u, float v) {
        var mh$ = glEvalCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2f", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2dv$descriptor() {
        return glEvalCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord2dv$handle() {
        return glEvalCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord2dv$address() {
        return glEvalCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord2dv(MemorySegment u) {
        var mh$ = glEvalCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2fv$descriptor() {
        return glEvalCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord2fv$handle() {
        return glEvalCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord2fv$address() {
        return glEvalCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord2fv(MemorySegment u) {
        var mh$ = glEvalCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMapGrid1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1d$descriptor() {
        return glMapGrid1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MethodHandle glMapGrid1d$handle() {
        return glMapGrid1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MemorySegment glMapGrid1d$address() {
        return glMapGrid1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static void glMapGrid1d(int un, double u1, double u2) {
        var mh$ = glMapGrid1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1d", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMapGrid1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1f$descriptor() {
        return glMapGrid1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MethodHandle glMapGrid1f$handle() {
        return glMapGrid1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MemorySegment glMapGrid1f$address() {
        return glMapGrid1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static void glMapGrid1f(int un, float u1, float u2) {
        var mh$ = glMapGrid1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1f", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMapGrid2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2d$descriptor() {
        return glMapGrid2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MethodHandle glMapGrid2d$handle() {
        return glMapGrid2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MemorySegment glMapGrid2d$address() {
        return glMapGrid2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
        var mh$ = glMapGrid2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2d", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMapGrid2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2f$descriptor() {
        return glMapGrid2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glMapGrid2f$handle() {
        return glMapGrid2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glMapGrid2f$address() {
        return glMapGrid2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
        var mh$ = glMapGrid2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2f", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalPoint1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static FunctionDescriptor glEvalPoint1$descriptor() {
        return glEvalPoint1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MethodHandle glEvalPoint1$handle() {
        return glEvalPoint1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MemorySegment glEvalPoint1$address() {
        return glEvalPoint1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static void glEvalPoint1(int i) {
        var mh$ = glEvalPoint1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint1", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalPoint2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static FunctionDescriptor glEvalPoint2$descriptor() {
        return glEvalPoint2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MethodHandle glEvalPoint2$handle() {
        return glEvalPoint2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MemorySegment glEvalPoint2$address() {
        return glEvalPoint2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static void glEvalPoint2(int i, int j) {
        var mh$ = glEvalPoint2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint2", i, j);
            }
            mh$.invokeExact(i, j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalMesh1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static FunctionDescriptor glEvalMesh1$descriptor() {
        return glEvalMesh1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MethodHandle glEvalMesh1$handle() {
        return glEvalMesh1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MemorySegment glEvalMesh1$address() {
        return glEvalMesh1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static void glEvalMesh1(int mode, int i1, int i2) {
        var mh$ = glEvalMesh1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh1", mode, i1, i2);
            }
            mh$.invokeExact(mode, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glEvalMesh2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static FunctionDescriptor glEvalMesh2$descriptor() {
        return glEvalMesh2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MethodHandle glEvalMesh2$handle() {
        return glEvalMesh2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MemorySegment glEvalMesh2$address() {
        return glEvalMesh2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static void glEvalMesh2(int mode, int i1, int i2, int j1, int j2) {
        var mh$ = glEvalMesh2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh2", mode, i1, i2, j1, j2);
            }
            mh$.invokeExact(mode, i1, i2, j1, j2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glFogf$descriptor() {
        return glFogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glFogf$handle() {
        return glFogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glFogf$address() {
        return glFogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static void glFogf(int pname, float param) {
        var mh$ = glFogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFogi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glFogi$descriptor() {
        return glFogi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glFogi$handle() {
        return glFogi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glFogi$address() {
        return glFogi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static void glFogi(int pname, int param) {
        var mh$ = glFogi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFogfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glFogfv$descriptor() {
        return glFogfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glFogfv$handle() {
        return glFogfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glFogfv$address() {
        return glFogfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glFogfv(int pname, MemorySegment params) {
        var mh$ = glFogfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFogiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glFogiv$descriptor() {
        return glFogiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glFogiv$handle() {
        return glFogiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glFogiv$address() {
        return glFogiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static void glFogiv(int pname, MemorySegment params) {
        var mh$ = glFogiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogiv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFeedbackBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glFeedbackBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static FunctionDescriptor glFeedbackBuffer$descriptor() {
        return glFeedbackBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MethodHandle glFeedbackBuffer$handle() {
        return glFeedbackBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MemorySegment glFeedbackBuffer$address() {
        return glFeedbackBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static void glFeedbackBuffer(int size, int type, MemorySegment buffer) {
        var mh$ = glFeedbackBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFeedbackBuffer", size, type, buffer);
            }
            mh$.invokeExact(size, type, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPassThrough {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPassThrough");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static FunctionDescriptor glPassThrough$descriptor() {
        return glPassThrough.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MethodHandle glPassThrough$handle() {
        return glPassThrough.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MemorySegment glPassThrough$address() {
        return glPassThrough.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static void glPassThrough(float token) {
        var mh$ = glPassThrough.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPassThrough", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSelectBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glSelectBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static FunctionDescriptor glSelectBuffer$descriptor() {
        return glSelectBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MethodHandle glSelectBuffer$handle() {
        return glSelectBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MemorySegment glSelectBuffer$address() {
        return glSelectBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static void glSelectBuffer(int size, MemorySegment buffer) {
        var mh$ = glSelectBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSelectBuffer", size, buffer);
            }
            mh$.invokeExact(size, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInitNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glInitNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static FunctionDescriptor glInitNames$descriptor() {
        return glInitNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MethodHandle glInitNames$handle() {
        return glInitNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MemorySegment glInitNames$address() {
        return glInitNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static void glInitNames() {
        var mh$ = glInitNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInitNames");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLoadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static FunctionDescriptor glLoadName$descriptor() {
        return glLoadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MethodHandle glLoadName$handle() {
        return glLoadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MemorySegment glLoadName$address() {
        return glLoadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static void glLoadName(int name) {
        var mh$ = glLoadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPushName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static FunctionDescriptor glPushName$descriptor() {
        return glPushName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MethodHandle glPushName$handle() {
        return glPushName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MemorySegment glPushName$address() {
        return glPushName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static void glPushName(int name) {
        var mh$ = glPushName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glPopName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static FunctionDescriptor glPopName$descriptor() {
        return glPopName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MethodHandle glPopName$handle() {
        return glPopName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MemorySegment glPopName$address() {
        return glPopName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static void glPopName() {
        var mh$ = glPopName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopName");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawRangeElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glDrawRangeElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawRangeElements$descriptor() {
        return glDrawRangeElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawRangeElements$handle() {
        return glDrawRangeElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawRangeElements$address() {
        return glDrawRangeElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawRangeElements(int mode, int start, int end, int count, int type, MemorySegment indices) {
        var mh$ = glDrawRangeElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawRangeElements", mode, start, end, count, type, indices);
            }
            mh$.invokeExact(mode, start, end, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage3D$descriptor() {
        return glTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage3D$handle() {
        return glTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage3D$address() {
        return glTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage3D(int target, int level, int internalFormat, int width, int height, int depth, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage3D", target, level, internalFormat, width, height, depth, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, height, depth, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage3D$descriptor() {
        return glTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage3D$handle() {
        return glTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage3D$address() {
        return glTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage3D$descriptor() {
        return glCopyTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage3D$handle() {
        return glCopyTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage3D$address() {
        return glCopyTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage3D", target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static FunctionDescriptor glColorTable$descriptor() {
        return glColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MethodHandle glColorTable$handle() {
        return glColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MemorySegment glColorTable$address() {
        return glColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static void glColorTable(int target, int internalformat, int width, int format, int type, MemorySegment table) {
        var mh$ = glColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTable", target, internalformat, width, format, type, table);
            }
            mh$.invokeExact(target, internalformat, width, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glColorSubTable$descriptor() {
        return glColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MethodHandle glColorSubTable$handle() {
        return glColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MemorySegment glColorSubTable$address() {
        return glColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static void glColorSubTable(int target, int start, int count, int format, int type, MemorySegment data) {
        var mh$ = glColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorSubTable", target, start, count, format, type, data);
            }
            mh$.invokeExact(target, start, count, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameteriv$descriptor() {
        return glColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glColorTableParameteriv$handle() {
        return glColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glColorTableParameteriv$address() {
        return glColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameterfv$descriptor() {
        return glColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glColorTableParameterfv$handle() {
        return glColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glColorTableParameterfv$address() {
        return glColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorSubTable$descriptor() {
        return glCopyColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorSubTable$handle() {
        return glCopyColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorSubTable$address() {
        return glCopyColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorSubTable(int target, int start, int x, int y, int width) {
        var mh$ = glCopyColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorSubTable", target, start, x, y, width);
            }
            mh$.invokeExact(target, start, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorTable$descriptor() {
        return glCopyColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorTable$handle() {
        return glCopyColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorTable$address() {
        return glCopyColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorTable(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorTable", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static FunctionDescriptor glGetColorTable$descriptor() {
        return glGetColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MethodHandle glGetColorTable$handle() {
        return glGetColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MemorySegment glGetColorTable$address() {
        return glGetColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static void glGetColorTable(int target, int format, int type, MemorySegment table) {
        var mh$ = glGetColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTable", target, format, type, table);
            }
            mh$.invokeExact(target, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameterfv$descriptor() {
        return glGetColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetColorTableParameterfv$handle() {
        return glGetColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetColorTableParameterfv$address() {
        return glGetColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameteriv$descriptor() {
        return glGetColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetColorTableParameteriv$handle() {
        return glGetColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetColorTableParameteriv$address() {
        return glGetColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glBlendEquation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBlendEquation$descriptor() {
        return glBlendEquation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static MethodHandle glBlendEquation$handle() {
        return glBlendEquation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static MemorySegment glBlendEquation$address() {
        return glBlendEquation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static void glBlendEquation(int mode) {
        var mh$ = glBlendEquation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquation", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glBlendColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glBlendColor$descriptor() {
        return glBlendColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glBlendColor$handle() {
        return glBlendColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glBlendColor$address() {
        return glBlendColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glBlendColor(float red, float green, float blue, float alpha) {
        var mh$ = glBlendColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glHistogram$descriptor() {
        return glHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glHistogram$handle() {
        return glHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glHistogram$address() {
        return glHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glHistogram(int target, int width, int internalformat, byte sink) {
        var mh$ = glHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHistogram", target, width, internalformat, sink);
            }
            mh$.invokeExact(target, width, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glResetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetHistogram$descriptor() {
        return glResetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static MethodHandle glResetHistogram$handle() {
        return glResetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static MemorySegment glResetHistogram$address() {
        return glResetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static void glResetHistogram(int target) {
        var mh$ = glResetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetHistogram", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_CHAR,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetHistogram$descriptor() {
        return glGetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MethodHandle glGetHistogram$handle() {
        return glGetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MemorySegment glGetHistogram$address() {
        return glGetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static void glGetHistogram(int target, byte reset, int format, int type, MemorySegment values) {
        var mh$ = glGetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogram", target, reset, format, type, values);
            }
            mh$.invokeExact(target, reset, format, type, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetHistogramParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameterfv$descriptor() {
        return glGetHistogramParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetHistogramParameterfv$handle() {
        return glGetHistogramParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetHistogramParameterfv$address() {
        return glGetHistogramParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetHistogramParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetHistogramParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameteriv$descriptor() {
        return glGetHistogramParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetHistogramParameteriv$handle() {
        return glGetHistogramParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetHistogramParameteriv$address() {
        return glGetHistogramParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetHistogramParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glMinmax$descriptor() {
        return glMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glMinmax$handle() {
        return glMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glMinmax$address() {
        return glMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glMinmax(int target, int internalformat, byte sink) {
        var mh$ = glMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMinmax", target, internalformat, sink);
            }
            mh$.invokeExact(target, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glResetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetMinmax$descriptor() {
        return glResetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static MethodHandle glResetMinmax$handle() {
        return glResetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static MemorySegment glResetMinmax$address() {
        return glResetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static void glResetMinmax(int target) {
        var mh$ = glResetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetMinmax", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_CHAR,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetMinmax$descriptor() {
        return glGetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static MethodHandle glGetMinmax$handle() {
        return glGetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static MemorySegment glGetMinmax$address() {
        return glGetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static void glGetMinmax(int target, byte reset, int format, int types, MemorySegment values) {
        var mh$ = glGetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmax", target, reset, format, types, values);
            }
            mh$.invokeExact(target, reset, format, types, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMinmaxParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameterfv$descriptor() {
        return glGetMinmaxParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameterfv$handle() {
        return glGetMinmaxParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameterfv$address() {
        return glGetMinmaxParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMinmaxParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetMinmaxParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameteriv$descriptor() {
        return glGetMinmaxParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameteriv$handle() {
        return glGetMinmaxParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameteriv$address() {
        return glGetMinmaxParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMinmaxParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter1D$descriptor() {
        return glConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter1D$handle() {
        return glConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter1D$address() {
        return glConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter1D", target, internalformat, width, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter2D$descriptor() {
        return glConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter2D$handle() {
        return glConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter2D$address() {
        return glConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter2D", target, internalformat, width, height, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glConvolutionParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterf$descriptor() {
        return glConvolutionParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MethodHandle glConvolutionParameterf$handle() {
        return glConvolutionParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MemorySegment glConvolutionParameterf$address() {
        return glConvolutionParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static void glConvolutionParameterf(int target, int pname, float params) {
        var mh$ = glConvolutionParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterf", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterfv$descriptor() {
        return glConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glConvolutionParameterfv$handle() {
        return glConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glConvolutionParameterfv$address() {
        return glConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glConvolutionParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteri$descriptor() {
        return glConvolutionParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MethodHandle glConvolutionParameteri$handle() {
        return glConvolutionParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MemorySegment glConvolutionParameteri$address() {
        return glConvolutionParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static void glConvolutionParameteri(int target, int pname, int params) {
        var mh$ = glConvolutionParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteri", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteriv$descriptor() {
        return glConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glConvolutionParameteriv$handle() {
        return glConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glConvolutionParameteriv$address() {
        return glConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter1D$descriptor() {
        return glCopyConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter1D$handle() {
        return glCopyConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter1D$address() {
        return glCopyConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter1D", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCopyConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter2D$descriptor() {
        return glCopyConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter2D$handle() {
        return glCopyConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter2D$address() {
        return glCopyConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height) {
        var mh$ = glCopyConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter2D", target, internalformat, x, y, width, height);
            }
            mh$.invokeExact(target, internalformat, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetConvolutionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static FunctionDescriptor glGetConvolutionFilter$descriptor() {
        return glGetConvolutionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MethodHandle glGetConvolutionFilter$handle() {
        return glGetConvolutionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MemorySegment glGetConvolutionFilter$address() {
        return glGetConvolutionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static void glGetConvolutionFilter(int target, int format, int type, MemorySegment image) {
        var mh$ = glGetConvolutionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionFilter", target, format, type, image);
            }
            mh$.invokeExact(target, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameterfv$descriptor() {
        return glGetConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameterfv$handle() {
        return glGetConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameterfv$address() {
        return glGetConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameteriv$descriptor() {
        return glGetConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameteriv$handle() {
        return glGetConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameteriv$address() {
        return glGetConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSeparableFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glSeparableFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static FunctionDescriptor glSeparableFilter2D$descriptor() {
        return glSeparableFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MethodHandle glSeparableFilter2D$handle() {
        return glSeparableFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MemorySegment glSeparableFilter2D$address() {
        return glSeparableFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment row, MemorySegment column) {
        var mh$ = glSeparableFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSeparableFilter2D", target, internalformat, width, height, format, type, row, column);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, row, column);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetSeparableFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetSeparableFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static FunctionDescriptor glGetSeparableFilter$descriptor() {
        return glGetSeparableFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MethodHandle glGetSeparableFilter$handle() {
        return glGetSeparableFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MemorySegment glGetSeparableFilter$address() {
        return glGetSeparableFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static void glGetSeparableFilter(int target, int format, int type, MemorySegment row, MemorySegment column, MemorySegment span) {
        var mh$ = glGetSeparableFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetSeparableFilter", target, format, type, row, column, span);
            }
            mh$.invokeExact(target, format, type, row, column, span);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTexture$descriptor() {
        return glActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTexture$handle() {
        return glActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTexture$address() {
        return glActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static void glActiveTexture(int texture) {
        var mh$ = glActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClientActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTexture$descriptor() {
        return glClientActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTexture$handle() {
        return glClientActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTexture$address() {
        return glClientActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static void glClientActiveTexture(int texture) {
        var mh$ = glClientActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCompressedTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage1D$descriptor() {
        return glCompressedTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage1D$handle() {
        return glCompressedTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage1D$address() {
        return glCompressedTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage1D", target, level, internalformat, width, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCompressedTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage2D$descriptor() {
        return glCompressedTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage2D$handle() {
        return glCompressedTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage2D$address() {
        return glCompressedTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage2D", target, level, internalformat, width, height, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCompressedTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage3D$descriptor() {
        return glCompressedTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage3D$handle() {
        return glCompressedTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage3D$address() {
        return glCompressedTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage3D", target, level, internalformat, width, height, depth, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, depth, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCompressedTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage1D$descriptor() {
        return glCompressedTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage1D$handle() {
        return glCompressedTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage1D$address() {
        return glCompressedTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage1D", target, level, xoffset, width, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, width, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCompressedTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage2D$descriptor() {
        return glCompressedTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage2D$handle() {
        return glCompressedTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage2D$address() {
        return glCompressedTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage2D", target, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glCompressedTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage3D$descriptor() {
        return glCompressedTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage3D$handle() {
        return glCompressedTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage3D$address() {
        return glCompressedTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetCompressedTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glGetCompressedTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static FunctionDescriptor glGetCompressedTexImage$descriptor() {
        return glGetCompressedTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MethodHandle glGetCompressedTexImage$handle() {
        return glGetCompressedTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MemorySegment glGetCompressedTexImage$address() {
        return glGetCompressedTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static void glGetCompressedTexImage(int target, int lod, MemorySegment img) {
        var mh$ = glGetCompressedTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetCompressedTexImage", target, lod, img);
            }
            mh$.invokeExact(target, lod, img);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1d$descriptor() {
        return glMultiTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1d$handle() {
        return glMultiTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1d$address() {
        return glMultiTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1d(int target, double s) {
        var mh$ = glMultiTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1d", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dv$descriptor() {
        return glMultiTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dv$handle() {
        return glMultiTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dv$address() {
        return glMultiTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1f$descriptor() {
        return glMultiTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1f$handle() {
        return glMultiTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1f$address() {
        return glMultiTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1f(int target, float s) {
        var mh$ = glMultiTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1f", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fv$descriptor() {
        return glMultiTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fv$handle() {
        return glMultiTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fv$address() {
        return glMultiTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1i$descriptor() {
        return glMultiTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1i$handle() {
        return glMultiTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1i$address() {
        return glMultiTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1i(int target, int s) {
        var mh$ = glMultiTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1i", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iv$descriptor() {
        return glMultiTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1iv$handle() {
        return glMultiTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1iv$address() {
        return glMultiTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1s$descriptor() {
        return glMultiTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1s$handle() {
        return glMultiTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1s$address() {
        return glMultiTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1s(int target, short s) {
        var mh$ = glMultiTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1s", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sv$descriptor() {
        return glMultiTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1sv$handle() {
        return glMultiTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1sv$address() {
        return glMultiTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2d$descriptor() {
        return glMultiTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2d$handle() {
        return glMultiTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2d$address() {
        return glMultiTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2d(int target, double s, double t) {
        var mh$ = glMultiTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2d", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dv$descriptor() {
        return glMultiTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dv$handle() {
        return glMultiTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dv$address() {
        return glMultiTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2f$descriptor() {
        return glMultiTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2f$handle() {
        return glMultiTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2f$address() {
        return glMultiTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2f(int target, float s, float t) {
        var mh$ = glMultiTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2f", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fv$descriptor() {
        return glMultiTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fv$handle() {
        return glMultiTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fv$address() {
        return glMultiTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2i$descriptor() {
        return glMultiTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2i$handle() {
        return glMultiTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2i$address() {
        return glMultiTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2i(int target, int s, int t) {
        var mh$ = glMultiTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2i", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iv$descriptor() {
        return glMultiTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2iv$handle() {
        return glMultiTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2iv$address() {
        return glMultiTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2s$descriptor() {
        return glMultiTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2s$handle() {
        return glMultiTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2s$address() {
        return glMultiTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2s(int target, short s, short t) {
        var mh$ = glMultiTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2s", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sv$descriptor() {
        return glMultiTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2sv$handle() {
        return glMultiTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2sv$address() {
        return glMultiTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3d$descriptor() {
        return glMultiTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3d$handle() {
        return glMultiTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3d$address() {
        return glMultiTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3d(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3d", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dv$descriptor() {
        return glMultiTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dv$handle() {
        return glMultiTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dv$address() {
        return glMultiTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3f$descriptor() {
        return glMultiTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3f$handle() {
        return glMultiTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3f$address() {
        return glMultiTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3f(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3f", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fv$descriptor() {
        return glMultiTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fv$handle() {
        return glMultiTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fv$address() {
        return glMultiTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3i$descriptor() {
        return glMultiTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3i$handle() {
        return glMultiTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3i$address() {
        return glMultiTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3i(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3i", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iv$descriptor() {
        return glMultiTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3iv$handle() {
        return glMultiTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3iv$address() {
        return glMultiTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3s$descriptor() {
        return glMultiTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3s$handle() {
        return glMultiTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3s$address() {
        return glMultiTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3s(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3s", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sv$descriptor() {
        return glMultiTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3sv$handle() {
        return glMultiTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3sv$address() {
        return glMultiTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4d$descriptor() {
        return glMultiTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4d$handle() {
        return glMultiTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4d$address() {
        return glMultiTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4d(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4d", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dv$descriptor() {
        return glMultiTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dv$handle() {
        return glMultiTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dv$address() {
        return glMultiTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4f$descriptor() {
        return glMultiTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4f$handle() {
        return glMultiTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4f$address() {
        return glMultiTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4f(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4f", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fv$descriptor() {
        return glMultiTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fv$handle() {
        return glMultiTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fv$address() {
        return glMultiTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4i$descriptor() {
        return glMultiTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4i$handle() {
        return glMultiTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4i$address() {
        return glMultiTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4i(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4i", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iv$descriptor() {
        return glMultiTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4iv$handle() {
        return glMultiTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4iv$address() {
        return glMultiTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4s$descriptor() {
        return glMultiTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4s$handle() {
        return glMultiTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4s$address() {
        return glMultiTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4s(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4s", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sv$descriptor() {
        return glMultiTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4sv$handle() {
        return glMultiTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4sv$address() {
        return glMultiTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLoadTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixd$descriptor() {
        return glLoadTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MethodHandle glLoadTransposeMatrixd$handle() {
        return glLoadTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MemorySegment glLoadTransposeMatrixd$address() {
        return glLoadTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static void glLoadTransposeMatrixd(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glLoadTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixf$descriptor() {
        return glLoadTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MethodHandle glLoadTransposeMatrixf$handle() {
        return glLoadTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MemorySegment glLoadTransposeMatrixf$address() {
        return glLoadTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static void glLoadTransposeMatrixf(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixd$descriptor() {
        return glMultTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MethodHandle glMultTransposeMatrixd$handle() {
        return glMultTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MemorySegment glMultTransposeMatrixd$address() {
        return glMultTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static void glMultTransposeMatrixd(MemorySegment m) {
        var mh$ = glMultTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixf$descriptor() {
        return glMultTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MethodHandle glMultTransposeMatrixf$handle() {
        return glMultTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MemorySegment glMultTransposeMatrixf$address() {
        return glMultTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static void glMultTransposeMatrixf(MemorySegment m) {
        var mh$ = glMultTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSampleCoverage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_FLOAT,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glSampleCoverage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static FunctionDescriptor glSampleCoverage$descriptor() {
        return glSampleCoverage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MethodHandle glSampleCoverage$handle() {
        return glSampleCoverage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MemorySegment glSampleCoverage$address() {
        return glSampleCoverage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static void glSampleCoverage(float value, byte invert) {
        var mh$ = glSampleCoverage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSampleCoverage", value, invert);
            }
            mh$.invokeExact(value, invert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTextureARB$descriptor() {
        return glActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTextureARB$handle() {
        return glActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTextureARB$address() {
        return glActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static void glActiveTextureARB(int texture) {
        var mh$ = glActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glClientActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTextureARB$descriptor() {
        return glClientActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTextureARB$handle() {
        return glClientActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTextureARB$address() {
        return glClientActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static void glClientActiveTextureARB(int texture) {
        var mh$ = glClientActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dARB$descriptor() {
        return glMultiTexCoord1dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1dARB$handle() {
        return glMultiTexCoord1dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1dARB$address() {
        return glMultiTexCoord1dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1dARB(int target, double s) {
        var mh$ = glMultiTexCoord1dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dvARB$descriptor() {
        return glMultiTexCoord1dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dvARB$handle() {
        return glMultiTexCoord1dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dvARB$address() {
        return glMultiTexCoord1dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fARB$descriptor() {
        return glMultiTexCoord1fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1fARB$handle() {
        return glMultiTexCoord1fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1fARB$address() {
        return glMultiTexCoord1fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1fARB(int target, float s) {
        var mh$ = glMultiTexCoord1fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fvARB$descriptor() {
        return glMultiTexCoord1fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fvARB$handle() {
        return glMultiTexCoord1fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fvARB$address() {
        return glMultiTexCoord1fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iARB$descriptor() {
        return glMultiTexCoord1iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1iARB$handle() {
        return glMultiTexCoord1iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1iARB$address() {
        return glMultiTexCoord1iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1iARB(int target, int s) {
        var mh$ = glMultiTexCoord1iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1ivARB$descriptor() {
        return glMultiTexCoord1ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1ivARB$handle() {
        return glMultiTexCoord1ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1ivARB$address() {
        return glMultiTexCoord1ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sARB$descriptor() {
        return glMultiTexCoord1sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1sARB$handle() {
        return glMultiTexCoord1sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1sARB$address() {
        return glMultiTexCoord1sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1sARB(int target, short s) {
        var mh$ = glMultiTexCoord1sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord1svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1svARB$descriptor() {
        return glMultiTexCoord1svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1svARB$handle() {
        return glMultiTexCoord1svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1svARB$address() {
        return glMultiTexCoord1svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dARB$descriptor() {
        return glMultiTexCoord2dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2dARB$handle() {
        return glMultiTexCoord2dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2dARB$address() {
        return glMultiTexCoord2dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2dARB(int target, double s, double t) {
        var mh$ = glMultiTexCoord2dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dvARB$descriptor() {
        return glMultiTexCoord2dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dvARB$handle() {
        return glMultiTexCoord2dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dvARB$address() {
        return glMultiTexCoord2dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fARB$descriptor() {
        return glMultiTexCoord2fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2fARB$handle() {
        return glMultiTexCoord2fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2fARB$address() {
        return glMultiTexCoord2fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2fARB(int target, float s, float t) {
        var mh$ = glMultiTexCoord2fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fvARB$descriptor() {
        return glMultiTexCoord2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fvARB$handle() {
        return glMultiTexCoord2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fvARB$address() {
        return glMultiTexCoord2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iARB$descriptor() {
        return glMultiTexCoord2iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2iARB$handle() {
        return glMultiTexCoord2iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2iARB$address() {
        return glMultiTexCoord2iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2iARB(int target, int s, int t) {
        var mh$ = glMultiTexCoord2iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2ivARB$descriptor() {
        return glMultiTexCoord2ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2ivARB$handle() {
        return glMultiTexCoord2ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2ivARB$address() {
        return glMultiTexCoord2ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sARB$descriptor() {
        return glMultiTexCoord2sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2sARB$handle() {
        return glMultiTexCoord2sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2sARB$address() {
        return glMultiTexCoord2sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2sARB(int target, short s, short t) {
        var mh$ = glMultiTexCoord2sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord2svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2svARB$descriptor() {
        return glMultiTexCoord2svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2svARB$handle() {
        return glMultiTexCoord2svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2svARB$address() {
        return glMultiTexCoord2svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dARB$descriptor() {
        return glMultiTexCoord3dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3dARB$handle() {
        return glMultiTexCoord3dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3dARB$address() {
        return glMultiTexCoord3dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3dARB(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dvARB$descriptor() {
        return glMultiTexCoord3dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dvARB$handle() {
        return glMultiTexCoord3dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dvARB$address() {
        return glMultiTexCoord3dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fARB$descriptor() {
        return glMultiTexCoord3fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3fARB$handle() {
        return glMultiTexCoord3fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3fARB$address() {
        return glMultiTexCoord3fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3fARB(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fvARB$descriptor() {
        return glMultiTexCoord3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fvARB$handle() {
        return glMultiTexCoord3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fvARB$address() {
        return glMultiTexCoord3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iARB$descriptor() {
        return glMultiTexCoord3iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3iARB$handle() {
        return glMultiTexCoord3iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3iARB$address() {
        return glMultiTexCoord3iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3iARB(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3ivARB$descriptor() {
        return glMultiTexCoord3ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3ivARB$handle() {
        return glMultiTexCoord3ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3ivARB$address() {
        return glMultiTexCoord3ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sARB$descriptor() {
        return glMultiTexCoord3sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3sARB$handle() {
        return glMultiTexCoord3sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3sARB$address() {
        return glMultiTexCoord3sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3sARB(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord3svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3svARB$descriptor() {
        return glMultiTexCoord3svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3svARB$handle() {
        return glMultiTexCoord3svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3svARB$address() {
        return glMultiTexCoord3svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dARB$descriptor() {
        return glMultiTexCoord4dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4dARB$handle() {
        return glMultiTexCoord4dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4dARB$address() {
        return glMultiTexCoord4dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4dARB(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dvARB$descriptor() {
        return glMultiTexCoord4dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dvARB$handle() {
        return glMultiTexCoord4dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dvARB$address() {
        return glMultiTexCoord4dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fARB$descriptor() {
        return glMultiTexCoord4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4fARB$handle() {
        return glMultiTexCoord4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4fARB$address() {
        return glMultiTexCoord4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4fARB(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fvARB$descriptor() {
        return glMultiTexCoord4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fvARB$handle() {
        return glMultiTexCoord4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fvARB$address() {
        return glMultiTexCoord4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iARB$descriptor() {
        return glMultiTexCoord4iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4iARB$handle() {
        return glMultiTexCoord4iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4iARB$address() {
        return glMultiTexCoord4iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4iARB(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4ivARB$descriptor() {
        return glMultiTexCoord4ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4ivARB$handle() {
        return glMultiTexCoord4ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4ivARB$address() {
        return glMultiTexCoord4ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT,
            glut_h.C_SHORT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sARB$descriptor() {
        return glMultiTexCoord4sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4sARB$handle() {
        return glMultiTexCoord4sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4sARB$address() {
        return glMultiTexCoord4sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4sARB(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glMultiTexCoord4svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4svARB$descriptor() {
        return glMultiTexCoord4svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4svARB$handle() {
        return glMultiTexCoord4svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4svARB$address() {
        return glMultiTexCoord4svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = glut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = glut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t khronos_int32_t
     * }
     */
    public static final OfInt khronos_int32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t khronos_uint32_t
     * }
     */
    public static final OfInt khronos_uint32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t khronos_int64_t
     * }
     */
    public static final OfLong khronos_int64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t khronos_uint64_t
     * }
     */
    public static final OfLong khronos_uint64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char khronos_int8_t
     * }
     */
    public static final OfByte khronos_int8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char khronos_uint8_t
     * }
     */
    public static final OfByte khronos_uint8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short khronos_int16_t
     * }
     */
    public static final OfShort khronos_int16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short khronos_uint16_t
     * }
     */
    public static final OfShort khronos_uint16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long khronos_intptr_t
     * }
     */
    public static final OfLong khronos_intptr_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long khronos_uintptr_t
     * }
     */
    public static final OfLong khronos_uintptr_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long khronos_ssize_t
     * }
     */
    public static final OfLong khronos_ssize_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long khronos_usize_t
     * }
     */
    public static final OfLong khronos_usize_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef float khronos_float_t
     * }
     */
    public static final OfFloat khronos_float_t = glut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t khronos_utime_nanoseconds_t
     * }
     */
    public static final OfLong khronos_utime_nanoseconds_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t khronos_stime_nanoseconds_t
     * }
     */
    public static final OfLong khronos_stime_nanoseconds_t = glut_h.C_LONG;
    private static final int KHRONOS_FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_FALSE = 0
     * }
     */
    public static int KHRONOS_FALSE() {
        return KHRONOS_FALSE;
    }
    private static final int KHRONOS_TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_TRUE = 1
     * }
     */
    public static int KHRONOS_TRUE() {
        return KHRONOS_TRUE;
    }
    private static final int KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 2147483647
     * }
     */
    public static int KHRONOS_BOOLEAN_ENUM_FORCE_SIZE() {
        return KHRONOS_BOOLEAN_ENUM_FORCE_SIZE;
    }
    /**
     * {@snippet lang=c :
     * typedef khronos_ssize_t GLsizeiptr
     * }
     */
    public static final OfLong GLsizeiptr = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_intptr_t GLintptr
     * }
     */
    public static final OfLong GLintptr = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char GLchar
     * }
     */
    public static final OfByte GLchar = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint16_t GLhalf
     * }
     */
    public static final OfShort GLhalf = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct __GLsync *GLsync
     * }
     */
    public static final AddressLayout GLsync = glut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t GLuint64
     * }
     */
    public static final OfLong GLuint64 = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t GLint64
     * }
     */
    public static final OfLong GLint64 = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t GLuint64EXT
     * }
     */
    public static final OfLong GLuint64EXT = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint16_t GLhalfARB
     * }
     */
    public static final OfShort GLhalfARB = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLhandleARB
     * }
     */
    public static final OfInt GLhandleARB = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char GLcharARB
     * }
     */
    public static final OfByte GLcharARB = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef khronos_ssize_t GLsizeiptrARB
     * }
     */
    public static final OfLong GLsizeiptrARB = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_intptr_t GLintptrARB
     * }
     */
    public static final OfLong GLintptrARB = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int32_t GLfixed
     * }
     */
    public static final OfInt GLfixed = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t GLint64EXT
     * }
     */
    public static final OfLong GLint64EXT = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *GLeglImageOES
     * }
     */
    public static final AddressLayout GLeglImageOES = glut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *GLeglClientBufferEXT
     * }
     */
    public static final AddressLayout GLeglClientBufferEXT = glut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short GLhalfNV
     * }
     */
    public static final OfShort GLhalfNV = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef GLintptr GLvdpauSurfaceNV
     * }
     */
    public static final OfLong GLvdpauSurfaceNV = glut_h.C_LONG;

    private static class glBlendEquationSeparateATI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glBlendEquationSeparateATI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static FunctionDescriptor glBlendEquationSeparateATI$descriptor() {
        return glBlendEquationSeparateATI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static MethodHandle glBlendEquationSeparateATI$handle() {
        return glBlendEquationSeparateATI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static MemorySegment glBlendEquationSeparateATI$address() {
        return glBlendEquationSeparateATI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static void glBlendEquationSeparateATI(int modeRGB, int modeA) {
        var mh$ = glBlendEquationSeparateATI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquationSeparateATI", modeRGB, modeA);
            }
            mh$.invokeExact(modeRGB, modeA);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBeginCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluBeginCurve$descriptor() {
        return gluBeginCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluBeginCurve$handle() {
        return gluBeginCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluBeginCurve$address() {
        return gluBeginCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static void gluBeginCurve(MemorySegment nurb) {
        var mh$ = gluBeginCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginCurve", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluBeginPolygon$descriptor() {
        return gluBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluBeginPolygon$handle() {
        return gluBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluBeginPolygon$address() {
        return gluBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluBeginPolygon(MemorySegment tess) {
        var mh$ = gluBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBeginSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluBeginSurface$descriptor() {
        return gluBeginSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluBeginSurface$handle() {
        return gluBeginSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluBeginSurface$address() {
        return gluBeginSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static void gluBeginSurface(MemorySegment nurb) {
        var mh$ = gluBeginSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginSurface", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBeginTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluBeginTrim$descriptor() {
        return gluBeginTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluBeginTrim$handle() {
        return gluBeginTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluBeginTrim$address() {
        return gluBeginTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static void gluBeginTrim(MemorySegment nurb) {
        var mh$ = gluBeginTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginTrim", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild1DMipmapLevels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBuild1DMipmapLevels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild1DMipmapLevels$descriptor() {
        return gluBuild1DMipmapLevels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MethodHandle gluBuild1DMipmapLevels$handle() {
        return gluBuild1DMipmapLevels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MemorySegment gluBuild1DMipmapLevels$address() {
        return gluBuild1DMipmapLevels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int base, int max, MemorySegment data) {
        var mh$ = gluBuild1DMipmapLevels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild1DMipmapLevels", target, internalFormat, width, format, type, level, base, max, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, format, type, level, base, max, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild1DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBuild1DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild1DMipmaps$descriptor() {
        return gluBuild1DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild1DMipmaps$handle() {
        return gluBuild1DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild1DMipmaps$address() {
        return gluBuild1DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, MemorySegment data) {
        var mh$ = gluBuild1DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild1DMipmaps", target, internalFormat, width, format, type, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild2DMipmapLevels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBuild2DMipmapLevels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild2DMipmapLevels$descriptor() {
        return gluBuild2DMipmapLevels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MethodHandle gluBuild2DMipmapLevels$handle() {
        return gluBuild2DMipmapLevels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MemorySegment gluBuild2DMipmapLevels$address() {
        return gluBuild2DMipmapLevels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int base, int max, MemorySegment data) {
        var mh$ = gluBuild2DMipmapLevels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild2DMipmapLevels", target, internalFormat, width, height, format, type, level, base, max, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, format, type, level, base, max, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild2DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBuild2DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild2DMipmaps$descriptor() {
        return gluBuild2DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild2DMipmaps$handle() {
        return gluBuild2DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild2DMipmaps$address() {
        return gluBuild2DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, MemorySegment data) {
        var mh$ = gluBuild2DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild2DMipmaps", target, internalFormat, width, height, format, type, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild3DMipmapLevels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBuild3DMipmapLevels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild3DMipmapLevels$descriptor() {
        return gluBuild3DMipmapLevels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MethodHandle gluBuild3DMipmapLevels$handle() {
        return gluBuild3DMipmapLevels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MemorySegment gluBuild3DMipmapLevels$address() {
        return gluBuild3DMipmapLevels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int base, int max, MemorySegment data) {
        var mh$ = gluBuild3DMipmapLevels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild3DMipmapLevels", target, internalFormat, width, height, depth, format, type, level, base, max, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, depth, format, type, level, base, max, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild3DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluBuild3DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild3DMipmaps$descriptor() {
        return gluBuild3DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild3DMipmaps$handle() {
        return gluBuild3DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild3DMipmaps$address() {
        return gluBuild3DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, MemorySegment data) {
        var mh$ = gluBuild3DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild3DMipmaps", target, internalFormat, width, height, depth, format, type, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, depth, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluCheckExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_CHAR,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluCheckExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static FunctionDescriptor gluCheckExtension$descriptor() {
        return gluCheckExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static MethodHandle gluCheckExtension$handle() {
        return gluCheckExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static MemorySegment gluCheckExtension$address() {
        return gluCheckExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static byte gluCheckExtension(MemorySegment extName, MemorySegment extString) {
        var mh$ = gluCheckExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluCheckExtension", extName, extString);
            }
            return (byte)mh$.invokeExact(extName, extString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluCylinder$descriptor() {
        return gluCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluCylinder$handle() {
        return gluCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluCylinder$address() {
        return gluCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static void gluCylinder(MemorySegment quad, double base, double top, double height, int slices, int stacks) {
        var mh$ = gluCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluCylinder", quad, base, top, height, slices, stacks);
            }
            mh$.invokeExact(quad, base, top, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluDeleteNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluDeleteNurbsRenderer$descriptor() {
        return gluDeleteNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluDeleteNurbsRenderer$handle() {
        return gluDeleteNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluDeleteNurbsRenderer$address() {
        return gluDeleteNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static void gluDeleteNurbsRenderer(MemorySegment nurb) {
        var mh$ = gluDeleteNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteNurbsRenderer", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluDeleteQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static FunctionDescriptor gluDeleteQuadric$descriptor() {
        return gluDeleteQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static MethodHandle gluDeleteQuadric$handle() {
        return gluDeleteQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static MemorySegment gluDeleteQuadric$address() {
        return gluDeleteQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static void gluDeleteQuadric(MemorySegment quad) {
        var mh$ = gluDeleteQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteQuadric", quad);
            }
            mh$.invokeExact(quad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluDeleteTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluDeleteTess$descriptor() {
        return gluDeleteTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluDeleteTess$handle() {
        return gluDeleteTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluDeleteTess$address() {
        return gluDeleteTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static void gluDeleteTess(MemorySegment tess) {
        var mh$ = gluDeleteTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteTess", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static FunctionDescriptor gluDisk$descriptor() {
        return gluDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static MethodHandle gluDisk$handle() {
        return gluDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static MemorySegment gluDisk$address() {
        return gluDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static void gluDisk(MemorySegment quad, double inner, double outer, int slices, int loops) {
        var mh$ = gluDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDisk", quad, inner, outer, slices, loops);
            }
            mh$.invokeExact(quad, inner, outer, slices, loops);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluEndCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluEndCurve$descriptor() {
        return gluEndCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluEndCurve$handle() {
        return gluEndCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluEndCurve$address() {
        return gluEndCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static void gluEndCurve(MemorySegment nurb) {
        var mh$ = gluEndCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndCurve", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluEndPolygon$descriptor() {
        return gluEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluEndPolygon$handle() {
        return gluEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluEndPolygon$address() {
        return gluEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluEndPolygon(MemorySegment tess) {
        var mh$ = gluEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluEndSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluEndSurface$descriptor() {
        return gluEndSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluEndSurface$handle() {
        return gluEndSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluEndSurface$address() {
        return gluEndSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static void gluEndSurface(MemorySegment nurb) {
        var mh$ = gluEndSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndSurface", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluEndTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluEndTrim$descriptor() {
        return gluEndTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluEndTrim$handle() {
        return gluEndTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluEndTrim$address() {
        return gluEndTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static void gluEndTrim(MemorySegment nurb) {
        var mh$ = gluEndTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndTrim", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluErrorString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluErrorString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static FunctionDescriptor gluErrorString$descriptor() {
        return gluErrorString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static MethodHandle gluErrorString$handle() {
        return gluErrorString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static MemorySegment gluErrorString$address() {
        return gluErrorString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static MemorySegment gluErrorString(int error) {
        var mh$ = gluErrorString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluErrorString", error);
            }
            return (MemorySegment)mh$.invokeExact(error);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluGetNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static FunctionDescriptor gluGetNurbsProperty$descriptor() {
        return gluGetNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static MethodHandle gluGetNurbsProperty$handle() {
        return gluGetNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static MemorySegment gluGetNurbsProperty$address() {
        return gluGetNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static void gluGetNurbsProperty(MemorySegment nurb, int property, MemorySegment data) {
        var mh$ = gluGetNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetNurbsProperty", nurb, property, data);
            }
            mh$.invokeExact(nurb, property, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor gluGetString$descriptor() {
        return gluGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MethodHandle gluGetString$handle() {
        return gluGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString$address() {
        return gluGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString(int name) {
        var mh$ = gluGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluGetTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static FunctionDescriptor gluGetTessProperty$descriptor() {
        return gluGetTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static MethodHandle gluGetTessProperty$handle() {
        return gluGetTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static MemorySegment gluGetTessProperty$address() {
        return gluGetTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static void gluGetTessProperty(MemorySegment tess, int which, MemorySegment data) {
        var mh$ = gluGetTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetTessProperty", tess, which, data);
            }
            mh$.invokeExact(tess, which, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLoadSamplingMatrices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluLoadSamplingMatrices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static FunctionDescriptor gluLoadSamplingMatrices$descriptor() {
        return gluLoadSamplingMatrices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static MethodHandle gluLoadSamplingMatrices$handle() {
        return gluLoadSamplingMatrices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static MemorySegment gluLoadSamplingMatrices$address() {
        return gluLoadSamplingMatrices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static void gluLoadSamplingMatrices(MemorySegment nurb, MemorySegment model, MemorySegment perspective, MemorySegment view) {
        var mh$ = gluLoadSamplingMatrices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLoadSamplingMatrices", nurb, model, perspective, view);
            }
            mh$.invokeExact(nurb, model, perspective, view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLookAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluLookAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static FunctionDescriptor gluLookAt$descriptor() {
        return gluLookAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static MethodHandle gluLookAt$handle() {
        return gluLookAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static MemorySegment gluLookAt$address() {
        return gluLookAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static void gluLookAt(double eyeX, double eyeY, double eyeZ, double centerX, double centerY, double centerZ, double upX, double upY, double upZ) {
        var mh$ = gluLookAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLookAt", eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
            }
            mh$.invokeExact(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNewNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static FunctionDescriptor gluNewNurbsRenderer$descriptor() {
        return gluNewNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MethodHandle gluNewNurbsRenderer$handle() {
        return gluNewNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer$address() {
        return gluNewNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer() {
        var mh$ = gluNewNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewNurbsRenderer");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNewQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static FunctionDescriptor gluNewQuadric$descriptor() {
        return gluNewQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MethodHandle gluNewQuadric$handle() {
        return gluNewQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric$address() {
        return gluNewQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric() {
        var mh$ = gluNewQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewQuadric");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNewTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static FunctionDescriptor gluNewTess$descriptor() {
        return gluNewTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MethodHandle gluNewTess$handle() {
        return gluNewTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess$address() {
        return gluNewTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess() {
        var mh$ = gluNewTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewTess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNextContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNextContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNextContour$descriptor() {
        return gluNextContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MethodHandle gluNextContour$handle() {
        return gluNextContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MemorySegment gluNextContour$address() {
        return gluNextContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static void gluNextContour(MemorySegment tess, int type) {
        var mh$ = gluNextContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNextContour", tess, type);
            }
            mh$.invokeExact(tess, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNurbsCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nurb, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static FunctionDescriptor gluNurbsCallback$descriptor() {
        return gluNurbsCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nurb, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static MethodHandle gluNurbsCallback$handle() {
        return gluNurbsCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nurb, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static MemorySegment gluNurbsCallback$address() {
        return gluNurbsCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nurb, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static void gluNurbsCallback(MemorySegment nurb, int which, MemorySegment CallBackFunc) {
        var mh$ = gluNurbsCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallback", nurb, which, CallBackFunc);
            }
            mh$.invokeExact(nurb, which, CallBackFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallbackData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNurbsCallbackData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static FunctionDescriptor gluNurbsCallbackData$descriptor() {
        return gluNurbsCallbackData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MethodHandle gluNurbsCallbackData$handle() {
        return gluNurbsCallbackData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MemorySegment gluNurbsCallbackData$address() {
        return gluNurbsCallbackData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static void gluNurbsCallbackData(MemorySegment nurb, MemorySegment userData) {
        var mh$ = gluNurbsCallbackData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallbackData", nurb, userData);
            }
            mh$.invokeExact(nurb, userData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallbackDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNurbsCallbackDataEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static FunctionDescriptor gluNurbsCallbackDataEXT$descriptor() {
        return gluNurbsCallbackDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MethodHandle gluNurbsCallbackDataEXT$handle() {
        return gluNurbsCallbackDataEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MemorySegment gluNurbsCallbackDataEXT$address() {
        return gluNurbsCallbackDataEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static void gluNurbsCallbackDataEXT(MemorySegment nurb, MemorySegment userData) {
        var mh$ = gluNurbsCallbackDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallbackDataEXT", nurb, userData);
            }
            mh$.invokeExact(nurb, userData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNurbsCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsCurve$descriptor() {
        return gluNurbsCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsCurve$handle() {
        return gluNurbsCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsCurve$address() {
        return gluNurbsCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static void gluNurbsCurve(MemorySegment nurb, int knotCount, MemorySegment knots, int stride, MemorySegment control, int order, int type) {
        var mh$ = gluNurbsCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCurve", nurb, knotCount, knots, stride, control, order, type);
            }
            mh$.invokeExact(nurb, knotCount, knots, stride, control, order, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static FunctionDescriptor gluNurbsProperty$descriptor() {
        return gluNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static MethodHandle gluNurbsProperty$handle() {
        return gluNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static MemorySegment gluNurbsProperty$address() {
        return gluNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static void gluNurbsProperty(MemorySegment nurb, int property, float value) {
        var mh$ = gluNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsProperty", nurb, property, value);
            }
            mh$.invokeExact(nurb, property, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluNurbsSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsSurface$descriptor() {
        return gluNurbsSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsSurface$handle() {
        return gluNurbsSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsSurface$address() {
        return gluNurbsSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static void gluNurbsSurface(MemorySegment nurb, int sKnotCount, MemorySegment sKnots, int tKnotCount, MemorySegment tKnots, int sStride, int tStride, MemorySegment control, int sOrder, int tOrder, int type) {
        var mh$ = gluNurbsSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsSurface", nurb, sKnotCount, sKnots, tKnotCount, tKnots, sStride, tStride, control, sOrder, tOrder, type);
            }
            mh$.invokeExact(nurb, sKnotCount, sKnots, tKnotCount, tKnots, sStride, tStride, control, sOrder, tOrder, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluOrtho2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluOrtho2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static FunctionDescriptor gluOrtho2D$descriptor() {
        return gluOrtho2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MethodHandle gluOrtho2D$handle() {
        return gluOrtho2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MemorySegment gluOrtho2D$address() {
        return gluOrtho2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static void gluOrtho2D(double left, double right, double bottom, double top) {
        var mh$ = gluOrtho2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluOrtho2D", left, right, bottom, top);
            }
            mh$.invokeExact(left, right, bottom, top);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPartialDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluPartialDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static FunctionDescriptor gluPartialDisk$descriptor() {
        return gluPartialDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static MethodHandle gluPartialDisk$handle() {
        return gluPartialDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static MemorySegment gluPartialDisk$address() {
        return gluPartialDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static void gluPartialDisk(MemorySegment quad, double inner, double outer, int slices, int loops, double start, double sweep) {
        var mh$ = gluPartialDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPartialDisk", quad, inner, outer, slices, loops, start, sweep);
            }
            mh$.invokeExact(quad, inner, outer, slices, loops, start, sweep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor gluPerspective$descriptor() {
        return gluPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle gluPerspective$handle() {
        return gluPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment gluPerspective$address() {
        return gluPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void gluPerspective(double fovy, double aspect, double zNear, double zFar) {
        var mh$ = gluPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPerspective", fovy, aspect, zNear, zFar);
            }
            mh$.invokeExact(fovy, aspect, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPickMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluPickMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static FunctionDescriptor gluPickMatrix$descriptor() {
        return gluPickMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static MethodHandle gluPickMatrix$handle() {
        return gluPickMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static MemorySegment gluPickMatrix$address() {
        return gluPickMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static void gluPickMatrix(double x, double y, double delX, double delY, MemorySegment viewport) {
        var mh$ = gluPickMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPickMatrix", x, y, delX, delY, viewport);
            }
            mh$.invokeExact(x, y, delX, delY, viewport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static FunctionDescriptor gluProject$descriptor() {
        return gluProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static MethodHandle gluProject$handle() {
        return gluProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static MemorySegment gluProject$address() {
        return gluProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static int gluProject(double objX, double objY, double objZ, MemorySegment model, MemorySegment proj, MemorySegment view, MemorySegment winX, MemorySegment winY, MemorySegment winZ) {
        var mh$ = gluProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluProject", objX, objY, objZ, model, proj, view, winX, winY, winZ);
            }
            return (int)mh$.invokeExact(objX, objY, objZ, model, proj, view, winX, winY, winZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPwlCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluPwlCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static FunctionDescriptor gluPwlCurve$descriptor() {
        return gluPwlCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static MethodHandle gluPwlCurve$handle() {
        return gluPwlCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static MemorySegment gluPwlCurve$address() {
        return gluPwlCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static void gluPwlCurve(MemorySegment nurb, int count, MemorySegment data, int stride, int type) {
        var mh$ = gluPwlCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPwlCurve", nurb, count, data, stride, type);
            }
            mh$.invokeExact(nurb, count, data, stride, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluQuadricCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *quad, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static FunctionDescriptor gluQuadricCallback$descriptor() {
        return gluQuadricCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *quad, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static MethodHandle gluQuadricCallback$handle() {
        return gluQuadricCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *quad, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static MemorySegment gluQuadricCallback$address() {
        return gluQuadricCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *quad, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static void gluQuadricCallback(MemorySegment quad, int which, MemorySegment CallBackFunc) {
        var mh$ = gluQuadricCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricCallback", quad, which, CallBackFunc);
            }
            mh$.invokeExact(quad, which, CallBackFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricDrawStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluQuadricDrawStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static FunctionDescriptor gluQuadricDrawStyle$descriptor() {
        return gluQuadricDrawStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static MethodHandle gluQuadricDrawStyle$handle() {
        return gluQuadricDrawStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static MemorySegment gluQuadricDrawStyle$address() {
        return gluQuadricDrawStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static void gluQuadricDrawStyle(MemorySegment quad, int draw) {
        var mh$ = gluQuadricDrawStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricDrawStyle", quad, draw);
            }
            mh$.invokeExact(quad, draw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricNormals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluQuadricNormals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static FunctionDescriptor gluQuadricNormals$descriptor() {
        return gluQuadricNormals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static MethodHandle gluQuadricNormals$handle() {
        return gluQuadricNormals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static MemorySegment gluQuadricNormals$address() {
        return gluQuadricNormals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static void gluQuadricNormals(MemorySegment quad, int normal) {
        var mh$ = gluQuadricNormals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricNormals", quad, normal);
            }
            mh$.invokeExact(quad, normal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluQuadricOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static FunctionDescriptor gluQuadricOrientation$descriptor() {
        return gluQuadricOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static MethodHandle gluQuadricOrientation$handle() {
        return gluQuadricOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static MemorySegment gluQuadricOrientation$address() {
        return gluQuadricOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static void gluQuadricOrientation(MemorySegment quad, int orientation) {
        var mh$ = gluQuadricOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricOrientation", quad, orientation);
            }
            mh$.invokeExact(quad, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_CHAR
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluQuadricTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static FunctionDescriptor gluQuadricTexture$descriptor() {
        return gluQuadricTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static MethodHandle gluQuadricTexture$handle() {
        return gluQuadricTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static MemorySegment gluQuadricTexture$address() {
        return gluQuadricTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static void gluQuadricTexture(MemorySegment quad, byte texture) {
        var mh$ = gluQuadricTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricTexture", quad, texture);
            }
            mh$.invokeExact(quad, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluScaleImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluScaleImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static FunctionDescriptor gluScaleImage$descriptor() {
        return gluScaleImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static MethodHandle gluScaleImage$handle() {
        return gluScaleImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static MemorySegment gluScaleImage$address() {
        return gluScaleImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static int gluScaleImage(int format, int wIn, int hIn, int typeIn, MemorySegment dataIn, int wOut, int hOut, int typeOut, MemorySegment dataOut) {
        var mh$ = gluScaleImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluScaleImage", format, wIn, hIn, typeIn, dataIn, wOut, hOut, typeOut, dataOut);
            }
            return (int)mh$.invokeExact(format, wIn, hIn, typeIn, dataIn, wOut, hOut, typeOut, dataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluSphere$descriptor() {
        return gluSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluSphere$handle() {
        return gluSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluSphere$address() {
        return gluSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static void gluSphere(MemorySegment quad, double radius, int slices, int stacks) {
        var mh$ = gluSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluSphere", quad, radius, slices, stacks);
            }
            mh$.invokeExact(quad, radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessBeginContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessBeginContour$descriptor() {
        return gluTessBeginContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessBeginContour$handle() {
        return gluTessBeginContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessBeginContour$address() {
        return gluTessBeginContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessBeginContour(MemorySegment tess) {
        var mh$ = gluTessBeginContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static FunctionDescriptor gluTessBeginPolygon$descriptor() {
        return gluTessBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static MethodHandle gluTessBeginPolygon$handle() {
        return gluTessBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static MemorySegment gluTessBeginPolygon$address() {
        return gluTessBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static void gluTessBeginPolygon(MemorySegment tess, MemorySegment data) {
        var mh$ = gluTessBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginPolygon", tess, data);
            }
            mh$.invokeExact(tess, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static FunctionDescriptor gluTessCallback$descriptor() {
        return gluTessCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static MethodHandle gluTessCallback$handle() {
        return gluTessCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static MemorySegment gluTessCallback$address() {
        return gluTessCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, _GLUfuncptr CallBackFunc)
     * }
     */
    public static void gluTessCallback(MemorySegment tess, int which, MemorySegment CallBackFunc) {
        var mh$ = gluTessCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessCallback", tess, which, CallBackFunc);
            }
            mh$.invokeExact(tess, which, CallBackFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessEndContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndContour$descriptor() {
        return gluTessEndContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndContour$handle() {
        return gluTessEndContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndContour$address() {
        return gluTessEndContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndContour(MemorySegment tess) {
        var mh$ = gluTessEndContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndPolygon$descriptor() {
        return gluTessEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndPolygon$handle() {
        return gluTessEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndPolygon$address() {
        return gluTessEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndPolygon(MemorySegment tess) {
        var mh$ = gluTessEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessNormal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessNormal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static FunctionDescriptor gluTessNormal$descriptor() {
        return gluTessNormal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static MethodHandle gluTessNormal$handle() {
        return gluTessNormal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static MemorySegment gluTessNormal$address() {
        return gluTessNormal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static void gluTessNormal(MemorySegment tess, double valueX, double valueY, double valueZ) {
        var mh$ = gluTessNormal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessNormal", tess, valueX, valueY, valueZ);
            }
            mh$.invokeExact(tess, valueX, valueY, valueZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static FunctionDescriptor gluTessProperty$descriptor() {
        return gluTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static MethodHandle gluTessProperty$handle() {
        return gluTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static MemorySegment gluTessProperty$address() {
        return gluTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static void gluTessProperty(MemorySegment tess, int which, double data) {
        var mh$ = gluTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessProperty", tess, which, data);
            }
            mh$.invokeExact(tess, which, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluTessVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static FunctionDescriptor gluTessVertex$descriptor() {
        return gluTessVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static MethodHandle gluTessVertex$handle() {
        return gluTessVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static MemorySegment gluTessVertex$address() {
        return gluTessVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static void gluTessVertex(MemorySegment tess, MemorySegment location, MemorySegment data) {
        var mh$ = gluTessVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessVertex", tess, location, data);
            }
            mh$.invokeExact(tess, location, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluUnProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluUnProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static FunctionDescriptor gluUnProject$descriptor() {
        return gluUnProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static MethodHandle gluUnProject$handle() {
        return gluUnProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static MemorySegment gluUnProject$address() {
        return gluUnProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static int gluUnProject(double winX, double winY, double winZ, MemorySegment model, MemorySegment proj, MemorySegment view, MemorySegment objX, MemorySegment objY, MemorySegment objZ) {
        var mh$ = gluUnProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluUnProject", winX, winY, winZ, model, proj, view, objX, objY, objZ);
            }
            return (int)mh$.invokeExact(winX, winY, winZ, model, proj, view, objX, objY, objZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluUnProject4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gluUnProject4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static FunctionDescriptor gluUnProject4$descriptor() {
        return gluUnProject4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static MethodHandle gluUnProject4$handle() {
        return gluUnProject4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static MemorySegment gluUnProject4$address() {
        return gluUnProject4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static int gluUnProject4(double winX, double winY, double winZ, double clipW, MemorySegment model, MemorySegment proj, MemorySegment view, double nearVal, double farVal, MemorySegment objX, MemorySegment objY, MemorySegment objZ, MemorySegment objW) {
        var mh$ = gluUnProject4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluUnProject4", winX, winY, winZ, clipW, model, proj, view, nearVal, farVal, objX, objY, objZ, objW);
            }
            return (int)mh$.invokeExact(winX, winY, winZ, clipW, model, proj, view, nearVal, farVal, objX, objY, objZ, objW);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeRoman$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutStrokeRoman").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static AddressLayout glutStrokeRoman$layout() {
        return glutStrokeRoman$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static MemorySegment glutStrokeRoman$segment() {
        return glutStrokeRoman$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static MemorySegment glutStrokeRoman() {
        return glutStrokeRoman$constants.SEGMENT.get(glutStrokeRoman$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static void glutStrokeRoman(MemorySegment varValue) {
        glutStrokeRoman$constants.SEGMENT.set(glutStrokeRoman$constants.LAYOUT, 0L, varValue);
    }

    private static class glutStrokeMonoRoman$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutStrokeMonoRoman").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static AddressLayout glutStrokeMonoRoman$layout() {
        return glutStrokeMonoRoman$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static MemorySegment glutStrokeMonoRoman$segment() {
        return glutStrokeMonoRoman$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static MemorySegment glutStrokeMonoRoman() {
        return glutStrokeMonoRoman$constants.SEGMENT.get(glutStrokeMonoRoman$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static void glutStrokeMonoRoman(MemorySegment varValue) {
        glutStrokeMonoRoman$constants.SEGMENT.set(glutStrokeMonoRoman$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmap9By15$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutBitmap9By15").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static AddressLayout glutBitmap9By15$layout() {
        return glutBitmap9By15$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static MemorySegment glutBitmap9By15$segment() {
        return glutBitmap9By15$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static MemorySegment glutBitmap9By15() {
        return glutBitmap9By15$constants.SEGMENT.get(glutBitmap9By15$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static void glutBitmap9By15(MemorySegment varValue) {
        glutBitmap9By15$constants.SEGMENT.set(glutBitmap9By15$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmap8By13$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutBitmap8By13").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static AddressLayout glutBitmap8By13$layout() {
        return glutBitmap8By13$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static MemorySegment glutBitmap8By13$segment() {
        return glutBitmap8By13$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static MemorySegment glutBitmap8By13() {
        return glutBitmap8By13$constants.SEGMENT.get(glutBitmap8By13$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static void glutBitmap8By13(MemorySegment varValue) {
        glutBitmap8By13$constants.SEGMENT.set(glutBitmap8By13$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapTimesRoman10$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutBitmapTimesRoman10").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static AddressLayout glutBitmapTimesRoman10$layout() {
        return glutBitmapTimesRoman10$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static MemorySegment glutBitmapTimesRoman10$segment() {
        return glutBitmapTimesRoman10$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static MemorySegment glutBitmapTimesRoman10() {
        return glutBitmapTimesRoman10$constants.SEGMENT.get(glutBitmapTimesRoman10$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static void glutBitmapTimesRoman10(MemorySegment varValue) {
        glutBitmapTimesRoman10$constants.SEGMENT.set(glutBitmapTimesRoman10$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapTimesRoman24$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutBitmapTimesRoman24").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static AddressLayout glutBitmapTimesRoman24$layout() {
        return glutBitmapTimesRoman24$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static MemorySegment glutBitmapTimesRoman24$segment() {
        return glutBitmapTimesRoman24$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static MemorySegment glutBitmapTimesRoman24() {
        return glutBitmapTimesRoman24$constants.SEGMENT.get(glutBitmapTimesRoman24$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static void glutBitmapTimesRoman24(MemorySegment varValue) {
        glutBitmapTimesRoman24$constants.SEGMENT.set(glutBitmapTimesRoman24$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapHelvetica10$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutBitmapHelvetica10").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static AddressLayout glutBitmapHelvetica10$layout() {
        return glutBitmapHelvetica10$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static MemorySegment glutBitmapHelvetica10$segment() {
        return glutBitmapHelvetica10$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static MemorySegment glutBitmapHelvetica10() {
        return glutBitmapHelvetica10$constants.SEGMENT.get(glutBitmapHelvetica10$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static void glutBitmapHelvetica10(MemorySegment varValue) {
        glutBitmapHelvetica10$constants.SEGMENT.set(glutBitmapHelvetica10$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapHelvetica12$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutBitmapHelvetica12").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static AddressLayout glutBitmapHelvetica12$layout() {
        return glutBitmapHelvetica12$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static MemorySegment glutBitmapHelvetica12$segment() {
        return glutBitmapHelvetica12$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static MemorySegment glutBitmapHelvetica12() {
        return glutBitmapHelvetica12$constants.SEGMENT.get(glutBitmapHelvetica12$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static void glutBitmapHelvetica12(MemorySegment varValue) {
        glutBitmapHelvetica12$constants.SEGMENT.set(glutBitmapHelvetica12$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapHelvetica18$constants {
        public static final AddressLayout LAYOUT = glut_h.C_POINTER;
        public static final MemorySegment SEGMENT = glut_h.findOrThrow("glutBitmapHelvetica18").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static AddressLayout glutBitmapHelvetica18$layout() {
        return glutBitmapHelvetica18$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static MemorySegment glutBitmapHelvetica18$segment() {
        return glutBitmapHelvetica18$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static MemorySegment glutBitmapHelvetica18() {
        return glutBitmapHelvetica18$constants.SEGMENT.get(glutBitmapHelvetica18$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static void glutBitmapHelvetica18(MemorySegment varValue) {
        glutBitmapHelvetica18$constants.SEGMENT.set(glutBitmapHelvetica18$constants.LAYOUT, 0L, varValue);
    }

    private static class glutInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static FunctionDescriptor glutInit$descriptor() {
        return glutInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static MethodHandle glutInit$handle() {
        return glutInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static MemorySegment glutInit$address() {
        return glutInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static void glutInit(MemorySegment pargc, MemorySegment argv) {
        var mh$ = glutInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInit", pargc, argv);
            }
            mh$.invokeExact(pargc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutInitWindowPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static FunctionDescriptor glutInitWindowPosition$descriptor() {
        return glutInitWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static MethodHandle glutInitWindowPosition$handle() {
        return glutInitWindowPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static MemorySegment glutInitWindowPosition$address() {
        return glutInitWindowPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static void glutInitWindowPosition(int x, int y) {
        var mh$ = glutInitWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWindowPosition", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutInitWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static FunctionDescriptor glutInitWindowSize$descriptor() {
        return glutInitWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static MethodHandle glutInitWindowSize$handle() {
        return glutInitWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static MemorySegment glutInitWindowSize$address() {
        return glutInitWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static void glutInitWindowSize(int width, int height) {
        var mh$ = glutInitWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWindowSize", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutInitDisplayMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static FunctionDescriptor glutInitDisplayMode$descriptor() {
        return glutInitDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static MethodHandle glutInitDisplayMode$handle() {
        return glutInitDisplayMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static MemorySegment glutInitDisplayMode$address() {
        return glutInitDisplayMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static void glutInitDisplayMode(int displayMode) {
        var mh$ = glutInitDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitDisplayMode", displayMode);
            }
            mh$.invokeExact(displayMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitDisplayString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutInitDisplayString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static FunctionDescriptor glutInitDisplayString$descriptor() {
        return glutInitDisplayString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static MethodHandle glutInitDisplayString$handle() {
        return glutInitDisplayString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static MemorySegment glutInitDisplayString$address() {
        return glutInitDisplayString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static void glutInitDisplayString(MemorySegment displayMode) {
        var mh$ = glutInitDisplayString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitDisplayString", displayMode);
            }
            mh$.invokeExact(displayMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMainLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutMainLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static FunctionDescriptor glutMainLoop$descriptor() {
        return glutMainLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static MethodHandle glutMainLoop$handle() {
        return glutMainLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static MemorySegment glutMainLoop$address() {
        return glutMainLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static void glutMainLoop() {
        var mh$ = glutMainLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMainLoop");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutCreateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static FunctionDescriptor glutCreateWindow$descriptor() {
        return glutCreateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static MethodHandle glutCreateWindow$handle() {
        return glutCreateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static MemorySegment glutCreateWindow$address() {
        return glutCreateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static int glutCreateWindow(MemorySegment title) {
        var mh$ = glutCreateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateWindow", title);
            }
            return (int)mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateSubWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutCreateSubWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutCreateSubWindow$descriptor() {
        return glutCreateSubWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutCreateSubWindow$handle() {
        return glutCreateSubWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutCreateSubWindow$address() {
        return glutCreateSubWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static int glutCreateSubWindow(int window, int x, int y, int width, int height) {
        var mh$ = glutCreateSubWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateSubWindow", window, x, y, width, height);
            }
            return (int)mh$.invokeExact(window, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutDestroyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static FunctionDescriptor glutDestroyWindow$descriptor() {
        return glutDestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static MethodHandle glutDestroyWindow$handle() {
        return glutDestroyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static MemorySegment glutDestroyWindow$address() {
        return glutDestroyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static void glutDestroyWindow(int window) {
        var mh$ = glutDestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDestroyWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static FunctionDescriptor glutSetWindow$descriptor() {
        return glutSetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static MethodHandle glutSetWindow$handle() {
        return glutSetWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static MemorySegment glutSetWindow$address() {
        return glutSetWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static void glutSetWindow(int window) {
        var mh$ = glutSetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutGetWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static FunctionDescriptor glutGetWindow$descriptor() {
        return glutGetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static MethodHandle glutGetWindow$handle() {
        return glutGetWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static MemorySegment glutGetWindow$address() {
        return glutGetWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static int glutGetWindow() {
        var mh$ = glutGetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetWindow");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindowTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetWindowTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static FunctionDescriptor glutSetWindowTitle$descriptor() {
        return glutSetWindowTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static MethodHandle glutSetWindowTitle$handle() {
        return glutSetWindowTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static MemorySegment glutSetWindowTitle$address() {
        return glutSetWindowTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static void glutSetWindowTitle(MemorySegment title) {
        var mh$ = glutSetWindowTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindowTitle", title);
            }
            mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetIconTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetIconTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static FunctionDescriptor glutSetIconTitle$descriptor() {
        return glutSetIconTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static MethodHandle glutSetIconTitle$handle() {
        return glutSetIconTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static MemorySegment glutSetIconTitle$address() {
        return glutSetIconTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static void glutSetIconTitle(MemorySegment title) {
        var mh$ = glutSetIconTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetIconTitle", title);
            }
            mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutReshapeWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static FunctionDescriptor glutReshapeWindow$descriptor() {
        return glutReshapeWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static MethodHandle glutReshapeWindow$handle() {
        return glutReshapeWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static MemorySegment glutReshapeWindow$address() {
        return glutReshapeWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static void glutReshapeWindow(int width, int height) {
        var mh$ = glutReshapeWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeWindow", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPositionWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPositionWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static FunctionDescriptor glutPositionWindow$descriptor() {
        return glutPositionWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static MethodHandle glutPositionWindow$handle() {
        return glutPositionWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static MemorySegment glutPositionWindow$address() {
        return glutPositionWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static void glutPositionWindow(int x, int y) {
        var mh$ = glutPositionWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPositionWindow", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutShowWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutShowWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static FunctionDescriptor glutShowWindow$descriptor() {
        return glutShowWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static MethodHandle glutShowWindow$handle() {
        return glutShowWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static MemorySegment glutShowWindow$address() {
        return glutShowWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static void glutShowWindow() {
        var mh$ = glutShowWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutShowWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutHideWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutHideWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static FunctionDescriptor glutHideWindow$descriptor() {
        return glutHideWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static MethodHandle glutHideWindow$handle() {
        return glutHideWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static MemorySegment glutHideWindow$address() {
        return glutHideWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static void glutHideWindow() {
        var mh$ = glutHideWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutHideWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIconifyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutIconifyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static FunctionDescriptor glutIconifyWindow$descriptor() {
        return glutIconifyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static MethodHandle glutIconifyWindow$handle() {
        return glutIconifyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static MemorySegment glutIconifyWindow$address() {
        return glutIconifyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static void glutIconifyWindow() {
        var mh$ = glutIconifyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIconifyWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPushWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPushWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static FunctionDescriptor glutPushWindow$descriptor() {
        return glutPushWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static MethodHandle glutPushWindow$handle() {
        return glutPushWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static MemorySegment glutPushWindow$address() {
        return glutPushWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static void glutPushWindow() {
        var mh$ = glutPushWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPushWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPopWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPopWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static FunctionDescriptor glutPopWindow$descriptor() {
        return glutPopWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static MethodHandle glutPopWindow$handle() {
        return glutPopWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static MemorySegment glutPopWindow$address() {
        return glutPopWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static void glutPopWindow() {
        var mh$ = glutPopWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPopWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutFullScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutFullScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static FunctionDescriptor glutFullScreen$descriptor() {
        return glutFullScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static MethodHandle glutFullScreen$handle() {
        return glutFullScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static MemorySegment glutFullScreen$address() {
        return glutFullScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static void glutFullScreen() {
        var mh$ = glutFullScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutFullScreen");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostWindowRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPostWindowRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static FunctionDescriptor glutPostWindowRedisplay$descriptor() {
        return glutPostWindowRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static MethodHandle glutPostWindowRedisplay$handle() {
        return glutPostWindowRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static MemorySegment glutPostWindowRedisplay$address() {
        return glutPostWindowRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static void glutPostWindowRedisplay(int window) {
        var mh$ = glutPostWindowRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostWindowRedisplay", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPostRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static FunctionDescriptor glutPostRedisplay$descriptor() {
        return glutPostRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static MethodHandle glutPostRedisplay$handle() {
        return glutPostRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static MemorySegment glutPostRedisplay$address() {
        return glutPostRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static void glutPostRedisplay() {
        var mh$ = glutPostRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostRedisplay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static FunctionDescriptor glutSwapBuffers$descriptor() {
        return glutSwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static MethodHandle glutSwapBuffers$handle() {
        return glutSwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static MemorySegment glutSwapBuffers$address() {
        return glutSwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static void glutSwapBuffers() {
        var mh$ = glutSwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSwapBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWarpPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWarpPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static FunctionDescriptor glutWarpPointer$descriptor() {
        return glutWarpPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static MethodHandle glutWarpPointer$handle() {
        return glutWarpPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static MemorySegment glutWarpPointer$address() {
        return glutWarpPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static void glutWarpPointer(int x, int y) {
        var mh$ = glutWarpPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWarpPointer", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static FunctionDescriptor glutSetCursor$descriptor() {
        return glutSetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static MethodHandle glutSetCursor$handle() {
        return glutSetCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static MemorySegment glutSetCursor$address() {
        return glutSetCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static void glutSetCursor(int cursor) {
        var mh$ = glutSetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetCursor", cursor);
            }
            mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEstablishOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutEstablishOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static FunctionDescriptor glutEstablishOverlay$descriptor() {
        return glutEstablishOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static MethodHandle glutEstablishOverlay$handle() {
        return glutEstablishOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static MemorySegment glutEstablishOverlay$address() {
        return glutEstablishOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static void glutEstablishOverlay() {
        var mh$ = glutEstablishOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEstablishOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutRemoveOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutRemoveOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static FunctionDescriptor glutRemoveOverlay$descriptor() {
        return glutRemoveOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static MethodHandle glutRemoveOverlay$handle() {
        return glutRemoveOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static MemorySegment glutRemoveOverlay$address() {
        return glutRemoveOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static void glutRemoveOverlay() {
        var mh$ = glutRemoveOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutRemoveOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutUseLayer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutUseLayer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static FunctionDescriptor glutUseLayer$descriptor() {
        return glutUseLayer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static MethodHandle glutUseLayer$handle() {
        return glutUseLayer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static MemorySegment glutUseLayer$address() {
        return glutUseLayer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static void glutUseLayer(int layer) {
        var mh$ = glutUseLayer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutUseLayer", layer);
            }
            mh$.invokeExact(layer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostOverlayRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPostOverlayRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static FunctionDescriptor glutPostOverlayRedisplay$descriptor() {
        return glutPostOverlayRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static MethodHandle glutPostOverlayRedisplay$handle() {
        return glutPostOverlayRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static MemorySegment glutPostOverlayRedisplay$address() {
        return glutPostOverlayRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static void glutPostOverlayRedisplay() {
        var mh$ = glutPostOverlayRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostOverlayRedisplay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostWindowOverlayRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPostWindowOverlayRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static FunctionDescriptor glutPostWindowOverlayRedisplay$descriptor() {
        return glutPostWindowOverlayRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static MethodHandle glutPostWindowOverlayRedisplay$handle() {
        return glutPostWindowOverlayRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static MemorySegment glutPostWindowOverlayRedisplay$address() {
        return glutPostWindowOverlayRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static void glutPostWindowOverlayRedisplay(int window) {
        var mh$ = glutPostWindowOverlayRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostWindowOverlayRedisplay", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutShowOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutShowOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static FunctionDescriptor glutShowOverlay$descriptor() {
        return glutShowOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static MethodHandle glutShowOverlay$handle() {
        return glutShowOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static MemorySegment glutShowOverlay$address() {
        return glutShowOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static void glutShowOverlay() {
        var mh$ = glutShowOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutShowOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutHideOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutHideOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static FunctionDescriptor glutHideOverlay$descriptor() {
        return glutHideOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static MethodHandle glutHideOverlay$handle() {
        return glutHideOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static MemorySegment glutHideOverlay$address() {
        return glutHideOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static void glutHideOverlay() {
        var mh$ = glutHideOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutHideOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutCreateMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutCreateMenu$descriptor() {
        return glutCreateMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static MethodHandle glutCreateMenu$handle() {
        return glutCreateMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static MemorySegment glutCreateMenu$address() {
        return glutCreateMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static int glutCreateMenu(MemorySegment callback) {
        var mh$ = glutCreateMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateMenu", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDestroyMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutDestroyMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static FunctionDescriptor glutDestroyMenu$descriptor() {
        return glutDestroyMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static MethodHandle glutDestroyMenu$handle() {
        return glutDestroyMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static MemorySegment glutDestroyMenu$address() {
        return glutDestroyMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static void glutDestroyMenu(int menu) {
        var mh$ = glutDestroyMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDestroyMenu", menu);
            }
            mh$.invokeExact(menu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutGetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static FunctionDescriptor glutGetMenu$descriptor() {
        return glutGetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static MethodHandle glutGetMenu$handle() {
        return glutGetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static MemorySegment glutGetMenu$address() {
        return glutGetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static int glutGetMenu() {
        var mh$ = glutGetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetMenu");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static FunctionDescriptor glutSetMenu$descriptor() {
        return glutSetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static MethodHandle glutSetMenu$handle() {
        return glutSetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static MemorySegment glutSetMenu$address() {
        return glutSetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static void glutSetMenu(int menu) {
        var mh$ = glutSetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetMenu", menu);
            }
            mh$.invokeExact(menu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAddMenuEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutAddMenuEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutAddMenuEntry$descriptor() {
        return glutAddMenuEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static MethodHandle glutAddMenuEntry$handle() {
        return glutAddMenuEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static MemorySegment glutAddMenuEntry$address() {
        return glutAddMenuEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static void glutAddMenuEntry(MemorySegment label, int value) {
        var mh$ = glutAddMenuEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAddMenuEntry", label, value);
            }
            mh$.invokeExact(label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAddSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutAddSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static FunctionDescriptor glutAddSubMenu$descriptor() {
        return glutAddSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static MethodHandle glutAddSubMenu$handle() {
        return glutAddSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static MemorySegment glutAddSubMenu$address() {
        return glutAddSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static void glutAddSubMenu(MemorySegment label, int subMenu) {
        var mh$ = glutAddSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAddSubMenu", label, subMenu);
            }
            mh$.invokeExact(label, subMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutChangeToMenuEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutChangeToMenuEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutChangeToMenuEntry$descriptor() {
        return glutChangeToMenuEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static MethodHandle glutChangeToMenuEntry$handle() {
        return glutChangeToMenuEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static MemorySegment glutChangeToMenuEntry$address() {
        return glutChangeToMenuEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static void glutChangeToMenuEntry(int item, MemorySegment label, int value) {
        var mh$ = glutChangeToMenuEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutChangeToMenuEntry", item, label, value);
            }
            mh$.invokeExact(item, label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutChangeToSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutChangeToSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutChangeToSubMenu$descriptor() {
        return glutChangeToSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static MethodHandle glutChangeToSubMenu$handle() {
        return glutChangeToSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static MemorySegment glutChangeToSubMenu$address() {
        return glutChangeToSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static void glutChangeToSubMenu(int item, MemorySegment label, int value) {
        var mh$ = glutChangeToSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutChangeToSubMenu", item, label, value);
            }
            mh$.invokeExact(item, label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutRemoveMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutRemoveMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static FunctionDescriptor glutRemoveMenuItem$descriptor() {
        return glutRemoveMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static MethodHandle glutRemoveMenuItem$handle() {
        return glutRemoveMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static MemorySegment glutRemoveMenuItem$address() {
        return glutRemoveMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static void glutRemoveMenuItem(int item) {
        var mh$ = glutRemoveMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutRemoveMenuItem", item);
            }
            mh$.invokeExact(item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAttachMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutAttachMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static FunctionDescriptor glutAttachMenu$descriptor() {
        return glutAttachMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static MethodHandle glutAttachMenu$handle() {
        return glutAttachMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static MemorySegment glutAttachMenu$address() {
        return glutAttachMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static void glutAttachMenu(int button) {
        var mh$ = glutAttachMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAttachMenu", button);
            }
            mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDetachMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutDetachMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static FunctionDescriptor glutDetachMenu$descriptor() {
        return glutDetachMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static MethodHandle glutDetachMenu$handle() {
        return glutDetachMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static MemorySegment glutDetachMenu$address() {
        return glutDetachMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static void glutDetachMenu(int button) {
        var mh$ = glutDetachMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDetachMenu", button);
            }
            mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTimerFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutTimerFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static FunctionDescriptor glutTimerFunc$descriptor() {
        return glutTimerFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static MethodHandle glutTimerFunc$handle() {
        return glutTimerFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static MemorySegment glutTimerFunc$address() {
        return glutTimerFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static void glutTimerFunc(int time, MemorySegment callback, int value) {
        var mh$ = glutTimerFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTimerFunc", time, callback, value);
            }
            mh$.invokeExact(time, callback, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIdleFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutIdleFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutIdleFunc$descriptor() {
        return glutIdleFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutIdleFunc$handle() {
        return glutIdleFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutIdleFunc$address() {
        return glutIdleFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static void glutIdleFunc(MemorySegment callback) {
        var mh$ = glutIdleFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIdleFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutKeyboardFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static FunctionDescriptor glutKeyboardFunc$descriptor() {
        return glutKeyboardFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MethodHandle glutKeyboardFunc$handle() {
        return glutKeyboardFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MemorySegment glutKeyboardFunc$address() {
        return glutKeyboardFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static void glutKeyboardFunc(MemorySegment callback) {
        var mh$ = glutKeyboardFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSpecialFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpecialFunc$descriptor() {
        return glutSpecialFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpecialFunc$handle() {
        return glutSpecialFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpecialFunc$address() {
        return glutSpecialFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpecialFunc(MemorySegment callback) {
        var mh$ = glutSpecialFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutReshapeFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutReshapeFunc$descriptor() {
        return glutReshapeFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutReshapeFunc$handle() {
        return glutReshapeFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutReshapeFunc$address() {
        return glutReshapeFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static void glutReshapeFunc(MemorySegment callback) {
        var mh$ = glutReshapeFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVisibilityFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutVisibilityFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutVisibilityFunc$descriptor() {
        return glutVisibilityFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutVisibilityFunc$handle() {
        return glutVisibilityFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutVisibilityFunc$address() {
        return glutVisibilityFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static void glutVisibilityFunc(MemorySegment callback) {
        var mh$ = glutVisibilityFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVisibilityFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDisplayFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutDisplayFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutDisplayFunc$descriptor() {
        return glutDisplayFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutDisplayFunc$handle() {
        return glutDisplayFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutDisplayFunc$address() {
        return glutDisplayFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static void glutDisplayFunc(MemorySegment callback) {
        var mh$ = glutDisplayFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDisplayFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutMouseFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutMouseFunc$descriptor() {
        return glutMouseFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutMouseFunc$handle() {
        return glutMouseFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutMouseFunc$address() {
        return glutMouseFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutMouseFunc(MemorySegment callback) {
        var mh$ = glutMouseFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutMotionFunc$descriptor() {
        return glutMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutMotionFunc$handle() {
        return glutMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutMotionFunc$address() {
        return glutMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutMotionFunc(MemorySegment callback) {
        var mh$ = glutMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPassiveMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutPassiveMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutPassiveMotionFunc$descriptor() {
        return glutPassiveMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutPassiveMotionFunc$handle() {
        return glutPassiveMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutPassiveMotionFunc$address() {
        return glutPassiveMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutPassiveMotionFunc(MemorySegment callback) {
        var mh$ = glutPassiveMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPassiveMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEntryFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutEntryFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutEntryFunc$descriptor() {
        return glutEntryFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutEntryFunc$handle() {
        return glutEntryFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutEntryFunc$address() {
        return glutEntryFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static void glutEntryFunc(MemorySegment callback) {
        var mh$ = glutEntryFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEntryFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardUpFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutKeyboardUpFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static FunctionDescriptor glutKeyboardUpFunc$descriptor() {
        return glutKeyboardUpFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MethodHandle glutKeyboardUpFunc$handle() {
        return glutKeyboardUpFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MemorySegment glutKeyboardUpFunc$address() {
        return glutKeyboardUpFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static void glutKeyboardUpFunc(MemorySegment callback) {
        var mh$ = glutKeyboardUpFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardUpFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialUpFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSpecialUpFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpecialUpFunc$descriptor() {
        return glutSpecialUpFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpecialUpFunc$handle() {
        return glutSpecialUpFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpecialUpFunc$address() {
        return glutSpecialUpFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpecialUpFunc(MemorySegment callback) {
        var mh$ = glutSpecialUpFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialUpFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutJoystickFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static FunctionDescriptor glutJoystickFunc$descriptor() {
        return glutJoystickFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static MethodHandle glutJoystickFunc$handle() {
        return glutJoystickFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static MemorySegment glutJoystickFunc$address() {
        return glutJoystickFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static void glutJoystickFunc(MemorySegment callback, int pollInterval) {
        var mh$ = glutJoystickFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickFunc", callback, pollInterval);
            }
            mh$.invokeExact(callback, pollInterval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStateFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutMenuStateFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutMenuStateFunc$descriptor() {
        return glutMenuStateFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutMenuStateFunc$handle() {
        return glutMenuStateFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutMenuStateFunc$address() {
        return glutMenuStateFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static void glutMenuStateFunc(MemorySegment callback) {
        var mh$ = glutMenuStateFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStateFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutMenuStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutMenuStatusFunc$descriptor() {
        return glutMenuStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutMenuStatusFunc$handle() {
        return glutMenuStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutMenuStatusFunc$address() {
        return glutMenuStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutMenuStatusFunc(MemorySegment callback) {
        var mh$ = glutMenuStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutOverlayDisplayFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutOverlayDisplayFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutOverlayDisplayFunc$descriptor() {
        return glutOverlayDisplayFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutOverlayDisplayFunc$handle() {
        return glutOverlayDisplayFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutOverlayDisplayFunc$address() {
        return glutOverlayDisplayFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static void glutOverlayDisplayFunc(MemorySegment callback) {
        var mh$ = glutOverlayDisplayFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutOverlayDisplayFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWindowStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWindowStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutWindowStatusFunc$descriptor() {
        return glutWindowStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutWindowStatusFunc$handle() {
        return glutWindowStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutWindowStatusFunc$address() {
        return glutWindowStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static void glutWindowStatusFunc(MemorySegment callback) {
        var mh$ = glutWindowStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWindowStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSpaceballMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballMotionFunc$descriptor() {
        return glutSpaceballMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpaceballMotionFunc$handle() {
        return glutSpaceballMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpaceballMotionFunc$address() {
        return glutSpaceballMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpaceballMotionFunc(MemorySegment callback) {
        var mh$ = glutSpaceballMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballRotateFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSpaceballRotateFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballRotateFunc$descriptor() {
        return glutSpaceballRotateFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpaceballRotateFunc$handle() {
        return glutSpaceballRotateFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpaceballRotateFunc$address() {
        return glutSpaceballRotateFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpaceballRotateFunc(MemorySegment callback) {
        var mh$ = glutSpaceballRotateFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballRotateFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSpaceballButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballButtonFunc$descriptor() {
        return glutSpaceballButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutSpaceballButtonFunc$handle() {
        return glutSpaceballButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutSpaceballButtonFunc$address() {
        return glutSpaceballButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static void glutSpaceballButtonFunc(MemorySegment callback) {
        var mh$ = glutSpaceballButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutButtonBoxFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutButtonBoxFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutButtonBoxFunc$descriptor() {
        return glutButtonBoxFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutButtonBoxFunc$handle() {
        return glutButtonBoxFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutButtonBoxFunc$address() {
        return glutButtonBoxFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static void glutButtonBoxFunc(MemorySegment callback) {
        var mh$ = glutButtonBoxFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutButtonBoxFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDialsFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutDialsFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutDialsFunc$descriptor() {
        return glutDialsFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutDialsFunc$handle() {
        return glutDialsFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutDialsFunc$address() {
        return glutDialsFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static void glutDialsFunc(MemorySegment callback) {
        var mh$ = glutDialsFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDialsFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutTabletMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutTabletMotionFunc$descriptor() {
        return glutTabletMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutTabletMotionFunc$handle() {
        return glutTabletMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutTabletMotionFunc$address() {
        return glutTabletMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutTabletMotionFunc(MemorySegment callback) {
        var mh$ = glutTabletMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutTabletButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutTabletButtonFunc$descriptor() {
        return glutTabletButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutTabletButtonFunc$handle() {
        return glutTabletButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutTabletButtonFunc$address() {
        return glutTabletButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutTabletButtonFunc(MemorySegment callback) {
        var mh$ = glutTabletButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutGet$descriptor() {
        return glutGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static MethodHandle glutGet$handle() {
        return glutGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static MemorySegment glutGet$address() {
        return glutGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static int glutGet(int query) {
        var mh$ = glutGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDeviceGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutDeviceGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutDeviceGet$descriptor() {
        return glutDeviceGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static MethodHandle glutDeviceGet$handle() {
        return glutDeviceGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static MemorySegment glutDeviceGet$address() {
        return glutDeviceGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static int glutDeviceGet(int query) {
        var mh$ = glutDeviceGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDeviceGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetModifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutGetModifiers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static FunctionDescriptor glutGetModifiers$descriptor() {
        return glutGetModifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static MethodHandle glutGetModifiers$handle() {
        return glutGetModifiers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static MemorySegment glutGetModifiers$address() {
        return glutGetModifiers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static int glutGetModifiers() {
        var mh$ = glutGetModifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetModifiers");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLayerGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutLayerGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutLayerGet$descriptor() {
        return glutLayerGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static MethodHandle glutLayerGet$handle() {
        return glutLayerGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static MemorySegment glutLayerGet$address() {
        return glutLayerGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static int glutLayerGet(int query) {
        var mh$ = glutLayerGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLayerGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapCharacter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutBitmapCharacter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutBitmapCharacter$descriptor() {
        return glutBitmapCharacter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static MethodHandle glutBitmapCharacter$handle() {
        return glutBitmapCharacter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static MemorySegment glutBitmapCharacter$address() {
        return glutBitmapCharacter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static void glutBitmapCharacter(MemorySegment font, int character) {
        var mh$ = glutBitmapCharacter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapCharacter", font, character);
            }
            mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutBitmapWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutBitmapWidth$descriptor() {
        return glutBitmapWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static MethodHandle glutBitmapWidth$handle() {
        return glutBitmapWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static MemorySegment glutBitmapWidth$address() {
        return glutBitmapWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static int glutBitmapWidth(MemorySegment font, int character) {
        var mh$ = glutBitmapWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapWidth", font, character);
            }
            return (int)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeCharacter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutStrokeCharacter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeCharacter$descriptor() {
        return glutStrokeCharacter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeCharacter$handle() {
        return glutStrokeCharacter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeCharacter$address() {
        return glutStrokeCharacter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static void glutStrokeCharacter(MemorySegment font, int character) {
        var mh$ = glutStrokeCharacter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeCharacter", font, character);
            }
            mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutStrokeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeWidth$descriptor() {
        return glutStrokeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeWidth$handle() {
        return glutStrokeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeWidth$address() {
        return glutStrokeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static int glutStrokeWidth(MemorySegment font, int character) {
        var mh$ = glutStrokeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeWidth", font, character);
            }
            return (int)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutBitmapLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutBitmapLength$descriptor() {
        return glutBitmapLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutBitmapLength$handle() {
        return glutBitmapLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutBitmapLength$address() {
        return glutBitmapLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static int glutBitmapLength(MemorySegment font, MemorySegment string) {
        var mh$ = glutBitmapLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapLength", font, string);
            }
            return (int)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutStrokeLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutStrokeLength$descriptor() {
        return glutStrokeLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutStrokeLength$handle() {
        return glutStrokeLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutStrokeLength$address() {
        return glutStrokeLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static int glutStrokeLength(MemorySegment font, MemorySegment string) {
        var mh$ = glutStrokeLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeLength", font, string);
            }
            return (int)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCube(GLdouble size)
     * }
     */
    public static FunctionDescriptor glutWireCube$descriptor() {
        return glutWireCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCube(GLdouble size)
     * }
     */
    public static MethodHandle glutWireCube$handle() {
        return glutWireCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCube(GLdouble size)
     * }
     */
    public static MemorySegment glutWireCube$address() {
        return glutWireCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCube(GLdouble size)
     * }
     */
    public static void glutWireCube(double size) {
        var mh$ = glutWireCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCube", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCube(GLdouble size)
     * }
     */
    public static FunctionDescriptor glutSolidCube$descriptor() {
        return glutSolidCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCube(GLdouble size)
     * }
     */
    public static MethodHandle glutSolidCube$handle() {
        return glutSolidCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCube(GLdouble size)
     * }
     */
    public static MemorySegment glutSolidCube$address() {
        return glutSolidCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCube(GLdouble size)
     * }
     */
    public static void glutSolidCube(double size) {
        var mh$ = glutSolidCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCube", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireSphere$descriptor() {
        return glutWireSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireSphere$handle() {
        return glutWireSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireSphere$address() {
        return glutWireSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireSphere(double radius, int slices, int stacks) {
        var mh$ = glutWireSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireSphere", radius, slices, stacks);
            }
            mh$.invokeExact(radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidSphere$descriptor() {
        return glutSolidSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidSphere$handle() {
        return glutSolidSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidSphere$address() {
        return glutSolidSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidSphere(double radius, int slices, int stacks) {
        var mh$ = glutSolidSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidSphere", radius, slices, stacks);
            }
            mh$.invokeExact(radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireCone$descriptor() {
        return glutWireCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireCone$handle() {
        return glutWireCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireCone$address() {
        return glutWireCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireCone(double base, double height, int slices, int stacks) {
        var mh$ = glutWireCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCone", base, height, slices, stacks);
            }
            mh$.invokeExact(base, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidCone$descriptor() {
        return glutSolidCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidCone$handle() {
        return glutSolidCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidCone$address() {
        return glutSolidCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidCone(double base, double height, int slices, int stacks) {
        var mh$ = glutSolidCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCone", base, height, slices, stacks);
            }
            mh$.invokeExact(base, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static FunctionDescriptor glutWireTorus$descriptor() {
        return glutWireTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MethodHandle glutWireTorus$handle() {
        return glutWireTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MemorySegment glutWireTorus$address() {
        return glutWireTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static void glutWireTorus(double innerRadius, double outerRadius, int sides, int rings) {
        var mh$ = glutWireTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTorus", innerRadius, outerRadius, sides, rings);
            }
            mh$.invokeExact(innerRadius, outerRadius, sides, rings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static FunctionDescriptor glutSolidTorus$descriptor() {
        return glutSolidTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MethodHandle glutSolidTorus$handle() {
        return glutSolidTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MemorySegment glutSolidTorus$address() {
        return glutSolidTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings)
     * }
     */
    public static void glutSolidTorus(double innerRadius, double outerRadius, int sides, int rings) {
        var mh$ = glutSolidTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTorus", innerRadius, outerRadius, sides, rings);
            }
            mh$.invokeExact(innerRadius, outerRadius, sides, rings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static FunctionDescriptor glutWireDodecahedron$descriptor() {
        return glutWireDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static MethodHandle glutWireDodecahedron$handle() {
        return glutWireDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static MemorySegment glutWireDodecahedron$address() {
        return glutWireDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static void glutWireDodecahedron() {
        var mh$ = glutWireDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static FunctionDescriptor glutSolidDodecahedron$descriptor() {
        return glutSolidDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static MethodHandle glutSolidDodecahedron$handle() {
        return glutSolidDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static MemorySegment glutSolidDodecahedron$address() {
        return glutSolidDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static void glutSolidDodecahedron() {
        var mh$ = glutSolidDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireOctahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireOctahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static FunctionDescriptor glutWireOctahedron$descriptor() {
        return glutWireOctahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static MethodHandle glutWireOctahedron$handle() {
        return glutWireOctahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static MemorySegment glutWireOctahedron$address() {
        return glutWireOctahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static void glutWireOctahedron() {
        var mh$ = glutWireOctahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireOctahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidOctahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidOctahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static FunctionDescriptor glutSolidOctahedron$descriptor() {
        return glutSolidOctahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static MethodHandle glutSolidOctahedron$handle() {
        return glutSolidOctahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static MemorySegment glutSolidOctahedron$address() {
        return glutSolidOctahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static void glutSolidOctahedron() {
        var mh$ = glutSolidOctahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidOctahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTetrahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireTetrahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static FunctionDescriptor glutWireTetrahedron$descriptor() {
        return glutWireTetrahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static MethodHandle glutWireTetrahedron$handle() {
        return glutWireTetrahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static MemorySegment glutWireTetrahedron$address() {
        return glutWireTetrahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static void glutWireTetrahedron() {
        var mh$ = glutWireTetrahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTetrahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTetrahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidTetrahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static FunctionDescriptor glutSolidTetrahedron$descriptor() {
        return glutSolidTetrahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static MethodHandle glutSolidTetrahedron$handle() {
        return glutSolidTetrahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static MemorySegment glutSolidTetrahedron$address() {
        return glutSolidTetrahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static void glutSolidTetrahedron() {
        var mh$ = glutSolidTetrahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTetrahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireIcosahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireIcosahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static FunctionDescriptor glutWireIcosahedron$descriptor() {
        return glutWireIcosahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static MethodHandle glutWireIcosahedron$handle() {
        return glutWireIcosahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static MemorySegment glutWireIcosahedron$address() {
        return glutWireIcosahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static void glutWireIcosahedron() {
        var mh$ = glutWireIcosahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireIcosahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidIcosahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidIcosahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static FunctionDescriptor glutSolidIcosahedron$descriptor() {
        return glutSolidIcosahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static MethodHandle glutSolidIcosahedron$handle() {
        return glutSolidIcosahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static MemorySegment glutSolidIcosahedron$address() {
        return glutSolidIcosahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static void glutSolidIcosahedron() {
        var mh$ = glutSolidIcosahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidIcosahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTeapot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutWireTeapot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTeapot(GLdouble size)
     * }
     */
    public static FunctionDescriptor glutWireTeapot$descriptor() {
        return glutWireTeapot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTeapot(GLdouble size)
     * }
     */
    public static MethodHandle glutWireTeapot$handle() {
        return glutWireTeapot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTeapot(GLdouble size)
     * }
     */
    public static MemorySegment glutWireTeapot$address() {
        return glutWireTeapot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTeapot(GLdouble size)
     * }
     */
    public static void glutWireTeapot(double size) {
        var mh$ = glutWireTeapot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTeapot", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTeapot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSolidTeapot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTeapot(GLdouble size)
     * }
     */
    public static FunctionDescriptor glutSolidTeapot$descriptor() {
        return glutSolidTeapot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTeapot(GLdouble size)
     * }
     */
    public static MethodHandle glutSolidTeapot$handle() {
        return glutSolidTeapot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTeapot(GLdouble size)
     * }
     */
    public static MemorySegment glutSolidTeapot$address() {
        return glutSolidTeapot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTeapot(GLdouble size)
     * }
     */
    public static void glutSolidTeapot(double size) {
        var mh$ = glutSolidTeapot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTeapot", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGameModeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutGameModeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static FunctionDescriptor glutGameModeString$descriptor() {
        return glutGameModeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static MethodHandle glutGameModeString$handle() {
        return glutGameModeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static MemorySegment glutGameModeString$address() {
        return glutGameModeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static void glutGameModeString(MemorySegment string) {
        var mh$ = glutGameModeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGameModeString", string);
            }
            mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEnterGameMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutEnterGameMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static FunctionDescriptor glutEnterGameMode$descriptor() {
        return glutEnterGameMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static MethodHandle glutEnterGameMode$handle() {
        return glutEnterGameMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static MemorySegment glutEnterGameMode$address() {
        return glutEnterGameMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static int glutEnterGameMode() {
        var mh$ = glutEnterGameMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEnterGameMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLeaveGameMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutLeaveGameMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static FunctionDescriptor glutLeaveGameMode$descriptor() {
        return glutLeaveGameMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static MethodHandle glutLeaveGameMode$handle() {
        return glutLeaveGameMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static MemorySegment glutLeaveGameMode$address() {
        return glutLeaveGameMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static void glutLeaveGameMode() {
        var mh$ = glutLeaveGameMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLeaveGameMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGameModeGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutGameModeGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutGameModeGet$descriptor() {
        return glutGameModeGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static MethodHandle glutGameModeGet$handle() {
        return glutGameModeGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static MemorySegment glutGameModeGet$address() {
        return glutGameModeGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static int glutGameModeGet(int query) {
        var mh$ = glutGameModeGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGameModeGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoResizeGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutVideoResizeGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutVideoResizeGet$descriptor() {
        return glutVideoResizeGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static MethodHandle glutVideoResizeGet$handle() {
        return glutVideoResizeGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static MemorySegment glutVideoResizeGet$address() {
        return glutVideoResizeGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static int glutVideoResizeGet(int query) {
        var mh$ = glutVideoResizeGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoResizeGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetupVideoResizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetupVideoResizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static FunctionDescriptor glutSetupVideoResizing$descriptor() {
        return glutSetupVideoResizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static MethodHandle glutSetupVideoResizing$handle() {
        return glutSetupVideoResizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static MemorySegment glutSetupVideoResizing$address() {
        return glutSetupVideoResizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static void glutSetupVideoResizing() {
        var mh$ = glutSetupVideoResizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetupVideoResizing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStopVideoResizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutStopVideoResizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static FunctionDescriptor glutStopVideoResizing$descriptor() {
        return glutStopVideoResizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static MethodHandle glutStopVideoResizing$handle() {
        return glutStopVideoResizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static MemorySegment glutStopVideoResizing$address() {
        return glutStopVideoResizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static void glutStopVideoResizing() {
        var mh$ = glutStopVideoResizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStopVideoResizing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoResize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutVideoResize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutVideoResize$descriptor() {
        return glutVideoResize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutVideoResize$handle() {
        return glutVideoResize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutVideoResize$address() {
        return glutVideoResize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static void glutVideoResize(int x, int y, int width, int height) {
        var mh$ = glutVideoResize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoResize", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutVideoPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutVideoPan$descriptor() {
        return glutVideoPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutVideoPan$handle() {
        return glutVideoPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutVideoPan$address() {
        return glutVideoPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static void glutVideoPan(int x, int y, int width, int height) {
        var mh$ = glutVideoPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoPan", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT,
            glut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glutSetColor$descriptor() {
        return glutSetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glutSetColor$handle() {
        return glutSetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glutSetColor$address() {
        return glutSetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glutSetColor(int color, float red, float green, float blue) {
        var mh$ = glutSetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetColor", color, red, green, blue);
            }
            mh$.invokeExact(color, red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_FLOAT,
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutGetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static FunctionDescriptor glutGetColor$descriptor() {
        return glutGetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static MethodHandle glutGetColor$handle() {
        return glutGetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static MemorySegment glutGetColor$address() {
        return glutGetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static float glutGetColor(int color, int component) {
        var mh$ = glutGetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetColor", color, component);
            }
            return (float)mh$.invokeExact(color, component);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCopyColormap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutCopyColormap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static FunctionDescriptor glutCopyColormap$descriptor() {
        return glutCopyColormap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static MethodHandle glutCopyColormap$handle() {
        return glutCopyColormap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static MemorySegment glutCopyColormap$address() {
        return glutCopyColormap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static void glutCopyColormap(int window) {
        var mh$ = glutCopyColormap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCopyColormap", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIgnoreKeyRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutIgnoreKeyRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static FunctionDescriptor glutIgnoreKeyRepeat$descriptor() {
        return glutIgnoreKeyRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static MethodHandle glutIgnoreKeyRepeat$handle() {
        return glutIgnoreKeyRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static MemorySegment glutIgnoreKeyRepeat$address() {
        return glutIgnoreKeyRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static void glutIgnoreKeyRepeat(int ignore) {
        var mh$ = glutIgnoreKeyRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIgnoreKeyRepeat", ignore);
            }
            mh$.invokeExact(ignore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetKeyRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutSetKeyRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static FunctionDescriptor glutSetKeyRepeat$descriptor() {
        return glutSetKeyRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static MethodHandle glutSetKeyRepeat$handle() {
        return glutSetKeyRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static MemorySegment glutSetKeyRepeat$address() {
        return glutSetKeyRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static void glutSetKeyRepeat(int repeatMode) {
        var mh$ = glutSetKeyRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetKeyRepeat", repeatMode);
            }
            mh$.invokeExact(repeatMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutForceJoystickFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutForceJoystickFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static FunctionDescriptor glutForceJoystickFunc$descriptor() {
        return glutForceJoystickFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static MethodHandle glutForceJoystickFunc$handle() {
        return glutForceJoystickFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static MemorySegment glutForceJoystickFunc$address() {
        return glutForceJoystickFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static void glutForceJoystickFunc() {
        var mh$ = glutForceJoystickFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutForceJoystickFunc");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutExtensionSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutExtensionSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static FunctionDescriptor glutExtensionSupported$descriptor() {
        return glutExtensionSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static MethodHandle glutExtensionSupported$handle() {
        return glutExtensionSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static MemorySegment glutExtensionSupported$address() {
        return glutExtensionSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static int glutExtensionSupported(MemorySegment extension) {
        var mh$ = glutExtensionSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutExtensionSupported", extension);
            }
            return (int)mh$.invokeExact(extension);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReportErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("glutReportErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static FunctionDescriptor glutReportErrors$descriptor() {
        return glutReportErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static MethodHandle glutReportErrors$handle() {
        return glutReportErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static MemorySegment glutReportErrors$address() {
        return glutReportErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static void glutReportErrors() {
        var mh$ = glutReportErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReportErrors");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = glut_h.C_INT;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = glut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = glut_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = glut_h.C_DOUBLE;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_DOUBLE,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_DOUBLE,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_FLOAT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = glut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = glut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = glut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = glut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = glut_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = glut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = glut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = glut_h.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_DOUBLE    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_DOUBLE,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_LONG,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_LONG,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_LONG,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT    );

        public static final MemorySegment ADDR = glut_h.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG,
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glut_h.C_POINTER,
            glut_h.C_LONG,
            glut_h.C_LONG,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG_LONG,
            glut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            glut_h.C_INT,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            glut_h.C_LONG,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            glut_h.C_LONG_LONG,
            glut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_POINTER,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_DOUBLE,
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_LONG,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_LONG
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_POINTER,
            glut_h.C_POINTER
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glut_h.C_INT,
            glut_h.C_POINTER,
            glut_h.C_INT
        );

        public static final MemorySegment ADDR = glut_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GL_ALL_ATTRIB_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_ATTRIB_BITS 4294967295
     * }
     */
    public static int GL_ALL_ATTRIB_BITS() {
        return GL_ALL_ATTRIB_BITS;
    }
    private static final int GL_ALL_CLIENT_ATTRIB_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_CLIENT_ATTRIB_BITS 4294967295
     * }
     */
    public static int GL_ALL_CLIENT_ATTRIB_BITS() {
        return GL_ALL_CLIENT_ATTRIB_BITS;
    }
    private static final int GL_CLIENT_ALL_ATTRIB_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_CLIENT_ALL_ATTRIB_BITS 4294967295
     * }
     */
    public static int GL_CLIENT_ALL_ATTRIB_BITS() {
        return GL_CLIENT_ALL_ATTRIB_BITS;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
}

