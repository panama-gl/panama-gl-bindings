// Generated by jextract

package glxext.linux.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class glxext_h extends glxext_h_1 {

    glxext_h() {
        // Should not be called directly
    }

    private static class glNormal3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glNormal3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glNormal3bv$descriptor() {
        return glNormal3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glNormal3bv$handle() {
        return glNormal3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glNormal3bv$address() {
        return glNormal3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static void glNormal3bv(MemorySegment v) {
        var mh$ = glNormal3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glNormal3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glNormal3dv$descriptor() {
        return glNormal3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glNormal3dv$handle() {
        return glNormal3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glNormal3dv$address() {
        return glNormal3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static void glNormal3dv(MemorySegment v) {
        var mh$ = glNormal3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glNormal3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glNormal3fv$descriptor() {
        return glNormal3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glNormal3fv$handle() {
        return glNormal3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glNormal3fv$address() {
        return glNormal3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static void glNormal3fv(MemorySegment v) {
        var mh$ = glNormal3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glNormal3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glNormal3iv$descriptor() {
        return glNormal3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MethodHandle glNormal3iv$handle() {
        return glNormal3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MemorySegment glNormal3iv$address() {
        return glNormal3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static void glNormal3iv(MemorySegment v) {
        var mh$ = glNormal3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glNormal3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glNormal3sv$descriptor() {
        return glNormal3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glNormal3sv$handle() {
        return glNormal3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glNormal3sv$address() {
        return glNormal3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static void glNormal3sv(MemorySegment v) {
        var mh$ = glNormal3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static FunctionDescriptor glIndexd$descriptor() {
        return glIndexd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MethodHandle glIndexd$handle() {
        return glIndexd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MemorySegment glIndexd$address() {
        return glIndexd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static void glIndexd(double c) {
        var mh$ = glIndexd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexd", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static FunctionDescriptor glIndexf$descriptor() {
        return glIndexf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MethodHandle glIndexf$handle() {
        return glIndexf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MemorySegment glIndexf$address() {
        return glIndexf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static void glIndexf(float c) {
        var mh$ = glIndexf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexf", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static FunctionDescriptor glIndexi$descriptor() {
        return glIndexi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MethodHandle glIndexi$handle() {
        return glIndexi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MemorySegment glIndexi$address() {
        return glIndexi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static void glIndexi(int c) {
        var mh$ = glIndexi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexi", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static FunctionDescriptor glIndexs$descriptor() {
        return glIndexs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MethodHandle glIndexs$handle() {
        return glIndexs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MemorySegment glIndexs$address() {
        return glIndexs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static void glIndexs(short c) {
        var mh$ = glIndexs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexs", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static FunctionDescriptor glIndexub$descriptor() {
        return glIndexub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MethodHandle glIndexub$handle() {
        return glIndexub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MemorySegment glIndexub$address() {
        return glIndexub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static void glIndexub(byte c) {
        var mh$ = glIndexub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexub", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static FunctionDescriptor glIndexdv$descriptor() {
        return glIndexdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MethodHandle glIndexdv$handle() {
        return glIndexdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MemorySegment glIndexdv$address() {
        return glIndexdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static void glIndexdv(MemorySegment c) {
        var mh$ = glIndexdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexdv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static FunctionDescriptor glIndexfv$descriptor() {
        return glIndexfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MethodHandle glIndexfv$handle() {
        return glIndexfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MemorySegment glIndexfv$address() {
        return glIndexfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static void glIndexfv(MemorySegment c) {
        var mh$ = glIndexfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexfv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static FunctionDescriptor glIndexiv$descriptor() {
        return glIndexiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MethodHandle glIndexiv$handle() {
        return glIndexiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MemorySegment glIndexiv$address() {
        return glIndexiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static void glIndexiv(MemorySegment c) {
        var mh$ = glIndexiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexiv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static FunctionDescriptor glIndexsv$descriptor() {
        return glIndexsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MethodHandle glIndexsv$handle() {
        return glIndexsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MemorySegment glIndexsv$address() {
        return glIndexsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static void glIndexsv(MemorySegment c) {
        var mh$ = glIndexsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexsv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static FunctionDescriptor glIndexubv$descriptor() {
        return glIndexubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MethodHandle glIndexubv$handle() {
        return glIndexubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MemorySegment glIndexubv$address() {
        return glIndexubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static void glIndexubv(MemorySegment c) {
        var mh$ = glIndexubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexubv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_CHAR,
            glxext_h.C_CHAR,
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glColor3b$descriptor() {
        return glColor3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glColor3b$handle() {
        return glColor3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glColor3b$address() {
        return glColor3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glColor3b(byte red, byte green, byte blue) {
        var mh$ = glColor3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3b", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glColor3d$descriptor() {
        return glColor3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glColor3d$handle() {
        return glColor3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glColor3d$address() {
        return glColor3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glColor3d(double red, double green, double blue) {
        var mh$ = glColor3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3d", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glColor3f$descriptor() {
        return glColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glColor3f$handle() {
        return glColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glColor3f$address() {
        return glColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glColor3f(float red, float green, float blue) {
        var mh$ = glColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3f", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glColor3i$descriptor() {
        return glColor3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glColor3i$handle() {
        return glColor3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glColor3i$address() {
        return glColor3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glColor3i(int red, int green, int blue) {
        var mh$ = glColor3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3i", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glColor3s$descriptor() {
        return glColor3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glColor3s$handle() {
        return glColor3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glColor3s$address() {
        return glColor3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glColor3s(short red, short green, short blue) {
        var mh$ = glColor3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3s", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_CHAR,
            glxext_h.C_CHAR,
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glColor3ub$descriptor() {
        return glColor3ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glColor3ub$handle() {
        return glColor3ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glColor3ub$address() {
        return glColor3ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glColor3ub(byte red, byte green, byte blue) {
        var mh$ = glColor3ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ub", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glColor3ui$descriptor() {
        return glColor3ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glColor3ui$handle() {
        return glColor3ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glColor3ui$address() {
        return glColor3ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glColor3ui(int red, int green, int blue) {
        var mh$ = glColor3ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ui", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glColor3us$descriptor() {
        return glColor3us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glColor3us$handle() {
        return glColor3us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glColor3us$address() {
        return glColor3us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glColor3us(short red, short green, short blue) {
        var mh$ = glColor3us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3us", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_CHAR,
            glxext_h.C_CHAR,
            glxext_h.C_CHAR,
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4b$descriptor() {
        return glColor4b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MethodHandle glColor4b$handle() {
        return glColor4b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MemorySegment glColor4b$address() {
        return glColor4b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static void glColor4b(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4b", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static FunctionDescriptor glColor4d$descriptor() {
        return glColor4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MethodHandle glColor4d$handle() {
        return glColor4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MemorySegment glColor4d$address() {
        return glColor4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static void glColor4d(double red, double green, double blue, double alpha) {
        var mh$ = glColor4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4d", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glColor4f$descriptor() {
        return glColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glColor4f$handle() {
        return glColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glColor4f$address() {
        return glColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glColor4f(float red, float green, float blue, float alpha) {
        var mh$ = glColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4f", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static FunctionDescriptor glColor4i$descriptor() {
        return glColor4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MethodHandle glColor4i$handle() {
        return glColor4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MemorySegment glColor4i$address() {
        return glColor4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static void glColor4i(int red, int green, int blue, int alpha) {
        var mh$ = glColor4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4i", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static FunctionDescriptor glColor4s$descriptor() {
        return glColor4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MethodHandle glColor4s$handle() {
        return glColor4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MemorySegment glColor4s$address() {
        return glColor4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static void glColor4s(short red, short green, short blue, short alpha) {
        var mh$ = glColor4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4s", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_CHAR,
            glxext_h.C_CHAR,
            glxext_h.C_CHAR,
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4ub$descriptor() {
        return glColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MethodHandle glColor4ub$handle() {
        return glColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MemorySegment glColor4ub$address() {
        return glColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ub", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static FunctionDescriptor glColor4ui$descriptor() {
        return glColor4ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MethodHandle glColor4ui$handle() {
        return glColor4ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MemorySegment glColor4ui$address() {
        return glColor4ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static void glColor4ui(int red, int green, int blue, int alpha) {
        var mh$ = glColor4ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ui", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static FunctionDescriptor glColor4us$descriptor() {
        return glColor4us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MethodHandle glColor4us$handle() {
        return glColor4us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MemorySegment glColor4us$address() {
        return glColor4us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static void glColor4us(short red, short green, short blue, short alpha) {
        var mh$ = glColor4us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4us", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor3bv$descriptor() {
        return glColor3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor3bv$handle() {
        return glColor3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor3bv$address() {
        return glColor3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static void glColor3bv(MemorySegment v) {
        var mh$ = glColor3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor3dv$descriptor() {
        return glColor3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor3dv$handle() {
        return glColor3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor3dv$address() {
        return glColor3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static void glColor3dv(MemorySegment v) {
        var mh$ = glColor3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor3fv$descriptor() {
        return glColor3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor3fv$handle() {
        return glColor3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor3fv$address() {
        return glColor3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static void glColor3fv(MemorySegment v) {
        var mh$ = glColor3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor3iv$descriptor() {
        return glColor3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor3iv$handle() {
        return glColor3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor3iv$address() {
        return glColor3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static void glColor3iv(MemorySegment v) {
        var mh$ = glColor3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor3sv$descriptor() {
        return glColor3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor3sv$handle() {
        return glColor3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor3sv$address() {
        return glColor3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static void glColor3sv(MemorySegment v) {
        var mh$ = glColor3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor3ubv$descriptor() {
        return glColor3ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor3ubv$handle() {
        return glColor3ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor3ubv$address() {
        return glColor3ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static void glColor3ubv(MemorySegment v) {
        var mh$ = glColor3ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor3uiv$descriptor() {
        return glColor3uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor3uiv$handle() {
        return glColor3uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor3uiv$address() {
        return glColor3uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static void glColor3uiv(MemorySegment v) {
        var mh$ = glColor3uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor3usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor3usv$descriptor() {
        return glColor3usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor3usv$handle() {
        return glColor3usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor3usv$address() {
        return glColor3usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static void glColor3usv(MemorySegment v) {
        var mh$ = glColor3usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor4bv$descriptor() {
        return glColor4bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor4bv$handle() {
        return glColor4bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor4bv$address() {
        return glColor4bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static void glColor4bv(MemorySegment v) {
        var mh$ = glColor4bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor4dv$descriptor() {
        return glColor4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor4dv$handle() {
        return glColor4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor4dv$address() {
        return glColor4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static void glColor4dv(MemorySegment v) {
        var mh$ = glColor4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor4fv$descriptor() {
        return glColor4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor4fv$handle() {
        return glColor4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor4fv$address() {
        return glColor4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static void glColor4fv(MemorySegment v) {
        var mh$ = glColor4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor4iv$descriptor() {
        return glColor4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor4iv$handle() {
        return glColor4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor4iv$address() {
        return glColor4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static void glColor4iv(MemorySegment v) {
        var mh$ = glColor4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor4sv$descriptor() {
        return glColor4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor4sv$handle() {
        return glColor4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor4sv$address() {
        return glColor4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static void glColor4sv(MemorySegment v) {
        var mh$ = glColor4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor4ubv$descriptor() {
        return glColor4ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor4ubv$handle() {
        return glColor4ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor4ubv$address() {
        return glColor4ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static void glColor4ubv(MemorySegment v) {
        var mh$ = glColor4ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor4uiv$descriptor() {
        return glColor4uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor4uiv$handle() {
        return glColor4uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor4uiv$address() {
        return glColor4uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static void glColor4uiv(MemorySegment v) {
        var mh$ = glColor4uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColor4usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor4usv$descriptor() {
        return glColor4usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor4usv$handle() {
        return glColor4usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor4usv$address() {
        return glColor4usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static void glColor4usv(MemorySegment v) {
        var mh$ = glColor4usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static FunctionDescriptor glTexCoord1d$descriptor() {
        return glTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MethodHandle glTexCoord1d$handle() {
        return glTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MemorySegment glTexCoord1d$address() {
        return glTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static void glTexCoord1d(double s) {
        var mh$ = glTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1d", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static FunctionDescriptor glTexCoord1f$descriptor() {
        return glTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MethodHandle glTexCoord1f$handle() {
        return glTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MemorySegment glTexCoord1f$address() {
        return glTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static void glTexCoord1f(float s) {
        var mh$ = glTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1f", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static FunctionDescriptor glTexCoord1i$descriptor() {
        return glTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MethodHandle glTexCoord1i$handle() {
        return glTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MemorySegment glTexCoord1i$address() {
        return glTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static void glTexCoord1i(int s) {
        var mh$ = glTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1i", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static FunctionDescriptor glTexCoord1s$descriptor() {
        return glTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MethodHandle glTexCoord1s$handle() {
        return glTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MemorySegment glTexCoord1s$address() {
        return glTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static void glTexCoord1s(short s) {
        var mh$ = glTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1s", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glTexCoord2d$descriptor() {
        return glTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glTexCoord2d$handle() {
        return glTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glTexCoord2d$address() {
        return glTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static void glTexCoord2d(double s, double t) {
        var mh$ = glTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2d", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glTexCoord2f$descriptor() {
        return glTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glTexCoord2f$handle() {
        return glTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glTexCoord2f$address() {
        return glTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static void glTexCoord2f(float s, float t) {
        var mh$ = glTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2f", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glTexCoord2i$descriptor() {
        return glTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MethodHandle glTexCoord2i$handle() {
        return glTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MemorySegment glTexCoord2i$address() {
        return glTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static void glTexCoord2i(int s, int t) {
        var mh$ = glTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2i", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glTexCoord2s$descriptor() {
        return glTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glTexCoord2s$handle() {
        return glTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glTexCoord2s$address() {
        return glTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static void glTexCoord2s(short s, short t) {
        var mh$ = glTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2s", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glTexCoord3d$descriptor() {
        return glTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glTexCoord3d$handle() {
        return glTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glTexCoord3d$address() {
        return glTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glTexCoord3d(double s, double t, double r) {
        var mh$ = glTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3d", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glTexCoord3f$descriptor() {
        return glTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glTexCoord3f$handle() {
        return glTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glTexCoord3f$address() {
        return glTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glTexCoord3f(float s, float t, float r) {
        var mh$ = glTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3f", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glTexCoord3i$descriptor() {
        return glTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glTexCoord3i$handle() {
        return glTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glTexCoord3i$address() {
        return glTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static void glTexCoord3i(int s, int t, int r) {
        var mh$ = glTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3i", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glTexCoord3s$descriptor() {
        return glTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glTexCoord3s$handle() {
        return glTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glTexCoord3s$address() {
        return glTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glTexCoord3s(short s, short t, short r) {
        var mh$ = glTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3s", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glTexCoord4d$descriptor() {
        return glTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glTexCoord4d$handle() {
        return glTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glTexCoord4d$address() {
        return glTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glTexCoord4d(double s, double t, double r, double q) {
        var mh$ = glTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4d", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glTexCoord4f$descriptor() {
        return glTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glTexCoord4f$handle() {
        return glTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glTexCoord4f$address() {
        return glTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glTexCoord4f(float s, float t, float r, float q) {
        var mh$ = glTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4f", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glTexCoord4i$descriptor() {
        return glTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glTexCoord4i$handle() {
        return glTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glTexCoord4i$address() {
        return glTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glTexCoord4i(int s, int t, int r, int q) {
        var mh$ = glTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4i", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glTexCoord4s$descriptor() {
        return glTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glTexCoord4s$handle() {
        return glTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glTexCoord4s$address() {
        return glTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glTexCoord4s(short s, short t, short r, short q) {
        var mh$ = glTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4s", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1dv$descriptor() {
        return glTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord1dv$handle() {
        return glTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord1dv$address() {
        return glTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord1dv(MemorySegment v) {
        var mh$ = glTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1fv$descriptor() {
        return glTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord1fv$handle() {
        return glTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord1fv$address() {
        return glTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord1fv(MemorySegment v) {
        var mh$ = glTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1iv$descriptor() {
        return glTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord1iv$handle() {
        return glTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord1iv$address() {
        return glTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static void glTexCoord1iv(MemorySegment v) {
        var mh$ = glTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1sv$descriptor() {
        return glTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord1sv$handle() {
        return glTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord1sv$address() {
        return glTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static void glTexCoord1sv(MemorySegment v) {
        var mh$ = glTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2dv$descriptor() {
        return glTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord2dv$handle() {
        return glTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord2dv$address() {
        return glTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord2dv(MemorySegment v) {
        var mh$ = glTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2fv$descriptor() {
        return glTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord2fv$handle() {
        return glTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord2fv$address() {
        return glTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord2fv(MemorySegment v) {
        var mh$ = glTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2iv$descriptor() {
        return glTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord2iv$handle() {
        return glTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord2iv$address() {
        return glTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static void glTexCoord2iv(MemorySegment v) {
        var mh$ = glTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2sv$descriptor() {
        return glTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord2sv$handle() {
        return glTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord2sv$address() {
        return glTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static void glTexCoord2sv(MemorySegment v) {
        var mh$ = glTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3dv$descriptor() {
        return glTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord3dv$handle() {
        return glTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord3dv$address() {
        return glTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord3dv(MemorySegment v) {
        var mh$ = glTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3fv$descriptor() {
        return glTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord3fv$handle() {
        return glTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord3fv$address() {
        return glTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord3fv(MemorySegment v) {
        var mh$ = glTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3iv$descriptor() {
        return glTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord3iv$handle() {
        return glTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord3iv$address() {
        return glTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static void glTexCoord3iv(MemorySegment v) {
        var mh$ = glTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3sv$descriptor() {
        return glTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord3sv$handle() {
        return glTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord3sv$address() {
        return glTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static void glTexCoord3sv(MemorySegment v) {
        var mh$ = glTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4dv$descriptor() {
        return glTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord4dv$handle() {
        return glTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord4dv$address() {
        return glTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord4dv(MemorySegment v) {
        var mh$ = glTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4fv$descriptor() {
        return glTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord4fv$handle() {
        return glTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord4fv$address() {
        return glTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord4fv(MemorySegment v) {
        var mh$ = glTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4iv$descriptor() {
        return glTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord4iv$handle() {
        return glTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord4iv$address() {
        return glTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static void glTexCoord4iv(MemorySegment v) {
        var mh$ = glTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4sv$descriptor() {
        return glTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord4sv$handle() {
        return glTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord4sv$address() {
        return glTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static void glTexCoord4sv(MemorySegment v) {
        var mh$ = glTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glRasterPos2d$descriptor() {
        return glRasterPos2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glRasterPos2d$handle() {
        return glRasterPos2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glRasterPos2d$address() {
        return glRasterPos2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glRasterPos2d(double x, double y) {
        var mh$ = glRasterPos2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glRasterPos2f$descriptor() {
        return glRasterPos2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glRasterPos2f$handle() {
        return glRasterPos2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glRasterPos2f$address() {
        return glRasterPos2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glRasterPos2f(float x, float y) {
        var mh$ = glRasterPos2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glRasterPos2i$descriptor() {
        return glRasterPos2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glRasterPos2i$handle() {
        return glRasterPos2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glRasterPos2i$address() {
        return glRasterPos2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static void glRasterPos2i(int x, int y) {
        var mh$ = glRasterPos2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glRasterPos2s$descriptor() {
        return glRasterPos2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glRasterPos2s$handle() {
        return glRasterPos2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glRasterPos2s$address() {
        return glRasterPos2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static void glRasterPos2s(short x, short y) {
        var mh$ = glRasterPos2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRasterPos3d$descriptor() {
        return glRasterPos3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRasterPos3d$handle() {
        return glRasterPos3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRasterPos3d$address() {
        return glRasterPos3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRasterPos3d(double x, double y, double z) {
        var mh$ = glRasterPos3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRasterPos3f$descriptor() {
        return glRasterPos3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRasterPos3f$handle() {
        return glRasterPos3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRasterPos3f$address() {
        return glRasterPos3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRasterPos3f(float x, float y, float z) {
        var mh$ = glRasterPos3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glRasterPos3i$descriptor() {
        return glRasterPos3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glRasterPos3i$handle() {
        return glRasterPos3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glRasterPos3i$address() {
        return glRasterPos3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glRasterPos3i(int x, int y, int z) {
        var mh$ = glRasterPos3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glRasterPos3s$descriptor() {
        return glRasterPos3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glRasterPos3s$handle() {
        return glRasterPos3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glRasterPos3s$address() {
        return glRasterPos3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glRasterPos3s(short x, short y, short z) {
        var mh$ = glRasterPos3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glRasterPos4d$descriptor() {
        return glRasterPos4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glRasterPos4d$handle() {
        return glRasterPos4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glRasterPos4d$address() {
        return glRasterPos4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glRasterPos4d(double x, double y, double z, double w) {
        var mh$ = glRasterPos4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glRasterPos4f$descriptor() {
        return glRasterPos4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glRasterPos4f$handle() {
        return glRasterPos4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glRasterPos4f$address() {
        return glRasterPos4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glRasterPos4f(float x, float y, float z, float w) {
        var mh$ = glRasterPos4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glRasterPos4i$descriptor() {
        return glRasterPos4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glRasterPos4i$handle() {
        return glRasterPos4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glRasterPos4i$address() {
        return glRasterPos4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glRasterPos4i(int x, int y, int z, int w) {
        var mh$ = glRasterPos4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glRasterPos4s$descriptor() {
        return glRasterPos4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glRasterPos4s$handle() {
        return glRasterPos4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glRasterPos4s$address() {
        return glRasterPos4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glRasterPos4s(short x, short y, short z, short w) {
        var mh$ = glRasterPos4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2dv$descriptor() {
        return glRasterPos2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos2dv$handle() {
        return glRasterPos2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos2dv$address() {
        return glRasterPos2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos2dv(MemorySegment v) {
        var mh$ = glRasterPos2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2fv$descriptor() {
        return glRasterPos2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos2fv$handle() {
        return glRasterPos2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos2fv$address() {
        return glRasterPos2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos2fv(MemorySegment v) {
        var mh$ = glRasterPos2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2iv$descriptor() {
        return glRasterPos2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos2iv$handle() {
        return glRasterPos2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos2iv$address() {
        return glRasterPos2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static void glRasterPos2iv(MemorySegment v) {
        var mh$ = glRasterPos2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2sv$descriptor() {
        return glRasterPos2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos2sv$handle() {
        return glRasterPos2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos2sv$address() {
        return glRasterPos2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static void glRasterPos2sv(MemorySegment v) {
        var mh$ = glRasterPos2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3dv$descriptor() {
        return glRasterPos3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos3dv$handle() {
        return glRasterPos3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos3dv$address() {
        return glRasterPos3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos3dv(MemorySegment v) {
        var mh$ = glRasterPos3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3fv$descriptor() {
        return glRasterPos3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos3fv$handle() {
        return glRasterPos3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos3fv$address() {
        return glRasterPos3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos3fv(MemorySegment v) {
        var mh$ = glRasterPos3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3iv$descriptor() {
        return glRasterPos3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos3iv$handle() {
        return glRasterPos3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos3iv$address() {
        return glRasterPos3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static void glRasterPos3iv(MemorySegment v) {
        var mh$ = glRasterPos3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3sv$descriptor() {
        return glRasterPos3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos3sv$handle() {
        return glRasterPos3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos3sv$address() {
        return glRasterPos3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static void glRasterPos3sv(MemorySegment v) {
        var mh$ = glRasterPos3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4dv$descriptor() {
        return glRasterPos4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos4dv$handle() {
        return glRasterPos4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos4dv$address() {
        return glRasterPos4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos4dv(MemorySegment v) {
        var mh$ = glRasterPos4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4fv$descriptor() {
        return glRasterPos4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos4fv$handle() {
        return glRasterPos4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos4fv$address() {
        return glRasterPos4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos4fv(MemorySegment v) {
        var mh$ = glRasterPos4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4iv$descriptor() {
        return glRasterPos4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos4iv$handle() {
        return glRasterPos4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos4iv$address() {
        return glRasterPos4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static void glRasterPos4iv(MemorySegment v) {
        var mh$ = glRasterPos4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRasterPos4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4sv$descriptor() {
        return glRasterPos4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos4sv$handle() {
        return glRasterPos4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos4sv$address() {
        return glRasterPos4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static void glRasterPos4sv(MemorySegment v) {
        var mh$ = glRasterPos4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRectd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static FunctionDescriptor glRectd$descriptor() {
        return glRectd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MethodHandle glRectd$handle() {
        return glRectd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MemorySegment glRectd$address() {
        return glRectd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static void glRectd(double x1, double y1, double x2, double y2) {
        var mh$ = glRectd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectd", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRectf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static FunctionDescriptor glRectf$descriptor() {
        return glRectf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MethodHandle glRectf$handle() {
        return glRectf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MemorySegment glRectf$address() {
        return glRectf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static void glRectf(float x1, float y1, float x2, float y2) {
        var mh$ = glRectf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectf", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRecti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRecti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static FunctionDescriptor glRecti$descriptor() {
        return glRecti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MethodHandle glRecti$handle() {
        return glRecti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MemorySegment glRecti$address() {
        return glRecti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static void glRecti(int x1, int y1, int x2, int y2) {
        var mh$ = glRecti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRecti", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static FunctionDescriptor glRects$descriptor() {
        return glRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MethodHandle glRects$handle() {
        return glRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MemorySegment glRects$address() {
        return glRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static void glRects(short x1, short y1, short x2, short y2) {
        var mh$ = glRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRects", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRectdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static FunctionDescriptor glRectdv$descriptor() {
        return glRectdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MethodHandle glRectdv$handle() {
        return glRectdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MemorySegment glRectdv$address() {
        return glRectdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static void glRectdv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectdv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRectfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static FunctionDescriptor glRectfv$descriptor() {
        return glRectfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MethodHandle glRectfv$handle() {
        return glRectfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MemorySegment glRectfv$address() {
        return glRectfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static void glRectfv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectfv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRectiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static FunctionDescriptor glRectiv$descriptor() {
        return glRectiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MethodHandle glRectiv$handle() {
        return glRectiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MemorySegment glRectiv$address() {
        return glRectiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static void glRectiv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectiv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glRectsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static FunctionDescriptor glRectsv$descriptor() {
        return glRectsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MethodHandle glRectsv$handle() {
        return glRectsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MemorySegment glRectsv$address() {
        return glRectsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static void glRectsv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectsv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glVertexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glVertexPointer$descriptor() {
        return glVertexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glVertexPointer$handle() {
        return glVertexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glVertexPointer$address() {
        return glVertexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glVertexPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glVertexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormalPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glNormalPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glNormalPointer$descriptor() {
        return glNormalPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glNormalPointer$handle() {
        return glNormalPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glNormalPointer$address() {
        return glNormalPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glNormalPointer(int type, int stride, MemorySegment ptr) {
        var mh$ = glNormalPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormalPointer", type, stride, ptr);
            }
            mh$.invokeExact(type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColorPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glColorPointer$descriptor() {
        return glColorPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glColorPointer$handle() {
        return glColorPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glColorPointer$address() {
        return glColorPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glColorPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glColorPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIndexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glIndexPointer$descriptor() {
        return glIndexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glIndexPointer$handle() {
        return glIndexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glIndexPointer$address() {
        return glIndexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glIndexPointer(int type, int stride, MemorySegment ptr) {
        var mh$ = glIndexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexPointer", type, stride, ptr);
            }
            mh$.invokeExact(type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoordPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexCoordPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glTexCoordPointer$descriptor() {
        return glTexCoordPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glTexCoordPointer$handle() {
        return glTexCoordPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glTexCoordPointer$address() {
        return glTexCoordPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glTexCoordPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glTexCoordPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoordPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEdgeFlagPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glEdgeFlagPointer$descriptor() {
        return glEdgeFlagPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glEdgeFlagPointer$handle() {
        return glEdgeFlagPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glEdgeFlagPointer$address() {
        return glEdgeFlagPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glEdgeFlagPointer(int stride, MemorySegment ptr) {
        var mh$ = glEdgeFlagPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagPointer", stride, ptr);
            }
            mh$.invokeExact(stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetPointerv$descriptor() {
        return glGetPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetPointerv$handle() {
        return glGetPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetPointerv$address() {
        return glGetPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetPointerv(int pname, MemorySegment params) {
        var mh$ = glGetPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPointerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glArrayElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glArrayElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static FunctionDescriptor glArrayElement$descriptor() {
        return glArrayElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MethodHandle glArrayElement$handle() {
        return glArrayElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MemorySegment glArrayElement$address() {
        return glArrayElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static void glArrayElement(int i) {
        var mh$ = glArrayElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glArrayElement", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glDrawArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawArrays$descriptor() {
        return glDrawArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawArrays$handle() {
        return glDrawArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawArrays$address() {
        return glDrawArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static void glDrawArrays(int mode, int first, int count) {
        var mh$ = glDrawArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawArrays", mode, first, count);
            }
            mh$.invokeExact(mode, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glDrawElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawElements$descriptor() {
        return glDrawElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawElements$handle() {
        return glDrawElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawElements$address() {
        return glDrawElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawElements(int mode, int count, int type, MemorySegment indices) {
        var mh$ = glDrawElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElements", mode, count, type, indices);
            }
            mh$.invokeExact(mode, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInterleavedArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glInterleavedArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glInterleavedArrays$descriptor() {
        return glInterleavedArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glInterleavedArrays$handle() {
        return glInterleavedArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glInterleavedArrays$address() {
        return glInterleavedArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glInterleavedArrays(int format, int stride, MemorySegment pointer) {
        var mh$ = glInterleavedArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInterleavedArrays", format, stride, pointer);
            }
            mh$.invokeExact(format, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShadeModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glShadeModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static FunctionDescriptor glShadeModel$descriptor() {
        return glShadeModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MethodHandle glShadeModel$handle() {
        return glShadeModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MemorySegment glShadeModel$address() {
        return glShadeModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static void glShadeModel(int mode) {
        var mh$ = glShadeModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShadeModel", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLightf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightf$descriptor() {
        return glLightf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightf$handle() {
        return glLightf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightf$address() {
        return glLightf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static void glLightf(int light, int pname, float param) {
        var mh$ = glLightf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightf", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLighti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLighti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLighti$descriptor() {
        return glLighti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLighti$handle() {
        return glLighti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLighti$address() {
        return glLighti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static void glLighti(int light, int pname, int param) {
        var mh$ = glLighti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLighti", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightfv$descriptor() {
        return glLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightfv$handle() {
        return glLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightfv$address() {
        return glLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightiv$descriptor() {
        return glLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightiv$handle() {
        return glLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightiv$address() {
        return glLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static void glLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetLightfv$descriptor() {
        return glGetLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetLightfv$handle() {
        return glGetLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetLightfv$address() {
        return glGetLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetLightiv$descriptor() {
        return glGetLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetLightiv$handle() {
        return glGetLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetLightiv$address() {
        return glGetLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static void glGetLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLightModelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightModelf$descriptor() {
        return glLightModelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightModelf$handle() {
        return glLightModelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightModelf$address() {
        return glLightModelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static void glLightModelf(int pname, float param) {
        var mh$ = glLightModelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeli {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLightModeli");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLightModeli$descriptor() {
        return glLightModeli.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLightModeli$handle() {
        return glLightModeli.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLightModeli$address() {
        return glLightModeli.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static void glLightModeli(int pname, int param) {
        var mh$ = glLightModeli.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeli", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLightModelfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightModelfv$descriptor() {
        return glLightModelfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightModelfv$handle() {
        return glLightModelfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightModelfv$address() {
        return glLightModelfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightModelfv(int pname, MemorySegment params) {
        var mh$ = glLightModelfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeliv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLightModeliv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightModeliv$descriptor() {
        return glLightModeliv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightModeliv$handle() {
        return glLightModeliv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightModeliv$address() {
        return glLightModeliv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static void glLightModeliv(int pname, MemorySegment params) {
        var mh$ = glLightModeliv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeliv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMaterialf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glMaterialf$descriptor() {
        return glMaterialf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glMaterialf$handle() {
        return glMaterialf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glMaterialf$address() {
        return glMaterialf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static void glMaterialf(int face, int pname, float param) {
        var mh$ = glMaterialf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialf", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMateriali {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMateriali");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glMateriali$descriptor() {
        return glMateriali.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glMateriali$handle() {
        return glMateriali.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glMateriali$address() {
        return glMateriali.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static void glMateriali(int face, int pname, int param) {
        var mh$ = glMateriali.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMateriali", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glMaterialfv$descriptor() {
        return glMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glMaterialfv$handle() {
        return glMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glMaterialfv$address() {
        return glMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glMaterialiv$descriptor() {
        return glMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glMaterialiv$handle() {
        return glMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glMaterialiv$address() {
        return glMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static void glMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialfv$descriptor() {
        return glGetMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMaterialfv$handle() {
        return glGetMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMaterialfv$address() {
        return glGetMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialiv$descriptor() {
        return glGetMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMaterialiv$handle() {
        return glGetMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMaterialiv$address() {
        return glGetMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColorMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glColorMaterial$descriptor() {
        return glColorMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glColorMaterial$handle() {
        return glColorMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glColorMaterial$address() {
        return glColorMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static void glColorMaterial(int face, int mode) {
        var mh$ = glColorMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMaterial", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static FunctionDescriptor glPixelZoom$descriptor() {
        return glPixelZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MethodHandle glPixelZoom$handle() {
        return glPixelZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MemorySegment glPixelZoom$address() {
        return glPixelZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static void glPixelZoom(float xfactor, float yfactor) {
        var mh$ = glPixelZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelZoom", xfactor, yfactor);
            }
            mh$.invokeExact(xfactor, yfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStoref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelStoref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelStoref$descriptor() {
        return glPixelStoref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelStoref$handle() {
        return glPixelStoref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelStoref$address() {
        return glPixelStoref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelStoref(int pname, float param) {
        var mh$ = glPixelStoref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStoref", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStorei {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelStorei");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelStorei$descriptor() {
        return glPixelStorei.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelStorei$handle() {
        return glPixelStorei.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelStorei$address() {
        return glPixelStorei.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static void glPixelStorei(int pname, int param) {
        var mh$ = glPixelStorei.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStorei", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelTransferf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelTransferf$descriptor() {
        return glPixelTransferf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelTransferf$handle() {
        return glPixelTransferf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelTransferf$address() {
        return glPixelTransferf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelTransferf(int pname, float param) {
        var mh$ = glPixelTransferf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelTransferi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelTransferi$descriptor() {
        return glPixelTransferi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelTransferi$handle() {
        return glPixelTransferi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelTransferi$address() {
        return glPixelTransferi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static void glPixelTransferi(int pname, int param) {
        var mh$ = glPixelTransferi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static FunctionDescriptor glPixelMapfv$descriptor() {
        return glPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MethodHandle glPixelMapfv$handle() {
        return glPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MemorySegment glPixelMapfv$address() {
        return glPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static void glPixelMapfv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapfv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static FunctionDescriptor glPixelMapuiv$descriptor() {
        return glPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MethodHandle glPixelMapuiv$handle() {
        return glPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MemorySegment glPixelMapuiv$address() {
        return glPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static void glPixelMapuiv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapuiv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static FunctionDescriptor glPixelMapusv$descriptor() {
        return glPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MethodHandle glPixelMapusv$handle() {
        return glPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MemorySegment glPixelMapusv$address() {
        return glPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static void glPixelMapusv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapusv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapfv$descriptor() {
        return glGetPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MethodHandle glGetPixelMapfv$handle() {
        return glGetPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MemorySegment glGetPixelMapfv$address() {
        return glGetPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static void glGetPixelMapfv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapfv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapuiv$descriptor() {
        return glGetPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MethodHandle glGetPixelMapuiv$handle() {
        return glGetPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MemorySegment glGetPixelMapuiv$address() {
        return glGetPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static void glGetPixelMapuiv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapuiv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapusv$descriptor() {
        return glGetPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MethodHandle glGetPixelMapusv$handle() {
        return glGetPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MemorySegment glGetPixelMapusv$address() {
        return glGetPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static void glGetPixelMapusv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapusv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static FunctionDescriptor glBitmap$descriptor() {
        return glBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MethodHandle glBitmap$handle() {
        return glBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MemorySegment glBitmap$address() {
        return glBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, MemorySegment bitmap) {
        var mh$ = glBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBitmap", width, height, xorig, yorig, xmove, ymove, bitmap);
            }
            mh$.invokeExact(width, height, xorig, yorig, xmove, ymove, bitmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glReadPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glReadPixels$descriptor() {
        return glReadPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glReadPixels$handle() {
        return glReadPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glReadPixels$address() {
        return glReadPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glReadPixels(int x, int y, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glReadPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadPixels", x, y, width, height, format, type, pixels);
            }
            mh$.invokeExact(x, y, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glDrawPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glDrawPixels$descriptor() {
        return glDrawPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glDrawPixels$handle() {
        return glDrawPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glDrawPixels$address() {
        return glDrawPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glDrawPixels(int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glDrawPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawPixels", width, height, format, type, pixels);
            }
            mh$.invokeExact(width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static FunctionDescriptor glCopyPixels$descriptor() {
        return glCopyPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MethodHandle glCopyPixels$handle() {
        return glCopyPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MemorySegment glCopyPixels$address() {
        return glCopyPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static void glCopyPixels(int x, int y, int width, int height, int type) {
        var mh$ = glCopyPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyPixels", x, y, width, height, type);
            }
            mh$.invokeExact(x, y, width, height, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glStencilFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFunc$descriptor() {
        return glStencilFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFunc$handle() {
        return glStencilFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFunc$address() {
        return glStencilFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFunc(int func, int ref, int mask) {
        var mh$ = glStencilFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFunc", func, ref, mask);
            }
            mh$.invokeExact(func, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glStencilMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilMask$descriptor() {
        return glStencilMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MethodHandle glStencilMask$handle() {
        return glStencilMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MemorySegment glStencilMask$address() {
        return glStencilMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static void glStencilMask(int mask) {
        var mh$ = glStencilMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glStencilOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static FunctionDescriptor glStencilOp$descriptor() {
        return glStencilOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MethodHandle glStencilOp$handle() {
        return glStencilOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MemorySegment glStencilOp$address() {
        return glStencilOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static void glStencilOp(int fail, int zfail, int zpass) {
        var mh$ = glStencilOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOp", fail, zfail, zpass);
            }
            mh$.invokeExact(fail, zfail, zpass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearStencil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glClearStencil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static FunctionDescriptor glClearStencil$descriptor() {
        return glClearStencil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MethodHandle glClearStencil$handle() {
        return glClearStencil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MemorySegment glClearStencil$address() {
        return glClearStencil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static void glClearStencil(int s) {
        var mh$ = glClearStencil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearStencil", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexGend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static FunctionDescriptor glTexGend$descriptor() {
        return glTexGend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MethodHandle glTexGend$handle() {
        return glTexGend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MemorySegment glTexGend$address() {
        return glTexGend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static void glTexGend(int coord, int pname, double param) {
        var mh$ = glTexGend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGend", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexGenf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexGenf$descriptor() {
        return glTexGenf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexGenf$handle() {
        return glTexGenf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexGenf$address() {
        return glTexGenf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexGenf(int coord, int pname, float param) {
        var mh$ = glTexGenf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenf", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexGeni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexGeni$descriptor() {
        return glTexGeni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexGeni$handle() {
        return glTexGeni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexGeni$address() {
        return glTexGeni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static void glTexGeni(int coord, int pname, int param) {
        var mh$ = glTexGeni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeni", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glTexGendv$descriptor() {
        return glTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MethodHandle glTexGendv$handle() {
        return glTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MemorySegment glTexGendv$address() {
        return glTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static void glTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexGenfv$descriptor() {
        return glTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexGenfv$handle() {
        return glTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexGenfv$address() {
        return glTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexGeniv$descriptor() {
        return glTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexGeniv$handle() {
        return glTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexGeniv$address() {
        return glTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetTexGendv$descriptor() {
        return glGetTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetTexGendv$handle() {
        return glGetTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetTexGendv$address() {
        return glGetTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexGenfv$descriptor() {
        return glGetTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexGenfv$handle() {
        return glGetTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexGenfv$address() {
        return glGetTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexGeniv$descriptor() {
        return glGetTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexGeniv$handle() {
        return glGetTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexGeniv$address() {
        return glGetTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexEnvf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexEnvf$descriptor() {
        return glTexEnvf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexEnvf$handle() {
        return glTexEnvf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexEnvf$address() {
        return glTexEnvf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexEnvf(int target, int pname, float param) {
        var mh$ = glTexEnvf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexEnvi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexEnvi$descriptor() {
        return glTexEnvi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexEnvi$handle() {
        return glTexEnvi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexEnvi$address() {
        return glTexEnvi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexEnvi(int target, int pname, int param) {
        var mh$ = glTexEnvi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvi", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexEnvfv$descriptor() {
        return glTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexEnvfv$handle() {
        return glTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexEnvfv$address() {
        return glTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexEnviv$descriptor() {
        return glTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexEnviv$handle() {
        return glTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexEnviv$address() {
        return glTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnvfv$descriptor() {
        return glGetTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexEnvfv$handle() {
        return glGetTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexEnvfv$address() {
        return glGetTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnviv$descriptor() {
        return glGetTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexEnviv$handle() {
        return glGetTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexEnviv$address() {
        return glGetTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexParameterf$descriptor() {
        return glTexParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexParameterf$handle() {
        return glTexParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexParameterf$address() {
        return glTexParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexParameterf(int target, int pname, float param) {
        var mh$ = glTexParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexParameteri$descriptor() {
        return glTexParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexParameteri$handle() {
        return glTexParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexParameteri$address() {
        return glTexParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexParameteri(int target, int pname, int param) {
        var mh$ = glTexParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteri", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexParameterfv$descriptor() {
        return glTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexParameterfv$handle() {
        return glTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexParameterfv$address() {
        return glTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexParameteriv$descriptor() {
        return glTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexParameteriv$handle() {
        return glTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexParameteriv$address() {
        return glTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterfv$descriptor() {
        return glGetTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexParameterfv$handle() {
        return glGetTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexParameterfv$address() {
        return glGetTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameteriv$descriptor() {
        return glGetTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexParameteriv$handle() {
        return glGetTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexParameteriv$address() {
        return glGetTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexLevelParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameterfv$descriptor() {
        return glGetTexLevelParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameterfv$handle() {
        return glGetTexLevelParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameterfv$address() {
        return glGetTexLevelParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexLevelParameterfv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameterfv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexLevelParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameteriv$descriptor() {
        return glGetTexLevelParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameteriv$handle() {
        return glGetTexLevelParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameteriv$address() {
        return glGetTexLevelParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexLevelParameteriv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameteriv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage1D$descriptor() {
        return glTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage1D$handle() {
        return glTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage1D$address() {
        return glTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage1D(int target, int level, int internalFormat, int width, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage1D", target, level, internalFormat, width, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage2D$descriptor() {
        return glTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage2D$handle() {
        return glTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage2D$address() {
        return glTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage2D", target, level, internalFormat, width, height, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, height, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glGetTexImage$descriptor() {
        return glGetTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glGetTexImage$handle() {
        return glGetTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glGetTexImage$address() {
        return glGetTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glGetTexImage(int target, int level, int format, int type, MemorySegment pixels) {
        var mh$ = glGetTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexImage", target, level, format, type, pixels);
            }
            mh$.invokeExact(target, level, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGenTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static FunctionDescriptor glGenTextures$descriptor() {
        return glGenTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MethodHandle glGenTextures$handle() {
        return glGenTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MemorySegment glGenTextures$address() {
        return glGenTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static void glGenTextures(int n, MemorySegment textures) {
        var mh$ = glGenTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glDeleteTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static FunctionDescriptor glDeleteTextures$descriptor() {
        return glDeleteTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MethodHandle glDeleteTextures$handle() {
        return glDeleteTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MemorySegment glDeleteTextures$address() {
        return glDeleteTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static void glDeleteTextures(int n, MemorySegment textures) {
        var mh$ = glDeleteTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glBindTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static FunctionDescriptor glBindTexture$descriptor() {
        return glBindTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MethodHandle glBindTexture$handle() {
        return glBindTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MemorySegment glBindTexture$address() {
        return glBindTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static void glBindTexture(int target, int texture) {
        var mh$ = glBindTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindTexture", target, texture);
            }
            mh$.invokeExact(target, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPrioritizeTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPrioritizeTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static FunctionDescriptor glPrioritizeTextures$descriptor() {
        return glPrioritizeTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MethodHandle glPrioritizeTextures$handle() {
        return glPrioritizeTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MemorySegment glPrioritizeTextures$address() {
        return glPrioritizeTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static void glPrioritizeTextures(int n, MemorySegment textures, MemorySegment priorities) {
        var mh$ = glPrioritizeTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPrioritizeTextures", n, textures, priorities);
            }
            mh$.invokeExact(n, textures, priorities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAreTexturesResident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_CHAR,
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glAreTexturesResident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static FunctionDescriptor glAreTexturesResident$descriptor() {
        return glAreTexturesResident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MethodHandle glAreTexturesResident$handle() {
        return glAreTexturesResident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MemorySegment glAreTexturesResident$address() {
        return glAreTexturesResident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static byte glAreTexturesResident(int n, MemorySegment textures, MemorySegment residences) {
        var mh$ = glAreTexturesResident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAreTexturesResident", n, textures, residences);
            }
            return (byte)mh$.invokeExact(n, textures, residences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_CHAR,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glIsTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static FunctionDescriptor glIsTexture$descriptor() {
        return glIsTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MethodHandle glIsTexture$handle() {
        return glIsTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MemorySegment glIsTexture$address() {
        return glIsTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static byte glIsTexture(int texture) {
        var mh$ = glIsTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsTexture", texture);
            }
            return (byte)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage1D$descriptor() {
        return glTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage1D$handle() {
        return glTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage1D$address() {
        return glTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage1D", target, level, xoffset, width, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, width, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage2D$descriptor() {
        return glTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage2D$handle() {
        return glTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage2D$address() {
        return glTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage2D", target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage1D$descriptor() {
        return glCopyTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage1D$handle() {
        return glCopyTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage1D$address() {
        return glCopyTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static void glCopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border) {
        var mh$ = glCopyTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage1D", target, level, internalformat, x, y, width, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage2D$descriptor() {
        return glCopyTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage2D$handle() {
        return glCopyTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage2D$address() {
        return glCopyTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
        var mh$ = glCopyTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage2D", target, level, internalformat, x, y, width, height, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, height, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage1D$descriptor() {
        return glCopyTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyTexSubImage1D$handle() {
        return glCopyTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyTexSubImage1D$address() {
        return glCopyTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width) {
        var mh$ = glCopyTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage1D", target, level, xoffset, x, y, width);
            }
            mh$.invokeExact(target, level, xoffset, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage2D$descriptor() {
        return glCopyTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage2D$handle() {
        return glCopyTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage2D$address() {
        return glCopyTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage2D", target, level, xoffset, yoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMap1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap1d$descriptor() {
        return glMap1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap1d$handle() {
        return glMap1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap1d$address() {
        return glMap1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static void glMap1d(int target, double u1, double u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1d", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMap1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap1f$descriptor() {
        return glMap1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap1f$handle() {
        return glMap1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap1f$address() {
        return glMap1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static void glMap1f(int target, float u1, float u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1f", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMap2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap2d$descriptor() {
        return glMap2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap2d$handle() {
        return glMap2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap2d$address() {
        return glMap2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2d", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMap2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap2f$descriptor() {
        return glMap2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap2f$handle() {
        return glMap2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap2f$address() {
        return glMap2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2f", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMapdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static FunctionDescriptor glGetMapdv$descriptor() {
        return glGetMapdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MethodHandle glGetMapdv$handle() {
        return glGetMapdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MemorySegment glGetMapdv$address() {
        return glGetMapdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static void glGetMapdv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapdv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static FunctionDescriptor glGetMapfv$descriptor() {
        return glGetMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MethodHandle glGetMapfv$handle() {
        return glGetMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MemorySegment glGetMapfv$address() {
        return glGetMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static void glGetMapfv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapfv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMapiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static FunctionDescriptor glGetMapiv$descriptor() {
        return glGetMapiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MethodHandle glGetMapiv$handle() {
        return glGetMapiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MemorySegment glGetMapiv$address() {
        return glGetMapiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static void glGetMapiv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapiv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1d$descriptor() {
        return glEvalCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MethodHandle glEvalCoord1d$handle() {
        return glEvalCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MemorySegment glEvalCoord1d$address() {
        return glEvalCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static void glEvalCoord1d(double u) {
        var mh$ = glEvalCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1d", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1f$descriptor() {
        return glEvalCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MethodHandle glEvalCoord1f$handle() {
        return glEvalCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MemorySegment glEvalCoord1f$address() {
        return glEvalCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static void glEvalCoord1f(float u) {
        var mh$ = glEvalCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1f", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1dv$descriptor() {
        return glEvalCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord1dv$handle() {
        return glEvalCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord1dv$address() {
        return glEvalCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord1dv(MemorySegment u) {
        var mh$ = glEvalCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1fv$descriptor() {
        return glEvalCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord1fv$handle() {
        return glEvalCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord1fv$address() {
        return glEvalCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord1fv(MemorySegment u) {
        var mh$ = glEvalCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2d$descriptor() {
        return glEvalCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MethodHandle glEvalCoord2d$handle() {
        return glEvalCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MemorySegment glEvalCoord2d$address() {
        return glEvalCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static void glEvalCoord2d(double u, double v) {
        var mh$ = glEvalCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2d", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2f$descriptor() {
        return glEvalCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MethodHandle glEvalCoord2f$handle() {
        return glEvalCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MemorySegment glEvalCoord2f$address() {
        return glEvalCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static void glEvalCoord2f(float u, float v) {
        var mh$ = glEvalCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2f", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2dv$descriptor() {
        return glEvalCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord2dv$handle() {
        return glEvalCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord2dv$address() {
        return glEvalCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord2dv(MemorySegment u) {
        var mh$ = glEvalCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2fv$descriptor() {
        return glEvalCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord2fv$handle() {
        return glEvalCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord2fv$address() {
        return glEvalCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord2fv(MemorySegment u) {
        var mh$ = glEvalCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMapGrid1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1d$descriptor() {
        return glMapGrid1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MethodHandle glMapGrid1d$handle() {
        return glMapGrid1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MemorySegment glMapGrid1d$address() {
        return glMapGrid1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static void glMapGrid1d(int un, double u1, double u2) {
        var mh$ = glMapGrid1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1d", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMapGrid1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1f$descriptor() {
        return glMapGrid1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MethodHandle glMapGrid1f$handle() {
        return glMapGrid1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MemorySegment glMapGrid1f$address() {
        return glMapGrid1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static void glMapGrid1f(int un, float u1, float u2) {
        var mh$ = glMapGrid1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1f", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMapGrid2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2d$descriptor() {
        return glMapGrid2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MethodHandle glMapGrid2d$handle() {
        return glMapGrid2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MemorySegment glMapGrid2d$address() {
        return glMapGrid2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
        var mh$ = glMapGrid2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2d", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMapGrid2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2f$descriptor() {
        return glMapGrid2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glMapGrid2f$handle() {
        return glMapGrid2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glMapGrid2f$address() {
        return glMapGrid2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
        var mh$ = glMapGrid2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2f", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalPoint1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static FunctionDescriptor glEvalPoint1$descriptor() {
        return glEvalPoint1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MethodHandle glEvalPoint1$handle() {
        return glEvalPoint1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MemorySegment glEvalPoint1$address() {
        return glEvalPoint1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static void glEvalPoint1(int i) {
        var mh$ = glEvalPoint1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint1", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalPoint2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static FunctionDescriptor glEvalPoint2$descriptor() {
        return glEvalPoint2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MethodHandle glEvalPoint2$handle() {
        return glEvalPoint2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MemorySegment glEvalPoint2$address() {
        return glEvalPoint2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static void glEvalPoint2(int i, int j) {
        var mh$ = glEvalPoint2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint2", i, j);
            }
            mh$.invokeExact(i, j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalMesh1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static FunctionDescriptor glEvalMesh1$descriptor() {
        return glEvalMesh1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MethodHandle glEvalMesh1$handle() {
        return glEvalMesh1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MemorySegment glEvalMesh1$address() {
        return glEvalMesh1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static void glEvalMesh1(int mode, int i1, int i2) {
        var mh$ = glEvalMesh1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh1", mode, i1, i2);
            }
            mh$.invokeExact(mode, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glEvalMesh2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static FunctionDescriptor glEvalMesh2$descriptor() {
        return glEvalMesh2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MethodHandle glEvalMesh2$handle() {
        return glEvalMesh2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MemorySegment glEvalMesh2$address() {
        return glEvalMesh2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static void glEvalMesh2(int mode, int i1, int i2, int j1, int j2) {
        var mh$ = glEvalMesh2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh2", mode, i1, i2, j1, j2);
            }
            mh$.invokeExact(mode, i1, i2, j1, j2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glFogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glFogf$descriptor() {
        return glFogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glFogf$handle() {
        return glFogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glFogf$address() {
        return glFogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static void glFogf(int pname, float param) {
        var mh$ = glFogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glFogi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glFogi$descriptor() {
        return glFogi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glFogi$handle() {
        return glFogi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glFogi$address() {
        return glFogi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static void glFogi(int pname, int param) {
        var mh$ = glFogi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glFogfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glFogfv$descriptor() {
        return glFogfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glFogfv$handle() {
        return glFogfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glFogfv$address() {
        return glFogfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glFogfv(int pname, MemorySegment params) {
        var mh$ = glFogfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glFogiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glFogiv$descriptor() {
        return glFogiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glFogiv$handle() {
        return glFogiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glFogiv$address() {
        return glFogiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static void glFogiv(int pname, MemorySegment params) {
        var mh$ = glFogiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogiv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFeedbackBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glFeedbackBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static FunctionDescriptor glFeedbackBuffer$descriptor() {
        return glFeedbackBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MethodHandle glFeedbackBuffer$handle() {
        return glFeedbackBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MemorySegment glFeedbackBuffer$address() {
        return glFeedbackBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static void glFeedbackBuffer(int size, int type, MemorySegment buffer) {
        var mh$ = glFeedbackBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFeedbackBuffer", size, type, buffer);
            }
            mh$.invokeExact(size, type, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPassThrough {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPassThrough");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static FunctionDescriptor glPassThrough$descriptor() {
        return glPassThrough.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MethodHandle glPassThrough$handle() {
        return glPassThrough.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MemorySegment glPassThrough$address() {
        return glPassThrough.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static void glPassThrough(float token) {
        var mh$ = glPassThrough.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPassThrough", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSelectBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glSelectBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static FunctionDescriptor glSelectBuffer$descriptor() {
        return glSelectBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MethodHandle glSelectBuffer$handle() {
        return glSelectBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MemorySegment glSelectBuffer$address() {
        return glSelectBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static void glSelectBuffer(int size, MemorySegment buffer) {
        var mh$ = glSelectBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSelectBuffer", size, buffer);
            }
            mh$.invokeExact(size, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInitNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glInitNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static FunctionDescriptor glInitNames$descriptor() {
        return glInitNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MethodHandle glInitNames$handle() {
        return glInitNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MemorySegment glInitNames$address() {
        return glInitNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static void glInitNames() {
        var mh$ = glInitNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInitNames");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLoadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static FunctionDescriptor glLoadName$descriptor() {
        return glLoadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MethodHandle glLoadName$handle() {
        return glLoadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MemorySegment glLoadName$address() {
        return glLoadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static void glLoadName(int name) {
        var mh$ = glLoadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPushName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static FunctionDescriptor glPushName$descriptor() {
        return glPushName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MethodHandle glPushName$handle() {
        return glPushName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MemorySegment glPushName$address() {
        return glPushName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static void glPushName(int name) {
        var mh$ = glPushName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glPopName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static FunctionDescriptor glPopName$descriptor() {
        return glPopName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MethodHandle glPopName$handle() {
        return glPopName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MemorySegment glPopName$address() {
        return glPopName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static void glPopName() {
        var mh$ = glPopName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopName");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawRangeElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glDrawRangeElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawRangeElements$descriptor() {
        return glDrawRangeElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawRangeElements$handle() {
        return glDrawRangeElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawRangeElements$address() {
        return glDrawRangeElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawRangeElements(int mode, int start, int end, int count, int type, MemorySegment indices) {
        var mh$ = glDrawRangeElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawRangeElements", mode, start, end, count, type, indices);
            }
            mh$.invokeExact(mode, start, end, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage3D$descriptor() {
        return glTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage3D$handle() {
        return glTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage3D$address() {
        return glTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage3D(int target, int level, int internalFormat, int width, int height, int depth, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage3D", target, level, internalFormat, width, height, depth, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, height, depth, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage3D$descriptor() {
        return glTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage3D$handle() {
        return glTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage3D$address() {
        return glTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage3D$descriptor() {
        return glCopyTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage3D$handle() {
        return glCopyTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage3D$address() {
        return glCopyTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage3D", target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static FunctionDescriptor glColorTable$descriptor() {
        return glColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MethodHandle glColorTable$handle() {
        return glColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MemorySegment glColorTable$address() {
        return glColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static void glColorTable(int target, int internalformat, int width, int format, int type, MemorySegment table) {
        var mh$ = glColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTable", target, internalformat, width, format, type, table);
            }
            mh$.invokeExact(target, internalformat, width, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glColorSubTable$descriptor() {
        return glColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MethodHandle glColorSubTable$handle() {
        return glColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MemorySegment glColorSubTable$address() {
        return glColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static void glColorSubTable(int target, int start, int count, int format, int type, MemorySegment data) {
        var mh$ = glColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorSubTable", target, start, count, format, type, data);
            }
            mh$.invokeExact(target, start, count, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameteriv$descriptor() {
        return glColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glColorTableParameteriv$handle() {
        return glColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glColorTableParameteriv$address() {
        return glColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameterfv$descriptor() {
        return glColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glColorTableParameterfv$handle() {
        return glColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glColorTableParameterfv$address() {
        return glColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorSubTable$descriptor() {
        return glCopyColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorSubTable$handle() {
        return glCopyColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorSubTable$address() {
        return glCopyColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorSubTable(int target, int start, int x, int y, int width) {
        var mh$ = glCopyColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorSubTable", target, start, x, y, width);
            }
            mh$.invokeExact(target, start, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorTable$descriptor() {
        return glCopyColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorTable$handle() {
        return glCopyColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorTable$address() {
        return glCopyColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorTable(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorTable", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static FunctionDescriptor glGetColorTable$descriptor() {
        return glGetColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MethodHandle glGetColorTable$handle() {
        return glGetColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MemorySegment glGetColorTable$address() {
        return glGetColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static void glGetColorTable(int target, int format, int type, MemorySegment table) {
        var mh$ = glGetColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTable", target, format, type, table);
            }
            mh$.invokeExact(target, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameterfv$descriptor() {
        return glGetColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetColorTableParameterfv$handle() {
        return glGetColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetColorTableParameterfv$address() {
        return glGetColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameteriv$descriptor() {
        return glGetColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetColorTableParameteriv$handle() {
        return glGetColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetColorTableParameteriv$address() {
        return glGetColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glBlendEquation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBlendEquation$descriptor() {
        return glBlendEquation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static MethodHandle glBlendEquation$handle() {
        return glBlendEquation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static MemorySegment glBlendEquation$address() {
        return glBlendEquation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static void glBlendEquation(int mode) {
        var mh$ = glBlendEquation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquation", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glBlendColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glBlendColor$descriptor() {
        return glBlendColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glBlendColor$handle() {
        return glBlendColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glBlendColor$address() {
        return glBlendColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glBlendColor(float red, float green, float blue, float alpha) {
        var mh$ = glBlendColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glHistogram$descriptor() {
        return glHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glHistogram$handle() {
        return glHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glHistogram$address() {
        return glHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glHistogram(int target, int width, int internalformat, byte sink) {
        var mh$ = glHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHistogram", target, width, internalformat, sink);
            }
            mh$.invokeExact(target, width, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glResetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetHistogram$descriptor() {
        return glResetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static MethodHandle glResetHistogram$handle() {
        return glResetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static MemorySegment glResetHistogram$address() {
        return glResetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static void glResetHistogram(int target) {
        var mh$ = glResetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetHistogram", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_CHAR,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetHistogram$descriptor() {
        return glGetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MethodHandle glGetHistogram$handle() {
        return glGetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MemorySegment glGetHistogram$address() {
        return glGetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static void glGetHistogram(int target, byte reset, int format, int type, MemorySegment values) {
        var mh$ = glGetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogram", target, reset, format, type, values);
            }
            mh$.invokeExact(target, reset, format, type, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetHistogramParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameterfv$descriptor() {
        return glGetHistogramParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetHistogramParameterfv$handle() {
        return glGetHistogramParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetHistogramParameterfv$address() {
        return glGetHistogramParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetHistogramParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetHistogramParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameteriv$descriptor() {
        return glGetHistogramParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetHistogramParameteriv$handle() {
        return glGetHistogramParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetHistogramParameteriv$address() {
        return glGetHistogramParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetHistogramParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glMinmax$descriptor() {
        return glMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glMinmax$handle() {
        return glMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glMinmax$address() {
        return glMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glMinmax(int target, int internalformat, byte sink) {
        var mh$ = glMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMinmax", target, internalformat, sink);
            }
            mh$.invokeExact(target, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glResetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetMinmax$descriptor() {
        return glResetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static MethodHandle glResetMinmax$handle() {
        return glResetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static MemorySegment glResetMinmax$address() {
        return glResetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static void glResetMinmax(int target) {
        var mh$ = glResetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetMinmax", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_CHAR,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetMinmax$descriptor() {
        return glGetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static MethodHandle glGetMinmax$handle() {
        return glGetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static MemorySegment glGetMinmax$address() {
        return glGetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static void glGetMinmax(int target, byte reset, int format, int types, MemorySegment values) {
        var mh$ = glGetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmax", target, reset, format, types, values);
            }
            mh$.invokeExact(target, reset, format, types, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMinmaxParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameterfv$descriptor() {
        return glGetMinmaxParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameterfv$handle() {
        return glGetMinmaxParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameterfv$address() {
        return glGetMinmaxParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMinmaxParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetMinmaxParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameteriv$descriptor() {
        return glGetMinmaxParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameteriv$handle() {
        return glGetMinmaxParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameteriv$address() {
        return glGetMinmaxParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMinmaxParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter1D$descriptor() {
        return glConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter1D$handle() {
        return glConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter1D$address() {
        return glConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter1D", target, internalformat, width, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter2D$descriptor() {
        return glConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter2D$handle() {
        return glConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter2D$address() {
        return glConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter2D", target, internalformat, width, height, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glConvolutionParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterf$descriptor() {
        return glConvolutionParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MethodHandle glConvolutionParameterf$handle() {
        return glConvolutionParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MemorySegment glConvolutionParameterf$address() {
        return glConvolutionParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static void glConvolutionParameterf(int target, int pname, float params) {
        var mh$ = glConvolutionParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterf", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterfv$descriptor() {
        return glConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glConvolutionParameterfv$handle() {
        return glConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glConvolutionParameterfv$address() {
        return glConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glConvolutionParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteri$descriptor() {
        return glConvolutionParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MethodHandle glConvolutionParameteri$handle() {
        return glConvolutionParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MemorySegment glConvolutionParameteri$address() {
        return glConvolutionParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static void glConvolutionParameteri(int target, int pname, int params) {
        var mh$ = glConvolutionParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteri", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteriv$descriptor() {
        return glConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glConvolutionParameteriv$handle() {
        return glConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glConvolutionParameteriv$address() {
        return glConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter1D$descriptor() {
        return glCopyConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter1D$handle() {
        return glCopyConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter1D$address() {
        return glCopyConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter1D", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCopyConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter2D$descriptor() {
        return glCopyConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter2D$handle() {
        return glCopyConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter2D$address() {
        return glCopyConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height) {
        var mh$ = glCopyConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter2D", target, internalformat, x, y, width, height);
            }
            mh$.invokeExact(target, internalformat, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetConvolutionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static FunctionDescriptor glGetConvolutionFilter$descriptor() {
        return glGetConvolutionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MethodHandle glGetConvolutionFilter$handle() {
        return glGetConvolutionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MemorySegment glGetConvolutionFilter$address() {
        return glGetConvolutionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static void glGetConvolutionFilter(int target, int format, int type, MemorySegment image) {
        var mh$ = glGetConvolutionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionFilter", target, format, type, image);
            }
            mh$.invokeExact(target, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameterfv$descriptor() {
        return glGetConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameterfv$handle() {
        return glGetConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameterfv$address() {
        return glGetConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameteriv$descriptor() {
        return glGetConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameteriv$handle() {
        return glGetConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameteriv$address() {
        return glGetConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSeparableFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glSeparableFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static FunctionDescriptor glSeparableFilter2D$descriptor() {
        return glSeparableFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MethodHandle glSeparableFilter2D$handle() {
        return glSeparableFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MemorySegment glSeparableFilter2D$address() {
        return glSeparableFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment row, MemorySegment column) {
        var mh$ = glSeparableFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSeparableFilter2D", target, internalformat, width, height, format, type, row, column);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, row, column);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetSeparableFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetSeparableFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static FunctionDescriptor glGetSeparableFilter$descriptor() {
        return glGetSeparableFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MethodHandle glGetSeparableFilter$handle() {
        return glGetSeparableFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MemorySegment glGetSeparableFilter$address() {
        return glGetSeparableFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static void glGetSeparableFilter(int target, int format, int type, MemorySegment row, MemorySegment column, MemorySegment span) {
        var mh$ = glGetSeparableFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetSeparableFilter", target, format, type, row, column, span);
            }
            mh$.invokeExact(target, format, type, row, column, span);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTexture$descriptor() {
        return glActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTexture$handle() {
        return glActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTexture$address() {
        return glActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static void glActiveTexture(int texture) {
        var mh$ = glActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glClientActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTexture$descriptor() {
        return glClientActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTexture$handle() {
        return glClientActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTexture$address() {
        return glClientActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static void glClientActiveTexture(int texture) {
        var mh$ = glClientActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCompressedTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage1D$descriptor() {
        return glCompressedTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage1D$handle() {
        return glCompressedTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage1D$address() {
        return glCompressedTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage1D", target, level, internalformat, width, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCompressedTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage2D$descriptor() {
        return glCompressedTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage2D$handle() {
        return glCompressedTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage2D$address() {
        return glCompressedTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage2D", target, level, internalformat, width, height, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCompressedTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage3D$descriptor() {
        return glCompressedTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage3D$handle() {
        return glCompressedTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage3D$address() {
        return glCompressedTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage3D", target, level, internalformat, width, height, depth, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, depth, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCompressedTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage1D$descriptor() {
        return glCompressedTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage1D$handle() {
        return glCompressedTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage1D$address() {
        return glCompressedTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage1D", target, level, xoffset, width, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, width, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCompressedTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage2D$descriptor() {
        return glCompressedTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage2D$handle() {
        return glCompressedTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage2D$address() {
        return glCompressedTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage2D", target, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glCompressedTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage3D$descriptor() {
        return glCompressedTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage3D$handle() {
        return glCompressedTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage3D$address() {
        return glCompressedTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetCompressedTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glGetCompressedTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static FunctionDescriptor glGetCompressedTexImage$descriptor() {
        return glGetCompressedTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MethodHandle glGetCompressedTexImage$handle() {
        return glGetCompressedTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MemorySegment glGetCompressedTexImage$address() {
        return glGetCompressedTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static void glGetCompressedTexImage(int target, int lod, MemorySegment img) {
        var mh$ = glGetCompressedTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetCompressedTexImage", target, lod, img);
            }
            mh$.invokeExact(target, lod, img);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1d$descriptor() {
        return glMultiTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1d$handle() {
        return glMultiTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1d$address() {
        return glMultiTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1d(int target, double s) {
        var mh$ = glMultiTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1d", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dv$descriptor() {
        return glMultiTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dv$handle() {
        return glMultiTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dv$address() {
        return glMultiTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1f$descriptor() {
        return glMultiTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1f$handle() {
        return glMultiTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1f$address() {
        return glMultiTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1f(int target, float s) {
        var mh$ = glMultiTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1f", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fv$descriptor() {
        return glMultiTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fv$handle() {
        return glMultiTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fv$address() {
        return glMultiTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1i$descriptor() {
        return glMultiTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1i$handle() {
        return glMultiTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1i$address() {
        return glMultiTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1i(int target, int s) {
        var mh$ = glMultiTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1i", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iv$descriptor() {
        return glMultiTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1iv$handle() {
        return glMultiTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1iv$address() {
        return glMultiTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1s$descriptor() {
        return glMultiTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1s$handle() {
        return glMultiTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1s$address() {
        return glMultiTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1s(int target, short s) {
        var mh$ = glMultiTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1s", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sv$descriptor() {
        return glMultiTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1sv$handle() {
        return glMultiTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1sv$address() {
        return glMultiTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2d$descriptor() {
        return glMultiTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2d$handle() {
        return glMultiTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2d$address() {
        return glMultiTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2d(int target, double s, double t) {
        var mh$ = glMultiTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2d", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dv$descriptor() {
        return glMultiTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dv$handle() {
        return glMultiTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dv$address() {
        return glMultiTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2f$descriptor() {
        return glMultiTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2f$handle() {
        return glMultiTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2f$address() {
        return glMultiTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2f(int target, float s, float t) {
        var mh$ = glMultiTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2f", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fv$descriptor() {
        return glMultiTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fv$handle() {
        return glMultiTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fv$address() {
        return glMultiTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2i$descriptor() {
        return glMultiTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2i$handle() {
        return glMultiTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2i$address() {
        return glMultiTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2i(int target, int s, int t) {
        var mh$ = glMultiTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2i", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iv$descriptor() {
        return glMultiTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2iv$handle() {
        return glMultiTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2iv$address() {
        return glMultiTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2s$descriptor() {
        return glMultiTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2s$handle() {
        return glMultiTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2s$address() {
        return glMultiTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2s(int target, short s, short t) {
        var mh$ = glMultiTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2s", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sv$descriptor() {
        return glMultiTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2sv$handle() {
        return glMultiTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2sv$address() {
        return glMultiTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3d$descriptor() {
        return glMultiTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3d$handle() {
        return glMultiTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3d$address() {
        return glMultiTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3d(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3d", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dv$descriptor() {
        return glMultiTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dv$handle() {
        return glMultiTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dv$address() {
        return glMultiTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3f$descriptor() {
        return glMultiTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3f$handle() {
        return glMultiTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3f$address() {
        return glMultiTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3f(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3f", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fv$descriptor() {
        return glMultiTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fv$handle() {
        return glMultiTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fv$address() {
        return glMultiTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3i$descriptor() {
        return glMultiTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3i$handle() {
        return glMultiTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3i$address() {
        return glMultiTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3i(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3i", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iv$descriptor() {
        return glMultiTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3iv$handle() {
        return glMultiTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3iv$address() {
        return glMultiTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3s$descriptor() {
        return glMultiTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3s$handle() {
        return glMultiTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3s$address() {
        return glMultiTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3s(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3s", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sv$descriptor() {
        return glMultiTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3sv$handle() {
        return glMultiTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3sv$address() {
        return glMultiTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4d$descriptor() {
        return glMultiTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4d$handle() {
        return glMultiTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4d$address() {
        return glMultiTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4d(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4d", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dv$descriptor() {
        return glMultiTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dv$handle() {
        return glMultiTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dv$address() {
        return glMultiTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4f$descriptor() {
        return glMultiTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4f$handle() {
        return glMultiTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4f$address() {
        return glMultiTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4f(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4f", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fv$descriptor() {
        return glMultiTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fv$handle() {
        return glMultiTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fv$address() {
        return glMultiTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4i$descriptor() {
        return glMultiTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4i$handle() {
        return glMultiTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4i$address() {
        return glMultiTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4i(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4i", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iv$descriptor() {
        return glMultiTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4iv$handle() {
        return glMultiTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4iv$address() {
        return glMultiTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4s$descriptor() {
        return glMultiTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4s$handle() {
        return glMultiTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4s$address() {
        return glMultiTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4s(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4s", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sv$descriptor() {
        return glMultiTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4sv$handle() {
        return glMultiTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4sv$address() {
        return glMultiTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLoadTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixd$descriptor() {
        return glLoadTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MethodHandle glLoadTransposeMatrixd$handle() {
        return glLoadTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MemorySegment glLoadTransposeMatrixd$address() {
        return glLoadTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static void glLoadTransposeMatrixd(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glLoadTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixf$descriptor() {
        return glLoadTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MethodHandle glLoadTransposeMatrixf$handle() {
        return glLoadTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MemorySegment glLoadTransposeMatrixf$address() {
        return glLoadTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static void glLoadTransposeMatrixf(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixd$descriptor() {
        return glMultTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MethodHandle glMultTransposeMatrixd$handle() {
        return glMultTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MemorySegment glMultTransposeMatrixd$address() {
        return glMultTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static void glMultTransposeMatrixd(MemorySegment m) {
        var mh$ = glMultTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixf$descriptor() {
        return glMultTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MethodHandle glMultTransposeMatrixf$handle() {
        return glMultTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MemorySegment glMultTransposeMatrixf$address() {
        return glMultTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static void glMultTransposeMatrixf(MemorySegment m) {
        var mh$ = glMultTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSampleCoverage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_FLOAT,
            glxext_h.C_CHAR
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glSampleCoverage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static FunctionDescriptor glSampleCoverage$descriptor() {
        return glSampleCoverage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MethodHandle glSampleCoverage$handle() {
        return glSampleCoverage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MemorySegment glSampleCoverage$address() {
        return glSampleCoverage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static void glSampleCoverage(float value, byte invert) {
        var mh$ = glSampleCoverage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSampleCoverage", value, invert);
            }
            mh$.invokeExact(value, invert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTextureARB$descriptor() {
        return glActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTextureARB$handle() {
        return glActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTextureARB$address() {
        return glActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static void glActiveTextureARB(int texture) {
        var mh$ = glActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glClientActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTextureARB$descriptor() {
        return glClientActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTextureARB$handle() {
        return glClientActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTextureARB$address() {
        return glClientActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static void glClientActiveTextureARB(int texture) {
        var mh$ = glClientActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dARB$descriptor() {
        return glMultiTexCoord1dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1dARB$handle() {
        return glMultiTexCoord1dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1dARB$address() {
        return glMultiTexCoord1dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1dARB(int target, double s) {
        var mh$ = glMultiTexCoord1dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dvARB$descriptor() {
        return glMultiTexCoord1dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dvARB$handle() {
        return glMultiTexCoord1dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dvARB$address() {
        return glMultiTexCoord1dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fARB$descriptor() {
        return glMultiTexCoord1fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1fARB$handle() {
        return glMultiTexCoord1fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1fARB$address() {
        return glMultiTexCoord1fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1fARB(int target, float s) {
        var mh$ = glMultiTexCoord1fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fvARB$descriptor() {
        return glMultiTexCoord1fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fvARB$handle() {
        return glMultiTexCoord1fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fvARB$address() {
        return glMultiTexCoord1fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iARB$descriptor() {
        return glMultiTexCoord1iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1iARB$handle() {
        return glMultiTexCoord1iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1iARB$address() {
        return glMultiTexCoord1iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1iARB(int target, int s) {
        var mh$ = glMultiTexCoord1iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1ivARB$descriptor() {
        return glMultiTexCoord1ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1ivARB$handle() {
        return glMultiTexCoord1ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1ivARB$address() {
        return glMultiTexCoord1ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sARB$descriptor() {
        return glMultiTexCoord1sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1sARB$handle() {
        return glMultiTexCoord1sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1sARB$address() {
        return glMultiTexCoord1sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1sARB(int target, short s) {
        var mh$ = glMultiTexCoord1sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord1svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1svARB$descriptor() {
        return glMultiTexCoord1svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1svARB$handle() {
        return glMultiTexCoord1svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1svARB$address() {
        return glMultiTexCoord1svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dARB$descriptor() {
        return glMultiTexCoord2dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2dARB$handle() {
        return glMultiTexCoord2dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2dARB$address() {
        return glMultiTexCoord2dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2dARB(int target, double s, double t) {
        var mh$ = glMultiTexCoord2dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dvARB$descriptor() {
        return glMultiTexCoord2dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dvARB$handle() {
        return glMultiTexCoord2dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dvARB$address() {
        return glMultiTexCoord2dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fARB$descriptor() {
        return glMultiTexCoord2fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2fARB$handle() {
        return glMultiTexCoord2fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2fARB$address() {
        return glMultiTexCoord2fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2fARB(int target, float s, float t) {
        var mh$ = glMultiTexCoord2fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fvARB$descriptor() {
        return glMultiTexCoord2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fvARB$handle() {
        return glMultiTexCoord2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fvARB$address() {
        return glMultiTexCoord2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iARB$descriptor() {
        return glMultiTexCoord2iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2iARB$handle() {
        return glMultiTexCoord2iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2iARB$address() {
        return glMultiTexCoord2iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2iARB(int target, int s, int t) {
        var mh$ = glMultiTexCoord2iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2ivARB$descriptor() {
        return glMultiTexCoord2ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2ivARB$handle() {
        return glMultiTexCoord2ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2ivARB$address() {
        return glMultiTexCoord2ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sARB$descriptor() {
        return glMultiTexCoord2sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2sARB$handle() {
        return glMultiTexCoord2sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2sARB$address() {
        return glMultiTexCoord2sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2sARB(int target, short s, short t) {
        var mh$ = glMultiTexCoord2sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord2svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2svARB$descriptor() {
        return glMultiTexCoord2svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2svARB$handle() {
        return glMultiTexCoord2svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2svARB$address() {
        return glMultiTexCoord2svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dARB$descriptor() {
        return glMultiTexCoord3dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3dARB$handle() {
        return glMultiTexCoord3dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3dARB$address() {
        return glMultiTexCoord3dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3dARB(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dvARB$descriptor() {
        return glMultiTexCoord3dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dvARB$handle() {
        return glMultiTexCoord3dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dvARB$address() {
        return glMultiTexCoord3dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fARB$descriptor() {
        return glMultiTexCoord3fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3fARB$handle() {
        return glMultiTexCoord3fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3fARB$address() {
        return glMultiTexCoord3fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3fARB(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fvARB$descriptor() {
        return glMultiTexCoord3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fvARB$handle() {
        return glMultiTexCoord3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fvARB$address() {
        return glMultiTexCoord3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iARB$descriptor() {
        return glMultiTexCoord3iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3iARB$handle() {
        return glMultiTexCoord3iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3iARB$address() {
        return glMultiTexCoord3iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3iARB(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3ivARB$descriptor() {
        return glMultiTexCoord3ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3ivARB$handle() {
        return glMultiTexCoord3ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3ivARB$address() {
        return glMultiTexCoord3ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sARB$descriptor() {
        return glMultiTexCoord3sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3sARB$handle() {
        return glMultiTexCoord3sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3sARB$address() {
        return glMultiTexCoord3sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3sARB(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord3svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3svARB$descriptor() {
        return glMultiTexCoord3svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3svARB$handle() {
        return glMultiTexCoord3svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3svARB$address() {
        return glMultiTexCoord3svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE,
            glxext_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dARB$descriptor() {
        return glMultiTexCoord4dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4dARB$handle() {
        return glMultiTexCoord4dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4dARB$address() {
        return glMultiTexCoord4dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4dARB(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dvARB$descriptor() {
        return glMultiTexCoord4dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dvARB$handle() {
        return glMultiTexCoord4dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dvARB$address() {
        return glMultiTexCoord4dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fARB$descriptor() {
        return glMultiTexCoord4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4fARB$handle() {
        return glMultiTexCoord4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4fARB$address() {
        return glMultiTexCoord4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4fARB(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fvARB$descriptor() {
        return glMultiTexCoord4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fvARB$handle() {
        return glMultiTexCoord4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fvARB$address() {
        return glMultiTexCoord4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iARB$descriptor() {
        return glMultiTexCoord4iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4iARB$handle() {
        return glMultiTexCoord4iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4iARB$address() {
        return glMultiTexCoord4iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4iARB(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4ivARB$descriptor() {
        return glMultiTexCoord4ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4ivARB$handle() {
        return glMultiTexCoord4ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4ivARB$address() {
        return glMultiTexCoord4ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT,
            glxext_h.C_SHORT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sARB$descriptor() {
        return glMultiTexCoord4sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4sARB$handle() {
        return glMultiTexCoord4sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4sARB$address() {
        return glMultiTexCoord4sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4sARB(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glMultiTexCoord4svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4svARB$descriptor() {
        return glMultiTexCoord4svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4svARB$handle() {
        return glMultiTexCoord4svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4svARB$address() {
        return glMultiTexCoord4svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t khronos_int32_t
     * }
     */
    public static final OfInt khronos_int32_t = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t khronos_uint32_t
     * }
     */
    public static final OfInt khronos_uint32_t = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t khronos_int64_t
     * }
     */
    public static final OfLong khronos_int64_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t khronos_uint64_t
     * }
     */
    public static final OfLong khronos_uint64_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char khronos_int8_t
     * }
     */
    public static final OfByte khronos_int8_t = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char khronos_uint8_t
     * }
     */
    public static final OfByte khronos_uint8_t = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short khronos_int16_t
     * }
     */
    public static final OfShort khronos_int16_t = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short khronos_uint16_t
     * }
     */
    public static final OfShort khronos_uint16_t = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long khronos_intptr_t
     * }
     */
    public static final OfLong khronos_intptr_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long khronos_uintptr_t
     * }
     */
    public static final OfLong khronos_uintptr_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long khronos_ssize_t
     * }
     */
    public static final OfLong khronos_ssize_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long khronos_usize_t
     * }
     */
    public static final OfLong khronos_usize_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef float khronos_float_t
     * }
     */
    public static final OfFloat khronos_float_t = glxext_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t khronos_utime_nanoseconds_t
     * }
     */
    public static final OfLong khronos_utime_nanoseconds_t = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t khronos_stime_nanoseconds_t
     * }
     */
    public static final OfLong khronos_stime_nanoseconds_t = glxext_h.C_LONG;
    private static final int KHRONOS_FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_FALSE = 0
     * }
     */
    public static int KHRONOS_FALSE() {
        return KHRONOS_FALSE;
    }
    private static final int KHRONOS_TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_TRUE = 1
     * }
     */
    public static int KHRONOS_TRUE() {
        return KHRONOS_TRUE;
    }
    private static final int KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 2147483647
     * }
     */
    public static int KHRONOS_BOOLEAN_ENUM_FORCE_SIZE() {
        return KHRONOS_BOOLEAN_ENUM_FORCE_SIZE;
    }
    /**
     * {@snippet lang=c :
     * typedef khronos_ssize_t GLsizeiptr
     * }
     */
    public static final OfLong GLsizeiptr = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_intptr_t GLintptr
     * }
     */
    public static final OfLong GLintptr = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char GLchar
     * }
     */
    public static final OfByte GLchar = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint16_t GLhalf
     * }
     */
    public static final OfShort GLhalf = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct __GLsync *GLsync
     * }
     */
    public static final AddressLayout GLsync = glxext_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t GLuint64
     * }
     */
    public static final OfLong GLuint64 = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t GLint64
     * }
     */
    public static final OfLong GLint64 = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t GLuint64EXT
     * }
     */
    public static final OfLong GLuint64EXT = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint16_t GLhalfARB
     * }
     */
    public static final OfShort GLhalfARB = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLhandleARB
     * }
     */
    public static final OfInt GLhandleARB = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char GLcharARB
     * }
     */
    public static final OfByte GLcharARB = glxext_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef khronos_ssize_t GLsizeiptrARB
     * }
     */
    public static final OfLong GLsizeiptrARB = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_intptr_t GLintptrARB
     * }
     */
    public static final OfLong GLintptrARB = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int32_t GLfixed
     * }
     */
    public static final OfInt GLfixed = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t GLint64EXT
     * }
     */
    public static final OfLong GLint64EXT = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *GLeglImageOES
     * }
     */
    public static final AddressLayout GLeglImageOES = glxext_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *GLeglClientBufferEXT
     * }
     */
    public static final AddressLayout GLeglClientBufferEXT = glxext_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short GLhalfNV
     * }
     */
    public static final OfShort GLhalfNV = glxext_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef GLintptr GLvdpauSurfaceNV
     * }
     */
    public static final OfLong GLvdpauSurfaceNV = glxext_h.C_LONG;

    private static class glBlendEquationSeparateATI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glBlendEquationSeparateATI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static FunctionDescriptor glBlendEquationSeparateATI$descriptor() {
        return glBlendEquationSeparateATI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static MethodHandle glBlendEquationSeparateATI$handle() {
        return glBlendEquationSeparateATI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static MemorySegment glBlendEquationSeparateATI$address() {
        return glBlendEquationSeparateATI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static void glBlendEquationSeparateATI(int modeRGB, int modeA) {
        var mh$ = glBlendEquationSeparateATI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquationSeparateATI", modeRGB, modeA);
            }
            mh$.invokeExact(modeRGB, modeA);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __GLXcontextRec *GLXContext
     * }
     */
    public static final AddressLayout GLXContext = glxext_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef XID GLXPixmap
     * }
     */
    public static final OfLong GLXPixmap = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef XID GLXDrawable
     * }
     */
    public static final OfLong GLXDrawable = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __GLXFBConfigRec *GLXFBConfig
     * }
     */
    public static final AddressLayout GLXFBConfig = glxext_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef XID GLXFBConfigID
     * }
     */
    public static final OfLong GLXFBConfigID = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef XID GLXContextID
     * }
     */
    public static final OfLong GLXContextID = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef XID GLXWindow
     * }
     */
    public static final OfLong GLXWindow = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef XID GLXPbuffer
     * }
     */
    public static final OfLong GLXPbuffer = glxext_h.C_LONG;

    private static class glXChooseVisual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXChooseVisual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern XVisualInfo *glXChooseVisual(Display *dpy, int screen, int *attribList)
     * }
     */
    public static FunctionDescriptor glXChooseVisual$descriptor() {
        return glXChooseVisual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern XVisualInfo *glXChooseVisual(Display *dpy, int screen, int *attribList)
     * }
     */
    public static MethodHandle glXChooseVisual$handle() {
        return glXChooseVisual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern XVisualInfo *glXChooseVisual(Display *dpy, int screen, int *attribList)
     * }
     */
    public static MemorySegment glXChooseVisual$address() {
        return glXChooseVisual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern XVisualInfo *glXChooseVisual(Display *dpy, int screen, int *attribList)
     * }
     */
    public static MemorySegment glXChooseVisual(MemorySegment dpy, int screen, MemorySegment attribList) {
        var mh$ = glXChooseVisual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXChooseVisual", dpy, screen, attribList);
            }
            return (MemorySegment)mh$.invokeExact(dpy, screen, attribList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, int direct)
     * }
     */
    public static FunctionDescriptor glXCreateContext$descriptor() {
        return glXCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, int direct)
     * }
     */
    public static MethodHandle glXCreateContext$handle() {
        return glXCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, int direct)
     * }
     */
    public static MemorySegment glXCreateContext$address() {
        return glXCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, int direct)
     * }
     */
    public static MemorySegment glXCreateContext(MemorySegment dpy, MemorySegment vis, MemorySegment shareList, int direct) {
        var mh$ = glXCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXCreateContext", dpy, vis, shareList, direct);
            }
            return (MemorySegment)mh$.invokeExact(dpy, vis, shareList, direct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXDestroyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXDestroyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXDestroyContext(Display *dpy, GLXContext ctx)
     * }
     */
    public static FunctionDescriptor glXDestroyContext$descriptor() {
        return glXDestroyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXDestroyContext(Display *dpy, GLXContext ctx)
     * }
     */
    public static MethodHandle glXDestroyContext$handle() {
        return glXDestroyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXDestroyContext(Display *dpy, GLXContext ctx)
     * }
     */
    public static MemorySegment glXDestroyContext$address() {
        return glXDestroyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXDestroyContext(Display *dpy, GLXContext ctx)
     * }
     */
    public static void glXDestroyContext(MemorySegment dpy, MemorySegment ctx) {
        var mh$ = glXDestroyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXDestroyContext", dpy, ctx);
            }
            mh$.invokeExact(dpy, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXMakeCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXMakeCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
     * }
     */
    public static FunctionDescriptor glXMakeCurrent$descriptor() {
        return glXMakeCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
     * }
     */
    public static MethodHandle glXMakeCurrent$handle() {
        return glXMakeCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
     * }
     */
    public static MemorySegment glXMakeCurrent$address() {
        return glXMakeCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
     * }
     */
    public static int glXMakeCurrent(MemorySegment dpy, long drawable, MemorySegment ctx) {
        var mh$ = glXMakeCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXMakeCurrent", dpy, drawable, ctx);
            }
            return (int)mh$.invokeExact(dpy, drawable, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXCopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXCopyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
     * }
     */
    public static FunctionDescriptor glXCopyContext$descriptor() {
        return glXCopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
     * }
     */
    public static MethodHandle glXCopyContext$handle() {
        return glXCopyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
     * }
     */
    public static MemorySegment glXCopyContext$address() {
        return glXCopyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
     * }
     */
    public static void glXCopyContext(MemorySegment dpy, MemorySegment src, MemorySegment dst, long mask) {
        var mh$ = glXCopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXCopyContext", dpy, src, dst, mask);
            }
            mh$.invokeExact(dpy, src, dst, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXSwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXSwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXSwapBuffers(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static FunctionDescriptor glXSwapBuffers$descriptor() {
        return glXSwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXSwapBuffers(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static MethodHandle glXSwapBuffers$handle() {
        return glXSwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXSwapBuffers(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static MemorySegment glXSwapBuffers$address() {
        return glXSwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXSwapBuffers(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static void glXSwapBuffers(MemorySegment dpy, long drawable) {
        var mh$ = glXSwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXSwapBuffers", dpy, drawable);
            }
            mh$.invokeExact(dpy, drawable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXCreateGLXPixmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXCreateGLXPixmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXPixmap glXCreateGLXPixmap(Display *dpy, XVisualInfo *visual, Pixmap pixmap)
     * }
     */
    public static FunctionDescriptor glXCreateGLXPixmap$descriptor() {
        return glXCreateGLXPixmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXPixmap glXCreateGLXPixmap(Display *dpy, XVisualInfo *visual, Pixmap pixmap)
     * }
     */
    public static MethodHandle glXCreateGLXPixmap$handle() {
        return glXCreateGLXPixmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXPixmap glXCreateGLXPixmap(Display *dpy, XVisualInfo *visual, Pixmap pixmap)
     * }
     */
    public static MemorySegment glXCreateGLXPixmap$address() {
        return glXCreateGLXPixmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXPixmap glXCreateGLXPixmap(Display *dpy, XVisualInfo *visual, Pixmap pixmap)
     * }
     */
    public static long glXCreateGLXPixmap(MemorySegment dpy, MemorySegment visual, long pixmap) {
        var mh$ = glXCreateGLXPixmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXCreateGLXPixmap", dpy, visual, pixmap);
            }
            return (long)mh$.invokeExact(dpy, visual, pixmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXDestroyGLXPixmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXDestroyGLXPixmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXDestroyGLXPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static FunctionDescriptor glXDestroyGLXPixmap$descriptor() {
        return glXDestroyGLXPixmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXDestroyGLXPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static MethodHandle glXDestroyGLXPixmap$handle() {
        return glXDestroyGLXPixmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXDestroyGLXPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static MemorySegment glXDestroyGLXPixmap$address() {
        return glXDestroyGLXPixmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXDestroyGLXPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static void glXDestroyGLXPixmap(MemorySegment dpy, long pixmap) {
        var mh$ = glXDestroyGLXPixmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXDestroyGLXPixmap", dpy, pixmap);
            }
            mh$.invokeExact(dpy, pixmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXQueryExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXQueryExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXQueryExtension(Display *dpy, int *errorb, int *event)
     * }
     */
    public static FunctionDescriptor glXQueryExtension$descriptor() {
        return glXQueryExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXQueryExtension(Display *dpy, int *errorb, int *event)
     * }
     */
    public static MethodHandle glXQueryExtension$handle() {
        return glXQueryExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXQueryExtension(Display *dpy, int *errorb, int *event)
     * }
     */
    public static MemorySegment glXQueryExtension$address() {
        return glXQueryExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXQueryExtension(Display *dpy, int *errorb, int *event)
     * }
     */
    public static int glXQueryExtension(MemorySegment dpy, MemorySegment errorb, MemorySegment event) {
        var mh$ = glXQueryExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXQueryExtension", dpy, errorb, event);
            }
            return (int)mh$.invokeExact(dpy, errorb, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXQueryVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXQueryVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXQueryVersion(Display *dpy, int *maj, int *min)
     * }
     */
    public static FunctionDescriptor glXQueryVersion$descriptor() {
        return glXQueryVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXQueryVersion(Display *dpy, int *maj, int *min)
     * }
     */
    public static MethodHandle glXQueryVersion$handle() {
        return glXQueryVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXQueryVersion(Display *dpy, int *maj, int *min)
     * }
     */
    public static MemorySegment glXQueryVersion$address() {
        return glXQueryVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXQueryVersion(Display *dpy, int *maj, int *min)
     * }
     */
    public static int glXQueryVersion(MemorySegment dpy, MemorySegment maj, MemorySegment min) {
        var mh$ = glXQueryVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXQueryVersion", dpy, maj, min);
            }
            return (int)mh$.invokeExact(dpy, maj, min);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXIsDirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXIsDirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXIsDirect(Display *dpy, GLXContext ctx)
     * }
     */
    public static FunctionDescriptor glXIsDirect$descriptor() {
        return glXIsDirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXIsDirect(Display *dpy, GLXContext ctx)
     * }
     */
    public static MethodHandle glXIsDirect$handle() {
        return glXIsDirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXIsDirect(Display *dpy, GLXContext ctx)
     * }
     */
    public static MemorySegment glXIsDirect$address() {
        return glXIsDirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXIsDirect(Display *dpy, GLXContext ctx)
     * }
     */
    public static int glXIsDirect(MemorySegment dpy, MemorySegment ctx) {
        var mh$ = glXIsDirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXIsDirect", dpy, ctx);
            }
            return (int)mh$.invokeExact(dpy, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXGetConfig(Display *dpy, XVisualInfo *visual, int attrib, int *value)
     * }
     */
    public static FunctionDescriptor glXGetConfig$descriptor() {
        return glXGetConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXGetConfig(Display *dpy, XVisualInfo *visual, int attrib, int *value)
     * }
     */
    public static MethodHandle glXGetConfig$handle() {
        return glXGetConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXGetConfig(Display *dpy, XVisualInfo *visual, int attrib, int *value)
     * }
     */
    public static MemorySegment glXGetConfig$address() {
        return glXGetConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXGetConfig(Display *dpy, XVisualInfo *visual, int attrib, int *value)
     * }
     */
    public static int glXGetConfig(MemorySegment dpy, MemorySegment visual, int attrib, MemorySegment value) {
        var mh$ = glXGetConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetConfig", dpy, visual, attrib, value);
            }
            return (int)mh$.invokeExact(dpy, visual, attrib, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetCurrentContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetCurrentContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXContext glXGetCurrentContext()
     * }
     */
    public static FunctionDescriptor glXGetCurrentContext$descriptor() {
        return glXGetCurrentContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXContext glXGetCurrentContext()
     * }
     */
    public static MethodHandle glXGetCurrentContext$handle() {
        return glXGetCurrentContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXContext glXGetCurrentContext()
     * }
     */
    public static MemorySegment glXGetCurrentContext$address() {
        return glXGetCurrentContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXContext glXGetCurrentContext()
     * }
     */
    public static MemorySegment glXGetCurrentContext() {
        var mh$ = glXGetCurrentContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetCurrentContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetCurrentDrawable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetCurrentDrawable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentDrawable()
     * }
     */
    public static FunctionDescriptor glXGetCurrentDrawable$descriptor() {
        return glXGetCurrentDrawable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentDrawable()
     * }
     */
    public static MethodHandle glXGetCurrentDrawable$handle() {
        return glXGetCurrentDrawable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentDrawable()
     * }
     */
    public static MemorySegment glXGetCurrentDrawable$address() {
        return glXGetCurrentDrawable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentDrawable()
     * }
     */
    public static long glXGetCurrentDrawable() {
        var mh$ = glXGetCurrentDrawable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetCurrentDrawable");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXWaitGL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXWaitGL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXWaitGL()
     * }
     */
    public static FunctionDescriptor glXWaitGL$descriptor() {
        return glXWaitGL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXWaitGL()
     * }
     */
    public static MethodHandle glXWaitGL$handle() {
        return glXWaitGL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXWaitGL()
     * }
     */
    public static MemorySegment glXWaitGL$address() {
        return glXWaitGL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXWaitGL()
     * }
     */
    public static void glXWaitGL() {
        var mh$ = glXWaitGL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXWaitGL");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXWaitX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXWaitX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXWaitX()
     * }
     */
    public static FunctionDescriptor glXWaitX$descriptor() {
        return glXWaitX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXWaitX()
     * }
     */
    public static MethodHandle glXWaitX$handle() {
        return glXWaitX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXWaitX()
     * }
     */
    public static MemorySegment glXWaitX$address() {
        return glXWaitX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXWaitX()
     * }
     */
    public static void glXWaitX() {
        var mh$ = glXWaitX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXWaitX");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXUseXFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_LONG,
            glxext_h.C_INT,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXUseXFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXUseXFont(Font font, int first, int count, int list)
     * }
     */
    public static FunctionDescriptor glXUseXFont$descriptor() {
        return glXUseXFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXUseXFont(Font font, int first, int count, int list)
     * }
     */
    public static MethodHandle glXUseXFont$handle() {
        return glXUseXFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXUseXFont(Font font, int first, int count, int list)
     * }
     */
    public static MemorySegment glXUseXFont$address() {
        return glXUseXFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXUseXFont(Font font, int first, int count, int list)
     * }
     */
    public static void glXUseXFont(long font, int first, int count, int list) {
        var mh$ = glXUseXFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXUseXFont", font, first, count, list);
            }
            mh$.invokeExact(font, first, count, list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXQueryExtensionsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXQueryExtensionsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *glXQueryExtensionsString(Display *dpy, int screen)
     * }
     */
    public static FunctionDescriptor glXQueryExtensionsString$descriptor() {
        return glXQueryExtensionsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *glXQueryExtensionsString(Display *dpy, int screen)
     * }
     */
    public static MethodHandle glXQueryExtensionsString$handle() {
        return glXQueryExtensionsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *glXQueryExtensionsString(Display *dpy, int screen)
     * }
     */
    public static MemorySegment glXQueryExtensionsString$address() {
        return glXQueryExtensionsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *glXQueryExtensionsString(Display *dpy, int screen)
     * }
     */
    public static MemorySegment glXQueryExtensionsString(MemorySegment dpy, int screen) {
        var mh$ = glXQueryExtensionsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXQueryExtensionsString", dpy, screen);
            }
            return (MemorySegment)mh$.invokeExact(dpy, screen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXQueryServerString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXQueryServerString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *glXQueryServerString(Display *dpy, int screen, int name)
     * }
     */
    public static FunctionDescriptor glXQueryServerString$descriptor() {
        return glXQueryServerString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *glXQueryServerString(Display *dpy, int screen, int name)
     * }
     */
    public static MethodHandle glXQueryServerString$handle() {
        return glXQueryServerString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *glXQueryServerString(Display *dpy, int screen, int name)
     * }
     */
    public static MemorySegment glXQueryServerString$address() {
        return glXQueryServerString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *glXQueryServerString(Display *dpy, int screen, int name)
     * }
     */
    public static MemorySegment glXQueryServerString(MemorySegment dpy, int screen, int name) {
        var mh$ = glXQueryServerString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXQueryServerString", dpy, screen, name);
            }
            return (MemorySegment)mh$.invokeExact(dpy, screen, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetClientString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetClientString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *glXGetClientString(Display *dpy, int name)
     * }
     */
    public static FunctionDescriptor glXGetClientString$descriptor() {
        return glXGetClientString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *glXGetClientString(Display *dpy, int name)
     * }
     */
    public static MethodHandle glXGetClientString$handle() {
        return glXGetClientString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *glXGetClientString(Display *dpy, int name)
     * }
     */
    public static MemorySegment glXGetClientString$address() {
        return glXGetClientString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *glXGetClientString(Display *dpy, int name)
     * }
     */
    public static MemorySegment glXGetClientString(MemorySegment dpy, int name) {
        var mh$ = glXGetClientString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetClientString", dpy, name);
            }
            return (MemorySegment)mh$.invokeExact(dpy, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetCurrentDisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetCurrentDisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern Display *glXGetCurrentDisplay()
     * }
     */
    public static FunctionDescriptor glXGetCurrentDisplay$descriptor() {
        return glXGetCurrentDisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern Display *glXGetCurrentDisplay()
     * }
     */
    public static MethodHandle glXGetCurrentDisplay$handle() {
        return glXGetCurrentDisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern Display *glXGetCurrentDisplay()
     * }
     */
    public static MemorySegment glXGetCurrentDisplay$address() {
        return glXGetCurrentDisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern Display *glXGetCurrentDisplay()
     * }
     */
    public static MemorySegment glXGetCurrentDisplay() {
        var mh$ = glXGetCurrentDisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetCurrentDisplay");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXChooseFBConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXChooseFBConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attribList, int *nitems)
     * }
     */
    public static FunctionDescriptor glXChooseFBConfig$descriptor() {
        return glXChooseFBConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attribList, int *nitems)
     * }
     */
    public static MethodHandle glXChooseFBConfig$handle() {
        return glXChooseFBConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attribList, int *nitems)
     * }
     */
    public static MemorySegment glXChooseFBConfig$address() {
        return glXChooseFBConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attribList, int *nitems)
     * }
     */
    public static MemorySegment glXChooseFBConfig(MemorySegment dpy, int screen, MemorySegment attribList, MemorySegment nitems) {
        var mh$ = glXChooseFBConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXChooseFBConfig", dpy, screen, attribList, nitems);
            }
            return (MemorySegment)mh$.invokeExact(dpy, screen, attribList, nitems);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetFBConfigAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetFBConfigAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
     * }
     */
    public static FunctionDescriptor glXGetFBConfigAttrib$descriptor() {
        return glXGetFBConfigAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
     * }
     */
    public static MethodHandle glXGetFBConfigAttrib$handle() {
        return glXGetFBConfigAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
     * }
     */
    public static MemorySegment glXGetFBConfigAttrib$address() {
        return glXGetFBConfigAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
     * }
     */
    public static int glXGetFBConfigAttrib(MemorySegment dpy, MemorySegment config, int attribute, MemorySegment value) {
        var mh$ = glXGetFBConfigAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetFBConfigAttrib", dpy, config, attribute, value);
            }
            return (int)mh$.invokeExact(dpy, config, attribute, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetFBConfigs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetFBConfigs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXFBConfig *glXGetFBConfigs(Display *dpy, int screen, int *nelements)
     * }
     */
    public static FunctionDescriptor glXGetFBConfigs$descriptor() {
        return glXGetFBConfigs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXFBConfig *glXGetFBConfigs(Display *dpy, int screen, int *nelements)
     * }
     */
    public static MethodHandle glXGetFBConfigs$handle() {
        return glXGetFBConfigs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXFBConfig *glXGetFBConfigs(Display *dpy, int screen, int *nelements)
     * }
     */
    public static MemorySegment glXGetFBConfigs$address() {
        return glXGetFBConfigs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXFBConfig *glXGetFBConfigs(Display *dpy, int screen, int *nelements)
     * }
     */
    public static MemorySegment glXGetFBConfigs(MemorySegment dpy, int screen, MemorySegment nelements) {
        var mh$ = glXGetFBConfigs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetFBConfigs", dpy, screen, nelements);
            }
            return (MemorySegment)mh$.invokeExact(dpy, screen, nelements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetVisualFromFBConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetVisualFromFBConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern XVisualInfo *glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
     * }
     */
    public static FunctionDescriptor glXGetVisualFromFBConfig$descriptor() {
        return glXGetVisualFromFBConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern XVisualInfo *glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
     * }
     */
    public static MethodHandle glXGetVisualFromFBConfig$handle() {
        return glXGetVisualFromFBConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern XVisualInfo *glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
     * }
     */
    public static MemorySegment glXGetVisualFromFBConfig$address() {
        return glXGetVisualFromFBConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern XVisualInfo *glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
     * }
     */
    public static MemorySegment glXGetVisualFromFBConfig(MemorySegment dpy, MemorySegment config) {
        var mh$ = glXGetVisualFromFBConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetVisualFromFBConfig", dpy, config);
            }
            return (MemorySegment)mh$.invokeExact(dpy, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXCreateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXCreateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXWindow glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attribList)
     * }
     */
    public static FunctionDescriptor glXCreateWindow$descriptor() {
        return glXCreateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXWindow glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attribList)
     * }
     */
    public static MethodHandle glXCreateWindow$handle() {
        return glXCreateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXWindow glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attribList)
     * }
     */
    public static MemorySegment glXCreateWindow$address() {
        return glXCreateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXWindow glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attribList)
     * }
     */
    public static long glXCreateWindow(MemorySegment dpy, MemorySegment config, long win, MemorySegment attribList) {
        var mh$ = glXCreateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXCreateWindow", dpy, config, win, attribList);
            }
            return (long)mh$.invokeExact(dpy, config, win, attribList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXDestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXDestroyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXDestroyWindow(Display *dpy, GLXWindow window)
     * }
     */
    public static FunctionDescriptor glXDestroyWindow$descriptor() {
        return glXDestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXDestroyWindow(Display *dpy, GLXWindow window)
     * }
     */
    public static MethodHandle glXDestroyWindow$handle() {
        return glXDestroyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXDestroyWindow(Display *dpy, GLXWindow window)
     * }
     */
    public static MemorySegment glXDestroyWindow$address() {
        return glXDestroyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXDestroyWindow(Display *dpy, GLXWindow window)
     * }
     */
    public static void glXDestroyWindow(MemorySegment dpy, long window) {
        var mh$ = glXDestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXDestroyWindow", dpy, window);
            }
            mh$.invokeExact(dpy, window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXCreatePixmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXCreatePixmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXPixmap glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attribList)
     * }
     */
    public static FunctionDescriptor glXCreatePixmap$descriptor() {
        return glXCreatePixmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXPixmap glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attribList)
     * }
     */
    public static MethodHandle glXCreatePixmap$handle() {
        return glXCreatePixmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXPixmap glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attribList)
     * }
     */
    public static MemorySegment glXCreatePixmap$address() {
        return glXCreatePixmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXPixmap glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attribList)
     * }
     */
    public static long glXCreatePixmap(MemorySegment dpy, MemorySegment config, long pixmap, MemorySegment attribList) {
        var mh$ = glXCreatePixmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXCreatePixmap", dpy, config, pixmap, attribList);
            }
            return (long)mh$.invokeExact(dpy, config, pixmap, attribList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXDestroyPixmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXDestroyPixmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static FunctionDescriptor glXDestroyPixmap$descriptor() {
        return glXDestroyPixmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static MethodHandle glXDestroyPixmap$handle() {
        return glXDestroyPixmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static MemorySegment glXDestroyPixmap$address() {
        return glXDestroyPixmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
     * }
     */
    public static void glXDestroyPixmap(MemorySegment dpy, long pixmap) {
        var mh$ = glXDestroyPixmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXDestroyPixmap", dpy, pixmap);
            }
            mh$.invokeExact(dpy, pixmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXCreatePbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXCreatePbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXPbuffer glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attribList)
     * }
     */
    public static FunctionDescriptor glXCreatePbuffer$descriptor() {
        return glXCreatePbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXPbuffer glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attribList)
     * }
     */
    public static MethodHandle glXCreatePbuffer$handle() {
        return glXCreatePbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXPbuffer glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attribList)
     * }
     */
    public static MemorySegment glXCreatePbuffer$address() {
        return glXCreatePbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXPbuffer glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attribList)
     * }
     */
    public static long glXCreatePbuffer(MemorySegment dpy, MemorySegment config, MemorySegment attribList) {
        var mh$ = glXCreatePbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXCreatePbuffer", dpy, config, attribList);
            }
            return (long)mh$.invokeExact(dpy, config, attribList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXDestroyPbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXDestroyPbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
     * }
     */
    public static FunctionDescriptor glXDestroyPbuffer$descriptor() {
        return glXDestroyPbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
     * }
     */
    public static MethodHandle glXDestroyPbuffer$handle() {
        return glXDestroyPbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
     * }
     */
    public static MemorySegment glXDestroyPbuffer$address() {
        return glXDestroyPbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
     * }
     */
    public static void glXDestroyPbuffer(MemorySegment dpy, long pbuf) {
        var mh$ = glXDestroyPbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXDestroyPbuffer", dpy, pbuf);
            }
            mh$.invokeExact(dpy, pbuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXQueryDrawable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXQueryDrawable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
     * }
     */
    public static FunctionDescriptor glXQueryDrawable$descriptor() {
        return glXQueryDrawable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
     * }
     */
    public static MethodHandle glXQueryDrawable$handle() {
        return glXQueryDrawable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
     * }
     */
    public static MemorySegment glXQueryDrawable$address() {
        return glXQueryDrawable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
     * }
     */
    public static void glXQueryDrawable(MemorySegment dpy, long draw, int attribute, MemorySegment value) {
        var mh$ = glXQueryDrawable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXQueryDrawable", dpy, draw, attribute, value);
            }
            mh$.invokeExact(dpy, draw, attribute, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXCreateNewContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXCreateNewContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXContext glXCreateNewContext(Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct)
     * }
     */
    public static FunctionDescriptor glXCreateNewContext$descriptor() {
        return glXCreateNewContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXContext glXCreateNewContext(Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct)
     * }
     */
    public static MethodHandle glXCreateNewContext$handle() {
        return glXCreateNewContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXContext glXCreateNewContext(Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct)
     * }
     */
    public static MemorySegment glXCreateNewContext$address() {
        return glXCreateNewContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXContext glXCreateNewContext(Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct)
     * }
     */
    public static MemorySegment glXCreateNewContext(MemorySegment dpy, MemorySegment config, int renderType, MemorySegment shareList, int direct) {
        var mh$ = glXCreateNewContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXCreateNewContext", dpy, config, renderType, shareList, direct);
            }
            return (MemorySegment)mh$.invokeExact(dpy, config, renderType, shareList, direct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXMakeContextCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_LONG,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXMakeContextCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXMakeContextCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
     * }
     */
    public static FunctionDescriptor glXMakeContextCurrent$descriptor() {
        return glXMakeContextCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXMakeContextCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
     * }
     */
    public static MethodHandle glXMakeContextCurrent$handle() {
        return glXMakeContextCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXMakeContextCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
     * }
     */
    public static MemorySegment glXMakeContextCurrent$address() {
        return glXMakeContextCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXMakeContextCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
     * }
     */
    public static int glXMakeContextCurrent(MemorySegment dpy, long draw, long read, MemorySegment ctx) {
        var mh$ = glXMakeContextCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXMakeContextCurrent", dpy, draw, read, ctx);
            }
            return (int)mh$.invokeExact(dpy, draw, read, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetCurrentReadDrawable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG    );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetCurrentReadDrawable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentReadDrawable()
     * }
     */
    public static FunctionDescriptor glXGetCurrentReadDrawable$descriptor() {
        return glXGetCurrentReadDrawable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentReadDrawable()
     * }
     */
    public static MethodHandle glXGetCurrentReadDrawable$handle() {
        return glXGetCurrentReadDrawable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentReadDrawable()
     * }
     */
    public static MemorySegment glXGetCurrentReadDrawable$address() {
        return glXGetCurrentReadDrawable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLXDrawable glXGetCurrentReadDrawable()
     * }
     */
    public static long glXGetCurrentReadDrawable() {
        var mh$ = glXGetCurrentReadDrawable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetCurrentReadDrawable");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXQueryContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXQueryContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
     * }
     */
    public static FunctionDescriptor glXQueryContext$descriptor() {
        return glXQueryContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
     * }
     */
    public static MethodHandle glXQueryContext$handle() {
        return glXQueryContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
     * }
     */
    public static MemorySegment glXQueryContext$address() {
        return glXQueryContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
     * }
     */
    public static int glXQueryContext(MemorySegment dpy, MemorySegment ctx, int attribute, MemorySegment value) {
        var mh$ = glXQueryContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXQueryContext", dpy, ctx, attribute, value);
            }
            return (int)mh$.invokeExact(dpy, ctx, attribute, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXSelectEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXSelectEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXSelectEvent(Display *dpy, GLXDrawable drawable, unsigned long mask)
     * }
     */
    public static FunctionDescriptor glXSelectEvent$descriptor() {
        return glXSelectEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXSelectEvent(Display *dpy, GLXDrawable drawable, unsigned long mask)
     * }
     */
    public static MethodHandle glXSelectEvent$handle() {
        return glXSelectEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXSelectEvent(Display *dpy, GLXDrawable drawable, unsigned long mask)
     * }
     */
    public static MemorySegment glXSelectEvent$address() {
        return glXSelectEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXSelectEvent(Display *dpy, GLXDrawable drawable, unsigned long mask)
     * }
     */
    public static void glXSelectEvent(MemorySegment dpy, long drawable, long mask) {
        var mh$ = glXSelectEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXSelectEvent", dpy, drawable, mask);
            }
            mh$.invokeExact(dpy, drawable, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetSelectedEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetSelectedEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXGetSelectedEvent(Display *dpy, GLXDrawable drawable, unsigned long *mask)
     * }
     */
    public static FunctionDescriptor glXGetSelectedEvent$descriptor() {
        return glXGetSelectedEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXGetSelectedEvent(Display *dpy, GLXDrawable drawable, unsigned long *mask)
     * }
     */
    public static MethodHandle glXGetSelectedEvent$handle() {
        return glXGetSelectedEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXGetSelectedEvent(Display *dpy, GLXDrawable drawable, unsigned long *mask)
     * }
     */
    public static MemorySegment glXGetSelectedEvent$address() {
        return glXGetSelectedEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXGetSelectedEvent(Display *dpy, GLXDrawable drawable, unsigned long *mask)
     * }
     */
    public static void glXGetSelectedEvent(MemorySegment dpy, long drawable, MemorySegment mask) {
        var mh$ = glXGetSelectedEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetSelectedEvent", dpy, drawable, mask);
            }
            mh$.invokeExact(dpy, drawable, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetProcAddressARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetProcAddressARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *)
     * }
     */
    public static FunctionDescriptor glXGetProcAddressARB$descriptor() {
        return glXGetProcAddressARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *)
     * }
     */
    public static MethodHandle glXGetProcAddressARB$handle() {
        return glXGetProcAddressARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *)
     * }
     */
    public static MemorySegment glXGetProcAddressARB$address() {
        return glXGetProcAddressARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __GLXextFuncPtr glXGetProcAddressARB(const GLubyte *)
     * }
     */
    public static MemorySegment glXGetProcAddressARB(MemorySegment x0) {
        var mh$ = glXGetProcAddressARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetProcAddressARB", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (*glXGetProcAddress(const GLubyte *procname))(void)
     * }
     */
    public static FunctionDescriptor glXGetProcAddress$descriptor() {
        return glXGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (*glXGetProcAddress(const GLubyte *procname))(void)
     * }
     */
    public static MethodHandle glXGetProcAddress$handle() {
        return glXGetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void (*glXGetProcAddress(const GLubyte *procname))(void)
     * }
     */
    public static MemorySegment glXGetProcAddress$address() {
        return glXGetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void (*glXGetProcAddress(const GLubyte *procname))(void)
     * }
     */
    public static MemorySegment glXGetProcAddress(MemorySegment procname) {
        var mh$ = glXGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetProcAddress", procname);
            }
            return (MemorySegment)mh$.invokeExact(procname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef XID GLXVideoCaptureDeviceNV
     * }
     */
    public static final OfLong GLXVideoCaptureDeviceNV = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLXVideoDeviceNV
     * }
     */
    public static final OfInt GLXVideoDeviceNV = glxext_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = glxext_h.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            glxext_h.C_LONG,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef XID GLXPbufferSGIX
     * }
     */
    public static final OfLong GLXPbufferSGIX = glxext_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __GLXFBConfigRec *GLXFBConfigSGIX
     * }
     */
    public static final AddressLayout GLXFBConfigSGIX = glxext_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef XID GLXVideoSourceSGIX
     * }
     */
    public static final OfLong GLXVideoSourceSGIX = glxext_h.C_LONG;

    private static class glXAllocateMemoryNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_POINTER,
            glxext_h.C_INT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT,
            glxext_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXAllocateMemoryNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority)
     * }
     */
    public static FunctionDescriptor glXAllocateMemoryNV$descriptor() {
        return glXAllocateMemoryNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority)
     * }
     */
    public static MethodHandle glXAllocateMemoryNV$handle() {
        return glXAllocateMemoryNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority)
     * }
     */
    public static MemorySegment glXAllocateMemoryNV$address() {
        return glXAllocateMemoryNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority)
     * }
     */
    public static MemorySegment glXAllocateMemoryNV(int size, float readfreq, float writefreq, float priority) {
        var mh$ = glXAllocateMemoryNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXAllocateMemoryNV", size, readfreq, writefreq, priority);
            }
            return (MemorySegment)mh$.invokeExact(size, readfreq, writefreq, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXFreeMemoryNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXFreeMemoryNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glXFreeMemoryNV(GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glXFreeMemoryNV$descriptor() {
        return glXFreeMemoryNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glXFreeMemoryNV(GLvoid *pointer)
     * }
     */
    public static MethodHandle glXFreeMemoryNV$handle() {
        return glXFreeMemoryNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glXFreeMemoryNV(GLvoid *pointer)
     * }
     */
    public static MemorySegment glXFreeMemoryNV$address() {
        return glXFreeMemoryNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glXFreeMemoryNV(GLvoid *pointer)
     * }
     */
    public static void glXFreeMemoryNV(MemorySegment pointer) {
        var mh$ = glXFreeMemoryNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXFreeMemoryNV", pointer);
            }
            mh$.invokeExact(pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXBindTexImageARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXBindTexImageARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXBindTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static FunctionDescriptor glXBindTexImageARB$descriptor() {
        return glXBindTexImageARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXBindTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static MethodHandle glXBindTexImageARB$handle() {
        return glXBindTexImageARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXBindTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static MemorySegment glXBindTexImageARB$address() {
        return glXBindTexImageARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXBindTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static int glXBindTexImageARB(MemorySegment dpy, long pbuffer, int buffer) {
        var mh$ = glXBindTexImageARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXBindTexImageARB", dpy, pbuffer, buffer);
            }
            return (int)mh$.invokeExact(dpy, pbuffer, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXReleaseTexImageARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_INT
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXReleaseTexImageARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXReleaseTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static FunctionDescriptor glXReleaseTexImageARB$descriptor() {
        return glXReleaseTexImageARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXReleaseTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static MethodHandle glXReleaseTexImageARB$handle() {
        return glXReleaseTexImageARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXReleaseTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static MemorySegment glXReleaseTexImageARB$address() {
        return glXReleaseTexImageARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXReleaseTexImageARB(Display *dpy, GLXPbuffer pbuffer, int buffer)
     * }
     */
    public static int glXReleaseTexImageARB(MemorySegment dpy, long pbuffer, int buffer) {
        var mh$ = glXReleaseTexImageARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXReleaseTexImageARB", dpy, pbuffer, buffer);
            }
            return (int)mh$.invokeExact(dpy, pbuffer, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXDrawableAttribARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXDrawableAttribARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXDrawableAttribARB(Display *dpy, GLXDrawable draw, const int *attribList)
     * }
     */
    public static FunctionDescriptor glXDrawableAttribARB$descriptor() {
        return glXDrawableAttribARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXDrawableAttribARB(Display *dpy, GLXDrawable draw, const int *attribList)
     * }
     */
    public static MethodHandle glXDrawableAttribARB$handle() {
        return glXDrawableAttribARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXDrawableAttribARB(Display *dpy, GLXDrawable draw, const int *attribList)
     * }
     */
    public static MemorySegment glXDrawableAttribARB$address() {
        return glXDrawableAttribARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXDrawableAttribARB(Display *dpy, GLXDrawable draw, const int *attribList)
     * }
     */
    public static int glXDrawableAttribARB(MemorySegment dpy, long draw, MemorySegment attribList) {
        var mh$ = glXDrawableAttribARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXDrawableAttribARB", dpy, draw, attribList);
            }
            return (int)mh$.invokeExact(dpy, draw, attribList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXGetFrameUsageMESA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXGetFrameUsageMESA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXGetFrameUsageMESA(Display *dpy, GLXDrawable drawable, float *usage)
     * }
     */
    public static FunctionDescriptor glXGetFrameUsageMESA$descriptor() {
        return glXGetFrameUsageMESA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXGetFrameUsageMESA(Display *dpy, GLXDrawable drawable, float *usage)
     * }
     */
    public static MethodHandle glXGetFrameUsageMESA$handle() {
        return glXGetFrameUsageMESA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXGetFrameUsageMESA(Display *dpy, GLXDrawable drawable, float *usage)
     * }
     */
    public static MemorySegment glXGetFrameUsageMESA$address() {
        return glXGetFrameUsageMESA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXGetFrameUsageMESA(Display *dpy, GLXDrawable drawable, float *usage)
     * }
     */
    public static int glXGetFrameUsageMESA(MemorySegment dpy, long drawable, MemorySegment usage) {
        var mh$ = glXGetFrameUsageMESA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXGetFrameUsageMESA", dpy, drawable, usage);
            }
            return (int)mh$.invokeExact(dpy, drawable, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXBeginFrameTrackingMESA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXBeginFrameTrackingMESA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXBeginFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static FunctionDescriptor glXBeginFrameTrackingMESA$descriptor() {
        return glXBeginFrameTrackingMESA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXBeginFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static MethodHandle glXBeginFrameTrackingMESA$handle() {
        return glXBeginFrameTrackingMESA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXBeginFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static MemorySegment glXBeginFrameTrackingMESA$address() {
        return glXBeginFrameTrackingMESA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXBeginFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static int glXBeginFrameTrackingMESA(MemorySegment dpy, long drawable) {
        var mh$ = glXBeginFrameTrackingMESA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXBeginFrameTrackingMESA", dpy, drawable);
            }
            return (int)mh$.invokeExact(dpy, drawable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXEndFrameTrackingMESA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXEndFrameTrackingMESA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXEndFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static FunctionDescriptor glXEndFrameTrackingMESA$descriptor() {
        return glXEndFrameTrackingMESA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXEndFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static MethodHandle glXEndFrameTrackingMESA$handle() {
        return glXEndFrameTrackingMESA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXEndFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static MemorySegment glXEndFrameTrackingMESA$address() {
        return glXEndFrameTrackingMESA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXEndFrameTrackingMESA(Display *dpy, GLXDrawable drawable)
     * }
     */
    public static int glXEndFrameTrackingMESA(MemorySegment dpy, long drawable) {
        var mh$ = glXEndFrameTrackingMESA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXEndFrameTrackingMESA", dpy, drawable);
            }
            return (int)mh$.invokeExact(dpy, drawable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glXQueryFrameTrackingMESA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glxext_h.C_INT,
            glxext_h.C_POINTER,
            glxext_h.C_LONG,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER,
            glxext_h.C_POINTER
        );

        public static final MemorySegment ADDR = glxext_h.findOrThrow("glXQueryFrameTrackingMESA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int glXQueryFrameTrackingMESA(Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage)
     * }
     */
    public static FunctionDescriptor glXQueryFrameTrackingMESA$descriptor() {
        return glXQueryFrameTrackingMESA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int glXQueryFrameTrackingMESA(Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage)
     * }
     */
    public static MethodHandle glXQueryFrameTrackingMESA$handle() {
        return glXQueryFrameTrackingMESA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int glXQueryFrameTrackingMESA(Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage)
     * }
     */
    public static MemorySegment glXQueryFrameTrackingMESA$address() {
        return glXQueryFrameTrackingMESA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int glXQueryFrameTrackingMESA(Display *dpy, GLXDrawable drawable, int64_t *swapCount, int64_t *missedFrames, float *lastMissedUsage)
     * }
     */
    public static int glXQueryFrameTrackingMESA(MemorySegment dpy, long drawable, MemorySegment swapCount, MemorySegment missedFrames, MemorySegment lastMissedUsage) {
        var mh$ = glXQueryFrameTrackingMESA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glXQueryFrameTrackingMESA", dpy, drawable, swapCount, missedFrames, lastMissedUsage);
            }
            return (int)mh$.invokeExact(dpy, drawable, swapCount, missedFrames, lastMissedUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    /**
     * {@snippet lang=c :
     * #define __FD_ZERO_STOS "stosq"
     * }
     */
    public static MemorySegment __FD_ZERO_STOS() {
        class Holder {
            static final MemorySegment __FD_ZERO_STOS
                = glxext_h.LIBRARY_ARENA.allocateFrom("stosq");
        }
        return Holder.__FD_ZERO_STOS;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    private static final long None = 0L;
    /**
     * {@snippet lang=c :
     * #define None 0
     * }
     */
    public static long None() {
        return None;
    }
    private static final long ParentRelative = 1L;
    /**
     * {@snippet lang=c :
     * #define ParentRelative 1
     * }
     */
    public static long ParentRelative() {
        return ParentRelative;
    }
    private static final long CopyFromParent = 0L;
    /**
     * {@snippet lang=c :
     * #define CopyFromParent 0
     * }
     */
    public static long CopyFromParent() {
        return CopyFromParent;
    }
    private static final long PointerWindow = 0L;
    /**
     * {@snippet lang=c :
     * #define PointerWindow 0
     * }
     */
    public static long PointerWindow() {
        return PointerWindow;
    }
    private static final long InputFocus = 1L;
    /**
     * {@snippet lang=c :
     * #define InputFocus 1
     * }
     */
    public static long InputFocus() {
        return InputFocus;
    }
    private static final long PointerRoot = 1L;
    /**
     * {@snippet lang=c :
     * #define PointerRoot 1
     * }
     */
    public static long PointerRoot() {
        return PointerRoot;
    }
    private static final long AnyPropertyType = 0L;
    /**
     * {@snippet lang=c :
     * #define AnyPropertyType 0
     * }
     */
    public static long AnyPropertyType() {
        return AnyPropertyType;
    }
    private static final long AnyKey = 0L;
    /**
     * {@snippet lang=c :
     * #define AnyKey 0
     * }
     */
    public static long AnyKey() {
        return AnyKey;
    }
    private static final long AnyButton = 0L;
    /**
     * {@snippet lang=c :
     * #define AnyButton 0
     * }
     */
    public static long AnyButton() {
        return AnyButton;
    }
    private static final long AllTemporary = 0L;
    /**
     * {@snippet lang=c :
     * #define AllTemporary 0
     * }
     */
    public static long AllTemporary() {
        return AllTemporary;
    }
    private static final long CurrentTime = 0L;
    /**
     * {@snippet lang=c :
     * #define CurrentTime 0
     * }
     */
    public static long CurrentTime() {
        return CurrentTime;
    }
    private static final long NoSymbol = 0L;
    /**
     * {@snippet lang=c :
     * #define NoSymbol 0
     * }
     */
    public static long NoSymbol() {
        return NoSymbol;
    }
    private static final long NoEventMask = 0L;
    /**
     * {@snippet lang=c :
     * #define NoEventMask 0
     * }
     */
    public static long NoEventMask() {
        return NoEventMask;
    }
    private static final long KeyPressMask = 1L;
    /**
     * {@snippet lang=c :
     * #define KeyPressMask 1
     * }
     */
    public static long KeyPressMask() {
        return KeyPressMask;
    }
    private static final long KeyReleaseMask = 2L;
    /**
     * {@snippet lang=c :
     * #define KeyReleaseMask 2
     * }
     */
    public static long KeyReleaseMask() {
        return KeyReleaseMask;
    }
    private static final long ButtonPressMask = 4L;
    /**
     * {@snippet lang=c :
     * #define ButtonPressMask 4
     * }
     */
    public static long ButtonPressMask() {
        return ButtonPressMask;
    }
    private static final long ButtonReleaseMask = 8L;
    /**
     * {@snippet lang=c :
     * #define ButtonReleaseMask 8
     * }
     */
    public static long ButtonReleaseMask() {
        return ButtonReleaseMask;
    }
    private static final long EnterWindowMask = 16L;
    /**
     * {@snippet lang=c :
     * #define EnterWindowMask 16
     * }
     */
    public static long EnterWindowMask() {
        return EnterWindowMask;
    }
    private static final long LeaveWindowMask = 32L;
    /**
     * {@snippet lang=c :
     * #define LeaveWindowMask 32
     * }
     */
    public static long LeaveWindowMask() {
        return LeaveWindowMask;
    }
    private static final long PointerMotionMask = 64L;
    /**
     * {@snippet lang=c :
     * #define PointerMotionMask 64
     * }
     */
    public static long PointerMotionMask() {
        return PointerMotionMask;
    }
    private static final long PointerMotionHintMask = 128L;
    /**
     * {@snippet lang=c :
     * #define PointerMotionHintMask 128
     * }
     */
    public static long PointerMotionHintMask() {
        return PointerMotionHintMask;
    }
    private static final long Button1MotionMask = 256L;
    /**
     * {@snippet lang=c :
     * #define Button1MotionMask 256
     * }
     */
    public static long Button1MotionMask() {
        return Button1MotionMask;
    }
    private static final long Button2MotionMask = 512L;
    /**
     * {@snippet lang=c :
     * #define Button2MotionMask 512
     * }
     */
    public static long Button2MotionMask() {
        return Button2MotionMask;
    }
    private static final long Button3MotionMask = 1024L;
    /**
     * {@snippet lang=c :
     * #define Button3MotionMask 1024
     * }
     */
    public static long Button3MotionMask() {
        return Button3MotionMask;
    }
    private static final long Button4MotionMask = 2048L;
    /**
     * {@snippet lang=c :
     * #define Button4MotionMask 2048
     * }
     */
    public static long Button4MotionMask() {
        return Button4MotionMask;
    }
    private static final long Button5MotionMask = 4096L;
    /**
     * {@snippet lang=c :
     * #define Button5MotionMask 4096
     * }
     */
    public static long Button5MotionMask() {
        return Button5MotionMask;
    }
    private static final long ButtonMotionMask = 8192L;
    /**
     * {@snippet lang=c :
     * #define ButtonMotionMask 8192
     * }
     */
    public static long ButtonMotionMask() {
        return ButtonMotionMask;
    }
    private static final long KeymapStateMask = 16384L;
    /**
     * {@snippet lang=c :
     * #define KeymapStateMask 16384
     * }
     */
    public static long KeymapStateMask() {
        return KeymapStateMask;
    }
    private static final long ExposureMask = 32768L;
    /**
     * {@snippet lang=c :
     * #define ExposureMask 32768
     * }
     */
    public static long ExposureMask() {
        return ExposureMask;
    }
    private static final long VisibilityChangeMask = 65536L;
    /**
     * {@snippet lang=c :
     * #define VisibilityChangeMask 65536
     * }
     */
    public static long VisibilityChangeMask() {
        return VisibilityChangeMask;
    }
    private static final long StructureNotifyMask = 131072L;
    /**
     * {@snippet lang=c :
     * #define StructureNotifyMask 131072
     * }
     */
    public static long StructureNotifyMask() {
        return StructureNotifyMask;
    }
    private static final long ResizeRedirectMask = 262144L;
    /**
     * {@snippet lang=c :
     * #define ResizeRedirectMask 262144
     * }
     */
    public static long ResizeRedirectMask() {
        return ResizeRedirectMask;
    }
    private static final long SubstructureNotifyMask = 524288L;
    /**
     * {@snippet lang=c :
     * #define SubstructureNotifyMask 524288
     * }
     */
    public static long SubstructureNotifyMask() {
        return SubstructureNotifyMask;
    }
    private static final long SubstructureRedirectMask = 1048576L;
    /**
     * {@snippet lang=c :
     * #define SubstructureRedirectMask 1048576
     * }
     */
    public static long SubstructureRedirectMask() {
        return SubstructureRedirectMask;
    }
    private static final long FocusChangeMask = 2097152L;
    /**
     * {@snippet lang=c :
     * #define FocusChangeMask 2097152
     * }
     */
    public static long FocusChangeMask() {
        return FocusChangeMask;
    }
    private static final long PropertyChangeMask = 4194304L;
    /**
     * {@snippet lang=c :
     * #define PropertyChangeMask 4194304
     * }
     */
    public static long PropertyChangeMask() {
        return PropertyChangeMask;
    }
    private static final long ColormapChangeMask = 8388608L;
    /**
     * {@snippet lang=c :
     * #define ColormapChangeMask 8388608
     * }
     */
    public static long ColormapChangeMask() {
        return ColormapChangeMask;
    }
    private static final long OwnerGrabButtonMask = 16777216L;
    /**
     * {@snippet lang=c :
     * #define OwnerGrabButtonMask 16777216
     * }
     */
    public static long OwnerGrabButtonMask() {
        return OwnerGrabButtonMask;
    }
    private static final int ShiftMask = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ShiftMask 1
     * }
     */
    public static int ShiftMask() {
        return ShiftMask;
    }
    private static final int LockMask = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LockMask 2
     * }
     */
    public static int LockMask() {
        return LockMask;
    }
    private static final int ControlMask = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ControlMask 4
     * }
     */
    public static int ControlMask() {
        return ControlMask;
    }
    private static final int Mod1Mask = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Mod1Mask 8
     * }
     */
    public static int Mod1Mask() {
        return Mod1Mask;
    }
    private static final int Mod2Mask = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Mod2Mask 16
     * }
     */
    public static int Mod2Mask() {
        return Mod2Mask;
    }
    private static final int Mod3Mask = (int)32L;
    /**
     * {@snippet lang=c :
     * #define Mod3Mask 32
     * }
     */
    public static int Mod3Mask() {
        return Mod3Mask;
    }
    private static final int Mod4Mask = (int)64L;
    /**
     * {@snippet lang=c :
     * #define Mod4Mask 64
     * }
     */
    public static int Mod4Mask() {
        return Mod4Mask;
    }
    private static final int Mod5Mask = (int)128L;
    /**
     * {@snippet lang=c :
     * #define Mod5Mask 128
     * }
     */
    public static int Mod5Mask() {
        return Mod5Mask;
    }
    private static final int Button1Mask = (int)256L;
    /**
     * {@snippet lang=c :
     * #define Button1Mask 256
     * }
     */
    public static int Button1Mask() {
        return Button1Mask;
    }
    private static final int Button2Mask = (int)512L;
    /**
     * {@snippet lang=c :
     * #define Button2Mask 512
     * }
     */
    public static int Button2Mask() {
        return Button2Mask;
    }
    private static final int Button3Mask = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define Button3Mask 1024
     * }
     */
    public static int Button3Mask() {
        return Button3Mask;
    }
    private static final int Button4Mask = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define Button4Mask 2048
     * }
     */
    public static int Button4Mask() {
        return Button4Mask;
    }
    private static final int Button5Mask = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define Button5Mask 4096
     * }
     */
    public static int Button5Mask() {
        return Button5Mask;
    }
    private static final int AnyModifier = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AnyModifier 32768
     * }
     */
    public static int AnyModifier() {
        return AnyModifier;
    }
    private static final int RevertToNone = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RevertToNone 0
     * }
     */
    public static int RevertToNone() {
        return RevertToNone;
    }
    private static final int RevertToPointerRoot = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RevertToPointerRoot 1
     * }
     */
    public static int RevertToPointerRoot() {
        return RevertToPointerRoot;
    }
    private static final long CWBackPixmap = 1L;
    /**
     * {@snippet lang=c :
     * #define CWBackPixmap 1
     * }
     */
    public static long CWBackPixmap() {
        return CWBackPixmap;
    }
    private static final long CWBackPixel = 2L;
    /**
     * {@snippet lang=c :
     * #define CWBackPixel 2
     * }
     */
    public static long CWBackPixel() {
        return CWBackPixel;
    }
    private static final long CWBorderPixmap = 4L;
    /**
     * {@snippet lang=c :
     * #define CWBorderPixmap 4
     * }
     */
    public static long CWBorderPixmap() {
        return CWBorderPixmap;
    }
    private static final long CWBorderPixel = 8L;
    /**
     * {@snippet lang=c :
     * #define CWBorderPixel 8
     * }
     */
    public static long CWBorderPixel() {
        return CWBorderPixel;
    }
    private static final long CWBitGravity = 16L;
    /**
     * {@snippet lang=c :
     * #define CWBitGravity 16
     * }
     */
    public static long CWBitGravity() {
        return CWBitGravity;
    }
    private static final long CWWinGravity = 32L;
    /**
     * {@snippet lang=c :
     * #define CWWinGravity 32
     * }
     */
    public static long CWWinGravity() {
        return CWWinGravity;
    }
    private static final long CWBackingStore = 64L;
    /**
     * {@snippet lang=c :
     * #define CWBackingStore 64
     * }
     */
    public static long CWBackingStore() {
        return CWBackingStore;
    }
    private static final long CWBackingPlanes = 128L;
    /**
     * {@snippet lang=c :
     * #define CWBackingPlanes 128
     * }
     */
    public static long CWBackingPlanes() {
        return CWBackingPlanes;
    }
    private static final long CWBackingPixel = 256L;
    /**
     * {@snippet lang=c :
     * #define CWBackingPixel 256
     * }
     */
    public static long CWBackingPixel() {
        return CWBackingPixel;
    }
    private static final long CWOverrideRedirect = 512L;
    /**
     * {@snippet lang=c :
     * #define CWOverrideRedirect 512
     * }
     */
    public static long CWOverrideRedirect() {
        return CWOverrideRedirect;
    }
    private static final long CWSaveUnder = 1024L;
    /**
     * {@snippet lang=c :
     * #define CWSaveUnder 1024
     * }
     */
    public static long CWSaveUnder() {
        return CWSaveUnder;
    }
    private static final long CWEventMask = 2048L;
    /**
     * {@snippet lang=c :
     * #define CWEventMask 2048
     * }
     */
    public static long CWEventMask() {
        return CWEventMask;
    }
    private static final long CWDontPropagate = 4096L;
    /**
     * {@snippet lang=c :
     * #define CWDontPropagate 4096
     * }
     */
    public static long CWDontPropagate() {
        return CWDontPropagate;
    }
    private static final long CWColormap = 8192L;
    /**
     * {@snippet lang=c :
     * #define CWColormap 8192
     * }
     */
    public static long CWColormap() {
        return CWColormap;
    }
    private static final long CWCursor = 16384L;
    /**
     * {@snippet lang=c :
     * #define CWCursor 16384
     * }
     */
    public static long CWCursor() {
        return CWCursor;
    }
    private static final int CWX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CWX 1
     * }
     */
    public static int CWX() {
        return CWX;
    }
    private static final int CWY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CWY 2
     * }
     */
    public static int CWY() {
        return CWY;
    }
    private static final int CWWidth = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CWWidth 4
     * }
     */
    public static int CWWidth() {
        return CWWidth;
    }
    private static final int CWHeight = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CWHeight 8
     * }
     */
    public static int CWHeight() {
        return CWHeight;
    }
    private static final int CWBorderWidth = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CWBorderWidth 16
     * }
     */
    public static int CWBorderWidth() {
        return CWBorderWidth;
    }
    private static final int CWSibling = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CWSibling 32
     * }
     */
    public static int CWSibling() {
        return CWSibling;
    }
    private static final int CWStackMode = (int)64L;
    /**
     * {@snippet lang=c :
     * #define CWStackMode 64
     * }
     */
    public static int CWStackMode() {
        return CWStackMode;
    }
    private static final long GCFunction = 1L;
    /**
     * {@snippet lang=c :
     * #define GCFunction 1
     * }
     */
    public static long GCFunction() {
        return GCFunction;
    }
    private static final long GCPlaneMask = 2L;
    /**
     * {@snippet lang=c :
     * #define GCPlaneMask 2
     * }
     */
    public static long GCPlaneMask() {
        return GCPlaneMask;
    }
    private static final long GCForeground = 4L;
    /**
     * {@snippet lang=c :
     * #define GCForeground 4
     * }
     */
    public static long GCForeground() {
        return GCForeground;
    }
    private static final long GCBackground = 8L;
    /**
     * {@snippet lang=c :
     * #define GCBackground 8
     * }
     */
    public static long GCBackground() {
        return GCBackground;
    }
    private static final long GCLineWidth = 16L;
    /**
     * {@snippet lang=c :
     * #define GCLineWidth 16
     * }
     */
    public static long GCLineWidth() {
        return GCLineWidth;
    }
    private static final long GCLineStyle = 32L;
    /**
     * {@snippet lang=c :
     * #define GCLineStyle 32
     * }
     */
    public static long GCLineStyle() {
        return GCLineStyle;
    }
    private static final long GCCapStyle = 64L;
    /**
     * {@snippet lang=c :
     * #define GCCapStyle 64
     * }
     */
    public static long GCCapStyle() {
        return GCCapStyle;
    }
    private static final long GCJoinStyle = 128L;
    /**
     * {@snippet lang=c :
     * #define GCJoinStyle 128
     * }
     */
    public static long GCJoinStyle() {
        return GCJoinStyle;
    }
    private static final long GCFillStyle = 256L;
    /**
     * {@snippet lang=c :
     * #define GCFillStyle 256
     * }
     */
    public static long GCFillStyle() {
        return GCFillStyle;
    }
    private static final long GCFillRule = 512L;
    /**
     * {@snippet lang=c :
     * #define GCFillRule 512
     * }
     */
    public static long GCFillRule() {
        return GCFillRule;
    }
    private static final long GCTile = 1024L;
    /**
     * {@snippet lang=c :
     * #define GCTile 1024
     * }
     */
    public static long GCTile() {
        return GCTile;
    }
    private static final long GCStipple = 2048L;
    /**
     * {@snippet lang=c :
     * #define GCStipple 2048
     * }
     */
    public static long GCStipple() {
        return GCStipple;
    }
    private static final long GCTileStipXOrigin = 4096L;
    /**
     * {@snippet lang=c :
     * #define GCTileStipXOrigin 4096
     * }
     */
    public static long GCTileStipXOrigin() {
        return GCTileStipXOrigin;
    }
    private static final long GCTileStipYOrigin = 8192L;
    /**
     * {@snippet lang=c :
     * #define GCTileStipYOrigin 8192
     * }
     */
    public static long GCTileStipYOrigin() {
        return GCTileStipYOrigin;
    }
    private static final long GCFont = 16384L;
    /**
     * {@snippet lang=c :
     * #define GCFont 16384
     * }
     */
    public static long GCFont() {
        return GCFont;
    }
    private static final long GCSubwindowMode = 32768L;
    /**
     * {@snippet lang=c :
     * #define GCSubwindowMode 32768
     * }
     */
    public static long GCSubwindowMode() {
        return GCSubwindowMode;
    }
    private static final long GCGraphicsExposures = 65536L;
    /**
     * {@snippet lang=c :
     * #define GCGraphicsExposures 65536
     * }
     */
    public static long GCGraphicsExposures() {
        return GCGraphicsExposures;
    }
    private static final long GCClipXOrigin = 131072L;
    /**
     * {@snippet lang=c :
     * #define GCClipXOrigin 131072
     * }
     */
    public static long GCClipXOrigin() {
        return GCClipXOrigin;
    }
    private static final long GCClipYOrigin = 262144L;
    /**
     * {@snippet lang=c :
     * #define GCClipYOrigin 262144
     * }
     */
    public static long GCClipYOrigin() {
        return GCClipYOrigin;
    }
    private static final long GCClipMask = 524288L;
    /**
     * {@snippet lang=c :
     * #define GCClipMask 524288
     * }
     */
    public static long GCClipMask() {
        return GCClipMask;
    }
    private static final long GCDashOffset = 1048576L;
    /**
     * {@snippet lang=c :
     * #define GCDashOffset 1048576
     * }
     */
    public static long GCDashOffset() {
        return GCDashOffset;
    }
    private static final long GCDashList = 2097152L;
    /**
     * {@snippet lang=c :
     * #define GCDashList 2097152
     * }
     */
    public static long GCDashList() {
        return GCDashList;
    }
    private static final long GCArcMode = 4194304L;
    /**
     * {@snippet lang=c :
     * #define GCArcMode 4194304
     * }
     */
    public static long GCArcMode() {
        return GCArcMode;
    }
    private static final int DoRed = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DoRed 1
     * }
     */
    public static int DoRed() {
        return DoRed;
    }
    private static final int DoGreen = (int)2L;
    /**
     * {@snippet lang=c :
     * #define DoGreen 2
     * }
     */
    public static int DoGreen() {
        return DoGreen;
    }
    private static final int DoBlue = (int)4L;
    /**
     * {@snippet lang=c :
     * #define DoBlue 4
     * }
     */
    public static int DoBlue() {
        return DoBlue;
    }
    private static final long KBKeyClickPercent = 1L;
    /**
     * {@snippet lang=c :
     * #define KBKeyClickPercent 1
     * }
     */
    public static long KBKeyClickPercent() {
        return KBKeyClickPercent;
    }
    private static final long KBBellPercent = 2L;
    /**
     * {@snippet lang=c :
     * #define KBBellPercent 2
     * }
     */
    public static long KBBellPercent() {
        return KBBellPercent;
    }
    private static final long KBBellPitch = 4L;
    /**
     * {@snippet lang=c :
     * #define KBBellPitch 4
     * }
     */
    public static long KBBellPitch() {
        return KBBellPitch;
    }
    private static final long KBBellDuration = 8L;
    /**
     * {@snippet lang=c :
     * #define KBBellDuration 8
     * }
     */
    public static long KBBellDuration() {
        return KBBellDuration;
    }
    private static final long KBLed = 16L;
    /**
     * {@snippet lang=c :
     * #define KBLed 16
     * }
     */
    public static long KBLed() {
        return KBLed;
    }
    private static final long KBLedMode = 32L;
    /**
     * {@snippet lang=c :
     * #define KBLedMode 32
     * }
     */
    public static long KBLedMode() {
        return KBLedMode;
    }
    private static final long KBKey = 64L;
    /**
     * {@snippet lang=c :
     * #define KBKey 64
     * }
     */
    public static long KBKey() {
        return KBKey;
    }
    private static final long KBAutoRepeatMode = 128L;
    /**
     * {@snippet lang=c :
     * #define KBAutoRepeatMode 128
     * }
     */
    public static long KBAutoRepeatMode() {
        return KBAutoRepeatMode;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long AllPlanes = -1L;
    /**
     * {@snippet lang=c :
     * #define AllPlanes -1
     * }
     */
    public static long AllPlanes() {
        return AllPlanes;
    }
    /**
     * {@snippet lang=c :
     * #define XNRequiredCharSet "requiredCharSet"
     * }
     */
    public static MemorySegment XNRequiredCharSet() {
        class Holder {
            static final MemorySegment XNRequiredCharSet
                = glxext_h.LIBRARY_ARENA.allocateFrom("requiredCharSet");
        }
        return Holder.XNRequiredCharSet;
    }
    /**
     * {@snippet lang=c :
     * #define XNQueryOrientation "queryOrientation"
     * }
     */
    public static MemorySegment XNQueryOrientation() {
        class Holder {
            static final MemorySegment XNQueryOrientation
                = glxext_h.LIBRARY_ARENA.allocateFrom("queryOrientation");
        }
        return Holder.XNQueryOrientation;
    }
    /**
     * {@snippet lang=c :
     * #define XNBaseFontName "baseFontName"
     * }
     */
    public static MemorySegment XNBaseFontName() {
        class Holder {
            static final MemorySegment XNBaseFontName
                = glxext_h.LIBRARY_ARENA.allocateFrom("baseFontName");
        }
        return Holder.XNBaseFontName;
    }
    /**
     * {@snippet lang=c :
     * #define XNOMAutomatic "omAutomatic"
     * }
     */
    public static MemorySegment XNOMAutomatic() {
        class Holder {
            static final MemorySegment XNOMAutomatic
                = glxext_h.LIBRARY_ARENA.allocateFrom("omAutomatic");
        }
        return Holder.XNOMAutomatic;
    }
    /**
     * {@snippet lang=c :
     * #define XNMissingCharSet "missingCharSet"
     * }
     */
    public static MemorySegment XNMissingCharSet() {
        class Holder {
            static final MemorySegment XNMissingCharSet
                = glxext_h.LIBRARY_ARENA.allocateFrom("missingCharSet");
        }
        return Holder.XNMissingCharSet;
    }
    /**
     * {@snippet lang=c :
     * #define XNDefaultString "defaultString"
     * }
     */
    public static MemorySegment XNDefaultString() {
        class Holder {
            static final MemorySegment XNDefaultString
                = glxext_h.LIBRARY_ARENA.allocateFrom("defaultString");
        }
        return Holder.XNDefaultString;
    }
    /**
     * {@snippet lang=c :
     * #define XNOrientation "orientation"
     * }
     */
    public static MemorySegment XNOrientation() {
        class Holder {
            static final MemorySegment XNOrientation
                = glxext_h.LIBRARY_ARENA.allocateFrom("orientation");
        }
        return Holder.XNOrientation;
    }
    /**
     * {@snippet lang=c :
     * #define XNDirectionalDependentDrawing "directionalDependentDrawing"
     * }
     */
    public static MemorySegment XNDirectionalDependentDrawing() {
        class Holder {
            static final MemorySegment XNDirectionalDependentDrawing
                = glxext_h.LIBRARY_ARENA.allocateFrom("directionalDependentDrawing");
        }
        return Holder.XNDirectionalDependentDrawing;
    }
    /**
     * {@snippet lang=c :
     * #define XNContextualDrawing "contextualDrawing"
     * }
     */
    public static MemorySegment XNContextualDrawing() {
        class Holder {
            static final MemorySegment XNContextualDrawing
                = glxext_h.LIBRARY_ARENA.allocateFrom("contextualDrawing");
        }
        return Holder.XNContextualDrawing;
    }
    /**
     * {@snippet lang=c :
     * #define XNFontInfo "fontInfo"
     * }
     */
    public static MemorySegment XNFontInfo() {
        class Holder {
            static final MemorySegment XNFontInfo
                = glxext_h.LIBRARY_ARENA.allocateFrom("fontInfo");
        }
        return Holder.XNFontInfo;
    }
    private static final long XIMPreeditArea = 1L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditArea 1
     * }
     */
    public static long XIMPreeditArea() {
        return XIMPreeditArea;
    }
    private static final long XIMPreeditCallbacks = 2L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditCallbacks 2
     * }
     */
    public static long XIMPreeditCallbacks() {
        return XIMPreeditCallbacks;
    }
    private static final long XIMPreeditPosition = 4L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditPosition 4
     * }
     */
    public static long XIMPreeditPosition() {
        return XIMPreeditPosition;
    }
    private static final long XIMPreeditNothing = 8L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditNothing 8
     * }
     */
    public static long XIMPreeditNothing() {
        return XIMPreeditNothing;
    }
    private static final long XIMPreeditNone = 16L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditNone 16
     * }
     */
    public static long XIMPreeditNone() {
        return XIMPreeditNone;
    }
    private static final long XIMStatusArea = 256L;
    /**
     * {@snippet lang=c :
     * #define XIMStatusArea 256
     * }
     */
    public static long XIMStatusArea() {
        return XIMStatusArea;
    }
    private static final long XIMStatusCallbacks = 512L;
    /**
     * {@snippet lang=c :
     * #define XIMStatusCallbacks 512
     * }
     */
    public static long XIMStatusCallbacks() {
        return XIMStatusCallbacks;
    }
    private static final long XIMStatusNothing = 1024L;
    /**
     * {@snippet lang=c :
     * #define XIMStatusNothing 1024
     * }
     */
    public static long XIMStatusNothing() {
        return XIMStatusNothing;
    }
    private static final long XIMStatusNone = 2048L;
    /**
     * {@snippet lang=c :
     * #define XIMStatusNone 2048
     * }
     */
    public static long XIMStatusNone() {
        return XIMStatusNone;
    }
    /**
     * {@snippet lang=c :
     * #define XNVaNestedList "XNVaNestedList"
     * }
     */
    public static MemorySegment XNVaNestedList() {
        class Holder {
            static final MemorySegment XNVaNestedList
                = glxext_h.LIBRARY_ARENA.allocateFrom("XNVaNestedList");
        }
        return Holder.XNVaNestedList;
    }
    /**
     * {@snippet lang=c :
     * #define XNQueryInputStyle "queryInputStyle"
     * }
     */
    public static MemorySegment XNQueryInputStyle() {
        class Holder {
            static final MemorySegment XNQueryInputStyle
                = glxext_h.LIBRARY_ARENA.allocateFrom("queryInputStyle");
        }
        return Holder.XNQueryInputStyle;
    }
    /**
     * {@snippet lang=c :
     * #define XNClientWindow "clientWindow"
     * }
     */
    public static MemorySegment XNClientWindow() {
        class Holder {
            static final MemorySegment XNClientWindow
                = glxext_h.LIBRARY_ARENA.allocateFrom("clientWindow");
        }
        return Holder.XNClientWindow;
    }
    /**
     * {@snippet lang=c :
     * #define XNInputStyle "inputStyle"
     * }
     */
    public static MemorySegment XNInputStyle() {
        class Holder {
            static final MemorySegment XNInputStyle
                = glxext_h.LIBRARY_ARENA.allocateFrom("inputStyle");
        }
        return Holder.XNInputStyle;
    }
    /**
     * {@snippet lang=c :
     * #define XNFocusWindow "focusWindow"
     * }
     */
    public static MemorySegment XNFocusWindow() {
        class Holder {
            static final MemorySegment XNFocusWindow
                = glxext_h.LIBRARY_ARENA.allocateFrom("focusWindow");
        }
        return Holder.XNFocusWindow;
    }
    /**
     * {@snippet lang=c :
     * #define XNResourceName "resourceName"
     * }
     */
    public static MemorySegment XNResourceName() {
        class Holder {
            static final MemorySegment XNResourceName
                = glxext_h.LIBRARY_ARENA.allocateFrom("resourceName");
        }
        return Holder.XNResourceName;
    }
    /**
     * {@snippet lang=c :
     * #define XNResourceClass "resourceClass"
     * }
     */
    public static MemorySegment XNResourceClass() {
        class Holder {
            static final MemorySegment XNResourceClass
                = glxext_h.LIBRARY_ARENA.allocateFrom("resourceClass");
        }
        return Holder.XNResourceClass;
    }
    /**
     * {@snippet lang=c :
     * #define XNGeometryCallback "geometryCallback"
     * }
     */
    public static MemorySegment XNGeometryCallback() {
        class Holder {
            static final MemorySegment XNGeometryCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("geometryCallback");
        }
        return Holder.XNGeometryCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNDestroyCallback "destroyCallback"
     * }
     */
    public static MemorySegment XNDestroyCallback() {
        class Holder {
            static final MemorySegment XNDestroyCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("destroyCallback");
        }
        return Holder.XNDestroyCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNFilterEvents "filterEvents"
     * }
     */
    public static MemorySegment XNFilterEvents() {
        class Holder {
            static final MemorySegment XNFilterEvents
                = glxext_h.LIBRARY_ARENA.allocateFrom("filterEvents");
        }
        return Holder.XNFilterEvents;
    }
    /**
     * {@snippet lang=c :
     * #define XNPreeditStartCallback "preeditStartCallback"
     * }
     */
    public static MemorySegment XNPreeditStartCallback() {
        class Holder {
            static final MemorySegment XNPreeditStartCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("preeditStartCallback");
        }
        return Holder.XNPreeditStartCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNPreeditDoneCallback "preeditDoneCallback"
     * }
     */
    public static MemorySegment XNPreeditDoneCallback() {
        class Holder {
            static final MemorySegment XNPreeditDoneCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("preeditDoneCallback");
        }
        return Holder.XNPreeditDoneCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNPreeditDrawCallback "preeditDrawCallback"
     * }
     */
    public static MemorySegment XNPreeditDrawCallback() {
        class Holder {
            static final MemorySegment XNPreeditDrawCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("preeditDrawCallback");
        }
        return Holder.XNPreeditDrawCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNPreeditCaretCallback "preeditCaretCallback"
     * }
     */
    public static MemorySegment XNPreeditCaretCallback() {
        class Holder {
            static final MemorySegment XNPreeditCaretCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("preeditCaretCallback");
        }
        return Holder.XNPreeditCaretCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNPreeditStateNotifyCallback "preeditStateNotifyCallback"
     * }
     */
    public static MemorySegment XNPreeditStateNotifyCallback() {
        class Holder {
            static final MemorySegment XNPreeditStateNotifyCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("preeditStateNotifyCallback");
        }
        return Holder.XNPreeditStateNotifyCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNPreeditAttributes "preeditAttributes"
     * }
     */
    public static MemorySegment XNPreeditAttributes() {
        class Holder {
            static final MemorySegment XNPreeditAttributes
                = glxext_h.LIBRARY_ARENA.allocateFrom("preeditAttributes");
        }
        return Holder.XNPreeditAttributes;
    }
    /**
     * {@snippet lang=c :
     * #define XNStatusStartCallback "statusStartCallback"
     * }
     */
    public static MemorySegment XNStatusStartCallback() {
        class Holder {
            static final MemorySegment XNStatusStartCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("statusStartCallback");
        }
        return Holder.XNStatusStartCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNStatusDoneCallback "statusDoneCallback"
     * }
     */
    public static MemorySegment XNStatusDoneCallback() {
        class Holder {
            static final MemorySegment XNStatusDoneCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("statusDoneCallback");
        }
        return Holder.XNStatusDoneCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNStatusDrawCallback "statusDrawCallback"
     * }
     */
    public static MemorySegment XNStatusDrawCallback() {
        class Holder {
            static final MemorySegment XNStatusDrawCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("statusDrawCallback");
        }
        return Holder.XNStatusDrawCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNStatusAttributes "statusAttributes"
     * }
     */
    public static MemorySegment XNStatusAttributes() {
        class Holder {
            static final MemorySegment XNStatusAttributes
                = glxext_h.LIBRARY_ARENA.allocateFrom("statusAttributes");
        }
        return Holder.XNStatusAttributes;
    }
    /**
     * {@snippet lang=c :
     * #define XNArea "area"
     * }
     */
    public static MemorySegment XNArea() {
        class Holder {
            static final MemorySegment XNArea
                = glxext_h.LIBRARY_ARENA.allocateFrom("area");
        }
        return Holder.XNArea;
    }
    /**
     * {@snippet lang=c :
     * #define XNAreaNeeded "areaNeeded"
     * }
     */
    public static MemorySegment XNAreaNeeded() {
        class Holder {
            static final MemorySegment XNAreaNeeded
                = glxext_h.LIBRARY_ARENA.allocateFrom("areaNeeded");
        }
        return Holder.XNAreaNeeded;
    }
    /**
     * {@snippet lang=c :
     * #define XNSpotLocation "spotLocation"
     * }
     */
    public static MemorySegment XNSpotLocation() {
        class Holder {
            static final MemorySegment XNSpotLocation
                = glxext_h.LIBRARY_ARENA.allocateFrom("spotLocation");
        }
        return Holder.XNSpotLocation;
    }
    /**
     * {@snippet lang=c :
     * #define XNColormap "colorMap"
     * }
     */
    public static MemorySegment XNColormap() {
        class Holder {
            static final MemorySegment XNColormap
                = glxext_h.LIBRARY_ARENA.allocateFrom("colorMap");
        }
        return Holder.XNColormap;
    }
    /**
     * {@snippet lang=c :
     * #define XNStdColormap "stdColorMap"
     * }
     */
    public static MemorySegment XNStdColormap() {
        class Holder {
            static final MemorySegment XNStdColormap
                = glxext_h.LIBRARY_ARENA.allocateFrom("stdColorMap");
        }
        return Holder.XNStdColormap;
    }
    /**
     * {@snippet lang=c :
     * #define XNForeground "foreground"
     * }
     */
    public static MemorySegment XNForeground() {
        class Holder {
            static final MemorySegment XNForeground
                = glxext_h.LIBRARY_ARENA.allocateFrom("foreground");
        }
        return Holder.XNForeground;
    }
    /**
     * {@snippet lang=c :
     * #define XNBackground "background"
     * }
     */
    public static MemorySegment XNBackground() {
        class Holder {
            static final MemorySegment XNBackground
                = glxext_h.LIBRARY_ARENA.allocateFrom("background");
        }
        return Holder.XNBackground;
    }
    /**
     * {@snippet lang=c :
     * #define XNBackgroundPixmap "backgroundPixmap"
     * }
     */
    public static MemorySegment XNBackgroundPixmap() {
        class Holder {
            static final MemorySegment XNBackgroundPixmap
                = glxext_h.LIBRARY_ARENA.allocateFrom("backgroundPixmap");
        }
        return Holder.XNBackgroundPixmap;
    }
    /**
     * {@snippet lang=c :
     * #define XNFontSet "fontSet"
     * }
     */
    public static MemorySegment XNFontSet() {
        class Holder {
            static final MemorySegment XNFontSet
                = glxext_h.LIBRARY_ARENA.allocateFrom("fontSet");
        }
        return Holder.XNFontSet;
    }
    /**
     * {@snippet lang=c :
     * #define XNLineSpace "lineSpace"
     * }
     */
    public static MemorySegment XNLineSpace() {
        class Holder {
            static final MemorySegment XNLineSpace
                = glxext_h.LIBRARY_ARENA.allocateFrom("lineSpace");
        }
        return Holder.XNLineSpace;
    }
    /**
     * {@snippet lang=c :
     * #define XNCursor "cursor"
     * }
     */
    public static MemorySegment XNCursor() {
        class Holder {
            static final MemorySegment XNCursor
                = glxext_h.LIBRARY_ARENA.allocateFrom("cursor");
        }
        return Holder.XNCursor;
    }
    /**
     * {@snippet lang=c :
     * #define XNQueryIMValuesList "queryIMValuesList"
     * }
     */
    public static MemorySegment XNQueryIMValuesList() {
        class Holder {
            static final MemorySegment XNQueryIMValuesList
                = glxext_h.LIBRARY_ARENA.allocateFrom("queryIMValuesList");
        }
        return Holder.XNQueryIMValuesList;
    }
    /**
     * {@snippet lang=c :
     * #define XNQueryICValuesList "queryICValuesList"
     * }
     */
    public static MemorySegment XNQueryICValuesList() {
        class Holder {
            static final MemorySegment XNQueryICValuesList
                = glxext_h.LIBRARY_ARENA.allocateFrom("queryICValuesList");
        }
        return Holder.XNQueryICValuesList;
    }
    /**
     * {@snippet lang=c :
     * #define XNVisiblePosition "visiblePosition"
     * }
     */
    public static MemorySegment XNVisiblePosition() {
        class Holder {
            static final MemorySegment XNVisiblePosition
                = glxext_h.LIBRARY_ARENA.allocateFrom("visiblePosition");
        }
        return Holder.XNVisiblePosition;
    }
    /**
     * {@snippet lang=c :
     * #define XNR6PreeditCallback "r6PreeditCallback"
     * }
     */
    public static MemorySegment XNR6PreeditCallback() {
        class Holder {
            static final MemorySegment XNR6PreeditCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("r6PreeditCallback");
        }
        return Holder.XNR6PreeditCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNStringConversionCallback "stringConversionCallback"
     * }
     */
    public static MemorySegment XNStringConversionCallback() {
        class Holder {
            static final MemorySegment XNStringConversionCallback
                = glxext_h.LIBRARY_ARENA.allocateFrom("stringConversionCallback");
        }
        return Holder.XNStringConversionCallback;
    }
    /**
     * {@snippet lang=c :
     * #define XNStringConversion "stringConversion"
     * }
     */
    public static MemorySegment XNStringConversion() {
        class Holder {
            static final MemorySegment XNStringConversion
                = glxext_h.LIBRARY_ARENA.allocateFrom("stringConversion");
        }
        return Holder.XNStringConversion;
    }
    /**
     * {@snippet lang=c :
     * #define XNResetState "resetState"
     * }
     */
    public static MemorySegment XNResetState() {
        class Holder {
            static final MemorySegment XNResetState
                = glxext_h.LIBRARY_ARENA.allocateFrom("resetState");
        }
        return Holder.XNResetState;
    }
    /**
     * {@snippet lang=c :
     * #define XNHotKey "hotKey"
     * }
     */
    public static MemorySegment XNHotKey() {
        class Holder {
            static final MemorySegment XNHotKey
                = glxext_h.LIBRARY_ARENA.allocateFrom("hotKey");
        }
        return Holder.XNHotKey;
    }
    /**
     * {@snippet lang=c :
     * #define XNHotKeyState "hotKeyState"
     * }
     */
    public static MemorySegment XNHotKeyState() {
        class Holder {
            static final MemorySegment XNHotKeyState
                = glxext_h.LIBRARY_ARENA.allocateFrom("hotKeyState");
        }
        return Holder.XNHotKeyState;
    }
    /**
     * {@snippet lang=c :
     * #define XNPreeditState "preeditState"
     * }
     */
    public static MemorySegment XNPreeditState() {
        class Holder {
            static final MemorySegment XNPreeditState
                = glxext_h.LIBRARY_ARENA.allocateFrom("preeditState");
        }
        return Holder.XNPreeditState;
    }
    /**
     * {@snippet lang=c :
     * #define XNSeparatorofNestedList "separatorofNestedList"
     * }
     */
    public static MemorySegment XNSeparatorofNestedList() {
        class Holder {
            static final MemorySegment XNSeparatorofNestedList
                = glxext_h.LIBRARY_ARENA.allocateFrom("separatorofNestedList");
        }
        return Holder.XNSeparatorofNestedList;
    }
    private static final int XBufferOverflow = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define XBufferOverflow -1
     * }
     */
    public static int XBufferOverflow() {
        return XBufferOverflow;
    }
    private static final long XIMReverse = 1L;
    /**
     * {@snippet lang=c :
     * #define XIMReverse 1
     * }
     */
    public static long XIMReverse() {
        return XIMReverse;
    }
    private static final long XIMUnderline = 2L;
    /**
     * {@snippet lang=c :
     * #define XIMUnderline 2
     * }
     */
    public static long XIMUnderline() {
        return XIMUnderline;
    }
    private static final long XIMHighlight = 4L;
    /**
     * {@snippet lang=c :
     * #define XIMHighlight 4
     * }
     */
    public static long XIMHighlight() {
        return XIMHighlight;
    }
    private static final long XIMPrimary = 32L;
    /**
     * {@snippet lang=c :
     * #define XIMPrimary 32
     * }
     */
    public static long XIMPrimary() {
        return XIMPrimary;
    }
    private static final long XIMSecondary = 64L;
    /**
     * {@snippet lang=c :
     * #define XIMSecondary 64
     * }
     */
    public static long XIMSecondary() {
        return XIMSecondary;
    }
    private static final long XIMTertiary = 128L;
    /**
     * {@snippet lang=c :
     * #define XIMTertiary 128
     * }
     */
    public static long XIMTertiary() {
        return XIMTertiary;
    }
    private static final long XIMVisibleToForward = 256L;
    /**
     * {@snippet lang=c :
     * #define XIMVisibleToForward 256
     * }
     */
    public static long XIMVisibleToForward() {
        return XIMVisibleToForward;
    }
    private static final long XIMVisibleToBackword = 512L;
    /**
     * {@snippet lang=c :
     * #define XIMVisibleToBackword 512
     * }
     */
    public static long XIMVisibleToBackword() {
        return XIMVisibleToBackword;
    }
    private static final long XIMVisibleToCenter = 1024L;
    /**
     * {@snippet lang=c :
     * #define XIMVisibleToCenter 1024
     * }
     */
    public static long XIMVisibleToCenter() {
        return XIMVisibleToCenter;
    }
    private static final long XIMPreeditUnKnown = 0L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditUnKnown 0
     * }
     */
    public static long XIMPreeditUnKnown() {
        return XIMPreeditUnKnown;
    }
    private static final long XIMPreeditEnable = 1L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditEnable 1
     * }
     */
    public static long XIMPreeditEnable() {
        return XIMPreeditEnable;
    }
    private static final long XIMPreeditDisable = 2L;
    /**
     * {@snippet lang=c :
     * #define XIMPreeditDisable 2
     * }
     */
    public static long XIMPreeditDisable() {
        return XIMPreeditDisable;
    }
    private static final long XIMInitialState = 1L;
    /**
     * {@snippet lang=c :
     * #define XIMInitialState 1
     * }
     */
    public static long XIMInitialState() {
        return XIMInitialState;
    }
    private static final long XIMPreserveState = 2L;
    /**
     * {@snippet lang=c :
     * #define XIMPreserveState 2
     * }
     */
    public static long XIMPreserveState() {
        return XIMPreserveState;
    }
    private static final int XIMStringConversionLeftEdge = (int)1L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionLeftEdge 1
     * }
     */
    public static int XIMStringConversionLeftEdge() {
        return XIMStringConversionLeftEdge;
    }
    private static final int XIMStringConversionRightEdge = (int)2L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionRightEdge 2
     * }
     */
    public static int XIMStringConversionRightEdge() {
        return XIMStringConversionRightEdge;
    }
    private static final int XIMStringConversionTopEdge = (int)4L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionTopEdge 4
     * }
     */
    public static int XIMStringConversionTopEdge() {
        return XIMStringConversionTopEdge;
    }
    private static final int XIMStringConversionBottomEdge = (int)8L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionBottomEdge 8
     * }
     */
    public static int XIMStringConversionBottomEdge() {
        return XIMStringConversionBottomEdge;
    }
    private static final int XIMStringConversionConcealed = (int)16L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionConcealed 16
     * }
     */
    public static int XIMStringConversionConcealed() {
        return XIMStringConversionConcealed;
    }
    private static final int XIMStringConversionWrapped = (int)32L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionWrapped 32
     * }
     */
    public static int XIMStringConversionWrapped() {
        return XIMStringConversionWrapped;
    }
    private static final int XIMStringConversionBuffer = (int)1L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionBuffer 1
     * }
     */
    public static int XIMStringConversionBuffer() {
        return XIMStringConversionBuffer;
    }
    private static final int XIMStringConversionLine = (int)2L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionLine 2
     * }
     */
    public static int XIMStringConversionLine() {
        return XIMStringConversionLine;
    }
    private static final int XIMStringConversionWord = (int)3L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionWord 3
     * }
     */
    public static int XIMStringConversionWord() {
        return XIMStringConversionWord;
    }
    private static final int XIMStringConversionChar = (int)4L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionChar 4
     * }
     */
    public static int XIMStringConversionChar() {
        return XIMStringConversionChar;
    }
    private static final int XIMStringConversionSubstitution = (int)1L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionSubstitution 1
     * }
     */
    public static int XIMStringConversionSubstitution() {
        return XIMStringConversionSubstitution;
    }
    private static final int XIMStringConversionRetrieval = (int)2L;
    /**
     * {@snippet lang=c :
     * #define XIMStringConversionRetrieval 2
     * }
     */
    public static int XIMStringConversionRetrieval() {
        return XIMStringConversionRetrieval;
    }
    private static final long XIMHotKeyStateON = 1L;
    /**
     * {@snippet lang=c :
     * #define XIMHotKeyStateON 1
     * }
     */
    public static long XIMHotKeyStateON() {
        return XIMHotKeyStateON;
    }
    private static final long XIMHotKeyStateOFF = 2L;
    /**
     * {@snippet lang=c :
     * #define XIMHotKeyStateOFF 2
     * }
     */
    public static long XIMHotKeyStateOFF() {
        return XIMHotKeyStateOFF;
    }
    private static final long USPosition = 1L;
    /**
     * {@snippet lang=c :
     * #define USPosition 1
     * }
     */
    public static long USPosition() {
        return USPosition;
    }
    private static final long USSize = 2L;
    /**
     * {@snippet lang=c :
     * #define USSize 2
     * }
     */
    public static long USSize() {
        return USSize;
    }
    private static final long PPosition = 4L;
    /**
     * {@snippet lang=c :
     * #define PPosition 4
     * }
     */
    public static long PPosition() {
        return PPosition;
    }
    private static final long PSize = 8L;
    /**
     * {@snippet lang=c :
     * #define PSize 8
     * }
     */
    public static long PSize() {
        return PSize;
    }
    private static final long PMinSize = 16L;
    /**
     * {@snippet lang=c :
     * #define PMinSize 16
     * }
     */
    public static long PMinSize() {
        return PMinSize;
    }
    private static final long PMaxSize = 32L;
    /**
     * {@snippet lang=c :
     * #define PMaxSize 32
     * }
     */
    public static long PMaxSize() {
        return PMaxSize;
    }
    private static final long PResizeInc = 64L;
    /**
     * {@snippet lang=c :
     * #define PResizeInc 64
     * }
     */
    public static long PResizeInc() {
        return PResizeInc;
    }
    private static final long PAspect = 128L;
    /**
     * {@snippet lang=c :
     * #define PAspect 128
     * }
     */
    public static long PAspect() {
        return PAspect;
    }
    private static final long PBaseSize = 256L;
    /**
     * {@snippet lang=c :
     * #define PBaseSize 256
     * }
     */
    public static long PBaseSize() {
        return PBaseSize;
    }
    private static final long PWinGravity = 512L;
    /**
     * {@snippet lang=c :
     * #define PWinGravity 512
     * }
     */
    public static long PWinGravity() {
        return PWinGravity;
    }
    private static final long PAllHints = 252L;
    /**
     * {@snippet lang=c :
     * #define PAllHints 252
     * }
     */
    public static long PAllHints() {
        return PAllHints;
    }
    private static final long InputHint = 1L;
    /**
     * {@snippet lang=c :
     * #define InputHint 1
     * }
     */
    public static long InputHint() {
        return InputHint;
    }
    private static final long StateHint = 2L;
    /**
     * {@snippet lang=c :
     * #define StateHint 2
     * }
     */
    public static long StateHint() {
        return StateHint;
    }
    private static final long IconPixmapHint = 4L;
    /**
     * {@snippet lang=c :
     * #define IconPixmapHint 4
     * }
     */
    public static long IconPixmapHint() {
        return IconPixmapHint;
    }
    private static final long IconWindowHint = 8L;
    /**
     * {@snippet lang=c :
     * #define IconWindowHint 8
     * }
     */
    public static long IconWindowHint() {
        return IconWindowHint;
    }
    private static final long IconPositionHint = 16L;
    /**
     * {@snippet lang=c :
     * #define IconPositionHint 16
     * }
     */
    public static long IconPositionHint() {
        return IconPositionHint;
    }
    private static final long IconMaskHint = 32L;
    /**
     * {@snippet lang=c :
     * #define IconMaskHint 32
     * }
     */
    public static long IconMaskHint() {
        return IconMaskHint;
    }
    private static final long WindowGroupHint = 64L;
    /**
     * {@snippet lang=c :
     * #define WindowGroupHint 64
     * }
     */
    public static long WindowGroupHint() {
        return WindowGroupHint;
    }
    private static final long AllHints = 127L;
    /**
     * {@snippet lang=c :
     * #define AllHints 127
     * }
     */
    public static long AllHints() {
        return AllHints;
    }
    private static final long XUrgencyHint = 256L;
    /**
     * {@snippet lang=c :
     * #define XUrgencyHint 256
     * }
     */
    public static long XUrgencyHint() {
        return XUrgencyHint;
    }
    private static final int XNoMemory = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define XNoMemory -1
     * }
     */
    public static int XNoMemory() {
        return XNoMemory;
    }
    private static final int XLocaleNotSupported = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define XLocaleNotSupported -2
     * }
     */
    public static int XLocaleNotSupported() {
        return XLocaleNotSupported;
    }
    private static final int XConverterNotFound = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define XConverterNotFound -3
     * }
     */
    public static int XConverterNotFound() {
        return XConverterNotFound;
    }
    private static final long ReleaseByFreeingColormap = 1L;
    /**
     * {@snippet lang=c :
     * #define ReleaseByFreeingColormap 1
     * }
     */
    public static long ReleaseByFreeingColormap() {
        return ReleaseByFreeingColormap;
    }
    private static final int GL_ALL_ATTRIB_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_ATTRIB_BITS 4294967295
     * }
     */
    public static int GL_ALL_ATTRIB_BITS() {
        return GL_ALL_ATTRIB_BITS;
    }
    private static final int GL_ALL_CLIENT_ATTRIB_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_CLIENT_ATTRIB_BITS 4294967295
     * }
     */
    public static int GL_ALL_CLIENT_ATTRIB_BITS() {
        return GL_ALL_CLIENT_ATTRIB_BITS;
    }
    private static final int GL_CLIENT_ALL_ATTRIB_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_CLIENT_ALL_ATTRIB_BITS 4294967295
     * }
     */
    public static int GL_CLIENT_ALL_ATTRIB_BITS() {
        return GL_CLIENT_ALL_ATTRIB_BITS;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int GL_INVALID_INDEX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_INVALID_INDEX 4294967295
     * }
     */
    public static int GL_INVALID_INDEX() {
        return GL_INVALID_INDEX;
    }
    private static final long GL_TIMEOUT_IGNORED = -1L;
    /**
     * {@snippet lang=c :
     * #define GL_TIMEOUT_IGNORED -1
     * }
     */
    public static long GL_TIMEOUT_IGNORED() {
        return GL_TIMEOUT_IGNORED;
    }
    private static final int GL_ALL_SHADER_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_SHADER_BITS 4294967295
     * }
     */
    public static int GL_ALL_SHADER_BITS() {
        return GL_ALL_SHADER_BITS;
    }
    private static final int GL_ALL_BARRIER_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_BARRIER_BITS 4294967295
     * }
     */
    public static int GL_ALL_BARRIER_BITS() {
        return GL_ALL_BARRIER_BITS;
    }
    private static final int GL_ALL_PIXELS_AMD = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_PIXELS_AMD 4294967295
     * }
     */
    public static int GL_ALL_PIXELS_AMD() {
        return GL_ALL_PIXELS_AMD;
    }
    private static final int GL_QUERY_ALL_EVENT_BITS_AMD = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_QUERY_ALL_EVENT_BITS_AMD 4294967295
     * }
     */
    public static int GL_QUERY_ALL_EVENT_BITS_AMD() {
        return GL_QUERY_ALL_EVENT_BITS_AMD;
    }
    private static final int GL_ALL_BARRIER_BITS_EXT = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_ALL_BARRIER_BITS_EXT 4294967295
     * }
     */
    public static int GL_ALL_BARRIER_BITS_EXT() {
        return GL_ALL_BARRIER_BITS_EXT;
    }
    private static final int GL_NEXT_BUFFER_NV = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define GL_NEXT_BUFFER_NV -2
     * }
     */
    public static int GL_NEXT_BUFFER_NV() {
        return GL_NEXT_BUFFER_NV;
    }
    private static final int GL_SKIP_COMPONENTS4_NV = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define GL_SKIP_COMPONENTS4_NV -3
     * }
     */
    public static int GL_SKIP_COMPONENTS4_NV() {
        return GL_SKIP_COMPONENTS4_NV;
    }
    private static final int GL_SKIP_COMPONENTS3_NV = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define GL_SKIP_COMPONENTS3_NV -4
     * }
     */
    public static int GL_SKIP_COMPONENTS3_NV() {
        return GL_SKIP_COMPONENTS3_NV;
    }
    private static final int GL_SKIP_COMPONENTS2_NV = (int)-5L;
    /**
     * {@snippet lang=c :
     * #define GL_SKIP_COMPONENTS2_NV -5
     * }
     */
    public static int GL_SKIP_COMPONENTS2_NV() {
        return GL_SKIP_COMPONENTS2_NV;
    }
    private static final int GL_SKIP_COMPONENTS1_NV = (int)-6L;
    /**
     * {@snippet lang=c :
     * #define GL_SKIP_COMPONENTS1_NV -6
     * }
     */
    public static int GL_SKIP_COMPONENTS1_NV() {
        return GL_SKIP_COMPONENTS1_NV;
    }
    private static final int GL_TEXCOORD4_BIT_PGI = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define GL_TEXCOORD4_BIT_PGI 2147483648
     * }
     */
    public static int GL_TEXCOORD4_BIT_PGI() {
        return GL_TEXCOORD4_BIT_PGI;
    }
    /**
     * {@snippet lang=c :
     * #define GLX_EXTENSION_NAME "GLX"
     * }
     */
    public static MemorySegment GLX_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment GLX_EXTENSION_NAME
                = glxext_h.LIBRARY_ARENA.allocateFrom("GLX");
        }
        return Holder.GLX_EXTENSION_NAME;
    }
    private static final int GLX_DONT_CARE = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GLX_DONT_CARE 4294967295
     * }
     */
    public static int GLX_DONT_CARE() {
        return GLX_DONT_CARE;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI64_PREFIX "l"
     * }
     */
    public static MemorySegment __PRI64_PREFIX() {
        class Holder {
            static final MemorySegment __PRI64_PREFIX
                = glxext_h.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRI64_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define __PRIPTR_PREFIX "l"
     * }
     */
    public static MemorySegment __PRIPTR_PREFIX() {
        class Holder {
            static final MemorySegment __PRIPTR_PREFIX
                = glxext_h.LIBRARY_ARENA.allocateFrom("l");
        }
        return Holder.__PRIPTR_PREFIX;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "d"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "d"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "ld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "d"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "d"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "ld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "d"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "ld"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "ld"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "ld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "i"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "i"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "li"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "i"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "i"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "li"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "i"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "li"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "li"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "li"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "o"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "o"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "lo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "o"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "o"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "lo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "o"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "lo"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "lo"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "lo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "u"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "u"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "lu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "u"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "u"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "lu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "u"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "lu"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "lu"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "lu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "x"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "x"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "lx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "x"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "x"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "lx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "x"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "lx"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "lx"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "lx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "X"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = glxext_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "X"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = glxext_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = glxext_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "lX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "X"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "X"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "lX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "X"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "lX"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "lX"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "lX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "ld"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "li"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "lo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "lu"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "lx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "lX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "ld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "li"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "lo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "lu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "lx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "lX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "ld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "ld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "ld"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "ld"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "ld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "li"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "li"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "li"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "li"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "li"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "lu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "lu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "lu"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "lu"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "lu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = glxext_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "lo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "lo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "lo"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "lo"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "lo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "lx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "lx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = glxext_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "lx"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "lx"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "lx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "ld"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "li"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "lo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "lu"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "lx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "ld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "li"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "lo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "lu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "lx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = glxext_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxPTR;
    }
}

