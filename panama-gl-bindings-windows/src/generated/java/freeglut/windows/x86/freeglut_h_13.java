// Generated by jextract

package freeglut.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h_13 extends freeglut_h_14 {

    freeglut_h_13() {
        // Should not be called directly
    }

    private static class GetPrivateProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStringW$descriptor() {
        return GetPrivateProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileStringW$handle() {
        return GetPrivateProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileStringW$address() {
        return GetPrivateProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStringW", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WritePrivateProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStringA$descriptor() {
        return WritePrivateProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileStringA$handle() {
        return WritePrivateProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileStringA$address() {
        return WritePrivateProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStringA", lpAppName, lpKeyName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WritePrivateProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStringW$descriptor() {
        return WritePrivateProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileStringW$handle() {
        return WritePrivateProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileStringW$address() {
        return WritePrivateProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStringW", lpAppName, lpKeyName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionA$descriptor() {
        return GetPrivateProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionA$handle() {
        return GetPrivateProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionA$address() {
        return GetPrivateProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionA(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionA", lpAppName, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionW$descriptor() {
        return GetPrivateProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionW$handle() {
        return GetPrivateProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionW$address() {
        return GetPrivateProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionW(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionW", lpAppName, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WritePrivateProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileSectionA$descriptor() {
        return WritePrivateProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileSectionA$handle() {
        return WritePrivateProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileSectionA$address() {
        return WritePrivateProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileSectionA(MemorySegment lpAppName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileSectionA", lpAppName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WritePrivateProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileSectionW$descriptor() {
        return WritePrivateProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileSectionW$handle() {
        return WritePrivateProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment WritePrivateProfileSectionW$address() {
        return WritePrivateProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileSectionW(MemorySegment lpAppName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileSectionW", lpAppName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionNamesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileSectionNamesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionNamesA$descriptor() {
        return GetPrivateProfileSectionNamesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionNamesA$handle() {
        return GetPrivateProfileSectionNamesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionNamesA$address() {
        return GetPrivateProfileSectionNamesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionNamesA(MemorySegment lpszReturnBuffer, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionNamesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionNamesA", lpszReturnBuffer, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpszReturnBuffer, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionNamesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileSectionNamesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionNamesW$descriptor() {
        return GetPrivateProfileSectionNamesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionNamesW$handle() {
        return GetPrivateProfileSectionNamesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileSectionNamesW$address() {
        return GetPrivateProfileSectionNamesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionNamesW(MemorySegment lpszReturnBuffer, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionNamesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionNamesW", lpszReturnBuffer, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpszReturnBuffer, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStructA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileStructA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStructA$descriptor() {
        return GetPrivateProfileStructA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MethodHandle GetPrivateProfileStructA$handle() {
        return GetPrivateProfileStructA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MemorySegment GetPrivateProfileStructA$address() {
        return GetPrivateProfileStructA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static int GetPrivateProfileStructA(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = GetPrivateProfileStructA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStructA", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStructW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileStructW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStructW$descriptor() {
        return GetPrivateProfileStructW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MethodHandle GetPrivateProfileStructW$handle() {
        return GetPrivateProfileStructW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MemorySegment GetPrivateProfileStructW$address() {
        return GetPrivateProfileStructW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static int GetPrivateProfileStructW(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = GetPrivateProfileStructW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStructW", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStructA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WritePrivateProfileStructA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStructA$descriptor() {
        return WritePrivateProfileStructA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MethodHandle WritePrivateProfileStructA$handle() {
        return WritePrivateProfileStructA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MemorySegment WritePrivateProfileStructA$address() {
        return WritePrivateProfileStructA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static int WritePrivateProfileStructA(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = WritePrivateProfileStructA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStructA", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStructW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WritePrivateProfileStructW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStructW$descriptor() {
        return WritePrivateProfileStructW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MethodHandle WritePrivateProfileStructW$handle() {
        return WritePrivateProfileStructW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MemorySegment WritePrivateProfileStructW$address() {
        return WritePrivateProfileStructW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static int WritePrivateProfileStructW(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = WritePrivateProfileStructW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStructW", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64EnableWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64EnableWow64FsRedirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static FunctionDescriptor Wow64EnableWow64FsRedirection$descriptor() {
        return Wow64EnableWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static MethodHandle Wow64EnableWow64FsRedirection$handle() {
        return Wow64EnableWow64FsRedirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static MemorySegment Wow64EnableWow64FsRedirection$address() {
        return Wow64EnableWow64FsRedirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static byte Wow64EnableWow64FsRedirection(byte Wow64FsEnableRedirection) {
        var mh$ = Wow64EnableWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64EnableWow64FsRedirection", Wow64FsEnableRedirection);
            }
            return (byte)mh$.invokeExact(Wow64FsEnableRedirection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDllDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDllDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetDllDirectoryA$descriptor() {
        return SetDllDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle SetDllDirectoryA$handle() {
        return SetDllDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MemorySegment SetDllDirectoryA$address() {
        return SetDllDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int SetDllDirectoryA(MemorySegment lpPathName) {
        var mh$ = SetDllDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDllDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDllDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDllDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetDllDirectoryW$descriptor() {
        return SetDllDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle SetDllDirectoryW$handle() {
        return SetDllDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment SetDllDirectoryW$address() {
        return SetDllDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int SetDllDirectoryW(MemorySegment lpPathName) {
        var mh$ = SetDllDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDllDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDllDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDllDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetDllDirectoryA$descriptor() {
        return GetDllDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetDllDirectoryA$handle() {
        return GetDllDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetDllDirectoryA$address() {
        return GetDllDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetDllDirectoryA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetDllDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDllDirectoryA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDllDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDllDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetDllDirectoryW$descriptor() {
        return GetDllDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetDllDirectoryW$handle() {
        return GetDllDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetDllDirectoryW$address() {
        return GetDllDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetDllDirectoryW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetDllDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDllDirectoryW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSearchPathMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSearchPathMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetSearchPathMode$descriptor() {
        return SetSearchPathMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static MethodHandle SetSearchPathMode$handle() {
        return SetSearchPathMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static MemorySegment SetSearchPathMode$address() {
        return SetSearchPathMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static int SetSearchPathMode(int Flags) {
        var mh$ = SetSearchPathMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSearchPathMode", Flags);
            }
            return (int)mh$.invokeExact(Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDirectoryExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryExA$descriptor() {
        return CreateDirectoryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryExA$handle() {
        return CreateDirectoryExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryExA$address() {
        return CreateDirectoryExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryExA(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryExA", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDirectoryExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryExW$descriptor() {
        return CreateDirectoryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryExW$handle() {
        return CreateDirectoryExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryExW$address() {
        return CreateDirectoryExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryExW(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryExW", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDirectoryTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateDirectoryTransactedA$descriptor() {
        return CreateDirectoryTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateDirectoryTransactedA$handle() {
        return CreateDirectoryTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateDirectoryTransactedA$address() {
        return CreateDirectoryTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateDirectoryTransactedA(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateDirectoryTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryTransactedA", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDirectoryTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateDirectoryTransactedW$descriptor() {
        return CreateDirectoryTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateDirectoryTransactedW$handle() {
        return CreateDirectoryTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateDirectoryTransactedW$address() {
        return CreateDirectoryTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateDirectoryTransactedW(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateDirectoryTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryTransactedW", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveDirectoryTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryTransactedA$descriptor() {
        return RemoveDirectoryTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle RemoveDirectoryTransactedA$handle() {
        return RemoveDirectoryTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment RemoveDirectoryTransactedA$address() {
        return RemoveDirectoryTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static int RemoveDirectoryTransactedA(MemorySegment lpPathName, MemorySegment hTransaction) {
        var mh$ = RemoveDirectoryTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryTransactedA", lpPathName, hTransaction);
            }
            return (int)mh$.invokeExact(lpPathName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveDirectoryTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryTransactedW$descriptor() {
        return RemoveDirectoryTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle RemoveDirectoryTransactedW$handle() {
        return RemoveDirectoryTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment RemoveDirectoryTransactedW$address() {
        return RemoveDirectoryTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static int RemoveDirectoryTransactedW(MemorySegment lpPathName, MemorySegment hTransaction) {
        var mh$ = RemoveDirectoryTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryTransactedW", lpPathName, hTransaction);
            }
            return (int)mh$.invokeExact(lpPathName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFullPathNameTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFullPathNameTransactedA$descriptor() {
        return GetFullPathNameTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFullPathNameTransactedA$handle() {
        return GetFullPathNameTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFullPathNameTransactedA$address() {
        return GetFullPathNameTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static int GetFullPathNameTransactedA(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart, MemorySegment hTransaction) {
        var mh$ = GetFullPathNameTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameTransactedA", lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFullPathNameTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFullPathNameTransactedW$descriptor() {
        return GetFullPathNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFullPathNameTransactedW$handle() {
        return GetFullPathNameTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFullPathNameTransactedW$address() {
        return GetFullPathNameTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static int GetFullPathNameTransactedW(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart, MemorySegment hTransaction) {
        var mh$ = GetFullPathNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameTransactedW", lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineDosDeviceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefineDosDeviceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static FunctionDescriptor DefineDosDeviceA$descriptor() {
        return DefineDosDeviceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static MethodHandle DefineDosDeviceA$handle() {
        return DefineDosDeviceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static MemorySegment DefineDosDeviceA$address() {
        return DefineDosDeviceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static int DefineDosDeviceA(int dwFlags, MemorySegment lpDeviceName, MemorySegment lpTargetPath) {
        var mh$ = DefineDosDeviceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineDosDeviceA", dwFlags, lpDeviceName, lpTargetPath);
            }
            return (int)mh$.invokeExact(dwFlags, lpDeviceName, lpTargetPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDosDeviceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryDosDeviceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static FunctionDescriptor QueryDosDeviceA$descriptor() {
        return QueryDosDeviceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MethodHandle QueryDosDeviceA$handle() {
        return QueryDosDeviceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MemorySegment QueryDosDeviceA$address() {
        return QueryDosDeviceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static int QueryDosDeviceA(MemorySegment lpDeviceName, MemorySegment lpTargetPath, int ucchMax) {
        var mh$ = QueryDosDeviceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDosDeviceA", lpDeviceName, lpTargetPath, ucchMax);
            }
            return (int)mh$.invokeExact(lpDeviceName, lpTargetPath, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static FunctionDescriptor CreateFileTransactedA$descriptor() {
        return CreateFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MethodHandle CreateFileTransactedA$handle() {
        return CreateFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedA$address() {
        return CreateFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile, MemorySegment hTransaction, MemorySegment pusMiniVersion, MemorySegment lpExtendedParameter) {
        var mh$ = CreateFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileTransactedA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static FunctionDescriptor CreateFileTransactedW$descriptor() {
        return CreateFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MethodHandle CreateFileTransactedW$handle() {
        return CreateFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedW$address() {
        return CreateFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile, MemorySegment hTransaction, MemorySegment pusMiniVersion, MemorySegment lpExtendedParameter) {
        var mh$ = CreateFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileTransactedW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReOpenFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReOpenFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor ReOpenFile$descriptor() {
        return ReOpenFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle ReOpenFile$handle() {
        return ReOpenFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment ReOpenFile$address() {
        return ReOpenFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment ReOpenFile(MemorySegment hOriginalFile, int dwDesiredAccess, int dwShareMode, int dwFlagsAndAttributes) {
        var mh$ = ReOpenFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReOpenFile", hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileAttributesTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor SetFileAttributesTransactedA$descriptor() {
        return SetFileAttributesTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle SetFileAttributesTransactedA$handle() {
        return SetFileAttributesTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment SetFileAttributesTransactedA$address() {
        return SetFileAttributesTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static int SetFileAttributesTransactedA(MemorySegment lpFileName, int dwFileAttributes, MemorySegment hTransaction) {
        var mh$ = SetFileAttributesTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesTransactedA", lpFileName, dwFileAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileAttributesTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor SetFileAttributesTransactedW$descriptor() {
        return SetFileAttributesTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle SetFileAttributesTransactedW$handle() {
        return SetFileAttributesTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment SetFileAttributesTransactedW$address() {
        return SetFileAttributesTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static int SetFileAttributesTransactedW(MemorySegment lpFileName, int dwFileAttributes, MemorySegment hTransaction) {
        var mh$ = SetFileAttributesTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesTransactedW", lpFileName, dwFileAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileAttributesTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFileAttributesTransactedA$descriptor() {
        return GetFileAttributesTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFileAttributesTransactedA$handle() {
        return GetFileAttributesTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFileAttributesTransactedA$address() {
        return GetFileAttributesTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static int GetFileAttributesTransactedA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation, MemorySegment hTransaction) {
        var mh$ = GetFileAttributesTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesTransactedA", lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileAttributesTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFileAttributesTransactedW$descriptor() {
        return GetFileAttributesTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFileAttributesTransactedW$handle() {
        return GetFileAttributesTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetFileAttributesTransactedW$address() {
        return GetFileAttributesTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static int GetFileAttributesTransactedW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation, MemorySegment hTransaction) {
        var mh$ = GetFileAttributesTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesTransactedW", lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCompressedFileSizeTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeTransactedA$descriptor() {
        return GetCompressedFileSizeTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetCompressedFileSizeTransactedA$handle() {
        return GetCompressedFileSizeTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetCompressedFileSizeTransactedA$address() {
        return GetCompressedFileSizeTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static int GetCompressedFileSizeTransactedA(MemorySegment lpFileName, MemorySegment lpFileSizeHigh, MemorySegment hTransaction) {
        var mh$ = GetCompressedFileSizeTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeTransactedA", lpFileName, lpFileSizeHigh, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCompressedFileSizeTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeTransactedW$descriptor() {
        return GetCompressedFileSizeTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetCompressedFileSizeTransactedW$handle() {
        return GetCompressedFileSizeTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetCompressedFileSizeTransactedW$address() {
        return GetCompressedFileSizeTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static int GetCompressedFileSizeTransactedW(MemorySegment lpFileName, MemorySegment lpFileSizeHigh, MemorySegment hTransaction) {
        var mh$ = GetCompressedFileSizeTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeTransactedW", lpFileName, lpFileSizeHigh, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor DeleteFileTransactedA$descriptor() {
        return DeleteFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle DeleteFileTransactedA$handle() {
        return DeleteFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment DeleteFileTransactedA$address() {
        return DeleteFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static int DeleteFileTransactedA(MemorySegment lpFileName, MemorySegment hTransaction) {
        var mh$ = DeleteFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileTransactedA", lpFileName, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor DeleteFileTransactedW$descriptor() {
        return DeleteFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle DeleteFileTransactedW$handle() {
        return DeleteFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment DeleteFileTransactedW$address() {
        return DeleteFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static int DeleteFileTransactedW(MemorySegment lpFileName, MemorySegment hTransaction) {
        var mh$ = DeleteFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileTransactedW", lpFileName, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckNameLegalDOS8Dot3A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckNameLegalDOS8Dot3A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static FunctionDescriptor CheckNameLegalDOS8Dot3A$descriptor() {
        return CheckNameLegalDOS8Dot3A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MethodHandle CheckNameLegalDOS8Dot3A$handle() {
        return CheckNameLegalDOS8Dot3A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MemorySegment CheckNameLegalDOS8Dot3A$address() {
        return CheckNameLegalDOS8Dot3A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static int CheckNameLegalDOS8Dot3A(MemorySegment lpName, MemorySegment lpOemName, int OemNameSize, MemorySegment pbNameContainsSpaces, MemorySegment pbNameLegal) {
        var mh$ = CheckNameLegalDOS8Dot3A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckNameLegalDOS8Dot3A", lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
            }
            return (int)mh$.invokeExact(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckNameLegalDOS8Dot3W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckNameLegalDOS8Dot3W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static FunctionDescriptor CheckNameLegalDOS8Dot3W$descriptor() {
        return CheckNameLegalDOS8Dot3W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MethodHandle CheckNameLegalDOS8Dot3W$handle() {
        return CheckNameLegalDOS8Dot3W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MemorySegment CheckNameLegalDOS8Dot3W$address() {
        return CheckNameLegalDOS8Dot3W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static int CheckNameLegalDOS8Dot3W(MemorySegment lpName, MemorySegment lpOemName, int OemNameSize, MemorySegment pbNameContainsSpaces, MemorySegment pbNameLegal) {
        var mh$ = CheckNameLegalDOS8Dot3W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckNameLegalDOS8Dot3W", lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
            }
            return (int)mh$.invokeExact(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileTransactedA$descriptor() {
        return FindFirstFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileTransactedA$handle() {
        return FindFirstFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedA$address() {
        return FindFirstFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileTransactedA", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileTransactedW$descriptor() {
        return FindFirstFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileTransactedW$handle() {
        return FindFirstFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedW$address() {
        return FindFirstFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileTransactedW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileA$descriptor() {
        return CopyFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileA$handle() {
        return CopyFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MemorySegment CopyFileA$address() {
        return CopyFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileA", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileW$descriptor() {
        return CopyFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileW$handle() {
        return CopyFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MemorySegment CopyFileW$address() {
        return CopyFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileW", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFileExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static FunctionDescriptor CopyFileExA$descriptor() {
        return CopyFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MethodHandle CopyFileExA$handle() {
        return CopyFileExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MemorySegment CopyFileExA$address() {
        return CopyFileExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static int CopyFileExA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags) {
        var mh$ = CopyFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileExA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFileExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static FunctionDescriptor CopyFileExW$descriptor() {
        return CopyFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MethodHandle CopyFileExW$handle() {
        return CopyFileExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MemorySegment CopyFileExW$address() {
        return CopyFileExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static int CopyFileExW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags) {
        var mh$ = CopyFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileExW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CopyFileTransactedA$descriptor() {
        return CopyFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CopyFileTransactedA$handle() {
        return CopyFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CopyFileTransactedA$address() {
        return CopyFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static int CopyFileTransactedA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags, MemorySegment hTransaction) {
        var mh$ = CopyFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileTransactedA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CopyFileTransactedW$descriptor() {
        return CopyFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CopyFileTransactedW$handle() {
        return CopyFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CopyFileTransactedW$address() {
        return CopyFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static int CopyFileTransactedW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags, MemorySegment hTransaction) {
        var mh$ = CopyFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileTransactedW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int COPYFILE2_CALLBACK_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_NONE = 0
     * }
     */
    public static int COPYFILE2_CALLBACK_NONE() {
        return COPYFILE2_CALLBACK_NONE;
    }
    private static final int COPYFILE2_CALLBACK_CHUNK_STARTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_STARTED = 1
     * }
     */
    public static int COPYFILE2_CALLBACK_CHUNK_STARTED() {
        return COPYFILE2_CALLBACK_CHUNK_STARTED;
    }
    private static final int COPYFILE2_CALLBACK_CHUNK_FINISHED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_FINISHED = 2
     * }
     */
    public static int COPYFILE2_CALLBACK_CHUNK_FINISHED() {
        return COPYFILE2_CALLBACK_CHUNK_FINISHED;
    }
    private static final int COPYFILE2_CALLBACK_STREAM_STARTED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_STARTED = 3
     * }
     */
    public static int COPYFILE2_CALLBACK_STREAM_STARTED() {
        return COPYFILE2_CALLBACK_STREAM_STARTED;
    }
    private static final int COPYFILE2_CALLBACK_STREAM_FINISHED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_FINISHED = 4
     * }
     */
    public static int COPYFILE2_CALLBACK_STREAM_FINISHED() {
        return COPYFILE2_CALLBACK_STREAM_FINISHED;
    }
    private static final int COPYFILE2_CALLBACK_POLL_CONTINUE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_POLL_CONTINUE = 5
     * }
     */
    public static int COPYFILE2_CALLBACK_POLL_CONTINUE() {
        return COPYFILE2_CALLBACK_POLL_CONTINUE;
    }
    private static final int COPYFILE2_CALLBACK_ERROR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_ERROR = 6
     * }
     */
    public static int COPYFILE2_CALLBACK_ERROR() {
        return COPYFILE2_CALLBACK_ERROR;
    }
    private static final int COPYFILE2_CALLBACK_MAX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_MAX = 7
     * }
     */
    public static int COPYFILE2_CALLBACK_MAX() {
        return COPYFILE2_CALLBACK_MAX;
    }
    private static final int COPYFILE2_PROGRESS_CONTINUE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CONTINUE = 0
     * }
     */
    public static int COPYFILE2_PROGRESS_CONTINUE() {
        return COPYFILE2_PROGRESS_CONTINUE;
    }
    private static final int COPYFILE2_PROGRESS_CANCEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CANCEL = 1
     * }
     */
    public static int COPYFILE2_PROGRESS_CANCEL() {
        return COPYFILE2_PROGRESS_CANCEL;
    }
    private static final int COPYFILE2_PROGRESS_STOP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_STOP = 2
     * }
     */
    public static int COPYFILE2_PROGRESS_STOP() {
        return COPYFILE2_PROGRESS_STOP;
    }
    private static final int COPYFILE2_PROGRESS_QUIET = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_QUIET = 3
     * }
     */
    public static int COPYFILE2_PROGRESS_QUIET() {
        return COPYFILE2_PROGRESS_QUIET;
    }
    private static final int COPYFILE2_PROGRESS_PAUSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_PAUSE = 4
     * }
     */
    public static int COPYFILE2_PROGRESS_PAUSE() {
        return COPYFILE2_PROGRESS_PAUSE;
    }
    private static final int COPYFILE2_PHASE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NONE = 0
     * }
     */
    public static int COPYFILE2_PHASE_NONE() {
        return COPYFILE2_PHASE_NONE;
    }
    private static final int COPYFILE2_PHASE_PREPARE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_SOURCE = 1
     * }
     */
    public static int COPYFILE2_PHASE_PREPARE_SOURCE() {
        return COPYFILE2_PHASE_PREPARE_SOURCE;
    }
    private static final int COPYFILE2_PHASE_PREPARE_DEST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_DEST = 2
     * }
     */
    public static int COPYFILE2_PHASE_PREPARE_DEST() {
        return COPYFILE2_PHASE_PREPARE_DEST;
    }
    private static final int COPYFILE2_PHASE_READ_SOURCE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_READ_SOURCE = 3
     * }
     */
    public static int COPYFILE2_PHASE_READ_SOURCE() {
        return COPYFILE2_PHASE_READ_SOURCE;
    }
    private static final int COPYFILE2_PHASE_WRITE_DESTINATION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_WRITE_DESTINATION = 4
     * }
     */
    public static int COPYFILE2_PHASE_WRITE_DESTINATION() {
        return COPYFILE2_PHASE_WRITE_DESTINATION;
    }
    private static final int COPYFILE2_PHASE_SERVER_COPY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_SERVER_COPY = 5
     * }
     */
    public static int COPYFILE2_PHASE_SERVER_COPY() {
        return COPYFILE2_PHASE_SERVER_COPY;
    }
    private static final int COPYFILE2_PHASE_NAMEGRAFT_COPY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NAMEGRAFT_COPY = 6
     * }
     */
    public static int COPYFILE2_PHASE_NAMEGRAFT_COPY() {
        return COPYFILE2_PHASE_NAMEGRAFT_COPY;
    }
    private static final int COPYFILE2_PHASE_MAX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_MAX = 7
     * }
     */
    public static int COPYFILE2_PHASE_MAX() {
        return COPYFILE2_PHASE_MAX;
    }

    private static class CopyFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFile2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static FunctionDescriptor CopyFile2$descriptor() {
        return CopyFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static MethodHandle CopyFile2$handle() {
        return CopyFile2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static MemorySegment CopyFile2$address() {
        return CopyFile2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static int CopyFile2(MemorySegment pwszExistingFileName, MemorySegment pwszNewFileName, MemorySegment pExtendedParameters) {
        var mh$ = CopyFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFile2", pwszExistingFileName, pwszNewFileName, pExtendedParameters);
            }
            return (int)mh$.invokeExact(pwszExistingFileName, pwszNewFileName, pExtendedParameters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileA$descriptor() {
        return MoveFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileA$handle() {
        return MoveFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static MemorySegment MoveFileA$address() {
        return MoveFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static int MoveFileA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileA", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileW$descriptor() {
        return MoveFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileW$handle() {
        return MoveFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MemorySegment MoveFileW$address() {
        return MoveFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static int MoveFileW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileW", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileExA$descriptor() {
        return MoveFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileExA$handle() {
        return MoveFileExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileExA$address() {
        return MoveFileExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static int MoveFileExA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int dwFlags) {
        var mh$ = MoveFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileExA", lpExistingFileName, lpNewFileName, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileExW$descriptor() {
        return MoveFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileExW$handle() {
        return MoveFileExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileExW$address() {
        return MoveFileExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static int MoveFileExW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int dwFlags) {
        var mh$ = MoveFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileExW", lpExistingFileName, lpNewFileName, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileWithProgressA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileWithProgressA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileWithProgressA$descriptor() {
        return MoveFileWithProgressA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileWithProgressA$handle() {
        return MoveFileWithProgressA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileWithProgressA$address() {
        return MoveFileWithProgressA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static int MoveFileWithProgressA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags) {
        var mh$ = MoveFileWithProgressA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileWithProgressA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileWithProgressW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileWithProgressW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileWithProgressW$descriptor() {
        return MoveFileWithProgressW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileWithProgressW$handle() {
        return MoveFileWithProgressW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MemorySegment MoveFileWithProgressW$address() {
        return MoveFileWithProgressW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static int MoveFileWithProgressW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags) {
        var mh$ = MoveFileWithProgressW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileWithProgressW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor MoveFileTransactedA$descriptor() {
        return MoveFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle MoveFileTransactedA$handle() {
        return MoveFileTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment MoveFileTransactedA$address() {
        return MoveFileTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static int MoveFileTransactedA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = MoveFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileTransactedA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor MoveFileTransactedW$descriptor() {
        return MoveFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle MoveFileTransactedW$handle() {
        return MoveFileTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment MoveFileTransactedW$address() {
        return MoveFileTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static int MoveFileTransactedW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = MoveFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileTransactedW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReplaceFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileA$descriptor() {
        return ReplaceFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileA$handle() {
        return ReplaceFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MemorySegment ReplaceFileA$address() {
        return ReplaceFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileA(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileA", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReplaceFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileW$descriptor() {
        return ReplaceFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileW$handle() {
        return ReplaceFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MemorySegment ReplaceFileW$address() {
        return ReplaceFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileW(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileW", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateHardLinkA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateHardLinkA$descriptor() {
        return CreateHardLinkA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateHardLinkA$handle() {
        return CreateHardLinkA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateHardLinkA$address() {
        return CreateHardLinkA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateHardLinkA(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateHardLinkA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkA", lpFileName, lpExistingFileName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateHardLinkW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateHardLinkW$descriptor() {
        return CreateHardLinkW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateHardLinkW$handle() {
        return CreateHardLinkW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateHardLinkW$address() {
        return CreateHardLinkW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateHardLinkW(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateHardLinkW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkW", lpFileName, lpExistingFileName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateHardLinkTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateHardLinkTransactedA$descriptor() {
        return CreateHardLinkTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateHardLinkTransactedA$handle() {
        return CreateHardLinkTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateHardLinkTransactedA$address() {
        return CreateHardLinkTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateHardLinkTransactedA(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateHardLinkTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkTransactedA", lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateHardLinkTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateHardLinkTransactedW$descriptor() {
        return CreateHardLinkTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateHardLinkTransactedW$handle() {
        return CreateHardLinkTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateHardLinkTransactedW$address() {
        return CreateHardLinkTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateHardLinkTransactedW(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateHardLinkTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkTransactedW", lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstStreamTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstStreamTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstStreamTransactedW$descriptor() {
        return FindFirstStreamTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstStreamTransactedW$handle() {
        return FindFirstStreamTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstStreamTransactedW$address() {
        return FindFirstStreamTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstStreamTransactedW(MemorySegment lpFileName, int InfoLevel, MemorySegment lpFindStreamData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstStreamTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstStreamTransactedW", lpFileName, InfoLevel, lpFindStreamData, dwFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, InfoLevel, lpFindStreamData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstFileNameTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileNameTransactedW$descriptor() {
        return FindFirstFileNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileNameTransactedW$handle() {
        return FindFirstFileNameTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileNameTransactedW$address() {
        return FindFirstFileNameTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileNameTransactedW(MemorySegment lpFileName, int dwFlags, MemorySegment StringLength, MemorySegment LinkName, MemorySegment hTransaction) {
        var mh$ = FindFirstFileNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileNameTransactedW", lpFileName, dwFlags, StringLength, LinkName, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwFlags, StringLength, LinkName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateNamedPipeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateNamedPipeA$descriptor() {
        return CreateNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateNamedPipeA$handle() {
        return CreateNamedPipeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeA$address() {
        return CreateNamedPipeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeA(MemorySegment lpName, int dwOpenMode, int dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateNamedPipeA", lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeHandleStateA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeHandleStateA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static FunctionDescriptor GetNamedPipeHandleStateA$descriptor() {
        return GetNamedPipeHandleStateA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MethodHandle GetNamedPipeHandleStateA$handle() {
        return GetNamedPipeHandleStateA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MemorySegment GetNamedPipeHandleStateA$address() {
        return GetNamedPipeHandleStateA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static int GetNamedPipeHandleStateA(MemorySegment hNamedPipe, MemorySegment lpState, MemorySegment lpCurInstances, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout, MemorySegment lpUserName, int nMaxUserNameSize) {
        var mh$ = GetNamedPipeHandleStateA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeHandleStateA", hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallNamedPipeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor CallNamedPipeA$descriptor() {
        return CallNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MethodHandle CallNamedPipeA$handle() {
        return CallNamedPipeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MemorySegment CallNamedPipeA$address() {
        return CallNamedPipeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static int CallNamedPipeA(MemorySegment lpNamedPipeName, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, int nTimeOut) {
        var mh$ = CallNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNamedPipeA", lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitNamedPipeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor WaitNamedPipeA$descriptor() {
        return WaitNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MethodHandle WaitNamedPipeA$handle() {
        return WaitNamedPipeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MemorySegment WaitNamedPipeA$address() {
        return WaitNamedPipeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static int WaitNamedPipeA(MemorySegment lpNamedPipeName, int nTimeOut) {
        var mh$ = WaitNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitNamedPipeA", lpNamedPipeName, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeClientComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientComputerNameA$descriptor() {
        return GetNamedPipeClientComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MethodHandle GetNamedPipeClientComputerNameA$handle() {
        return GetNamedPipeClientComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MemorySegment GetNamedPipeClientComputerNameA$address() {
        return GetNamedPipeClientComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static int GetNamedPipeClientComputerNameA(MemorySegment Pipe, MemorySegment ClientComputerName, int ClientComputerNameLength) {
        var mh$ = GetNamedPipeClientComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientComputerNameA", Pipe, ClientComputerName, ClientComputerNameLength);
            }
            return (int)mh$.invokeExact(Pipe, ClientComputerName, ClientComputerNameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeClientProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientProcessId$descriptor() {
        return GetNamedPipeClientProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static MethodHandle GetNamedPipeClientProcessId$handle() {
        return GetNamedPipeClientProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static MemorySegment GetNamedPipeClientProcessId$address() {
        return GetNamedPipeClientProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static int GetNamedPipeClientProcessId(MemorySegment Pipe, MemorySegment ClientProcessId) {
        var mh$ = GetNamedPipeClientProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientProcessId", Pipe, ClientProcessId);
            }
            return (int)mh$.invokeExact(Pipe, ClientProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeClientSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientSessionId$descriptor() {
        return GetNamedPipeClientSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static MethodHandle GetNamedPipeClientSessionId$handle() {
        return GetNamedPipeClientSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static MemorySegment GetNamedPipeClientSessionId$address() {
        return GetNamedPipeClientSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static int GetNamedPipeClientSessionId(MemorySegment Pipe, MemorySegment ClientSessionId) {
        var mh$ = GetNamedPipeClientSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientSessionId", Pipe, ClientSessionId);
            }
            return (int)mh$.invokeExact(Pipe, ClientSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeServerProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeServerProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeServerProcessId$descriptor() {
        return GetNamedPipeServerProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static MethodHandle GetNamedPipeServerProcessId$handle() {
        return GetNamedPipeServerProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static MemorySegment GetNamedPipeServerProcessId$address() {
        return GetNamedPipeServerProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static int GetNamedPipeServerProcessId(MemorySegment Pipe, MemorySegment ServerProcessId) {
        var mh$ = GetNamedPipeServerProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeServerProcessId", Pipe, ServerProcessId);
            }
            return (int)mh$.invokeExact(Pipe, ServerProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeServerSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeServerSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeServerSessionId$descriptor() {
        return GetNamedPipeServerSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static MethodHandle GetNamedPipeServerSessionId$handle() {
        return GetNamedPipeServerSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static MemorySegment GetNamedPipeServerSessionId$address() {
        return GetNamedPipeServerSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static int GetNamedPipeServerSessionId(MemorySegment Pipe, MemorySegment ServerSessionId) {
        var mh$ = GetNamedPipeServerSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeServerSessionId", Pipe, ServerSessionId);
            }
            return (int)mh$.invokeExact(Pipe, ServerSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeLabelA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetVolumeLabelA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeLabelA$descriptor() {
        return SetVolumeLabelA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static MethodHandle SetVolumeLabelA$handle() {
        return SetVolumeLabelA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static MemorySegment SetVolumeLabelA$address() {
        return SetVolumeLabelA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static int SetVolumeLabelA(MemorySegment lpRootPathName, MemorySegment lpVolumeName) {
        var mh$ = SetVolumeLabelA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeLabelA", lpRootPathName, lpVolumeName);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeLabelW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetVolumeLabelW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeLabelW$descriptor() {
        return SetVolumeLabelW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static MethodHandle SetVolumeLabelW$handle() {
        return SetVolumeLabelW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static MemorySegment SetVolumeLabelW$address() {
        return SetVolumeLabelW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static int SetVolumeLabelW(MemorySegment lpRootPathName, MemorySegment lpVolumeName) {
        var mh$ = SetVolumeLabelW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeLabelW", lpRootPathName, lpVolumeName);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileBandwidthReservation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileBandwidthReservation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static FunctionDescriptor SetFileBandwidthReservation$descriptor() {
        return SetFileBandwidthReservation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MethodHandle SetFileBandwidthReservation$handle() {
        return SetFileBandwidthReservation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MemorySegment SetFileBandwidthReservation$address() {
        return SetFileBandwidthReservation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static int SetFileBandwidthReservation(MemorySegment hFile, int nPeriodMilliseconds, int nBytesPerPeriod, int bDiscardable, MemorySegment lpTransferSize, MemorySegment lpNumOutstandingRequests) {
        var mh$ = SetFileBandwidthReservation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileBandwidthReservation", hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests);
            }
            return (int)mh$.invokeExact(hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileBandwidthReservation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileBandwidthReservation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static FunctionDescriptor GetFileBandwidthReservation$descriptor() {
        return GetFileBandwidthReservation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MethodHandle GetFileBandwidthReservation$handle() {
        return GetFileBandwidthReservation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MemorySegment GetFileBandwidthReservation$address() {
        return GetFileBandwidthReservation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static int GetFileBandwidthReservation(MemorySegment hFile, MemorySegment lpPeriodMilliseconds, MemorySegment lpBytesPerPeriod, MemorySegment pDiscardable, MemorySegment lpTransferSize, MemorySegment lpNumOutstandingRequests) {
        var mh$ = GetFileBandwidthReservation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileBandwidthReservation", hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests);
            }
            return (int)mh$.invokeExact(hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClearEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor ClearEventLogA$descriptor() {
        return ClearEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MethodHandle ClearEventLogA$handle() {
        return ClearEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MemorySegment ClearEventLogA$address() {
        return ClearEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static int ClearEventLogA(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = ClearEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearEventLogA", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClearEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor ClearEventLogW$descriptor() {
        return ClearEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MethodHandle ClearEventLogW$handle() {
        return ClearEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MemorySegment ClearEventLogW$address() {
        return ClearEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static int ClearEventLogW(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = ClearEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearEventLogW", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BackupEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor BackupEventLogA$descriptor() {
        return BackupEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MethodHandle BackupEventLogA$handle() {
        return BackupEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MemorySegment BackupEventLogA$address() {
        return BackupEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static int BackupEventLogA(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = BackupEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupEventLogA", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BackupEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor BackupEventLogW$descriptor() {
        return BackupEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MethodHandle BackupEventLogW$handle() {
        return BackupEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MemorySegment BackupEventLogW$address() {
        return BackupEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static int BackupEventLogW(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = BackupEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupEventLogW", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEventLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseEventLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static FunctionDescriptor CloseEventLog$descriptor() {
        return CloseEventLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static MethodHandle CloseEventLog$handle() {
        return CloseEventLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static MemorySegment CloseEventLog$address() {
        return CloseEventLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static int CloseEventLog(MemorySegment hEventLog) {
        var mh$ = CloseEventLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEventLog", hEventLog);
            }
            return (int)mh$.invokeExact(hEventLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeregisterEventSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeregisterEventSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static FunctionDescriptor DeregisterEventSource$descriptor() {
        return DeregisterEventSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static MethodHandle DeregisterEventSource$handle() {
        return DeregisterEventSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static MemorySegment DeregisterEventSource$address() {
        return DeregisterEventSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static int DeregisterEventSource(MemorySegment hEventLog) {
        var mh$ = DeregisterEventSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeregisterEventSource", hEventLog);
            }
            return (int)mh$.invokeExact(hEventLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyChangeEventLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("NotifyChangeEventLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor NotifyChangeEventLog$descriptor() {
        return NotifyChangeEventLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static MethodHandle NotifyChangeEventLog$handle() {
        return NotifyChangeEventLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static MemorySegment NotifyChangeEventLog$address() {
        return NotifyChangeEventLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static int NotifyChangeEventLog(MemorySegment hEventLog, MemorySegment hEvent) {
        var mh$ = NotifyChangeEventLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyChangeEventLog", hEventLog, hEvent);
            }
            return (int)mh$.invokeExact(hEventLog, hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfEventLogRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumberOfEventLogRecords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static FunctionDescriptor GetNumberOfEventLogRecords$descriptor() {
        return GetNumberOfEventLogRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static MethodHandle GetNumberOfEventLogRecords$handle() {
        return GetNumberOfEventLogRecords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static MemorySegment GetNumberOfEventLogRecords$address() {
        return GetNumberOfEventLogRecords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static int GetNumberOfEventLogRecords(MemorySegment hEventLog, MemorySegment NumberOfRecords) {
        var mh$ = GetNumberOfEventLogRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfEventLogRecords", hEventLog, NumberOfRecords);
            }
            return (int)mh$.invokeExact(hEventLog, NumberOfRecords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOldestEventLogRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOldestEventLogRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static FunctionDescriptor GetOldestEventLogRecord$descriptor() {
        return GetOldestEventLogRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static MethodHandle GetOldestEventLogRecord$handle() {
        return GetOldestEventLogRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static MemorySegment GetOldestEventLogRecord$address() {
        return GetOldestEventLogRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static int GetOldestEventLogRecord(MemorySegment hEventLog, MemorySegment OldestRecord) {
        var mh$ = GetOldestEventLogRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOldestEventLogRecord", hEventLog, OldestRecord);
            }
            return (int)mh$.invokeExact(hEventLog, OldestRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor OpenEventLogA$descriptor() {
        return OpenEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MethodHandle OpenEventLogA$handle() {
        return OpenEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogA$address() {
        return OpenEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogA(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = OpenEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventLogA", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor OpenEventLogW$descriptor() {
        return OpenEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MethodHandle OpenEventLogW$handle() {
        return OpenEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogW$address() {
        return OpenEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogW(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = OpenEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventLogW", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterEventSourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterEventSourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor RegisterEventSourceA$descriptor() {
        return RegisterEventSourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MethodHandle RegisterEventSourceA$handle() {
        return RegisterEventSourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceA$address() {
        return RegisterEventSourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceA(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = RegisterEventSourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterEventSourceA", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterEventSourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterEventSourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor RegisterEventSourceW$descriptor() {
        return RegisterEventSourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MethodHandle RegisterEventSourceW$handle() {
        return RegisterEventSourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceW$address() {
        return RegisterEventSourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceW(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = RegisterEventSourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterEventSourceW", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenBackupEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenBackupEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor OpenBackupEventLogA$descriptor() {
        return OpenBackupEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle OpenBackupEventLogA$handle() {
        return OpenBackupEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogA$address() {
        return OpenBackupEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogA(MemorySegment lpUNCServerName, MemorySegment lpFileName) {
        var mh$ = OpenBackupEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenBackupEventLogA", lpUNCServerName, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenBackupEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenBackupEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor OpenBackupEventLogW$descriptor() {
        return OpenBackupEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle OpenBackupEventLogW$handle() {
        return OpenBackupEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogW$address() {
        return OpenBackupEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogW(MemorySegment lpUNCServerName, MemorySegment lpFileName) {
        var mh$ = OpenBackupEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenBackupEventLogW", lpUNCServerName, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadEventLogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static FunctionDescriptor ReadEventLogA$descriptor() {
        return ReadEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MethodHandle ReadEventLogA$handle() {
        return ReadEventLogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MemorySegment ReadEventLogA$address() {
        return ReadEventLogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static int ReadEventLogA(MemorySegment hEventLog, int dwReadFlags, int dwRecordOffset, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment pnBytesRead, MemorySegment pnMinNumberOfBytesNeeded) {
        var mh$ = ReadEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEventLogA", hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadEventLogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static FunctionDescriptor ReadEventLogW$descriptor() {
        return ReadEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MethodHandle ReadEventLogW$handle() {
        return ReadEventLogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MemorySegment ReadEventLogW$address() {
        return ReadEventLogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static int ReadEventLogW(MemorySegment hEventLog, int dwReadFlags, int dwRecordOffset, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment pnBytesRead, MemorySegment pnMinNumberOfBytesNeeded) {
        var mh$ = ReadEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEventLogW", hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReportEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReportEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static FunctionDescriptor ReportEventA$descriptor() {
        return ReportEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MethodHandle ReportEventA$handle() {
        return ReportEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MemorySegment ReportEventA$address() {
        return ReportEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static int ReportEventA(MemorySegment hEventLog, short wType, short wCategory, int dwEventID, MemorySegment lpUserSid, short wNumStrings, int dwDataSize, MemorySegment lpStrings, MemorySegment lpRawData) {
        var mh$ = ReportEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReportEventA", hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
            }
            return (int)mh$.invokeExact(hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReportEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReportEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static FunctionDescriptor ReportEventW$descriptor() {
        return ReportEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MethodHandle ReportEventW$handle() {
        return ReportEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MemorySegment ReportEventW$address() {
        return ReportEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static int ReportEventW(MemorySegment hEventLog, short wType, short wCategory, int dwEventID, MemorySegment lpUserSid, short wNumStrings, int dwDataSize, MemorySegment lpStrings, MemorySegment lpRawData) {
        var mh$ = ReportEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReportEventW", hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
            }
            return (int)mh$.invokeExact(hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _EVENTLOG_FULL_INFORMATION {
     *     DWORD dwFull;
     * } *LPEVENTLOG_FULL_INFORMATION
     * }
     */
    public static final AddressLayout LPEVENTLOG_FULL_INFORMATION = freeglut_h.C_POINTER;

    private static class GetEventLogInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEventLogInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor GetEventLogInformation$descriptor() {
        return GetEventLogInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle GetEventLogInformation$handle() {
        return GetEventLogInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment GetEventLogInformation$address() {
        return GetEventLogInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int GetEventLogInformation(MemorySegment hEventLog, int dwInfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = GetEventLogInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEventLogInformation", hEventLog, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ULONG OPERATION_ID
     * }
     */
    public static final OfInt OPERATION_ID = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _OPERATION_START_PARAMETERS {
     *     ULONG Version;
     *     OPERATION_ID OperationId;
     *     ULONG Flags;
     * } *POPERATION_START_PARAMETERS
     * }
     */
    public static final AddressLayout POPERATION_START_PARAMETERS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OPERATION_END_PARAMETERS {
     *     ULONG Version;
     *     OPERATION_ID OperationId;
     *     ULONG Flags;
     * } *POPERATION_END_PARAMETERS
     * }
     */
    public static final AddressLayout POPERATION_END_PARAMETERS = freeglut_h.C_POINTER;

    private static class OperationStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OperationStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static FunctionDescriptor OperationStart$descriptor() {
        return OperationStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static MethodHandle OperationStart$handle() {
        return OperationStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static MemorySegment OperationStart$address() {
        return OperationStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static int OperationStart(MemorySegment OperationStartParams) {
        var mh$ = OperationStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OperationStart", OperationStartParams);
            }
            return (int)mh$.invokeExact(OperationStartParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OperationEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OperationEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static FunctionDescriptor OperationEnd$descriptor() {
        return OperationEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static MethodHandle OperationEnd$handle() {
        return OperationEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static MemorySegment OperationEnd$address() {
        return OperationEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static int OperationEnd(MemorySegment OperationEndParams) {
        var mh$ = OperationEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OperationEnd", OperationEndParams);
            }
            return (int)mh$.invokeExact(OperationEndParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckAndAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckAndAuditAlarmA$descriptor() {
        return AccessCheckAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckAndAuditAlarmA$handle() {
        return AccessCheckAndAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckAndAuditAlarmA$address() {
        return AccessCheckAndAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, int DesiredAccess, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByTypeAndAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeAndAuditAlarmA$descriptor() {
        return AccessCheckByTypeAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeAndAuditAlarmA$handle() {
        return AccessCheckByTypeAndAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeAndAuditAlarmA$address() {
        return AccessCheckByTypeAndAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmA$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmA$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmA$address() {
        return AccessCheckByTypeResultListAndAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmByHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmByHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmByHandleA$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmByHandleA$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmByHandleA$address() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmByHandleA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmByHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmByHandleA", SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectOpenAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectOpenAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectOpenAuditAlarmA$descriptor() {
        return ObjectOpenAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectOpenAuditAlarmA$handle() {
        return ObjectOpenAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectOpenAuditAlarmA$address() {
        return ObjectOpenAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static int ObjectOpenAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, int GrantedAccess, MemorySegment Privileges, int ObjectCreation, int AccessGranted, MemorySegment GenerateOnClose) {
        var mh$ = ObjectOpenAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectOpenAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectPrivilegeAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectPrivilegeAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor ObjectPrivilegeAuditAlarmA$descriptor() {
        return ObjectPrivilegeAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle ObjectPrivilegeAuditAlarmA$handle() {
        return ObjectPrivilegeAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment ObjectPrivilegeAuditAlarmA$address() {
        return ObjectPrivilegeAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int ObjectPrivilegeAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, int DesiredAccess, MemorySegment Privileges, int AccessGranted) {
        var mh$ = ObjectPrivilegeAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectPrivilegeAuditAlarmA", SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCloseAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectCloseAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectCloseAuditAlarmA$descriptor() {
        return ObjectCloseAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectCloseAuditAlarmA$handle() {
        return ObjectCloseAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectCloseAuditAlarmA$address() {
        return ObjectCloseAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectCloseAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectCloseAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCloseAuditAlarmA", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectDeleteAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectDeleteAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectDeleteAuditAlarmA$descriptor() {
        return ObjectDeleteAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectDeleteAuditAlarmA$handle() {
        return ObjectDeleteAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectDeleteAuditAlarmA$address() {
        return ObjectDeleteAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectDeleteAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectDeleteAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectDeleteAuditAlarmA", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegedServiceAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrivilegedServiceAuditAlarmA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor PrivilegedServiceAuditAlarmA$descriptor() {
        return PrivilegedServiceAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle PrivilegedServiceAuditAlarmA$handle() {
        return PrivilegedServiceAuditAlarmA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment PrivilegedServiceAuditAlarmA$address() {
        return PrivilegedServiceAuditAlarmA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int PrivilegedServiceAuditAlarmA(MemorySegment SubsystemName, MemorySegment ServiceName, MemorySegment ClientToken, MemorySegment Privileges, int AccessGranted) {
        var mh$ = PrivilegedServiceAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegedServiceAuditAlarmA", SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConditionalAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_CHAR,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddConditionalAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static FunctionDescriptor AddConditionalAce$descriptor() {
        return AddConditionalAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static MethodHandle AddConditionalAce$handle() {
        return AddConditionalAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static MemorySegment AddConditionalAce$address() {
        return AddConditionalAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static int AddConditionalAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, byte AceType, int AccessMask, MemorySegment pSid, MemorySegment ConditionStr, MemorySegment ReturnLength) {
        var mh$ = AddConditionalAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConditionalAce", pAcl, dwAceRevision, AceFlags, AceType, AccessMask, pSid, ConditionStr, ReturnLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AceType, AccessMask, pSid, ConditionStr, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileSecurityA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileSecurityA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetFileSecurityA$descriptor() {
        return SetFileSecurityA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle SetFileSecurityA$handle() {
        return SetFileSecurityA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment SetFileSecurityA$address() {
        return SetFileSecurityA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int SetFileSecurityA(MemorySegment lpFileName, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = SetFileSecurityA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileSecurityA", lpFileName, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(lpFileName, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSecurityA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileSecurityA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetFileSecurityA$descriptor() {
        return GetFileSecurityA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetFileSecurityA$handle() {
        return GetFileSecurityA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetFileSecurityA$address() {
        return GetFileSecurityA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetFileSecurityA(MemorySegment lpFileName, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetFileSecurityA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSecurityA", lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadDirectoryChangesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadDirectoryChangesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor ReadDirectoryChangesW$descriptor() {
        return ReadDirectoryChangesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle ReadDirectoryChangesW$handle() {
        return ReadDirectoryChangesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment ReadDirectoryChangesW$address() {
        return ReadDirectoryChangesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int ReadDirectoryChangesW(MemorySegment hDirectory, MemorySegment lpBuffer, int nBufferLength, int bWatchSubtree, int dwNotifyFilter, MemorySegment lpBytesReturned, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = ReadDirectoryChangesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadDirectoryChangesW", hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadDirectoryChangesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadDirectoryChangesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static FunctionDescriptor ReadDirectoryChangesExW$descriptor() {
        return ReadDirectoryChangesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static MethodHandle ReadDirectoryChangesExW$handle() {
        return ReadDirectoryChangesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static MemorySegment ReadDirectoryChangesExW$address() {
        return ReadDirectoryChangesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static int ReadDirectoryChangesExW(MemorySegment hDirectory, MemorySegment lpBuffer, int nBufferLength, int bWatchSubtree, int dwNotifyFilter, MemorySegment lpBytesReturned, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine, int ReadDirectoryNotifyInformationClass) {
        var mh$ = ReadDirectoryChangesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadDirectoryChangesExW", hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass);
            }
            return (int)mh$.invokeExact(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileExNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapViewOfFileExNuma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor MapViewOfFileExNuma$descriptor() {
        return MapViewOfFileExNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MethodHandle MapViewOfFileExNuma$handle() {
        return MapViewOfFileExNuma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MemorySegment MapViewOfFileExNuma$address() {
        return MapViewOfFileExNuma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MemorySegment MapViewOfFileExNuma(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap, MemorySegment lpBaseAddress, int nndPreferred) {
        var mh$ = MapViewOfFileExNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileExNuma", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadReadPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsBadReadPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadReadPtr$descriptor() {
        return IsBadReadPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadReadPtr$handle() {
        return IsBadReadPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadReadPtr$address() {
        return IsBadReadPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadReadPtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadReadPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadReadPtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadWritePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsBadWritePtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadWritePtr$descriptor() {
        return IsBadWritePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadWritePtr$handle() {
        return IsBadWritePtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadWritePtr$address() {
        return IsBadWritePtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadWritePtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadWritePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadWritePtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadHugeReadPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsBadHugeReadPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadHugeReadPtr$descriptor() {
        return IsBadHugeReadPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadHugeReadPtr$handle() {
        return IsBadHugeReadPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadHugeReadPtr$address() {
        return IsBadHugeReadPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadHugeReadPtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadHugeReadPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadHugeReadPtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadHugeWritePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsBadHugeWritePtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadHugeWritePtr$descriptor() {
        return IsBadHugeWritePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadHugeWritePtr$handle() {
        return IsBadHugeWritePtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MemorySegment IsBadHugeWritePtr$address() {
        return IsBadHugeWritePtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadHugeWritePtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadHugeWritePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadHugeWritePtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadCodePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsBadCodePtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static FunctionDescriptor IsBadCodePtr$descriptor() {
        return IsBadCodePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static MethodHandle IsBadCodePtr$handle() {
        return IsBadCodePtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static MemorySegment IsBadCodePtr$address() {
        return IsBadCodePtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static int IsBadCodePtr(MemorySegment lpfn) {
        var mh$ = IsBadCodePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadCodePtr", lpfn);
            }
            return (int)mh$.invokeExact(lpfn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadStringPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsBadStringPtrA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static FunctionDescriptor IsBadStringPtrA$descriptor() {
        return IsBadStringPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MethodHandle IsBadStringPtrA$handle() {
        return IsBadStringPtrA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MemorySegment IsBadStringPtrA$address() {
        return IsBadStringPtrA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static int IsBadStringPtrA(MemorySegment lpsz, long ucchMax) {
        var mh$ = IsBadStringPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadStringPtrA", lpsz, ucchMax);
            }
            return (int)mh$.invokeExact(lpsz, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadStringPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsBadStringPtrW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static FunctionDescriptor IsBadStringPtrW$descriptor() {
        return IsBadStringPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MethodHandle IsBadStringPtrW$handle() {
        return IsBadStringPtrW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MemorySegment IsBadStringPtrW$address() {
        return IsBadStringPtrW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static int IsBadStringPtrW(MemorySegment lpsz, long ucchMax) {
        var mh$ = IsBadStringPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadStringPtrW", lpsz, ucchMax);
            }
            return (int)mh$.invokeExact(lpsz, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountSidA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidA$descriptor() {
        return LookupAccountSidA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidA$handle() {
        return LookupAccountSidA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidA$address() {
        return LookupAccountSidA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidA(MemorySegment lpSystemName, MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidA", lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountSidW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidW$descriptor() {
        return LookupAccountSidW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidW$handle() {
        return LookupAccountSidW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidW$address() {
        return LookupAccountSidW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidW(MemorySegment lpSystemName, MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidW", lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameA$descriptor() {
        return LookupAccountNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameA$handle() {
        return LookupAccountNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameA$address() {
        return LookupAccountNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameA(MemorySegment lpSystemName, MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameA", lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameW$descriptor() {
        return LookupAccountNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameW$handle() {
        return LookupAccountNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameW$address() {
        return LookupAccountNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameW(MemorySegment lpSystemName, MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameW", lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameLocalA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountNameLocalA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameLocalA$descriptor() {
        return LookupAccountNameLocalA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameLocalA$handle() {
        return LookupAccountNameLocalA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameLocalA$address() {
        return LookupAccountNameLocalA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameLocalA(MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameLocalA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameLocalA", lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameLocalW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountNameLocalW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameLocalW$descriptor() {
        return LookupAccountNameLocalW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameLocalW$handle() {
        return LookupAccountNameLocalW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountNameLocalW$address() {
        return LookupAccountNameLocalW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameLocalW(MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameLocalW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameLocalW", lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidLocalA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountSidLocalA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidLocalA$descriptor() {
        return LookupAccountSidLocalA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidLocalA$handle() {
        return LookupAccountSidLocalA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidLocalA$address() {
        return LookupAccountSidLocalA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidLocalA(MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidLocalA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidLocalA", Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidLocalW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupAccountSidLocalW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidLocalW$descriptor() {
        return LookupAccountSidLocalW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidLocalW$handle() {
        return LookupAccountSidLocalW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MemorySegment LookupAccountSidLocalW$address() {
        return LookupAccountSidLocalW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidLocalW(MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidLocalW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidLocalW", Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupPrivilegeValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeValueA$descriptor() {
        return LookupPrivilegeValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static MethodHandle LookupPrivilegeValueA$handle() {
        return LookupPrivilegeValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static MemorySegment LookupPrivilegeValueA$address() {
        return LookupPrivilegeValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static int LookupPrivilegeValueA(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpLuid) {
        var mh$ = LookupPrivilegeValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeValueA", lpSystemName, lpName, lpLuid);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpLuid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupPrivilegeValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeValueW$descriptor() {
        return LookupPrivilegeValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static MethodHandle LookupPrivilegeValueW$handle() {
        return LookupPrivilegeValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static MemorySegment LookupPrivilegeValueW$address() {
        return LookupPrivilegeValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static int LookupPrivilegeValueW(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpLuid) {
        var mh$ = LookupPrivilegeValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeValueW", lpSystemName, lpName, lpLuid);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpLuid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupPrivilegeNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeNameA$descriptor() {
        return LookupPrivilegeNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static MethodHandle LookupPrivilegeNameA$handle() {
        return LookupPrivilegeNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static MemorySegment LookupPrivilegeNameA$address() {
        return LookupPrivilegeNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static int LookupPrivilegeNameA(MemorySegment lpSystemName, MemorySegment lpLuid, MemorySegment lpName, MemorySegment cchName) {
        var mh$ = LookupPrivilegeNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeNameA", lpSystemName, lpLuid, lpName, cchName);
            }
            return (int)mh$.invokeExact(lpSystemName, lpLuid, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupPrivilegeNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeNameW$descriptor() {
        return LookupPrivilegeNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static MethodHandle LookupPrivilegeNameW$handle() {
        return LookupPrivilegeNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static MemorySegment LookupPrivilegeNameW$address() {
        return LookupPrivilegeNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static int LookupPrivilegeNameW(MemorySegment lpSystemName, MemorySegment lpLuid, MemorySegment lpName, MemorySegment cchName) {
        var mh$ = LookupPrivilegeNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeNameW", lpSystemName, lpLuid, lpName, cchName);
            }
            return (int)mh$.invokeExact(lpSystemName, lpLuid, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeDisplayNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupPrivilegeDisplayNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeDisplayNameA$descriptor() {
        return LookupPrivilegeDisplayNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MethodHandle LookupPrivilegeDisplayNameA$handle() {
        return LookupPrivilegeDisplayNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MemorySegment LookupPrivilegeDisplayNameA$address() {
        return LookupPrivilegeDisplayNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static int LookupPrivilegeDisplayNameA(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpDisplayName, MemorySegment cchDisplayName, MemorySegment lpLanguageId) {
        var mh$ = LookupPrivilegeDisplayNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeDisplayNameA", lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeDisplayNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LookupPrivilegeDisplayNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeDisplayNameW$descriptor() {
        return LookupPrivilegeDisplayNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MethodHandle LookupPrivilegeDisplayNameW$handle() {
        return LookupPrivilegeDisplayNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MemorySegment LookupPrivilegeDisplayNameW$address() {
        return LookupPrivilegeDisplayNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static int LookupPrivilegeDisplayNameW(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpDisplayName, MemorySegment cchDisplayName, MemorySegment lpLanguageId) {
        var mh$ = LookupPrivilegeDisplayNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeDisplayNameW", lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BuildCommDCBA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor BuildCommDCBA$descriptor() {
        return BuildCommDCBA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MethodHandle BuildCommDCBA$handle() {
        return BuildCommDCBA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MemorySegment BuildCommDCBA$address() {
        return BuildCommDCBA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static int BuildCommDCBA(MemorySegment lpDef, MemorySegment lpDCB) {
        var mh$ = BuildCommDCBA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBA", lpDef, lpDCB);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BuildCommDCBW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor BuildCommDCBW$descriptor() {
        return BuildCommDCBW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MethodHandle BuildCommDCBW$handle() {
        return BuildCommDCBW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MemorySegment BuildCommDCBW$address() {
        return BuildCommDCBW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static int BuildCommDCBW(MemorySegment lpDef, MemorySegment lpDCB) {
        var mh$ = BuildCommDCBW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBW", lpDef, lpDCB);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBAndTimeoutsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BuildCommDCBAndTimeoutsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor BuildCommDCBAndTimeoutsA$descriptor() {
        return BuildCommDCBAndTimeoutsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle BuildCommDCBAndTimeoutsA$handle() {
        return BuildCommDCBAndTimeoutsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment BuildCommDCBAndTimeoutsA$address() {
        return BuildCommDCBAndTimeoutsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int BuildCommDCBAndTimeoutsA(MemorySegment lpDef, MemorySegment lpDCB, MemorySegment lpCommTimeouts) {
        var mh$ = BuildCommDCBAndTimeoutsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBAndTimeoutsA", lpDef, lpDCB, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBAndTimeoutsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BuildCommDCBAndTimeoutsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor BuildCommDCBAndTimeoutsW$descriptor() {
        return BuildCommDCBAndTimeoutsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle BuildCommDCBAndTimeoutsW$handle() {
        return BuildCommDCBAndTimeoutsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment BuildCommDCBAndTimeoutsW$address() {
        return BuildCommDCBAndTimeoutsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int BuildCommDCBAndTimeoutsW(MemorySegment lpDef, MemorySegment lpDCB, MemorySegment lpCommTimeouts) {
        var mh$ = BuildCommDCBAndTimeoutsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBAndTimeoutsW", lpDef, lpDCB, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CommConfigDialogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CommConfigDialogA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static FunctionDescriptor CommConfigDialogA$descriptor() {
        return CommConfigDialogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MethodHandle CommConfigDialogA$handle() {
        return CommConfigDialogA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MemorySegment CommConfigDialogA$address() {
        return CommConfigDialogA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static int CommConfigDialogA(MemorySegment lpszName, MemorySegment hWnd, MemorySegment lpCC) {
        var mh$ = CommConfigDialogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommConfigDialogA", lpszName, hWnd, lpCC);
            }
            return (int)mh$.invokeExact(lpszName, hWnd, lpCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CommConfigDialogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CommConfigDialogW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static FunctionDescriptor CommConfigDialogW$descriptor() {
        return CommConfigDialogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MethodHandle CommConfigDialogW$handle() {
        return CommConfigDialogW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MemorySegment CommConfigDialogW$address() {
        return CommConfigDialogW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static int CommConfigDialogW(MemorySegment lpszName, MemorySegment hWnd, MemorySegment lpCC) {
        var mh$ = CommConfigDialogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommConfigDialogW", lpszName, hWnd, lpCC);
            }
            return (int)mh$.invokeExact(lpszName, hWnd, lpCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDefaultCommConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDefaultCommConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetDefaultCommConfigA$descriptor() {
        return GetDefaultCommConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetDefaultCommConfigA$handle() {
        return GetDefaultCommConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MemorySegment GetDefaultCommConfigA$address() {
        return GetDefaultCommConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetDefaultCommConfigA(MemorySegment lpszName, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetDefaultCommConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDefaultCommConfigA", lpszName, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDefaultCommConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDefaultCommConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetDefaultCommConfigW$descriptor() {
        return GetDefaultCommConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetDefaultCommConfigW$handle() {
        return GetDefaultCommConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MemorySegment GetDefaultCommConfigW$address() {
        return GetDefaultCommConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetDefaultCommConfigW(MemorySegment lpszName, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetDefaultCommConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDefaultCommConfigW", lpszName, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultCommConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDefaultCommConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetDefaultCommConfigA$descriptor() {
        return SetDefaultCommConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetDefaultCommConfigA$handle() {
        return SetDefaultCommConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MemorySegment SetDefaultCommConfigA$address() {
        return SetDefaultCommConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetDefaultCommConfigA(MemorySegment lpszName, MemorySegment lpCC, int dwSize) {
        var mh$ = SetDefaultCommConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultCommConfigA", lpszName, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultCommConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDefaultCommConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetDefaultCommConfigW$descriptor() {
        return SetDefaultCommConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetDefaultCommConfigW$handle() {
        return SetDefaultCommConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MemorySegment SetDefaultCommConfigW$address() {
        return SetDefaultCommConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetDefaultCommConfigW(MemorySegment lpszName, MemorySegment lpCC, int dwSize) {
        var mh$ = SetDefaultCommConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultCommConfigW", lpszName, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameA$descriptor() {
        return GetComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameA$handle() {
        return GetComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameA$address() {
        return GetComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameA(MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameA", lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameW$descriptor() {
        return GetComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameW$handle() {
        return GetComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameW$address() {
        return GetComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameW(MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameW", lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DnsHostnameToComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameA$descriptor() {
        return DnsHostnameToComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameA$handle() {
        return DnsHostnameToComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MemorySegment DnsHostnameToComputerNameA$address() {
        return DnsHostnameToComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameA(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameA", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DnsHostnameToComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameW$descriptor() {
        return DnsHostnameToComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameW$handle() {
        return DnsHostnameToComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MemorySegment DnsHostnameToComputerNameW$address() {
        return DnsHostnameToComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameW(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameW", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static FunctionDescriptor GetUserNameA$descriptor() {
        return GetUserNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MethodHandle GetUserNameA$handle() {
        return GetUserNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MemorySegment GetUserNameA$address() {
        return GetUserNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static int GetUserNameA(MemorySegment lpBuffer, MemorySegment pcbBuffer) {
        var mh$ = GetUserNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserNameA", lpBuffer, pcbBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer, pcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static FunctionDescriptor GetUserNameW$descriptor() {
        return GetUserNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MethodHandle GetUserNameW$handle() {
        return GetUserNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MemorySegment GetUserNameW$address() {
        return GetUserNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static int GetUserNameW(MemorySegment lpBuffer, MemorySegment pcbBuffer) {
        var mh$ = GetUserNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserNameW", lpBuffer, pcbBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer, pcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LogonUserA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static FunctionDescriptor LogonUserA$descriptor() {
        return LogonUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MethodHandle LogonUserA$handle() {
        return LogonUserA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MemorySegment LogonUserA$address() {
        return LogonUserA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static int LogonUserA(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken) {
        var mh$ = LogonUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserA", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LogonUserW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static FunctionDescriptor LogonUserW$descriptor() {
        return LogonUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MethodHandle LogonUserW$handle() {
        return LogonUserW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MemorySegment LogonUserW$address() {
        return LogonUserW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static int LogonUserW(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken) {
        var mh$ = LogonUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserW", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LogonUserExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static FunctionDescriptor LogonUserExA$descriptor() {
        return LogonUserExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MethodHandle LogonUserExA$handle() {
        return LogonUserExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MemorySegment LogonUserExA$address() {
        return LogonUserExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static int LogonUserExA(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken, MemorySegment ppLogonSid, MemorySegment ppProfileBuffer, MemorySegment pdwProfileLength, MemorySegment pQuotaLimits) {
        var mh$ = LogonUserExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserExA", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LogonUserExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static FunctionDescriptor LogonUserExW$descriptor() {
        return LogonUserExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MethodHandle LogonUserExW$handle() {
        return LogonUserExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MemorySegment LogonUserExW$address() {
        return LogonUserExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static int LogonUserExW(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken, MemorySegment ppLogonSid, MemorySegment ppProfileBuffer, MemorySegment pdwProfileLength, MemorySegment pQuotaLimits) {
        var mh$ = LogonUserExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserExW", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessWithLogonW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateProcessWithLogonW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessWithLogonW$descriptor() {
        return CreateProcessWithLogonW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessWithLogonW$handle() {
        return CreateProcessWithLogonW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessWithLogonW$address() {
        return CreateProcessWithLogonW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessWithLogonW(MemorySegment lpUsername, MemorySegment lpDomain, MemorySegment lpPassword, int dwLogonFlags, MemorySegment lpApplicationName, MemorySegment lpCommandLine, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessWithLogonW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessWithLogonW", lpUsername, lpDomain, lpPassword, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpUsername, lpDomain, lpPassword, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessWithTokenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateProcessWithTokenW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessWithTokenW$descriptor() {
        return CreateProcessWithTokenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessWithTokenW$handle() {
        return CreateProcessWithTokenW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessWithTokenW$address() {
        return CreateProcessWithTokenW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessWithTokenW(MemorySegment hToken, int dwLogonFlags, MemorySegment lpApplicationName, MemorySegment lpCommandLine, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessWithTokenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessWithTokenW", hToken, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTokenUntrusted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsTokenUntrusted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor IsTokenUntrusted$descriptor() {
        return IsTokenUntrusted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static MethodHandle IsTokenUntrusted$handle() {
        return IsTokenUntrusted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static MemorySegment IsTokenUntrusted$address() {
        return IsTokenUntrusted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static int IsTokenUntrusted(MemorySegment TokenHandle) {
        var mh$ = IsTokenUntrusted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTokenUntrusted", TokenHandle);
            }
            return (int)mh$.invokeExact(TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterWaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterWaitForSingleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterWaitForSingleObject$descriptor() {
        return RegisterWaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static MethodHandle RegisterWaitForSingleObject$handle() {
        return RegisterWaitForSingleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static MemorySegment RegisterWaitForSingleObject$address() {
        return RegisterWaitForSingleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static int RegisterWaitForSingleObject(MemorySegment phNewWaitObject, MemorySegment hObject, MemorySegment Callback, MemorySegment Context, int dwMilliseconds, int dwFlags) {
        var mh$ = RegisterWaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWaitForSingleObject", phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags);
            }
            return (int)mh$.invokeExact(phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static FunctionDescriptor UnregisterWait$descriptor() {
        return UnregisterWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static MethodHandle UnregisterWait$handle() {
        return UnregisterWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static MemorySegment UnregisterWait$address() {
        return UnregisterWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static int UnregisterWait(MemorySegment WaitHandle) {
        var mh$ = UnregisterWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterWait", WaitHandle);
            }
            return (int)mh$.invokeExact(WaitHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BindIoCompletionCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BindIoCompletionCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static FunctionDescriptor BindIoCompletionCallback$descriptor() {
        return BindIoCompletionCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static MethodHandle BindIoCompletionCallback$handle() {
        return BindIoCompletionCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static MemorySegment BindIoCompletionCallback$address() {
        return BindIoCompletionCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static int BindIoCompletionCallback(MemorySegment FileHandle, MemorySegment Function, int Flags) {
        var mh$ = BindIoCompletionCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BindIoCompletionCallback", FileHandle, Function, Flags);
            }
            return (int)mh$.invokeExact(FileHandle, Function, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static FunctionDescriptor SetTimerQueueTimer$descriptor() {
        return SetTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MethodHandle SetTimerQueueTimer$handle() {
        return SetTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MemorySegment SetTimerQueueTimer$address() {
        return SetTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MemorySegment SetTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Callback, MemorySegment Parameter, int DueTime, int Period, int PreferIo) {
        var mh$ = SetTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimerQueueTimer", TimerQueue, Callback, Parameter, DueTime, Period, PreferIo);
            }
            return (MemorySegment)mh$.invokeExact(TimerQueue, Callback, Parameter, DueTime, Period, PreferIo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static FunctionDescriptor CancelTimerQueueTimer$descriptor() {
        return CancelTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static MethodHandle CancelTimerQueueTimer$handle() {
        return CancelTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static MemorySegment CancelTimerQueueTimer$address() {
        return CancelTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static int CancelTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer) {
        var mh$ = CancelTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelTimerQueueTimer", TimerQueue, Timer);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteTimerQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueue$descriptor() {
        return DeleteTimerQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static MethodHandle DeleteTimerQueue$handle() {
        return DeleteTimerQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static MemorySegment DeleteTimerQueue$address() {
        return DeleteTimerQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static int DeleteTimerQueue(MemorySegment TimerQueue) {
        var mh$ = DeleteTimerQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueue", TimerQueue);
            }
            return (int)mh$.invokeExact(TimerQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateNamespaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePrivateNamespaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor CreatePrivateNamespaceA$descriptor() {
        return CreatePrivateNamespaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle CreatePrivateNamespaceA$handle() {
        return CreatePrivateNamespaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceA$address() {
        return CreatePrivateNamespaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceA(MemorySegment lpPrivateNamespaceAttributes, MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = CreatePrivateNamespaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateNamespaceA", lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenPrivateNamespaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenPrivateNamespaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor OpenPrivateNamespaceA$descriptor() {
        return OpenPrivateNamespaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle OpenPrivateNamespaceA$handle() {
        return OpenPrivateNamespaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceA$address() {
        return OpenPrivateNamespaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceA(MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = OpenPrivateNamespaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenPrivateNamespaceA", lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBoundaryDescriptorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateBoundaryDescriptorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateBoundaryDescriptorA$descriptor() {
        return CreateBoundaryDescriptorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MethodHandle CreateBoundaryDescriptorA$handle() {
        return CreateBoundaryDescriptorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorA$address() {
        return CreateBoundaryDescriptorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorA(MemorySegment Name, int Flags) {
        var mh$ = CreateBoundaryDescriptorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBoundaryDescriptorA", Name, Flags);
            }
            return (MemorySegment)mh$.invokeExact(Name, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddIntegrityLabelToBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddIntegrityLabelToBoundaryDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static FunctionDescriptor AddIntegrityLabelToBoundaryDescriptor$descriptor() {
        return AddIntegrityLabelToBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static MethodHandle AddIntegrityLabelToBoundaryDescriptor$handle() {
        return AddIntegrityLabelToBoundaryDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static MemorySegment AddIntegrityLabelToBoundaryDescriptor$address() {
        return AddIntegrityLabelToBoundaryDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static int AddIntegrityLabelToBoundaryDescriptor(MemorySegment BoundaryDescriptor, MemorySegment IntegrityLabel) {
        var mh$ = AddIntegrityLabelToBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddIntegrityLabelToBoundaryDescriptor", BoundaryDescriptor, IntegrityLabel);
            }
            return (int)mh$.invokeExact(BoundaryDescriptor, IntegrityLabel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagHW_PROFILE_INFOA {
     *     DWORD dwDockInfo;
     *     CHAR szHwProfileGuid[39];
     *     CHAR szHwProfileName[80];
     * } *LPHW_PROFILE_INFOA
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHW_PROFILE_INFOW {
     *     DWORD dwDockInfo;
     *     WCHAR szHwProfileGuid[39];
     *     WCHAR szHwProfileName[80];
     * } *LPHW_PROFILE_INFOW
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFO = freeglut_h.C_POINTER;

    private static class GetCurrentHwProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentHwProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static FunctionDescriptor GetCurrentHwProfileA$descriptor() {
        return GetCurrentHwProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static MethodHandle GetCurrentHwProfileA$handle() {
        return GetCurrentHwProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static MemorySegment GetCurrentHwProfileA$address() {
        return GetCurrentHwProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static int GetCurrentHwProfileA(MemorySegment lpHwProfileInfo) {
        var mh$ = GetCurrentHwProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentHwProfileA", lpHwProfileInfo);
            }
            return (int)mh$.invokeExact(lpHwProfileInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentHwProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentHwProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static FunctionDescriptor GetCurrentHwProfileW$descriptor() {
        return GetCurrentHwProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static MethodHandle GetCurrentHwProfileW$handle() {
        return GetCurrentHwProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static MemorySegment GetCurrentHwProfileW$address() {
        return GetCurrentHwProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static int GetCurrentHwProfileW(MemorySegment lpHwProfileInfo) {
        var mh$ = GetCurrentHwProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentHwProfileW", lpHwProfileInfo);
            }
            return (int)mh$.invokeExact(lpHwProfileInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyVersionInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerifyVersionInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static FunctionDescriptor VerifyVersionInfoA$descriptor() {
        return VerifyVersionInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MethodHandle VerifyVersionInfoA$handle() {
        return VerifyVersionInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MemorySegment VerifyVersionInfoA$address() {
        return VerifyVersionInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static int VerifyVersionInfoA(MemorySegment lpVersionInformation, int dwTypeMask, long dwlConditionMask) {
        var mh$ = VerifyVersionInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyVersionInfoA", lpVersionInformation, dwTypeMask, dwlConditionMask);
            }
            return (int)mh$.invokeExact(lpVersionInformation, dwTypeMask, dwlConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyVersionInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerifyVersionInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static FunctionDescriptor VerifyVersionInfoW$descriptor() {
        return VerifyVersionInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MethodHandle VerifyVersionInfoW$handle() {
        return VerifyVersionInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MemorySegment VerifyVersionInfoW$address() {
        return VerifyVersionInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static int VerifyVersionInfoW(MemorySegment lpVersionInformation, int dwTypeMask, long dwlConditionMask) {
        var mh$ = VerifyVersionInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyVersionInfoW", lpVersionInformation, dwTypeMask, dwlConditionMask);
            }
            return (int)mh$.invokeExact(lpVersionInformation, dwTypeMask, dwlConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     * } *PTIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout PTIME_ZONE_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     * } *LPTIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout LPTIME_ZONE_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     *     WCHAR TimeZoneKeyName[128];
     *     BOOLEAN DynamicDaylightTimeDisabled;
     * } *PDYNAMIC_TIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout PDYNAMIC_TIME_ZONE_INFORMATION = freeglut_h.C_POINTER;

    private static class SystemTimeToTzSpecificLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SystemTimeToTzSpecificLocalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToTzSpecificLocalTime$descriptor() {
        return SystemTimeToTzSpecificLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MethodHandle SystemTimeToTzSpecificLocalTime$handle() {
        return SystemTimeToTzSpecificLocalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MemorySegment SystemTimeToTzSpecificLocalTime$address() {
        return SystemTimeToTzSpecificLocalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static int SystemTimeToTzSpecificLocalTime(MemorySegment lpTimeZoneInformation, MemorySegment lpUniversalTime, MemorySegment lpLocalTime) {
        var mh$ = SystemTimeToTzSpecificLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToTzSpecificLocalTime", lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TzSpecificLocalTimeToSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TzSpecificLocalTimeToSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static FunctionDescriptor TzSpecificLocalTimeToSystemTime$descriptor() {
        return TzSpecificLocalTimeToSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MethodHandle TzSpecificLocalTimeToSystemTime$handle() {
        return TzSpecificLocalTimeToSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MemorySegment TzSpecificLocalTimeToSystemTime$address() {
        return TzSpecificLocalTimeToSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static int TzSpecificLocalTimeToSystemTime(MemorySegment lpTimeZoneInformation, MemorySegment lpLocalTime, MemorySegment lpUniversalTime) {
        var mh$ = TzSpecificLocalTimeToSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TzSpecificLocalTimeToSystemTime", lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FileTimeToSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor FileTimeToSystemTime$descriptor() {
        return FileTimeToSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle FileTimeToSystemTime$handle() {
        return FileTimeToSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MemorySegment FileTimeToSystemTime$address() {
        return FileTimeToSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static int FileTimeToSystemTime(MemorySegment lpFileTime, MemorySegment lpSystemTime) {
        var mh$ = FileTimeToSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToSystemTime", lpFileTime, lpSystemTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SystemTimeToFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToFileTime$descriptor() {
        return SystemTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle SystemTimeToFileTime$handle() {
        return SystemTimeToFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static MemorySegment SystemTimeToFileTime$address() {
        return SystemTimeToFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static int SystemTimeToFileTime(MemorySegment lpSystemTime, MemorySegment lpFileTime) {
        var mh$ = SystemTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToFileTime", lpSystemTime, lpFileTime);
            }
            return (int)mh$.invokeExact(lpSystemTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor GetTimeZoneInformation$descriptor() {
        return GetTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MethodHandle GetTimeZoneInformation$handle() {
        return GetTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MemorySegment GetTimeZoneInformation$address() {
        return GetTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static int GetTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = GetTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor SetTimeZoneInformation$descriptor() {
        return SetTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MethodHandle SetTimeZoneInformation$handle() {
        return SetTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MemorySegment SetTimeZoneInformation$address() {
        return SetTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static int SetTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = SetTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDynamicTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor SetDynamicTimeZoneInformation$descriptor() {
        return SetDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MethodHandle SetDynamicTimeZoneInformation$handle() {
        return SetDynamicTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MemorySegment SetDynamicTimeZoneInformation$address() {
        return SetDynamicTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static int SetDynamicTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = SetDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDynamicTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDynamicTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor GetDynamicTimeZoneInformation$descriptor() {
        return GetDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static MethodHandle GetDynamicTimeZoneInformation$handle() {
        return GetDynamicTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static MemorySegment GetDynamicTimeZoneInformation$address() {
        return GetDynamicTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static int GetDynamicTimeZoneInformation(MemorySegment pTimeZoneInformation) {
        var mh$ = GetDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDynamicTimeZoneInformation", pTimeZoneInformation);
            }
            return (int)mh$.invokeExact(pTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeZoneInformationForYear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTimeZoneInformationForYear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static FunctionDescriptor GetTimeZoneInformationForYear$descriptor() {
        return GetTimeZoneInformationForYear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static MethodHandle GetTimeZoneInformationForYear$handle() {
        return GetTimeZoneInformationForYear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static MemorySegment GetTimeZoneInformationForYear$address() {
        return GetTimeZoneInformationForYear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static int GetTimeZoneInformationForYear(short wYear, MemorySegment pdtzi, MemorySegment ptzi) {
        var mh$ = GetTimeZoneInformationForYear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeZoneInformationForYear", wYear, pdtzi, ptzi);
            }
            return (int)mh$.invokeExact(wYear, pdtzi, ptzi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDynamicTimeZoneInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor EnumDynamicTimeZoneInformation$descriptor() {
        return EnumDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MethodHandle EnumDynamicTimeZoneInformation$handle() {
        return EnumDynamicTimeZoneInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MemorySegment EnumDynamicTimeZoneInformation$address() {
        return EnumDynamicTimeZoneInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static int EnumDynamicTimeZoneInformation(int dwIndex, MemorySegment lpTimeZoneInformation) {
        var mh$ = EnumDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDynamicTimeZoneInformation", dwIndex, lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(dwIndex, lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDynamicTimeZoneInformationEffectiveYears {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDynamicTimeZoneInformationEffectiveYears");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static FunctionDescriptor GetDynamicTimeZoneInformationEffectiveYears$descriptor() {
        return GetDynamicTimeZoneInformationEffectiveYears.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static MethodHandle GetDynamicTimeZoneInformationEffectiveYears$handle() {
        return GetDynamicTimeZoneInformationEffectiveYears.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static MemorySegment GetDynamicTimeZoneInformationEffectiveYears$address() {
        return GetDynamicTimeZoneInformationEffectiveYears.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static int GetDynamicTimeZoneInformationEffectiveYears(MemorySegment lpTimeZoneInformation, MemorySegment FirstYear, MemorySegment LastYear) {
        var mh$ = GetDynamicTimeZoneInformationEffectiveYears.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDynamicTimeZoneInformationEffectiveYears", lpTimeZoneInformation, FirstYear, LastYear);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, FirstYear, LastYear);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemTimeToTzSpecificLocalTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SystemTimeToTzSpecificLocalTimeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToTzSpecificLocalTimeEx$descriptor() {
        return SystemTimeToTzSpecificLocalTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MethodHandle SystemTimeToTzSpecificLocalTimeEx$handle() {
        return SystemTimeToTzSpecificLocalTimeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MemorySegment SystemTimeToTzSpecificLocalTimeEx$address() {
        return SystemTimeToTzSpecificLocalTimeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static int SystemTimeToTzSpecificLocalTimeEx(MemorySegment lpTimeZoneInformation, MemorySegment lpUniversalTime, MemorySegment lpLocalTime) {
        var mh$ = SystemTimeToTzSpecificLocalTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToTzSpecificLocalTimeEx", lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TzSpecificLocalTimeToSystemTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TzSpecificLocalTimeToSystemTimeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static FunctionDescriptor TzSpecificLocalTimeToSystemTimeEx$descriptor() {
        return TzSpecificLocalTimeToSystemTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MethodHandle TzSpecificLocalTimeToSystemTimeEx$handle() {
        return TzSpecificLocalTimeToSystemTimeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MemorySegment TzSpecificLocalTimeToSystemTimeEx$address() {
        return TzSpecificLocalTimeToSystemTimeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static int TzSpecificLocalTimeToSystemTimeEx(MemorySegment lpTimeZoneInformation, MemorySegment lpLocalTime, MemorySegment lpUniversalTime) {
        var mh$ = TzSpecificLocalTimeToSystemTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TzSpecificLocalTimeToSystemTimeEx", lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFileTimeToLocalSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalFileTimeToLocalSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static FunctionDescriptor LocalFileTimeToLocalSystemTime$descriptor() {
        return LocalFileTimeToLocalSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static MethodHandle LocalFileTimeToLocalSystemTime$handle() {
        return LocalFileTimeToLocalSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static MemorySegment LocalFileTimeToLocalSystemTime$address() {
        return LocalFileTimeToLocalSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static int LocalFileTimeToLocalSystemTime(MemorySegment timeZoneInformation, MemorySegment localFileTime, MemorySegment localSystemTime) {
        var mh$ = LocalFileTimeToLocalSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFileTimeToLocalSystemTime", timeZoneInformation, localFileTime, localSystemTime);
            }
            return (int)mh$.invokeExact(timeZoneInformation, localFileTime, localSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalSystemTimeToLocalFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalSystemTimeToLocalFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static FunctionDescriptor LocalSystemTimeToLocalFileTime$descriptor() {
        return LocalSystemTimeToLocalFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static MethodHandle LocalSystemTimeToLocalFileTime$handle() {
        return LocalSystemTimeToLocalFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static MemorySegment LocalSystemTimeToLocalFileTime$address() {
        return LocalSystemTimeToLocalFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static int LocalSystemTimeToLocalFileTime(MemorySegment timeZoneInformation, MemorySegment localSystemTime, MemorySegment localFileTime) {
        var mh$ = LocalSystemTimeToLocalFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalSystemTimeToLocalFileTime", timeZoneInformation, localSystemTime, localFileTime);
            }
            return (int)mh$.invokeExact(timeZoneInformation, localSystemTime, localFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemPowerState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSystemPowerState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static FunctionDescriptor SetSystemPowerState$descriptor() {
        return SetSystemPowerState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static MethodHandle SetSystemPowerState$handle() {
        return SetSystemPowerState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static MemorySegment SetSystemPowerState$address() {
        return SetSystemPowerState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static int SetSystemPowerState(int fSuspend, int fForce) {
        var mh$ = SetSystemPowerState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPowerState", fSuspend, fForce);
            }
            return (int)mh$.invokeExact(fSuspend, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_POWER_STATUS {
     *     BYTE ACLineStatus;
     *     BYTE BatteryFlag;
     *     BYTE BatteryLifePercent;
     *     BYTE SystemStatusFlag;
     *     DWORD BatteryLifeTime;
     *     DWORD BatteryFullLifeTime;
     * } *LPSYSTEM_POWER_STATUS
     * }
     */
    public static final AddressLayout LPSYSTEM_POWER_STATUS = freeglut_h.C_POINTER;

    private static class GetSystemPowerStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemPowerStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static FunctionDescriptor GetSystemPowerStatus$descriptor() {
        return GetSystemPowerStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static MethodHandle GetSystemPowerStatus$handle() {
        return GetSystemPowerStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static MemorySegment GetSystemPowerStatus$address() {
        return GetSystemPowerStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static int GetSystemPowerStatus(MemorySegment lpSystemPowerStatus) {
        var mh$ = GetSystemPowerStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPowerStatus", lpSystemPowerStatus);
            }
            return (int)mh$.invokeExact(lpSystemPowerStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapUserPhysicalPagesScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapUserPhysicalPagesScatter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor MapUserPhysicalPagesScatter$descriptor() {
        return MapUserPhysicalPagesScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle MapUserPhysicalPagesScatter$handle() {
        return MapUserPhysicalPagesScatter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment MapUserPhysicalPagesScatter$address() {
        return MapUserPhysicalPagesScatter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int MapUserPhysicalPagesScatter(MemorySegment VirtualAddresses, long NumberOfPages, MemorySegment PageArray) {
        var mh$ = MapUserPhysicalPagesScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapUserPhysicalPagesScatter", VirtualAddresses, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(VirtualAddresses, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateJobObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateJobObjectA$descriptor() {
        return CreateJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateJobObjectA$handle() {
        return CreateJobObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectA$address() {
        return CreateJobObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectA(MemorySegment lpJobAttributes, MemorySegment lpName) {
        var mh$ = CreateJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobObjectA", lpJobAttributes, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpJobAttributes, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenJobObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenJobObjectA$descriptor() {
        return OpenJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenJobObjectA$handle() {
        return OpenJobObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectA$address() {
        return OpenJobObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenJobObjectA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateJobSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateJobSet$descriptor() {
        return CreateJobSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static MethodHandle CreateJobSet$handle() {
        return CreateJobSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static MemorySegment CreateJobSet$address() {
        return CreateJobSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static int CreateJobSet(int NumJob, MemorySegment UserJobSet, int Flags) {
        var mh$ = CreateJobSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobSet", NumJob, UserJobSet, Flags);
            }
            return (int)mh$.invokeExact(NumJob, UserJobSet, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstVolumeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeA$descriptor() {
        return FindFirstVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeA$handle() {
        return FindFirstVolumeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeA$address() {
        return FindFirstVolumeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeA(MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindFirstVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeA", lpszVolumeName, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindNextVolumeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeA$descriptor() {
        return FindNextVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeA$handle() {
        return FindNextVolumeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeA$address() {
        return FindNextVolumeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeA(MemorySegment hFindVolume, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindNextVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeA", hFindVolume, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolume, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointA$descriptor() {
        return FindFirstVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointA$handle() {
        return FindFirstVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointA$address() {
        return FindFirstVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointA(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointA", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointW$descriptor() {
        return FindFirstVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointW$handle() {
        return FindFirstVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointW$address() {
        return FindFirstVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointW(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointW", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindNextVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointA$descriptor() {
        return FindNextVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointA$handle() {
        return FindNextVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeMountPointA$address() {
        return FindNextVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointA(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointA", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindNextVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointW$descriptor() {
        return FindNextVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointW$handle() {
        return FindNextVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindNextVolumeMountPointW$address() {
        return FindNextVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointW(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointW", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindVolumeMountPointClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindVolumeMountPointClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor FindVolumeMountPointClose$descriptor() {
        return FindVolumeMountPointClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static MethodHandle FindVolumeMountPointClose$handle() {
        return FindVolumeMountPointClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static MemorySegment FindVolumeMountPointClose$address() {
        return FindVolumeMountPointClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static int FindVolumeMountPointClose(MemorySegment hFindVolumeMountPoint) {
        var mh$ = FindVolumeMountPointClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindVolumeMountPointClose", hFindVolumeMountPoint);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointA$descriptor() {
        return SetVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointA$handle() {
        return SetVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static MemorySegment SetVolumeMountPointA$address() {
        return SetVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointW$descriptor() {
        return SetVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointW$handle() {
        return SetVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static MemorySegment SetVolumeMountPointW$address() {
        return SetVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor DeleteVolumeMountPointA$descriptor() {
        return DeleteVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static MethodHandle DeleteVolumeMountPointA$handle() {
        return DeleteVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static MemorySegment DeleteVolumeMountPointA$address() {
        return DeleteVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static int DeleteVolumeMountPointA(MemorySegment lpszVolumeMountPoint) {
        var mh$ = DeleteVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteVolumeMountPointA", lpszVolumeMountPoint);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumeNameForVolumeMountPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointA$descriptor() {
        return GetVolumeNameForVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointA$handle() {
        return GetVolumeNameForVolumeMountPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumeNameForVolumeMountPointA$address() {
        return GetVolumeNameForVolumeMountPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumePathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameA$descriptor() {
        return GetVolumePathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameA$handle() {
        return GetVolumePathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumePathNameA$address() {
        return GetVolumePathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameA(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameA", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumePathNamesForVolumeNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameA$descriptor() {
        return GetVolumePathNamesForVolumeNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameA$handle() {
        return GetVolumePathNamesForVolumeNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MemorySegment GetVolumePathNamesForVolumeNameA$address() {
        return GetVolumePathNamesForVolumeNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameA(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameA", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXA {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCSTR lpAssemblyDirectory;
     *     LPCSTR lpResourceName;
     *     LPCSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXA
     * }
     */
    public static final AddressLayout PACTCTXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXW {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCWSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCWSTR lpAssemblyDirectory;
     *     LPCWSTR lpResourceName;
     *     LPCWSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXW
     * }
     */
    public static final AddressLayout PACTCTXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PACTCTXA PACTCTX
     * }
     */
    public static final AddressLayout PACTCTX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXA *PCACTCTXA
     * }
     */
    public static final AddressLayout PCACTCTXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXW *PCACTCTXW
     * }
     */
    public static final AddressLayout PCACTCTXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCACTCTXA PCACTCTX
     * }
     */
    public static final AddressLayout PCACTCTX = freeglut_h.C_POINTER;

    private static class CreateActCtxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateActCtxA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxA$descriptor() {
        return CreateActCtxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxA$handle() {
        return CreateActCtxA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxA$address() {
        return CreateActCtxA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxA(MemorySegment pActCtx) {
        var mh$ = CreateActCtxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxA", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateActCtxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxW$descriptor() {
        return CreateActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxW$handle() {
        return CreateActCtxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxW$address() {
        return CreateActCtxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxW(MemorySegment pActCtx) {
        var mh$ = CreateActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxW", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddRefActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddRefActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor AddRefActCtx$descriptor() {
        return AddRefActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle AddRefActCtx$handle() {
        return AddRefActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment AddRefActCtx$address() {
        return AddRefActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static void AddRefActCtx(MemorySegment hActCtx) {
        var mh$ = AddRefActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddRefActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ReleaseActCtx$descriptor() {
        return ReleaseActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ReleaseActCtx$handle() {
        return ReleaseActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment ReleaseActCtx$address() {
        return ReleaseActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static void ReleaseActCtx(MemorySegment hActCtx) {
        var mh$ = ReleaseActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZombifyActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ZombifyActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ZombifyActCtx$descriptor() {
        return ZombifyActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ZombifyActCtx$handle() {
        return ZombifyActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static MemorySegment ZombifyActCtx$address() {
        return ZombifyActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static int ZombifyActCtx(MemorySegment hActCtx) {
        var mh$ = ZombifyActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZombifyActCtx", hActCtx);
            }
            return (int)mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ActivateActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static FunctionDescriptor ActivateActCtx$descriptor() {
        return ActivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static MethodHandle ActivateActCtx$handle() {
        return ActivateActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static MemorySegment ActivateActCtx$address() {
        return ActivateActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static int ActivateActCtx(MemorySegment hActCtx, MemorySegment lpCookie) {
        var mh$ = ActivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateActCtx", hActCtx, lpCookie);
            }
            return (int)mh$.invokeExact(hActCtx, lpCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeactivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeactivateActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static FunctionDescriptor DeactivateActCtx$descriptor() {
        return DeactivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static MethodHandle DeactivateActCtx$handle() {
        return DeactivateActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static MemorySegment DeactivateActCtx$address() {
        return DeactivateActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static int DeactivateActCtx(int dwFlags, long ulCookie) {
        var mh$ = DeactivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeactivateActCtx", dwFlags, ulCookie);
            }
            return (int)mh$.invokeExact(dwFlags, ulCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentActCtx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static FunctionDescriptor GetCurrentActCtx$descriptor() {
        return GetCurrentActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static MethodHandle GetCurrentActCtx$handle() {
        return GetCurrentActCtx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static MemorySegment GetCurrentActCtx$address() {
        return GetCurrentActCtx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static int GetCurrentActCtx(MemorySegment lphActCtx) {
        var mh$ = GetCurrentActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentActCtx", lphActCtx);
            }
            return (int)mh$.invokeExact(lphActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     * } *PACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_2600 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_2600 *PCACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_2600 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
     *     PVOID lpInformation;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionLength;
     *     PVOID lpSectionGlobalDataBase;
     *     ULONG ulSectionGlobalDataLength;
     * } *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     *     ULONG ulFlags;
     *     ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
     * } *PACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA *PCACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA = freeglut_h.C_POINTER;

    private static class FindActCtxSectionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindActCtxSectionStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringA$descriptor() {
        return FindActCtxSectionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringA$handle() {
        return FindActCtxSectionStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionStringA$address() {
        return FindActCtxSectionStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringA(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringA", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindActCtxSectionStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringW$descriptor() {
        return FindActCtxSectionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringW$handle() {
        return FindActCtxSectionStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionStringW$address() {
        return FindActCtxSectionStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringW(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringW", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionGuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindActCtxSectionGuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionGuid$descriptor() {
        return FindActCtxSectionGuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionGuid$handle() {
        return FindActCtxSectionGuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MemorySegment FindActCtxSectionGuid$address() {
        return FindActCtxSectionGuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionGuid(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpGuidToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionGuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionGuid", dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_BASIC_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PCACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_BASIC_INFORMATION = freeglut_h.C_POINTER;

    private static class QueryActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryActCtxW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxW$descriptor() {
        return QueryActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxW$handle() {
        return QueryActCtxW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static MemorySegment QueryActCtxW$address() {
        return QueryActCtxW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static int QueryActCtxW(int dwFlags, MemorySegment hActCtx, MemorySegment pvSubInstance, int ulInfoClass, MemorySegment pvBuffer, long cbBuffer, MemorySegment pcbWrittenOrRequired) {
        var mh$ = QueryActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxW", dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetActiveConsoleSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WTSGetActiveConsoleSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetActiveConsoleSessionId$descriptor() {
        return WTSGetActiveConsoleSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static MethodHandle WTSGetActiveConsoleSessionId$handle() {
        return WTSGetActiveConsoleSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static MemorySegment WTSGetActiveConsoleSessionId$address() {
        return WTSGetActiveConsoleSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static int WTSGetActiveConsoleSessionId() {
        var mh$ = WTSGetActiveConsoleSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetActiveConsoleSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetServiceSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WTSGetServiceSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetServiceSessionId$descriptor() {
        return WTSGetServiceSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static MethodHandle WTSGetServiceSessionId$handle() {
        return WTSGetServiceSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static MemorySegment WTSGetServiceSessionId$address() {
        return WTSGetServiceSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static int WTSGetServiceSessionId() {
        var mh$ = WTSGetServiceSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetServiceSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSIsServerContainer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WTSIsServerContainer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static FunctionDescriptor WTSIsServerContainer$descriptor() {
        return WTSIsServerContainer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static MethodHandle WTSIsServerContainer$handle() {
        return WTSIsServerContainer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static MemorySegment WTSIsServerContainer$address() {
        return WTSIsServerContainer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static byte WTSIsServerContainer() {
        var mh$ = WTSIsServerContainer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSIsServerContainer");
            }
            return (byte)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetActiveProcessorGroupCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetActiveProcessorGroupCount$descriptor() {
        return GetActiveProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static MethodHandle GetActiveProcessorGroupCount$handle() {
        return GetActiveProcessorGroupCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static MemorySegment GetActiveProcessorGroupCount$address() {
        return GetActiveProcessorGroupCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static short GetActiveProcessorGroupCount() {
        var mh$ = GetActiveProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMaximumProcessorGroupCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorGroupCount$descriptor() {
        return GetMaximumProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static MethodHandle GetMaximumProcessorGroupCount$handle() {
        return GetMaximumProcessorGroupCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static MemorySegment GetMaximumProcessorGroupCount$address() {
        return GetMaximumProcessorGroupCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static short GetMaximumProcessorGroupCount() {
        var mh$ = GetMaximumProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetActiveProcessorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetActiveProcessorCount$descriptor() {
        return GetActiveProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetActiveProcessorCount$handle() {
        return GetActiveProcessorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static MemorySegment GetActiveProcessorCount$address() {
        return GetActiveProcessorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetActiveProcessorCount(short GroupNumber) {
        var mh$ = GetActiveProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMaximumProcessorCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorCount$descriptor() {
        return GetMaximumProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetMaximumProcessorCount$handle() {
        return GetMaximumProcessorCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static MemorySegment GetMaximumProcessorCount$address() {
        return GetMaximumProcessorCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetMaximumProcessorCount(short GroupNumber) {
        var mh$ = GetMaximumProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaProcessorNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNode$descriptor() {
        return GetNumaProcessorNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNode$handle() {
        return GetNumaProcessorNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProcessorNode$address() {
        return GetNumaProcessorNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProcessorNode(byte Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNode", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeNumberFromHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaNodeNumberFromHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaNodeNumberFromHandle$descriptor() {
        return GetNumaNodeNumberFromHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaNodeNumberFromHandle$handle() {
        return GetNumaNodeNumberFromHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaNodeNumberFromHandle$address() {
        return GetNumaNodeNumberFromHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaNodeNumberFromHandle(MemorySegment hFile, MemorySegment NodeNumber) {
        var mh$ = GetNumaNodeNumberFromHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeNumberFromHandle", hFile, NodeNumber);
            }
            return (int)mh$.invokeExact(hFile, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaProcessorNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNodeEx$descriptor() {
        return GetNumaProcessorNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNodeEx$handle() {
        return GetNumaProcessorNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProcessorNodeEx$address() {
        return GetNumaProcessorNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaProcessorNodeEx(MemorySegment Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNodeEx", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaNodeProcessorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMask$descriptor() {
        return GetNumaNodeProcessorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMask$handle() {
        return GetNumaNodeProcessorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static MemorySegment GetNumaNodeProcessorMask$address() {
        return GetNumaNodeProcessorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static int GetNumaNodeProcessorMask(byte Node, MemorySegment ProcessorMask) {
        var mh$ = GetNumaNodeProcessorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMask", Node, ProcessorMask);
            }
            return (int)mh$.invokeExact(Node, ProcessorMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaAvailableMemoryNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNode$descriptor() {
        return GetNumaAvailableMemoryNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNode$handle() {
        return GetNumaAvailableMemoryNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MemorySegment GetNumaAvailableMemoryNode$address() {
        return GetNumaAvailableMemoryNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNode(byte Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNode", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaAvailableMemoryNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNodeEx$descriptor() {
        return GetNumaAvailableMemoryNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNodeEx$handle() {
        return GetNumaAvailableMemoryNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MemorySegment GetNumaAvailableMemoryNodeEx$address() {
        return GetNumaAvailableMemoryNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNodeEx(short Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNodeEx", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProximityNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaProximityNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProximityNode$descriptor() {
        return GetNumaProximityNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProximityNode$handle() {
        return GetNumaProximityNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProximityNode$address() {
        return GetNumaProximityNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProximityNode(int ProximityId, MemorySegment NodeNumber) {
        var mh$ = GetNumaProximityNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProximityNode", ProximityId, NodeNumber);
            }
            return (int)mh$.invokeExact(ProximityId, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRecoveryCallback$descriptor() {
        return RegisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRecoveryCallback$handle() {
        return RegisterApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegisterApplicationRecoveryCallback$address() {
        return RegisterApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRecoveryCallback(MemorySegment pRecoveyCallback, MemorySegment pvParameter, int dwPingInterval, int dwFlags) {
        var mh$ = RegisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRecoveryCallback", pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
            }
            return (int)mh$.invokeExact(pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRecoveryCallback$descriptor() {
        return UnregisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static MethodHandle UnregisterApplicationRecoveryCallback$handle() {
        return UnregisterApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static MemorySegment UnregisterApplicationRecoveryCallback$address() {
        return UnregisterApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static int UnregisterApplicationRecoveryCallback() {
        var mh$ = UnregisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRecoveryCallback");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterApplicationRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRestart$descriptor() {
        return RegisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRestart$handle() {
        return RegisterApplicationRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegisterApplicationRestart$address() {
        return RegisterApplicationRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRestart(MemorySegment pwzCommandline, int dwFlags) {
        var mh$ = RegisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRestart", pwzCommandline, dwFlags);
            }
            return (int)mh$.invokeExact(pwzCommandline, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterApplicationRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRestart$descriptor() {
        return UnregisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static MethodHandle UnregisterApplicationRestart$handle() {
        return UnregisterApplicationRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static MemorySegment UnregisterApplicationRestart$address() {
        return UnregisterApplicationRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static int UnregisterApplicationRestart() {
        var mh$ = UnregisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRestart");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetApplicationRecoveryCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRecoveryCallback$descriptor() {
        return GetApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRecoveryCallback$handle() {
        return GetApplicationRecoveryCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static MemorySegment GetApplicationRecoveryCallback$address() {
        return GetApplicationRecoveryCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRecoveryCallback(MemorySegment hProcess, MemorySegment pRecoveryCallback, MemorySegment ppvParameter, MemorySegment pdwPingInterval, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRecoveryCallback", hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRestartSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetApplicationRestartSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRestartSettings$descriptor() {
        return GetApplicationRestartSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRestartSettings$handle() {
        return GetApplicationRestartSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static MemorySegment GetApplicationRestartSettings$address() {
        return GetApplicationRestartSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRestartSettings(MemorySegment hProcess, MemorySegment pwzCommandline, MemorySegment pcchSize, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRestartSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRestartSettings", hProcess, pwzCommandline, pcchSize, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pwzCommandline, pcchSize, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryInProgress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ApplicationRecoveryInProgress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryInProgress$descriptor() {
        return ApplicationRecoveryInProgress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static MethodHandle ApplicationRecoveryInProgress$handle() {
        return ApplicationRecoveryInProgress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static MemorySegment ApplicationRecoveryInProgress$address() {
        return ApplicationRecoveryInProgress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static int ApplicationRecoveryInProgress(MemorySegment pbCancelled) {
        var mh$ = ApplicationRecoveryInProgress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryInProgress", pbCancelled);
            }
            return (int)mh$.invokeExact(pbCancelled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryFinished {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ApplicationRecoveryFinished");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryFinished$descriptor() {
        return ApplicationRecoveryFinished.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static MethodHandle ApplicationRecoveryFinished$handle() {
        return ApplicationRecoveryFinished.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static MemorySegment ApplicationRecoveryFinished$address() {
        return ApplicationRecoveryFinished.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static void ApplicationRecoveryFinished(int bSuccess) {
        var mh$ = ApplicationRecoveryFinished.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryFinished", bSuccess);
            }
            mh$.invokeExact(bSuccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_BASIC_INFO {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } *PFILE_BASIC_INFO
     * }
     */
    public static final AddressLayout PFILE_BASIC_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STANDARD_INFO {
     *     LARGE_INTEGER AllocationSize;
     *     LARGE_INTEGER EndOfFile;
     *     DWORD NumberOfLinks;
     *     BOOLEAN DeletePending;
     *     BOOLEAN Directory;
     * } *PFILE_STANDARD_INFO
     * }
     */
    public static final AddressLayout PFILE_STANDARD_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_NAME_INFO {
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_NAME_INFO
     * }
     */
    public static final AddressLayout PFILE_NAME_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_CASE_SENSITIVE_INFO {
     *     ULONG Flags;
     * } *PFILE_CASE_SENSITIVE_INFO
     * }
     */
    public static final AddressLayout PFILE_CASE_SENSITIVE_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_RENAME_INFO {
     *     union {
     *         BOOLEAN ReplaceIfExists;
     *         DWORD Flags;
     *     };
     *     HANDLE RootDirectory;
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_RENAME_INFO
     * }
     */
    public static final AddressLayout PFILE_RENAME_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALLOCATION_INFO {
     *     LARGE_INTEGER AllocationSize;
     * } *PFILE_ALLOCATION_INFO
     * }
     */
    public static final AddressLayout PFILE_ALLOCATION_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_END_OF_FILE_INFO {
     *     LARGE_INTEGER EndOfFile;
     * } *PFILE_END_OF_FILE_INFO
     * }
     */
    public static final AddressLayout PFILE_END_OF_FILE_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STREAM_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD StreamNameLength;
     *     LARGE_INTEGER StreamSize;
     *     LARGE_INTEGER StreamAllocationSize;
     *     WCHAR StreamName[1];
     * } *PFILE_STREAM_INFO
     * }
     */
    public static final AddressLayout PFILE_STREAM_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_COMPRESSION_INFO {
     *     LARGE_INTEGER CompressedFileSize;
     *     WORD CompressionFormat;
     *     UCHAR CompressionUnitShift;
     *     UCHAR ChunkShift;
     *     UCHAR ClusterShift;
     *     UCHAR Reserved[3];
     * } *PFILE_COMPRESSION_INFO
     * }
     */
    public static final AddressLayout PFILE_COMPRESSION_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ATTRIBUTE_TAG_INFO {
     *     DWORD FileAttributes;
     *     DWORD ReparseTag;
     * } *PFILE_ATTRIBUTE_TAG_INFO
     * }
     */
    public static final AddressLayout PFILE_ATTRIBUTE_TAG_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO {
     *     BOOLEAN DeleteFileA;
     * } *PFILE_DISPOSITION_INFO
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO_EX {
     *     DWORD Flags;
     * } *PFILE_DISPOSITION_INFO_EX
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO_EX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_BOTH_DIR_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     DWORD FileAttributes;
     *     DWORD FileNameLength;
     *     DWORD EaSize;
     *     CCHAR ShortNameLength;
     *     WCHAR ShortName[12];
     *     LARGE_INTEGER FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_BOTH_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_BOTH_DIR_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_FULL_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     WCHAR FileName[1];
     * } *PFILE_FULL_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_FULL_DIR_INFO = freeglut_h.C_POINTER;
    private static final int IoPriorityHintVeryLow = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintVeryLow = 0
     * }
     */
    public static int IoPriorityHintVeryLow() {
        return IoPriorityHintVeryLow;
    }
    private static final int IoPriorityHintLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintLow = 1
     * }
     */
    public static int IoPriorityHintLow() {
        return IoPriorityHintLow;
    }
    private static final int IoPriorityHintNormal = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintNormal = 2
     * }
     */
    public static int IoPriorityHintNormal() {
        return IoPriorityHintNormal;
    }
    private static final int MaximumIoPriorityHintType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.MaximumIoPriorityHintType = 3
     * }
     */
    public static int MaximumIoPriorityHintType() {
        return MaximumIoPriorityHintType;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_IO_PRIORITY_HINT_INFO {
     *     PRIORITY_HINT PriorityHint;
     * } *PFILE_IO_PRIORITY_HINT_INFO
     * }
     */
    public static final AddressLayout PFILE_IO_PRIORITY_HINT_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALIGNMENT_INFO {
     *     ULONG AlignmentRequirement;
     * } *PFILE_ALIGNMENT_INFO
     * }
     */
    public static final AddressLayout PFILE_ALIGNMENT_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STORAGE_INFO {
     *     ULONG LogicalBytesPerSector;
     *     ULONG PhysicalBytesPerSectorForAtomicity;
     *     ULONG PhysicalBytesPerSectorForPerformance;
     *     ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
     *     ULONG Flags;
     *     ULONG ByteOffsetForSectorAlignment;
     *     ULONG ByteOffsetForPartitionAlignment;
     * } *PFILE_STORAGE_INFO
     * }
     */
    public static final AddressLayout PFILE_STORAGE_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_INFO {
     *     ULONGLONG VolumeSerialNumber;
     *     FILE_ID_128 FileId;
     * } *PFILE_ID_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_EXTD_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     ULONG ReparsePointTag;
     *     FILE_ID_128 FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_EXTD_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_EXTD_DIR_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_REMOTE_PROTOCOL_INFO {
     *     USHORT StructureVersion;
     *     USHORT StructureSize;
     *     ULONG Protocol;
     *     USHORT ProtocolMajorVersion;
     *     USHORT ProtocolMinorVersion;
     *     USHORT ProtocolRevision;
     *     USHORT Reserved;
     *     ULONG Flags;
     *     struct {
     *         ULONG Reserved[8];
     *     } GenericReserved;
     *     union {
     *         struct {
     *             struct {
     *                 ULONG Capabilities;
     *             } Server;
     *             struct {
     *                 ULONG Capabilities;
     *                 ULONG CachingFlags;
     *             } Share;
     *         } Smb2;
     *         ULONG Reserved[16];
     *     } ProtocolSpecific;
     * } *PFILE_REMOTE_PROTOCOL_INFO
     * }
     */
    public static final AddressLayout PFILE_REMOTE_PROTOCOL_INFO = freeglut_h.C_POINTER;

    private static class GetFileInformationByHandleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileInformationByHandleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandleEx$descriptor() {
        return GetFileInformationByHandleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle GetFileInformationByHandleEx$handle() {
        return GetFileInformationByHandleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MemorySegment GetFileInformationByHandleEx$address() {
        return GetFileInformationByHandleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int GetFileInformationByHandleEx(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = GetFileInformationByHandleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandleEx", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FileIdType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.FileIdType = 0
     * }
     */
    public static int FileIdType() {
        return FileIdType;
    }
    private static final int ObjectIdType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ObjectIdType = 1
     * }
     */
    public static int ObjectIdType() {
        return ObjectIdType;
    }
    private static final int ExtendedFileIdType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ExtendedFileIdType = 2
     * }
     */
    public static int ExtendedFileIdType() {
        return ExtendedFileIdType;
    }
    private static final int MaximumFileIdType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.MaximumFileIdType = 3
     * }
     */
    public static int MaximumFileIdType() {
        return MaximumFileIdType;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_ID_TYPE {
     *     FileIdType,
     *     ObjectIdType,
     *     ExtendedFileIdType,
     *     MaximumFileIdType
     * } *PFILE_ID_TYPE
     * }
     */
    public static final AddressLayout PFILE_ID_TYPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct FILE_ID_DESCRIPTOR {
     *     DWORD dwSize;
     *     FILE_ID_TYPE Type;
     *     union {
     *         LARGE_INTEGER FileId;
     *         GUID ObjectId;
     *         FILE_ID_128 ExtendedFileId;
     *     };
     * } *LPFILE_ID_DESCRIPTOR
     * }
     */
    public static final AddressLayout LPFILE_ID_DESCRIPTOR = freeglut_h.C_POINTER;

    private static class OpenFileById {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenFileById");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor OpenFileById$descriptor() {
        return OpenFileById.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle OpenFileById$handle() {
        return OpenFileById.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenFileById$address() {
        return OpenFileById.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenFileById(MemorySegment hVolumeHint, MemorySegment lpFileId, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwFlagsAndAttributes) {
        var mh$ = OpenFileById.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileById", hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSymbolicLinkA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkA$descriptor() {
        return CreateSymbolicLinkA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkA$handle() {
        return CreateSymbolicLinkA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CreateSymbolicLinkA$address() {
        return CreateSymbolicLinkA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkA", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSymbolicLinkW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkW$descriptor() {
        return CreateSymbolicLinkW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkW$handle() {
        return CreateSymbolicLinkW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CreateSymbolicLinkW$address() {
        return CreateSymbolicLinkW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkW", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryActCtxSettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryActCtxSettingsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxSettingsW$descriptor() {
        return QueryActCtxSettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxSettingsW$handle() {
        return QueryActCtxSettingsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static MemorySegment QueryActCtxSettingsW$address() {
        return QueryActCtxSettingsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static int QueryActCtxSettingsW(int dwFlags, MemorySegment hActCtx, MemorySegment settingsNameSpace, MemorySegment settingName, MemorySegment pvBuffer, long dwBuffer, MemorySegment pdwWrittenOrRequired) {
        var mh$ = QueryActCtxSettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxSettingsW", dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSymbolicLinkTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedA$descriptor() {
        return CreateSymbolicLinkTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedA$handle() {
        return CreateSymbolicLinkTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateSymbolicLinkTransactedA$address() {
        return CreateSymbolicLinkTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedA", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSymbolicLinkTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedW$descriptor() {
        return CreateSymbolicLinkTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedW$handle() {
        return CreateSymbolicLinkTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment CreateSymbolicLinkTransactedW$address() {
        return CreateSymbolicLinkTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedW", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplacePartitionUnit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReplacePartitionUnit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static FunctionDescriptor ReplacePartitionUnit$descriptor() {
        return ReplacePartitionUnit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static MethodHandle ReplacePartitionUnit$handle() {
        return ReplacePartitionUnit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static MemorySegment ReplacePartitionUnit$address() {
        return ReplacePartitionUnit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static int ReplacePartitionUnit(MemorySegment TargetPartition, MemorySegment SparePartition, int Flags) {
        var mh$ = ReplacePartitionUnit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplacePartitionUnit", TargetPartition, SparePartition, Flags);
            }
            return (int)mh$.invokeExact(TargetPartition, SparePartition, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddSecureMemoryCacheCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor AddSecureMemoryCacheCallback$descriptor() {
        return AddSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle AddSecureMemoryCacheCallback$handle() {
        return AddSecureMemoryCacheCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MemorySegment AddSecureMemoryCacheCallback$address() {
        return AddSecureMemoryCacheCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int AddSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = AddSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveSecureMemoryCacheCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor RemoveSecureMemoryCacheCallback$descriptor() {
        return RemoveSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle RemoveSecureMemoryCacheCallback$handle() {
        return RemoveSecureMemoryCacheCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MemorySegment RemoveSecureMemoryCacheCallback$address() {
        return RemoveSecureMemoryCacheCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int RemoveSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = RemoveSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static FunctionDescriptor CopyContext$descriptor() {
        return CopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static MethodHandle CopyContext$handle() {
        return CopyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static MemorySegment CopyContext$address() {
        return CopyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static int CopyContext(MemorySegment Destination, int ContextFlags, MemorySegment Source) {
        var mh$ = CopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyContext", Destination, ContextFlags, Source);
            }
            return (int)mh$.invokeExact(Destination, ContextFlags, Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static FunctionDescriptor InitializeContext$descriptor() {
        return InitializeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static MethodHandle InitializeContext$handle() {
        return InitializeContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static MemorySegment InitializeContext$address() {
        return InitializeContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static int InitializeContext(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength) {
        var mh$ = InitializeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext", Buffer, ContextFlags, Context, ContextLength);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeContext2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static FunctionDescriptor InitializeContext2$descriptor() {
        return InitializeContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static MethodHandle InitializeContext2$handle() {
        return InitializeContext2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static MemorySegment InitializeContext2$address() {
        return InitializeContext2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static int InitializeContext2(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength, long XStateCompactionMask) {
        var mh$ = InitializeContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext2", Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnabledXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnabledXStateFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static FunctionDescriptor GetEnabledXStateFeatures$descriptor() {
        return GetEnabledXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static MethodHandle GetEnabledXStateFeatures$handle() {
        return GetEnabledXStateFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static MemorySegment GetEnabledXStateFeatures$address() {
        return GetEnabledXStateFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static long GetEnabledXStateFeatures() {
        var mh$ = GetEnabledXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnabledXStateFeatures");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetXStateFeaturesMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor GetXStateFeaturesMask$descriptor() {
        return GetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static MethodHandle GetXStateFeaturesMask$handle() {
        return GetXStateFeaturesMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static MemorySegment GetXStateFeaturesMask$address() {
        return GetXStateFeaturesMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static int GetXStateFeaturesMask(MemorySegment Context, MemorySegment FeatureMask) {
        var mh$ = GetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocateXStateFeature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocateXStateFeature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static FunctionDescriptor LocateXStateFeature$descriptor() {
        return LocateXStateFeature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MethodHandle LocateXStateFeature$handle() {
        return LocateXStateFeature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MemorySegment LocateXStateFeature$address() {
        return LocateXStateFeature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MemorySegment LocateXStateFeature(MemorySegment Context, int FeatureId, MemorySegment Length) {
        var mh$ = LocateXStateFeature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocateXStateFeature", Context, FeatureId, Length);
            }
            return (MemorySegment)mh$.invokeExact(Context, FeatureId, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetXStateFeaturesMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor SetXStateFeaturesMask$descriptor() {
        return SetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static MethodHandle SetXStateFeaturesMask$handle() {
        return SetXStateFeaturesMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static MemorySegment SetXStateFeaturesMask$address() {
        return SetXStateFeaturesMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static int SetXStateFeaturesMask(MemorySegment Context, long FeatureMask) {
        var mh$ = SetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnableThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor EnableThreadProfiling$descriptor() {
        return EnableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static MethodHandle EnableThreadProfiling$handle() {
        return EnableThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static MemorySegment EnableThreadProfiling$address() {
        return EnableThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static int EnableThreadProfiling(MemorySegment ThreadHandle, int Flags, long HardwareCounters, MemorySegment PerformanceDataHandle) {
        var mh$ = EnableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableThreadProfiling", ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DisableThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor DisableThreadProfiling$descriptor() {
        return DisableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static MethodHandle DisableThreadProfiling$handle() {
        return DisableThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static MemorySegment DisableThreadProfiling$address() {
        return DisableThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static int DisableThreadProfiling(MemorySegment PerformanceDataHandle) {
        var mh$ = DisableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableThreadProfiling", PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryThreadProfiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static FunctionDescriptor QueryThreadProfiling$descriptor() {
        return QueryThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static MethodHandle QueryThreadProfiling$handle() {
        return QueryThreadProfiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static MemorySegment QueryThreadProfiling$address() {
        return QueryThreadProfiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static int QueryThreadProfiling(MemorySegment ThreadHandle, MemorySegment Enabled) {
        var mh$ = QueryThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadProfiling", ThreadHandle, Enabled);
            }
            return (int)mh$.invokeExact(ThreadHandle, Enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadThreadProfilingData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadThreadProfilingData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static FunctionDescriptor ReadThreadProfilingData$descriptor() {
        return ReadThreadProfilingData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static MethodHandle ReadThreadProfilingData$handle() {
        return ReadThreadProfilingData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static MemorySegment ReadThreadProfilingData$address() {
        return ReadThreadProfilingData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static int ReadThreadProfilingData(MemorySegment PerformanceDataHandle, int Flags, MemorySegment PerformanceData) {
        var mh$ = ReadThreadProfilingData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadThreadProfilingData", PerformanceDataHandle, Flags, PerformanceData);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle, Flags, PerformanceData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseCustomSystemEventTrigger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RaiseCustomSystemEventTrigger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static FunctionDescriptor RaiseCustomSystemEventTrigger$descriptor() {
        return RaiseCustomSystemEventTrigger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static MethodHandle RaiseCustomSystemEventTrigger$handle() {
        return RaiseCustomSystemEventTrigger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static MemorySegment RaiseCustomSystemEventTrigger$address() {
        return RaiseCustomSystemEventTrigger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static int RaiseCustomSystemEventTrigger(MemorySegment CustomSystemEventTriggerConfig) {
        var mh$ = RaiseCustomSystemEventTrigger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseCustomSystemEventTrigger", CustomSystemEventTriggerConfig);
            }
            return (int)mh$.invokeExact(CustomSystemEventTriggerConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DRAWPATRECT {
     *     POINT ptPosition;
     *     POINT ptSize;
     *     WORD wStyle;
     *     WORD wPattern;
     * } *PDRAWPATRECT
     * }
     */
    public static final AddressLayout PDRAWPATRECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSINJECTDATA {
     *     DWORD DataBytes;
     *     WORD InjectionPoint;
     *     WORD PageNumber;
     * } *PPSINJECTDATA
     * }
     */
    public static final AddressLayout PPSINJECTDATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_OUTPUT {
     *     BOOL bPageIndependent;
     *     BOOL bSetPageDevice;
     * } *PPSFEATURE_OUTPUT
     * }
     */
    public static final AddressLayout PPSFEATURE_OUTPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_CUSTPAPER {
     *     LONG lOrientation;
     *     LONG lWidth;
     *     LONG lHeight;
     *     LONG lWidthOffset;
     *     LONG lHeightOffset;
     * } *PPSFEATURE_CUSTPAPER
     * }
     */
    public static final AddressLayout PPSFEATURE_CUSTPAPER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *PXFORM
     * }
     */
    public static final AddressLayout PXFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *LPXFORM
     * }
     */
    public static final AddressLayout LPXFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *PBITMAP
     * }
     */
    public static final AddressLayout PBITMAP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *NPBITMAP
     * }
     */
    public static final AddressLayout NPBITMAP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *LPBITMAP
     * }
     */
    public static final AddressLayout LPBITMAP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *PRGBTRIPLE
     * }
     */
    public static final AddressLayout PRGBTRIPLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *NPRGBTRIPLE
     * }
     */
    public static final AddressLayout NPRGBTRIPLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *LPRGBTRIPLE
     * }
     */
    public static final AddressLayout LPRGBTRIPLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RGBQUAD *LPRGBQUAD
     * }
     */
    public static final AddressLayout LPRGBQUAD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSCSTYPE
     * }
     */
    public static final OfInt LCSCSTYPE = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSGAMUTMATCH
     * }
     */
    public static final OfInt LCSGAMUTMATCH = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long FXPT16DOT16
     * }
     */
    public static final OfInt FXPT16DOT16 = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT16DOT16
     * }
     */
    public static final AddressLayout LPFXPT16DOT16 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long FXPT2DOT30
     * }
     */
    public static final OfInt FXPT2DOT30 = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT2DOT30
     * }
     */
    public static final AddressLayout LPFXPT2DOT30 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZ *LPCIEXYZ
     * }
     */
    public static final AddressLayout LPCIEXYZ = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZTRIPLE *LPCIEXYZTRIPLE
     * }
     */
    public static final AddressLayout LPCIEXYZTRIPLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEA {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     CHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEA
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEW {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     WCHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEW
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *LPBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout LPBITMAPCOREHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *PBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout PBITMAPCOREHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *LPBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout LPBITMAPINFOHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *PBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout PBITMAPINFOHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *LPBITMAPV4HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV4HEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *PBITMAPV4HEADER
     * }
     */
    public static final AddressLayout PBITMAPV4HEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *LPBITMAPV5HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV5HEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *PBITMAPV5HEADER
     * }
     */
    public static final AddressLayout PBITMAPV5HEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *LPBITMAPINFO
     * }
     */
    public static final AddressLayout LPBITMAPINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *PBITMAPINFO
     * }
     */
    public static final AddressLayout PBITMAPINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *LPBITMAPCOREINFO
     * }
     */
    public static final AddressLayout LPBITMAPCOREINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *PBITMAPCOREINFO
     * }
     */
    public static final AddressLayout PBITMAPCOREINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *LPBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout LPBITMAPFILEHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *PBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout PBITMAPFILEHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *PFONTSIGNATURE
     * }
     */
    public static final AddressLayout PFONTSIGNATURE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *LPFONTSIGNATURE
     * }
     */
    public static final AddressLayout LPFONTSIGNATURE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *PCHARSETINFO
     * }
     */
    public static final AddressLayout PCHARSETINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *NPCHARSETINFO
     * }
     */
    public static final AddressLayout NPCHARSETINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *LPCHARSETINFO
     * }
     */
    public static final AddressLayout LPCHARSETINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *PLOCALESIGNATURE
     * }
     */
    public static final AddressLayout PLOCALESIGNATURE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *LPLOCALESIGNATURE
     * }
     */
    public static final AddressLayout LPLOCALESIGNATURE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *PHANDLETABLE
     * }
     */
    public static final AddressLayout PHANDLETABLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *LPHANDLETABLE
     * }
     */
    public static final AddressLayout LPHANDLETABLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *PMETARECORD
     * }
     */
    public static final AddressLayout PMETARECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *LPMETARECORD
     * }
     */
    public static final AddressLayout LPMETARECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMETAFILEPICT {
     *     LONG mm;
     *     LONG xExt;
     *     LONG yExt;
     *     HMETAFILE hMF;
     * } *LPMETAFILEPICT
     * }
     */
    public static final AddressLayout LPMETAFILEPICT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *PMETAHEADER
     * }
     */
    public static final AddressLayout PMETAHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *LPMETAHEADER
     * }
     */
    public static final AddressLayout LPMETAHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *PENHMETARECORD
     * }
     */
    public static final AddressLayout PENHMETARECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *LPENHMETARECORD
     * }
     */
    public static final AddressLayout LPENHMETARECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *PENHMETAHEADER
     * }
     */
    public static final AddressLayout PENHMETAHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *LPENHMETAHEADER
     * }
     */
    public static final AddressLayout LPENHMETAHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BYTE BCHAR
     * }
     */
    public static final OfByte BCHAR = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICA
     * }
     */
    public static final AddressLayout PTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICA
     * }
     */
    public static final AddressLayout NPTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICA
     * }
     */
    public static final AddressLayout LPTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICW
     * }
     */
    public static final AddressLayout PTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICW
     * }
     */
    public static final AddressLayout NPTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICW
     * }
     */
    public static final AddressLayout LPTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PTEXTMETRICA PTEXTMETRIC
     * }
     */
    public static final AddressLayout PTEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPTEXTMETRICA NPTEXTMETRIC
     * }
     */
    public static final AddressLayout NPTEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPTEXTMETRICA LPTEXTMETRIC
     * }
     */
    public static final AddressLayout LPTEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNEWTEXTMETRICA PNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout PNEWTEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *PPELARRAY
     * }
     */
    public static final AddressLayout PPELARRAY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *NPPELARRAY
     * }
     */
    public static final AddressLayout NPPELARRAY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *LPPELARRAY
     * }
     */
    public static final AddressLayout LPPELARRAY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *PLOGBRUSH
     * }
     */
    public static final AddressLayout PLOGBRUSH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *NPLOGBRUSH
     * }
     */
    public static final AddressLayout NPLOGBRUSH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *LPLOGBRUSH
     * }
     */
    public static final AddressLayout LPLOGBRUSH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *PLOGBRUSH32
     * }
     */
    public static final AddressLayout PLOGBRUSH32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *NPLOGBRUSH32
     * }
     */
    public static final AddressLayout NPLOGBRUSH32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *LPLOGBRUSH32
     * }
     */
    public static final AddressLayout LPLOGBRUSH32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *PPATTERN
     * }
     */
    public static final AddressLayout PPATTERN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *NPPATTERN
     * }
     */
    public static final AddressLayout NPPATTERN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *LPPATTERN
     * }
     */
    public static final AddressLayout LPPATTERN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *PLOGPEN
     * }
     */
    public static final AddressLayout PLOGPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *NPLOGPEN
     * }
     */
    public static final AddressLayout NPLOGPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *LPLOGPEN
     * }
     */
    public static final AddressLayout LPLOGPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN
     * }
     */
    public static final AddressLayout PEXTLOGPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN
     * }
     */
    public static final AddressLayout NPEXTLOGPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN
     * }
     */
    public static final AddressLayout LPEXTLOGPEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN32
     * }
     */
    public static final AddressLayout PEXTLOGPEN32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN32
     * }
     */
    public static final AddressLayout NPEXTLOGPEN32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN32
     * }
     */
    public static final AddressLayout LPEXTLOGPEN32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *PPALETTEENTRY
     * }
     */
    public static final AddressLayout PPALETTEENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *LPPALETTEENTRY
     * }
     */
    public static final AddressLayout LPPALETTEENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *PLOGPALETTE
     * }
     */
    public static final AddressLayout PLOGPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *NPLOGPALETTE
     * }
     */
    public static final AddressLayout NPLOGPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *LPLOGPALETTE
     * }
     */
    public static final AddressLayout LPLOGPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *PLOGFONTA
     * }
     */
    public static final AddressLayout PLOGFONTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *NPLOGFONTA
     * }
     */
    public static final AddressLayout NPLOGFONTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *LPLOGFONTA
     * }
     */
    public static final AddressLayout LPLOGFONTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *PLOGFONTW
     * }
     */
    public static final AddressLayout PLOGFONTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *NPLOGFONTW
     * }
     */
    public static final AddressLayout NPLOGFONTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *LPLOGFONTW
     * }
     */
    public static final AddressLayout LPLOGFONTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PLOGFONTA PLOGFONT
     * }
     */
    public static final AddressLayout PLOGFONT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPLOGFONTA NPLOGFONT
     * }
     */
    public static final AddressLayout NPLOGFONT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGFONTA LPLOGFONT
     * }
     */
    public static final AddressLayout LPLOGFONT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     * } *LPENUMLOGFONTA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     * } *LPENUMLOGFONTW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTA LPENUMLOGFONT
     * }
     */
    public static final AddressLayout LPENUMLOGFONT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     BYTE elfScript[32];
     * } *LPENUMLOGFONTEXA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     WCHAR elfScript[32];
     * } *LPENUMLOGFONTEXW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPANOSE {
     *     BYTE bFamilyType;
     *     BYTE bSerifStyle;
     *     BYTE bWeight;
     *     BYTE bProportion;
     *     BYTE bContrast;
     *     BYTE bStrokeVariation;
     *     BYTE bArmStyle;
     *     BYTE bLetterform;
     *     BYTE bMidline;
     *     BYTE bXHeight;
     * } *LPPANOSE
     * }
     */
    public static final AddressLayout LPPANOSE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTA
     * }
     */
    public static final AddressLayout PEXTLOGFONTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTA
     * }
     */
    public static final AddressLayout NPEXTLOGFONTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTA
     * }
     */
    public static final AddressLayout LPEXTLOGFONTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTW
     * }
     */
    public static final AddressLayout PEXTLOGFONTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTW
     * }
     */
    public static final AddressLayout NPEXTLOGFONTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTW
     * }
     */
    public static final AddressLayout LPEXTLOGFONTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXTLOGFONTA PEXTLOGFONT
     * }
     */
    public static final AddressLayout PEXTLOGFONT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPEXTLOGFONTA NPEXTLOGFONT
     * }
     */
    public static final AddressLayout NPEXTLOGFONT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPEXTLOGFONTA LPEXTLOGFONT
     * }
     */
    public static final AddressLayout LPEXTLOGFONT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEA
     * }
     */
    public static final AddressLayout PDEVMODEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEA
     * }
     */
    public static final AddressLayout NPDEVMODEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEA
     * }
     */
    public static final AddressLayout LPDEVMODEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEW
     * }
     */
    public static final AddressLayout PDEVMODEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEW
     * }
     */
    public static final AddressLayout NPDEVMODEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEW
     * }
     */
    public static final AddressLayout LPDEVMODEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDEVMODEA PDEVMODE
     * }
     */
    public static final AddressLayout PDEVMODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPDEVMODEA NPDEVMODE
     * }
     */
    public static final AddressLayout NPDEVMODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDEVMODEA LPDEVMODE
     * }
     */
    public static final AddressLayout LPDEVMODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICE = freeglut_h.C_POINTER;
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = -2147483648
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCALING_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_IDENTITY() {
        return DISPLAYCONFIG_SCALING_IDENTITY;
    }
    private static final int DISPLAYCONFIG_SCALING_CENTERED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CENTERED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CENTERED() {
        return DISPLAYCONFIG_SCALING_CENTERED;
    }
    private static final int DISPLAYCONFIG_SCALING_STRETCHED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_STRETCHED = 3
     * }
     */
    public static int DISPLAYCONFIG_SCALING_STRETCHED() {
        return DISPLAYCONFIG_SCALING_STRETCHED;
    }
    private static final int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4
     * }
     */
    public static int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX() {
        return DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX;
    }
    private static final int DISPLAYCONFIG_SCALING_CUSTOM = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CUSTOM = 5
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CUSTOM() {
        return DISPLAYCONFIG_SCALING_CUSTOM;
    }
    private static final int DISPLAYCONFIG_SCALING_PREFERRED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_PREFERRED = 128
     * }
     */
    public static int DISPLAYCONFIG_SCALING_PREFERRED() {
        return DISPLAYCONFIG_SCALING_PREFERRED;
    }
    private static final int DISPLAYCONFIG_SCALING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCALING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_ROTATION_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_IDENTITY() {
        return DISPLAYCONFIG_ROTATION_IDENTITY;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE90 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE90 = 2
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE90() {
        return DISPLAYCONFIG_ROTATION_ROTATE90;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE180 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE180 = 3
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE180() {
        return DISPLAYCONFIG_ROTATION_ROTATE180;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE270 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE270 = 4
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE270() {
        return DISPLAYCONFIG_ROTATION_ROTATE270;
    }
    private static final int DISPLAYCONFIG_ROTATION_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_FORCE_UINT32() {
        return DISPLAYCONFIG_ROTATION_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_TARGET;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_8BPP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_8BPP = 1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_8BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_8BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_16BPP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_16BPP = 2
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_16BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_16BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_24BPP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_24BPP = 3
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_24BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_24BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_32BPP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_32BPP = 4
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_32BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_32BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_NONGDI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_NONGDI() {
        return DISPLAYCONFIG_PIXELFORMAT_NONGDI;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32() {
        return DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_INTERNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_INTERNAL = 1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_INTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_CLONE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_CLONE = 2
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_CLONE() {
        return DISPLAYCONFIG_TOPOLOGY_CLONE;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTEND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTEND = 4
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTEND() {
        return DISPLAYCONFIG_TOPOLOGY_EXTEND;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTERNAL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 8
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32() {
        return DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_RGB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_RGB = 0
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_RGB() {
        return DISPLAYCONFIG_COLOR_ENCODING_RGB;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR444;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR422;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR420;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY() {
        return DISPLAYCONFIG_COLOR_ENCODING_INTENSITY;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32() {
        return DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATAHEADER {
     *     DWORD dwSize;
     *     DWORD iType;
     *     DWORD nCount;
     *     DWORD nRgnSize;
     *     RECT rcBound;
     * } *PRGNDATAHEADER
     * }
     */
    public static final AddressLayout PRGNDATAHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *PRGNDATA
     * }
     */
    public static final AddressLayout PRGNDATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *NPRGNDATA
     * }
     */
    public static final AddressLayout NPRGNDATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *LPRGNDATA
     * }
     */
    public static final AddressLayout LPRGNDATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *PABC
     * }
     */
    public static final AddressLayout PABC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *NPABC
     * }
     */
    public static final AddressLayout NPABC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *LPABC
     * }
     */
    public static final AddressLayout LPABC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *PABCFLOAT
     * }
     */
    public static final AddressLayout PABCFLOAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *NPABCFLOAT
     * }
     */
    public static final AddressLayout NPABCFLOAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *LPABCFLOAT
     * }
     */
    public static final AddressLayout LPABCFLOAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTA
     * }
     */
    public static final AddressLayout PPOLYTEXTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTA
     * }
     */
    public static final AddressLayout NPPOLYTEXTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTA
     * }
     */
    public static final AddressLayout LPPOLYTEXTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTW
     * }
     */
    public static final AddressLayout PPOLYTEXTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTW
     * }
     */
    public static final AddressLayout NPPOLYTEXTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTW
     * }
     */
    public static final AddressLayout LPPOLYTEXTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PPOLYTEXTA PPOLYTEXT
     * }
     */
    public static final AddressLayout PPOLYTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPPOLYTEXTA NPPOLYTEXT
     * }
     */
    public static final AddressLayout NPPOLYTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPPOLYTEXTA LPPOLYTEXT
     * }
     */
    public static final AddressLayout LPPOLYTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MAT2 {
     *     FIXED eM11;
     *     FIXED eM12;
     *     FIXED eM21;
     *     FIXED eM22;
     * } *LPMAT2
     * }
     */
    public static final AddressLayout LPMAT2 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICS {
     *     UINT gmBlackBoxX;
     *     UINT gmBlackBoxY;
     *     POINT gmptGlyphOrigin;
     *     short gmCellIncX;
     *     short gmCellIncY;
     * } *LPGLYPHMETRICS
     * }
     */
    public static final AddressLayout LPGLYPHMETRICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTFX {
     *     FIXED x;
     *     FIXED y;
     * } *LPPOINTFX
     * }
     */
    public static final AddressLayout LPPOINTFX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYCURVE {
     *     WORD wType;
     *     WORD cpfx;
     *     POINTFX apfx[1];
     * } *LPTTPOLYCURVE
     * }
     */
    public static final AddressLayout LPTTPOLYCURVE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYGONHEADER {
     *     DWORD cb;
     *     DWORD dwType;
     *     POINTFX pfxStart;
     * } *LPTTPOLYGONHEADER
     * }
     */
    public static final AddressLayout LPTTPOLYGONHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSA {
     *     DWORD lStructSize;
     *     LPSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSA
     * }
     */
    public static final AddressLayout LPGCP_RESULTSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSW {
     *     DWORD lStructSize;
     *     LPWSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSW
     * }
     */
    public static final AddressLayout LPGCP_RESULTSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPGCP_RESULTSA LPGCP_RESULTS
     * }
     */
    public static final AddressLayout LPGCP_RESULTS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RASTERIZER_STATUS {
     *     short nSize;
     *     short wFlags;
     *     short nLanguageID;
     * } *LPRASTERIZER_STATUS
     * }
     */
    public static final AddressLayout LPRASTERIZER_STATUS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *PPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout PPIXELFORMATDESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *LPPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout LPPIXELFORMATDESCRIPTOR = freeglut_h.C_POINTER;

    private static class AddFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceA$descriptor() {
        return AddFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static MethodHandle AddFontResourceA$handle() {
        return AddFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static MemorySegment AddFontResourceA$address() {
        return AddFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static int AddFontResourceA(MemorySegment x0) {
        var mh$ = AddFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceW$descriptor() {
        return AddFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static MethodHandle AddFontResourceW$handle() {
        return AddFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static MemorySegment AddFontResourceW$address() {
        return AddFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static int AddFontResourceW(MemorySegment x0) {
        var mh$ = AddFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AnimatePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static FunctionDescriptor AnimatePalette$descriptor() {
        return AnimatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static MethodHandle AnimatePalette$handle() {
        return AnimatePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static MemorySegment AnimatePalette$address() {
        return AnimatePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static int AnimatePalette(MemorySegment hPal, int iStartIndex, int cEntries, MemorySegment ppe) {
        var mh$ = AnimatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimatePalette", hPal, iStartIndex, cEntries, ppe);
            }
            return (int)mh$.invokeExact(hPal, iStartIndex, cEntries, ppe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Arc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Arc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Arc$descriptor() {
        return Arc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Arc$handle() {
        return Arc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MemorySegment Arc$address() {
        return Arc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Arc(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Arc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Arc", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BitBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BitBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static FunctionDescriptor BitBlt$descriptor() {
        return BitBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static MethodHandle BitBlt$handle() {
        return BitBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static MemorySegment BitBlt$address() {
        return BitBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static int BitBlt(MemorySegment hdc, int x, int y, int cx, int cy, MemorySegment hdcSrc, int x1, int y1, int rop) {
        var mh$ = BitBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BitBlt", hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CancelDC$descriptor() {
        return CancelDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static MethodHandle CancelDC$handle() {
        return CancelDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static MemorySegment CancelDC$address() {
        return CancelDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static int CancelDC(MemorySegment hdc) {
        var mh$ = CancelDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Chord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Chord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Chord$descriptor() {
        return Chord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Chord$handle() {
        return Chord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MemorySegment Chord$address() {
        return Chord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Chord(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Chord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Chord", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChoosePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChoosePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor ChoosePixelFormat$descriptor() {
        return ChoosePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle ChoosePixelFormat$handle() {
        return ChoosePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment ChoosePixelFormat$address() {
        return ChoosePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int ChoosePixelFormat(MemorySegment hdc, MemorySegment ppfd) {
        var mh$ = ChoosePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChoosePixelFormat", hdc, ppfd);
            }
            return (int)mh$.invokeExact(hdc, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseMetaFile$descriptor() {
        return CloseMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseMetaFile$handle() {
        return CloseMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseMetaFile$address() {
        return CloseMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseMetaFile(MemorySegment hdc) {
        var mh$ = CloseMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CombineRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static FunctionDescriptor CombineRgn$descriptor() {
        return CombineRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static MethodHandle CombineRgn$handle() {
        return CombineRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static MemorySegment CombineRgn$address() {
        return CombineRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static int CombineRgn(MemorySegment hrgnDst, MemorySegment hrgnSrc1, MemorySegment hrgnSrc2, int iMode) {
        var mh$ = CombineRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineRgn", hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
            }
            return (int)mh$.invokeExact(hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileA$descriptor() {
        return CopyMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MethodHandle CopyMetaFileA$handle() {
        return CopyMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MemorySegment CopyMetaFileA$address() {
        return CopyMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MemorySegment CopyMetaFileA(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileA", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileW$descriptor() {
        return CopyMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MethodHandle CopyMetaFileW$handle() {
        return CopyMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MemorySegment CopyMetaFileW$address() {
        return CopyMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MemorySegment CopyMetaFileW(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileW", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static FunctionDescriptor CreateBitmap$descriptor() {
        return CreateBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MethodHandle CreateBitmap$handle() {
        return CreateBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MemorySegment CreateBitmap$address() {
        return CreateBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MemorySegment CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitCount, MemorySegment lpBits) {
        var mh$ = CreateBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmap", nWidth, nHeight, nPlanes, nBitCount, lpBits);
            }
            return (MemorySegment)mh$.invokeExact(nWidth, nHeight, nPlanes, nBitCount, lpBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmapIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateBitmapIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static FunctionDescriptor CreateBitmapIndirect$descriptor() {
        return CreateBitmapIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MethodHandle CreateBitmapIndirect$handle() {
        return CreateBitmapIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MemorySegment CreateBitmapIndirect$address() {
        return CreateBitmapIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MemorySegment CreateBitmapIndirect(MemorySegment pbm) {
        var mh$ = CreateBitmapIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmapIndirect", pbm);
            }
            return (MemorySegment)mh$.invokeExact(pbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBrushIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateBrushIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static FunctionDescriptor CreateBrushIndirect$descriptor() {
        return CreateBrushIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MethodHandle CreateBrushIndirect$handle() {
        return CreateBrushIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MemorySegment CreateBrushIndirect$address() {
        return CreateBrushIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MemorySegment CreateBrushIndirect(MemorySegment plbrush) {
        var mh$ = CreateBrushIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBrushIndirect", plbrush);
            }
            return (MemorySegment)mh$.invokeExact(plbrush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateCompatibleBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateCompatibleBitmap$descriptor() {
        return CreateCompatibleBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateCompatibleBitmap$handle() {
        return CreateCompatibleBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateCompatibleBitmap$address() {
        return CreateCompatibleBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateCompatibleBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateCompatibleBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDiscardableBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDiscardableBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateDiscardableBitmap$descriptor() {
        return CreateDiscardableBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateDiscardableBitmap$handle() {
        return CreateDiscardableBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateDiscardableBitmap$address() {
        return CreateDiscardableBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateDiscardableBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateDiscardableBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDiscardableBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateCompatibleDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateCompatibleDC$descriptor() {
        return CreateCompatibleDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MethodHandle CreateCompatibleDC$handle() {
        return CreateCompatibleDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MemorySegment CreateCompatibleDC$address() {
        return CreateCompatibleDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MemorySegment CreateCompatibleDC(MemorySegment hdc) {
        var mh$ = CreateCompatibleDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleDC", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDCA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCA$descriptor() {
        return CreateDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateDCA$handle() {
        return CreateDCA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateDCA$address() {
        return CreateDCA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateDCA(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCA", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCW$descriptor() {
        return CreateDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateDCW$handle() {
        return CreateDCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateDCW$address() {
        return CreateDCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateDCW(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCW", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDIBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBitmap$descriptor() {
        return CreateDIBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBitmap$handle() {
        return CreateDIBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBitmap$address() {
        return CreateDIBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBitmap(MemorySegment hdc, MemorySegment pbmih, int flInit, MemorySegment pjBits, MemorySegment pbmi, int iUsage) {
        var mh$ = CreateDIBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBitmap", hdc, pbmih, flInit, pjBits, pbmi, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmih, flInit, pjBits, pbmi, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDIBPatternBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrush$descriptor() {
        return CreateDIBPatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrush$handle() {
        return CreateDIBPatternBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrush$address() {
        return CreateDIBPatternBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrush(MemorySegment h, int iUsage) {
        var mh$ = CreateDIBPatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrush", h, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(h, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrushPt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDIBPatternBrushPt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrushPt$descriptor() {
        return CreateDIBPatternBrushPt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrushPt$handle() {
        return CreateDIBPatternBrushPt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrushPt$address() {
        return CreateDIBPatternBrushPt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrushPt(MemorySegment lpPackedDIB, int iUsage) {
        var mh$ = CreateDIBPatternBrushPt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrushPt", lpPackedDIB, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(lpPackedDIB, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEllipticRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgn$descriptor() {
        return CreateEllipticRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateEllipticRgn$handle() {
        return CreateEllipticRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateEllipticRgn$address() {
        return CreateEllipticRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateEllipticRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateEllipticRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEllipticRgnIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgnIndirect$descriptor() {
        return CreateEllipticRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateEllipticRgnIndirect$handle() {
        return CreateEllipticRgnIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateEllipticRgnIndirect$address() {
        return CreateEllipticRgnIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateEllipticRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateEllipticRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFontIndirectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectA$descriptor() {
        return CreateFontIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectA$handle() {
        return CreateFontIndirectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectA$address() {
        return CreateFontIndirectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectA(MemorySegment lplf) {
        var mh$ = CreateFontIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectA", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFontIndirectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectW$descriptor() {
        return CreateFontIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectW$handle() {
        return CreateFontIndirectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectW$address() {
        return CreateFontIndirectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectW(MemorySegment lplf) {
        var mh$ = CreateFontIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectW", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontA$descriptor() {
        return CreateFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontA$handle() {
        return CreateFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontA$address() {
        return CreateFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontA", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontW$descriptor() {
        return CreateFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontW$handle() {
        return CreateFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontW$address() {
        return CreateFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontW", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHatchBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateHatchBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateHatchBrush$descriptor() {
        return CreateHatchBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MethodHandle CreateHatchBrush$handle() {
        return CreateHatchBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MemorySegment CreateHatchBrush$address() {
        return CreateHatchBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MemorySegment CreateHatchBrush(int iHatch, int color) {
        var mh$ = CreateHatchBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHatchBrush", iHatch, color);
            }
            return (MemorySegment)mh$.invokeExact(iHatch, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateICA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateICA$descriptor() {
        return CreateICA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateICA$handle() {
        return CreateICA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateICA$address() {
        return CreateICA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateICA(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICA", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateICW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateICW$descriptor() {
        return CreateICW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateICW$handle() {
        return CreateICW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateICW$address() {
        return CreateICW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateICW(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICW", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileA$descriptor() {
        return CreateMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileA$handle() {
        return CreateMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileA$address() {
        return CreateMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileA(MemorySegment pszFile) {
        var mh$ = CreateMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileA", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileW$descriptor() {
        return CreateMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileW$handle() {
        return CreateMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileW$address() {
        return CreateMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileW(MemorySegment pszFile) {
        var mh$ = CreateMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileW", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static FunctionDescriptor CreatePalette$descriptor() {
        return CreatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MethodHandle CreatePalette$handle() {
        return CreatePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MemorySegment CreatePalette$address() {
        return CreatePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MemorySegment CreatePalette(MemorySegment plpal) {
        var mh$ = CreatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePalette", plpal);
            }
            return (MemorySegment)mh$.invokeExact(plpal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreatePen$descriptor() {
        return CreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MethodHandle CreatePen$handle() {
        return CreatePen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MemorySegment CreatePen$address() {
        return CreatePen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MemorySegment CreatePen(int iStyle, int cWidth, int color) {
        var mh$ = CreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePen", iStyle, cWidth, color);
            }
            return (MemorySegment)mh$.invokeExact(iStyle, cWidth, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePenIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePenIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static FunctionDescriptor CreatePenIndirect$descriptor() {
        return CreatePenIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MethodHandle CreatePenIndirect$handle() {
        return CreatePenIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MemorySegment CreatePenIndirect$address() {
        return CreatePenIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MemorySegment CreatePenIndirect(MemorySegment plpen) {
        var mh$ = CreatePenIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePenIndirect", plpen);
            }
            return (MemorySegment)mh$.invokeExact(plpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolyPolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePolyPolygonRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolyPolygonRgn$descriptor() {
        return CreatePolyPolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MethodHandle CreatePolyPolygonRgn$handle() {
        return CreatePolyPolygonRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MemorySegment CreatePolyPolygonRgn$address() {
        return CreatePolyPolygonRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MemorySegment CreatePolyPolygonRgn(MemorySegment pptl, MemorySegment pc, int cPoly, int iMode) {
        var mh$ = CreatePolyPolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolyPolygonRgn", pptl, pc, cPoly, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, pc, cPoly, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePatternBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static FunctionDescriptor CreatePatternBrush$descriptor() {
        return CreatePatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MethodHandle CreatePatternBrush$handle() {
        return CreatePatternBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MemorySegment CreatePatternBrush$address() {
        return CreatePatternBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MemorySegment CreatePatternBrush(MemorySegment hbm) {
        var mh$ = CreatePatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePatternBrush", hbm);
            }
            return (MemorySegment)mh$.invokeExact(hbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateRectRgn$descriptor() {
        return CreateRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateRectRgn$handle() {
        return CreateRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateRectRgn$address() {
        return CreateRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateRectRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateRectRgnIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateRectRgnIndirect$descriptor() {
        return CreateRectRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateRectRgnIndirect$handle() {
        return CreateRectRgnIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateRectRgnIndirect$address() {
        return CreateRectRgnIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateRectRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateRectRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRoundRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateRoundRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static FunctionDescriptor CreateRoundRectRgn$descriptor() {
        return CreateRoundRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MethodHandle CreateRoundRectRgn$handle() {
        return CreateRoundRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MemorySegment CreateRoundRectRgn$address() {
        return CreateRoundRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MemorySegment CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h) {
        var mh$ = CreateRoundRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRoundRectRgn", x1, y1, x2, y2, w, h);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateScalableFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceA$descriptor() {
        return CreateScalableFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceA$handle() {
        return CreateScalableFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static MemorySegment CreateScalableFontResourceA$address() {
        return CreateScalableFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceA(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceA", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateScalableFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceW$descriptor() {
        return CreateScalableFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceW$handle() {
        return CreateScalableFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static MemorySegment CreateScalableFontResourceW$address() {
        return CreateScalableFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceW(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceW", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSolidBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSolidBrush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateSolidBrush$descriptor() {
        return CreateSolidBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MethodHandle CreateSolidBrush$handle() {
        return CreateSolidBrush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MemorySegment CreateSolidBrush$address() {
        return CreateSolidBrush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MemorySegment CreateSolidBrush(int color) {
        var mh$ = CreateSolidBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSolidBrush", color);
            }
            return (MemorySegment)mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor DeleteDC$descriptor() {
        return DeleteDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static MethodHandle DeleteDC$handle() {
        return DeleteDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static MemorySegment DeleteDC$address() {
        return DeleteDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static int DeleteDC(MemorySegment hdc) {
        var mh$ = DeleteDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteMetaFile$descriptor() {
        return DeleteMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteMetaFile$handle() {
        return DeleteMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static MemorySegment DeleteMetaFile$address() {
        return DeleteMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static int DeleteMetaFile(MemorySegment hmf) {
        var mh$ = DeleteMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static FunctionDescriptor DeleteObject$descriptor() {
        return DeleteObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static MethodHandle DeleteObject$handle() {
        return DeleteObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static MemorySegment DeleteObject$address() {
        return DeleteObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static int DeleteObject(MemorySegment ho) {
        var mh$ = DeleteObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteObject", ho);
            }
            return (int)mh$.invokeExact(ho);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DescribePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DescribePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static FunctionDescriptor DescribePixelFormat$descriptor() {
        return DescribePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static MethodHandle DescribePixelFormat$handle() {
        return DescribePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static MemorySegment DescribePixelFormat$address() {
        return DescribePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static int DescribePixelFormat(MemorySegment hdc, int iPixelFormat, int nBytes, MemorySegment ppfd) {
        var mh$ = DescribePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DescribePixelFormat", hdc, iPixelFormat, nBytes, ppfd);
            }
            return (int)mh$.invokeExact(hdc, iPixelFormat, nBytes, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeviceCapabilitiesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesA$descriptor() {
        return DeviceCapabilitiesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesA$handle() {
        return DeviceCapabilitiesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static MemorySegment DeviceCapabilitiesA$address() {
        return DeviceCapabilitiesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesA(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesA", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeviceCapabilitiesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesW$descriptor() {
        return DeviceCapabilitiesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesW$handle() {
        return DeviceCapabilitiesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static MemorySegment DeviceCapabilitiesW$address() {
        return DeviceCapabilitiesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesW(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesW", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DrawEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static FunctionDescriptor DrawEscape$descriptor() {
        return DrawEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static MethodHandle DrawEscape$handle() {
        return DrawEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static MemorySegment DrawEscape$address() {
        return DrawEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static int DrawEscape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment lpIn) {
        var mh$ = DrawEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEscape", hdc, iEscape, cjIn, lpIn);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, lpIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ellipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Ellipse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Ellipse$descriptor() {
        return Ellipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Ellipse$handle() {
        return Ellipse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment Ellipse$address() {
        return Ellipse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Ellipse(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Ellipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ellipse", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumFontFamiliesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExA$descriptor() {
        return EnumFontFamiliesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExA$handle() {
        return EnumFontFamiliesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumFontFamiliesExA$address() {
        return EnumFontFamiliesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExA", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumFontFamiliesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExW$descriptor() {
        return EnumFontFamiliesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExW$handle() {
        return EnumFontFamiliesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumFontFamiliesExW$address() {
        return EnumFontFamiliesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExW", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumFontFamiliesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesA$descriptor() {
        return EnumFontFamiliesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesA$handle() {
        return EnumFontFamiliesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontFamiliesA$address() {
        return EnumFontFamiliesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumFontFamiliesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesW$descriptor() {
        return EnumFontFamiliesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesW$handle() {
        return EnumFontFamiliesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontFamiliesW$address() {
        return EnumFontFamiliesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumFontsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsA$descriptor() {
        return EnumFontsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsA$handle() {
        return EnumFontsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontsA$address() {
        return EnumFontsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumFontsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsW$descriptor() {
        return EnumFontsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsW$handle() {
        return EnumFontsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumFontsW$address() {
        return EnumFontsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumObjects$descriptor() {
        return EnumObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumObjects$handle() {
        return EnumObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumObjects$address() {
        return EnumObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static int EnumObjects(MemorySegment hdc, int nType, MemorySegment lpFunc, long lParam) {
        var mh$ = EnumObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumObjects", hdc, nType, lpFunc, lParam);
            }
            return (int)mh$.invokeExact(hdc, nType, lpFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EqualRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static FunctionDescriptor EqualRgn$descriptor() {
        return EqualRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static MethodHandle EqualRgn$handle() {
        return EqualRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static MemorySegment EqualRgn$address() {
        return EqualRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static int EqualRgn(MemorySegment hrgn1, MemorySegment hrgn2) {
        var mh$ = EqualRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualRgn", hrgn1, hrgn2);
            }
            return (int)mh$.invokeExact(hrgn1, hrgn2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Escape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Escape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static FunctionDescriptor Escape$descriptor() {
        return Escape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static MethodHandle Escape$handle() {
        return Escape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static MemorySegment Escape$address() {
        return Escape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static int Escape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment pvIn, MemorySegment pvOut) {
        var mh$ = Escape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Escape", hdc, iEscape, cjIn, pvIn, pvOut);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, pvIn, pvOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExtEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static FunctionDescriptor ExtEscape$descriptor() {
        return ExtEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static MethodHandle ExtEscape$handle() {
        return ExtEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static MemorySegment ExtEscape$address() {
        return ExtEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static int ExtEscape(MemorySegment hdc, int iEscape, int cjInput, MemorySegment lpInData, int cjOutput, MemorySegment lpOutData) {
        var mh$ = ExtEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtEscape", hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExcludeClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExcludeClipRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor ExcludeClipRect$descriptor() {
        return ExcludeClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle ExcludeClipRect$handle() {
        return ExcludeClipRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment ExcludeClipRect$address() {
        return ExcludeClipRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int ExcludeClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = ExcludeClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExcludeClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreateRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExtCreateRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static FunctionDescriptor ExtCreateRegion$descriptor() {
        return ExtCreateRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MethodHandle ExtCreateRegion$handle() {
        return ExtCreateRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MemorySegment ExtCreateRegion$address() {
        return ExtCreateRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MemorySegment ExtCreateRegion(MemorySegment lpx, int nCount, MemorySegment lpData) {
        var mh$ = ExtCreateRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreateRegion", lpx, nCount, lpData);
            }
            return (MemorySegment)mh$.invokeExact(lpx, nCount, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtFloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExtFloodFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static FunctionDescriptor ExtFloodFill$descriptor() {
        return ExtFloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static MethodHandle ExtFloodFill$handle() {
        return ExtFloodFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static MemorySegment ExtFloodFill$address() {
        return ExtFloodFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static int ExtFloodFill(MemorySegment hdc, int x, int y, int color, int type) {
        var mh$ = ExtFloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtFloodFill", hdc, x, y, color, type);
            }
            return (int)mh$.invokeExact(hdc, x, y, color, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FillRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FillRgn$descriptor() {
        return FillRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static MethodHandle FillRgn$handle() {
        return FillRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static MemorySegment FillRgn$address() {
        return FillRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static int FillRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr) {
        var mh$ = FillRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillRgn", hdc, hrgn, hbr);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FloodFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor FloodFill$descriptor() {
        return FloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle FloodFill$handle() {
        return FloodFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment FloodFill$address() {
        return FloodFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int FloodFill(MemorySegment hdc, int x, int y, int color) {
        var mh$ = FloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FloodFill", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FrameRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FrameRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static FunctionDescriptor FrameRgn$descriptor() {
        return FrameRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static MethodHandle FrameRgn$handle() {
        return FrameRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static MemorySegment FrameRgn$address() {
        return FrameRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static int FrameRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr, int w, int h) {
        var mh$ = FrameRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FrameRgn", hdc, hrgn, hbr, w, h);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetROP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetROP2$descriptor() {
        return GetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static MethodHandle GetROP2$handle() {
        return GetROP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static MemorySegment GetROP2$address() {
        return GetROP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static int GetROP2(MemorySegment hdc) {
        var mh$ = GetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetROP2", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAspectRatioFilterEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAspectRatioFilterEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetAspectRatioFilterEx$descriptor() {
        return GetAspectRatioFilterEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetAspectRatioFilterEx$handle() {
        return GetAspectRatioFilterEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetAspectRatioFilterEx$address() {
        return GetAspectRatioFilterEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetAspectRatioFilterEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetAspectRatioFilterEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAspectRatioFilterEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBkColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkColor$descriptor() {
        return GetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static MethodHandle GetBkColor$handle() {
        return GetBkColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static MemorySegment GetBkColor$address() {
        return GetBkColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static int GetBkColor(MemorySegment hdc) {
        var mh$ = GetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDCBrushColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCBrushColor$descriptor() {
        return GetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCBrushColor$handle() {
        return GetDCBrushColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static MemorySegment GetDCBrushColor$address() {
        return GetDCBrushColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static int GetDCBrushColor(MemorySegment hdc) {
        var mh$ = GetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCBrushColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDCPenColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCPenColor$descriptor() {
        return GetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCPenColor$handle() {
        return GetDCPenColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static MemorySegment GetDCPenColor$address() {
        return GetDCPenColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static int GetDCPenColor(MemorySegment hdc) {
        var mh$ = GetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCPenColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBkMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkMode$descriptor() {
        return GetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static MethodHandle GetBkMode$handle() {
        return GetBkMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static MemorySegment GetBkMode$address() {
        return GetBkMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static int GetBkMode(MemorySegment hdc) {
        var mh$ = GetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBitmapBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static FunctionDescriptor GetBitmapBits$descriptor() {
        return GetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static MethodHandle GetBitmapBits$handle() {
        return GetBitmapBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static MemorySegment GetBitmapBits$address() {
        return GetBitmapBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static int GetBitmapBits(MemorySegment hbit, int cb, MemorySegment lpvBits) {
        var mh$ = GetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapBits", hbit, cb, lpvBits);
            }
            return (int)mh$.invokeExact(hbit, cb, lpvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBitmapDimensionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetBitmapDimensionEx$descriptor() {
        return GetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetBitmapDimensionEx$handle() {
        return GetBitmapDimensionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetBitmapDimensionEx$address() {
        return GetBitmapDimensionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static int GetBitmapDimensionEx(MemorySegment hbit, MemorySegment lpsize) {
        var mh$ = GetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapDimensionEx", hbit, lpsize);
            }
            return (int)mh$.invokeExact(hbit, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBoundsRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor GetBoundsRect$descriptor() {
        return GetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static MethodHandle GetBoundsRect$handle() {
        return GetBoundsRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static MemorySegment GetBoundsRect$address() {
        return GetBoundsRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static int GetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = GetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetBrushOrgEx$descriptor() {
        return GetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetBrushOrgEx$handle() {
        return GetBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetBrushOrgEx$address() {
        return GetBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetBrushOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBrushOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharWidthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthA$descriptor() {
        return GetCharWidthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthA$handle() {
        return GetCharWidthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthA$address() {
        return GetCharWidthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharWidthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthW$descriptor() {
        return GetCharWidthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthW$handle() {
        return GetCharWidthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthW$address() {
        return GetCharWidthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharWidth32A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32A$descriptor() {
        return GetCharWidth32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32A$handle() {
        return GetCharWidth32A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidth32A$address() {
        return GetCharWidth32A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32A(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32A", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharWidth32W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32W$descriptor() {
        return GetCharWidth32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32W$handle() {
        return GetCharWidth32W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidth32W$address() {
        return GetCharWidth32W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32W(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32W", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharWidthFloatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatA$descriptor() {
        return GetCharWidthFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatA$handle() {
        return GetCharWidthFloatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthFloatA$address() {
        return GetCharWidthFloatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharWidthFloatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatW$descriptor() {
        return GetCharWidthFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatW$handle() {
        return GetCharWidthFloatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MemorySegment GetCharWidthFloatW$address() {
        return GetCharWidthFloatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharABCWidthsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsA$descriptor() {
        return GetCharABCWidthsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsA$handle() {
        return GetCharABCWidthsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsA$address() {
        return GetCharABCWidthsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsA(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsA", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharABCWidthsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsW$descriptor() {
        return GetCharABCWidthsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsW$handle() {
        return GetCharABCWidthsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsW$address() {
        return GetCharABCWidthsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsW(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsW", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharABCWidthsFloatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatA$descriptor() {
        return GetCharABCWidthsFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatA$handle() {
        return GetCharABCWidthsFloatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsFloatA$address() {
        return GetCharABCWidthsFloatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatA", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharABCWidthsFloatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatW$descriptor() {
        return GetCharABCWidthsFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatW$handle() {
        return GetCharABCWidthsFloatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MemorySegment GetCharABCWidthsFloatW$address() {
        return GetCharABCWidthsFloatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatW", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static FunctionDescriptor GetClipBox$descriptor() {
        return GetClipBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static MethodHandle GetClipBox$handle() {
        return GetClipBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static MemorySegment GetClipBox$address() {
        return GetClipBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static int GetClipBox(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = GetClipBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipBox", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetClipRgn$descriptor() {
        return GetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetClipRgn$handle() {
        return GetClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment GetClipRgn$address() {
        return GetClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMetaRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetMetaRgn$descriptor() {
        return GetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetMetaRgn$handle() {
        return GetMetaRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment GetMetaRgn$address() {
        return GetMetaRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetMetaRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static FunctionDescriptor GetCurrentObject$descriptor() {
        return GetCurrentObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MethodHandle GetCurrentObject$handle() {
        return GetCurrentObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MemorySegment GetCurrentObject$address() {
        return GetCurrentObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MemorySegment GetCurrentObject(MemorySegment hdc, int type) {
        var mh$ = GetCurrentObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentObject", hdc, type);
            }
            return (MemorySegment)mh$.invokeExact(hdc, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentPositionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentPositionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetCurrentPositionEx$descriptor() {
        return GetCurrentPositionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetCurrentPositionEx$handle() {
        return GetCurrentPositionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetCurrentPositionEx$address() {
        return GetCurrentPositionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetCurrentPositionEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetCurrentPositionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentPositionEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDeviceCaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static FunctionDescriptor GetDeviceCaps$descriptor() {
        return GetDeviceCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static MethodHandle GetDeviceCaps$handle() {
        return GetDeviceCaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static MemorySegment GetDeviceCaps$address() {
        return GetDeviceCaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static int GetDeviceCaps(MemorySegment hdc, int index) {
        var mh$ = GetDeviceCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceCaps", hdc, index);
            }
            return (int)mh$.invokeExact(hdc, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static FunctionDescriptor GetDIBits$descriptor() {
        return GetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static MethodHandle GetDIBits$handle() {
        return GetDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static MemorySegment GetDIBits$address() {
        return GetDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static int GetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int usage) {
        var mh$ = GetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBits", hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFontData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static FunctionDescriptor GetFontData$descriptor() {
        return GetFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static MethodHandle GetFontData$handle() {
        return GetFontData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static MemorySegment GetFontData$address() {
        return GetFontData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static int GetFontData(MemorySegment hdc, int dwTable, int dwOffset, MemorySegment pvBuffer, int cjBuffer) {
        var mh$ = GetFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontData", hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
            }
            return (int)mh$.invokeExact(hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGlyphOutlineA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineA$descriptor() {
        return GetGlyphOutlineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineA$handle() {
        return GetGlyphOutlineA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MemorySegment GetGlyphOutlineA$address() {
        return GetGlyphOutlineA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineA(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineA", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGlyphOutlineW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineW$descriptor() {
        return GetGlyphOutlineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineW$handle() {
        return GetGlyphOutlineW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MemorySegment GetGlyphOutlineW$address() {
        return GetGlyphOutlineW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineW(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineW", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGraphicsMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetGraphicsMode$descriptor() {
        return GetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static MethodHandle GetGraphicsMode$handle() {
        return GetGraphicsMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static MemorySegment GetGraphicsMode$address() {
        return GetGraphicsMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static int GetGraphicsMode(MemorySegment hdc) {
        var mh$ = GetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGraphicsMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMapMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetMapMode$descriptor() {
        return GetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static MethodHandle GetMapMode$handle() {
        return GetMapMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static MemorySegment GetMapMode$address() {
        return GetMapMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static int GetMapMode(MemorySegment hdc) {
        var mh$ = GetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMapMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMetaFileBitsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetMetaFileBitsEx$descriptor() {
        return GetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static MethodHandle GetMetaFileBitsEx$handle() {
        return GetMetaFileBitsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static MemorySegment GetMetaFileBitsEx$address() {
        return GetMetaFileBitsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static int GetMetaFileBitsEx(MemorySegment hMF, int cbBuffer, MemorySegment lpData) {
        var mh$ = GetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileBitsEx", hMF, cbBuffer, lpData);
            }
            return (int)mh$.invokeExact(hMF, cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileA$descriptor() {
        return GetMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileA$handle() {
        return GetMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileA$address() {
        return GetMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileA(MemorySegment lpName) {
        var mh$ = GetMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileW$descriptor() {
        return GetMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileW$handle() {
        return GetMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileW$address() {
        return GetMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileW(MemorySegment lpName) {
        var mh$ = GetMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNearestColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestColor$descriptor() {
        return GetNearestColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestColor$handle() {
        return GetNearestColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment GetNearestColor$address() {
        return GetNearestColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static int GetNearestColor(MemorySegment hdc, int color) {
        var mh$ = GetNearestColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestPaletteIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNearestPaletteIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestPaletteIndex$descriptor() {
        return GetNearestPaletteIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestPaletteIndex$handle() {
        return GetNearestPaletteIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static MemorySegment GetNearestPaletteIndex$address() {
        return GetNearestPaletteIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static int GetNearestPaletteIndex(MemorySegment h, int color) {
        var mh$ = GetNearestPaletteIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestPaletteIndex", h, color);
            }
            return (int)mh$.invokeExact(h, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetObjectType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor GetObjectType$descriptor() {
        return GetObjectType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static MethodHandle GetObjectType$handle() {
        return GetObjectType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static MemorySegment GetObjectType$address() {
        return GetObjectType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static int GetObjectType(MemorySegment h) {
        var mh$ = GetObjectType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectType", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOutlineTextMetricsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsA$descriptor() {
        return GetOutlineTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsA$handle() {
        return GetOutlineTextMetricsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static MemorySegment GetOutlineTextMetricsA$address() {
        return GetOutlineTextMetricsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static int GetOutlineTextMetricsA(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsA", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOutlineTextMetricsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsW$descriptor() {
        return GetOutlineTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsW$handle() {
        return GetOutlineTextMetricsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static MemorySegment GetOutlineTextMetricsW$address() {
        return GetOutlineTextMetricsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static int GetOutlineTextMetricsW(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsW", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetPaletteEntries$descriptor() {
        return GetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetPaletteEntries$handle() {
        return GetPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MemorySegment GetPaletteEntries$address() {
        return GetPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor GetPixel$descriptor() {
        return GetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle GetPixel$handle() {
        return GetPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment GetPixel$address() {
        return GetPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static int GetPixel(MemorySegment hdc, int x, int y) {
        var mh$ = GetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixel", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPixelFormat$descriptor() {
        return GetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static MethodHandle GetPixelFormat$handle() {
        return GetPixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static MemorySegment GetPixelFormat$address() {
        return GetPixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static int GetPixelFormat(MemorySegment hdc) {
        var mh$ = GetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelFormat", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPolyFillMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPolyFillMode$descriptor() {
        return GetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static MethodHandle GetPolyFillMode$handle() {
        return GetPolyFillMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static MemorySegment GetPolyFillMode$address() {
        return GetPolyFillMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static int GetPolyFillMode(MemorySegment hdc) {
        var mh$ = GetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPolyFillMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRasterizerCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRasterizerCaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static FunctionDescriptor GetRasterizerCaps$descriptor() {
        return GetRasterizerCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static MethodHandle GetRasterizerCaps$handle() {
        return GetRasterizerCaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static MemorySegment GetRasterizerCaps$address() {
        return GetRasterizerCaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static int GetRasterizerCaps(MemorySegment lpraststat, int cjBytes) {
        var mh$ = GetRasterizerCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRasterizerCaps", lpraststat, cjBytes);
            }
            return (int)mh$.invokeExact(lpraststat, cjBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRandomRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRandomRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static FunctionDescriptor GetRandomRgn$descriptor() {
        return GetRandomRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static MethodHandle GetRandomRgn$handle() {
        return GetRandomRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static MemorySegment GetRandomRgn$address() {
        return GetRandomRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static int GetRandomRgn(MemorySegment hdc, MemorySegment hrgn, int i) {
        var mh$ = GetRandomRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRandomRgn", hdc, hrgn, i);
            }
            return (int)mh$.invokeExact(hdc, hrgn, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRegionData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRegionData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static FunctionDescriptor GetRegionData$descriptor() {
        return GetRegionData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static MethodHandle GetRegionData$handle() {
        return GetRegionData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static MemorySegment GetRegionData$address() {
        return GetRegionData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static int GetRegionData(MemorySegment hrgn, int nCount, MemorySegment lpRgnData) {
        var mh$ = GetRegionData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRegionData", hrgn, nCount, lpRgnData);
            }
            return (int)mh$.invokeExact(hrgn, nCount, lpRgnData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRgnBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRgnBox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static FunctionDescriptor GetRgnBox$descriptor() {
        return GetRgnBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static MethodHandle GetRgnBox$handle() {
        return GetRgnBox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static MemorySegment GetRgnBox$address() {
        return GetRgnBox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static int GetRgnBox(MemorySegment hrgn, MemorySegment lprc) {
        var mh$ = GetRgnBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRgnBox", hrgn, lprc);
            }
            return (int)mh$.invokeExact(hrgn, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStockObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStockObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static FunctionDescriptor GetStockObject$descriptor() {
        return GetStockObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MethodHandle GetStockObject$handle() {
        return GetStockObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MemorySegment GetStockObject$address() {
        return GetStockObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MemorySegment GetStockObject(int i) {
        var mh$ = GetStockObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStockObject", i);
            }
            return (MemorySegment)mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStretchBltMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetStretchBltMode$descriptor() {
        return GetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static MethodHandle GetStretchBltMode$handle() {
        return GetStretchBltMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static MemorySegment GetStretchBltMode$address() {
        return GetStretchBltMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static int GetStretchBltMode(MemorySegment hdc) {
        var mh$ = GetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStretchBltMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteEntries$descriptor() {
        return GetSystemPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetSystemPaletteEntries$handle() {
        return GetSystemPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MemorySegment GetSystemPaletteEntries$address() {
        return GetSystemPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetSystemPaletteEntries(MemorySegment hdc, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetSystemPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteEntries", hdc, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemPaletteUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteUse$descriptor() {
        return GetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static MethodHandle GetSystemPaletteUse$handle() {
        return GetSystemPaletteUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static MemorySegment GetSystemPaletteUse$address() {
        return GetSystemPaletteUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static int GetSystemPaletteUse(MemorySegment hdc) {
        var mh$ = GetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteUse", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextCharacterExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharacterExtra$descriptor() {
        return GetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharacterExtra$handle() {
        return GetTextCharacterExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static MemorySegment GetTextCharacterExtra$address() {
        return GetTextCharacterExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static int GetTextCharacterExtra(MemorySegment hdc) {
        var mh$ = GetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharacterExtra", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextAlign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextAlign$descriptor() {
        return GetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static MethodHandle GetTextAlign$handle() {
        return GetTextAlign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static MemorySegment GetTextAlign$address() {
        return GetTextAlign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static int GetTextAlign(MemorySegment hdc) {
        var mh$ = GetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextAlign", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextColor$descriptor() {
        return GetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static MethodHandle GetTextColor$handle() {
        return GetTextColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static MemorySegment GetTextColor$address() {
        return GetTextColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static int GetTextColor(MemorySegment hdc) {
        var mh$ = GetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointA$descriptor() {
        return GetTextExtentPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointA$handle() {
        return GetTextExtentPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MemorySegment GetTextExtentPointA$address() {
        return GetTextExtentPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointA(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointA", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointW$descriptor() {
        return GetTextExtentPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointW$handle() {
        return GetTextExtentPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MemorySegment GetTextExtentPointW$address() {
        return GetTextExtentPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointW(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointW", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentPoint32A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32A$descriptor() {
        return GetTextExtentPoint32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32A$handle() {
        return GetTextExtentPoint32A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MemorySegment GetTextExtentPoint32A$address() {
        return GetTextExtentPoint32A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32A(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32A", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentPoint32W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32W$descriptor() {
        return GetTextExtentPoint32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32W$handle() {
        return GetTextExtentPoint32W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MemorySegment GetTextExtentPoint32W$address() {
        return GetTextExtentPoint32W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32W(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32W", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentExPointA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointA$descriptor() {
        return GetTextExtentExPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointA$handle() {
        return GetTextExtentExPointA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointA$address() {
        return GetTextExtentExPointA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointA(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointA", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentExPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointW$descriptor() {
        return GetTextExtentExPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointW$handle() {
        return GetTextExtentExPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointW$address() {
        return GetTextExtentExPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointW(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointW", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextCharset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharset$descriptor() {
        return GetTextCharset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharset$handle() {
        return GetTextCharset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static MemorySegment GetTextCharset$address() {
        return GetTextCharset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static int GetTextCharset(MemorySegment hdc) {
        var mh$ = GetTextCharset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharset", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextCharsetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetTextCharsetInfo$descriptor() {
        return GetTextCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetTextCharsetInfo$handle() {
        return GetTextCharsetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetTextCharsetInfo$address() {
        return GetTextCharsetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static int GetTextCharsetInfo(MemorySegment hdc, MemorySegment lpSig, int dwFlags) {
        var mh$ = GetTextCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharsetInfo", hdc, lpSig, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpSig, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TranslateCharsetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor TranslateCharsetInfo$descriptor() {
        return TranslateCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static MethodHandle TranslateCharsetInfo$handle() {
        return TranslateCharsetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static MemorySegment TranslateCharsetInfo$address() {
        return TranslateCharsetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static int TranslateCharsetInfo(MemorySegment lpSrc, MemorySegment lpCs, int dwFlags) {
        var mh$ = TranslateCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateCharsetInfo", lpSrc, lpCs, dwFlags);
            }
            return (int)mh$.invokeExact(lpSrc, lpCs, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontLanguageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFontLanguageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetFontLanguageInfo$descriptor() {
        return GetFontLanguageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static MethodHandle GetFontLanguageInfo$handle() {
        return GetFontLanguageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static MemorySegment GetFontLanguageInfo$address() {
        return GetFontLanguageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static int GetFontLanguageInfo(MemorySegment hdc) {
        var mh$ = GetFontLanguageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontLanguageInfo", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharacterPlacementA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementA$descriptor() {
        return GetCharacterPlacementA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementA$handle() {
        return GetCharacterPlacementA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetCharacterPlacementA$address() {
        return GetCharacterPlacementA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementA(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementA", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharacterPlacementW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementW$descriptor() {
        return GetCharacterPlacementW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementW$handle() {
        return GetCharacterPlacementW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetCharacterPlacementW$address() {
        return GetCharacterPlacementW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementW(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementW", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *PWCRANGE
     * }
     */
    public static final AddressLayout PWCRANGE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *LPWCRANGE
     * }
     */
    public static final AddressLayout LPWCRANGE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *PGLYPHSET
     * }
     */
    public static final AddressLayout PGLYPHSET = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *LPGLYPHSET
     * }
     */
    public static final AddressLayout LPGLYPHSET = freeglut_h.C_POINTER;

    private static class GetFontUnicodeRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFontUnicodeRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static FunctionDescriptor GetFontUnicodeRanges$descriptor() {
        return GetFontUnicodeRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static MethodHandle GetFontUnicodeRanges$handle() {
        return GetFontUnicodeRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static MemorySegment GetFontUnicodeRanges$address() {
        return GetFontUnicodeRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static int GetFontUnicodeRanges(MemorySegment hdc, MemorySegment lpgs) {
        var mh$ = GetFontUnicodeRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontUnicodeRanges", hdc, lpgs);
            }
            return (int)mh$.invokeExact(hdc, lpgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGlyphIndicesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesA$descriptor() {
        return GetGlyphIndicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesA$handle() {
        return GetGlyphIndicesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MemorySegment GetGlyphIndicesA$address() {
        return GetGlyphIndicesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesA(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesA", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGlyphIndicesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesW$descriptor() {
        return GetGlyphIndicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesW$handle() {
        return GetGlyphIndicesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MemorySegment GetGlyphIndicesW$address() {
        return GetGlyphIndicesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesW(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesW", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentPointI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointI$descriptor() {
        return GetTextExtentPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static MethodHandle GetTextExtentPointI$handle() {
        return GetTextExtentPointI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static MemorySegment GetTextExtentPointI$address() {
        return GetTextExtentPointI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static int GetTextExtentPointI(MemorySegment hdc, MemorySegment pgiIn, int cgi, MemorySegment psize) {
        var mh$ = GetTextExtentPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointI", hdc, pgiIn, cgi, psize);
            }
            return (int)mh$.invokeExact(hdc, pgiIn, cgi, psize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextExtentExPointI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointI$descriptor() {
        return GetTextExtentExPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointI$handle() {
        return GetTextExtentExPointI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MemorySegment GetTextExtentExPointI$address() {
        return GetTextExtentExPointI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointI(MemorySegment hdc, MemorySegment lpwszString, int cwchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointI", hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharWidthI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static FunctionDescriptor GetCharWidthI$descriptor() {
        return GetCharWidthI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static MethodHandle GetCharWidthI$handle() {
        return GetCharWidthI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static MemorySegment GetCharWidthI$address() {
        return GetCharWidthI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static int GetCharWidthI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment piWidths) {
        var mh$ = GetCharWidthI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthI", hdc, giFirst, cgi, pgi, piWidths);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, piWidths);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCharABCWidthsI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsI$descriptor() {
        return GetCharABCWidthsI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static MethodHandle GetCharABCWidthsI$handle() {
        return GetCharABCWidthsI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static MemorySegment GetCharABCWidthsI$address() {
        return GetCharABCWidthsI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static int GetCharABCWidthsI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment pabc) {
        var mh$ = GetCharABCWidthsI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsI", hdc, giFirst, cgi, pgi, pabc);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, pabc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *PDESIGNVECTOR
     * }
     */
    public static final AddressLayout PDESIGNVECTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *LPDESIGNVECTOR
     * }
     */
    public static final AddressLayout LPDESIGNVECTOR = freeglut_h.C_POINTER;

    private static class AddFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddFontResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExA$descriptor() {
        return AddFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExA$handle() {
        return AddFontResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MemorySegment AddFontResourceExA$address() {
        return AddFontResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExA(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExA", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddFontResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExW$descriptor() {
        return AddFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExW$handle() {
        return AddFontResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MemorySegment AddFontResourceExW$address() {
        return AddFontResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExW(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExW", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveFontResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExA$descriptor() {
        return RemoveFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExA$handle() {
        return RemoveFontResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MemorySegment RemoveFontResourceExA$address() {
        return RemoveFontResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExA(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExA", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveFontResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExW$descriptor() {
        return RemoveFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExW$handle() {
        return RemoveFontResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MemorySegment RemoveFontResourceExW$address() {
        return RemoveFontResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExW(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExW", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddFontMemResourceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static FunctionDescriptor AddFontMemResourceEx$descriptor() {
        return AddFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MethodHandle AddFontMemResourceEx$handle() {
        return AddFontMemResourceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MemorySegment AddFontMemResourceEx$address() {
        return AddFontMemResourceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MemorySegment AddFontMemResourceEx(MemorySegment pFileView, int cjSize, MemorySegment pvResrved, MemorySegment pNumFonts) {
        var mh$ = AddFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontMemResourceEx", pFileView, cjSize, pvResrved, pNumFonts);
            }
            return (MemorySegment)mh$.invokeExact(pFileView, cjSize, pvResrved, pNumFonts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveFontMemResourceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static FunctionDescriptor RemoveFontMemResourceEx$descriptor() {
        return RemoveFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static MethodHandle RemoveFontMemResourceEx$handle() {
        return RemoveFontMemResourceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static MemorySegment RemoveFontMemResourceEx$address() {
        return RemoveFontMemResourceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static int RemoveFontMemResourceEx(MemorySegment h) {
        var mh$ = RemoveFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontMemResourceEx", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *PAXISINFOA
     * }
     */
    public static final AddressLayout PAXISINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *LPAXISINFOA
     * }
     */
    public static final AddressLayout LPAXISINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *PAXISINFOW
     * }
     */
    public static final AddressLayout PAXISINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *LPAXISINFOW
     * }
     */
    public static final AddressLayout LPAXISINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXISINFOA PAXISINFO
     * }
     */
    public static final AddressLayout PAXISINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXISINFOA LPAXISINFO
     * }
     */
    public static final AddressLayout LPAXISINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *PAXESLISTA
     * }
     */
    public static final AddressLayout PAXESLISTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *LPAXESLISTA
     * }
     */
    public static final AddressLayout LPAXESLISTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *PAXESLISTW
     * }
     */
    public static final AddressLayout PAXESLISTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *LPAXESLISTW
     * }
     */
    public static final AddressLayout LPAXESLISTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXESLISTA PAXESLIST
     * }
     */
    public static final AddressLayout PAXESLIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXESLISTA LPAXESLIST
     * }
     */
    public static final AddressLayout LPAXESLIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDV = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDV = freeglut_h.C_POINTER;

    private static class CreateFontIndirectExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFontIndirectExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExA$descriptor() {
        return CreateFontIndirectExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MethodHandle CreateFontIndirectExA$handle() {
        return CreateFontIndirectExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MemorySegment CreateFontIndirectExA$address() {
        return CreateFontIndirectExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MemorySegment CreateFontIndirectExA(MemorySegment x0) {
        var mh$ = CreateFontIndirectExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExA", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFontIndirectExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExW$descriptor() {
        return CreateFontIndirectExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MethodHandle CreateFontIndirectExW$handle() {
        return CreateFontIndirectExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MemorySegment CreateFontIndirectExW$address() {
        return CreateFontIndirectExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MemorySegment CreateFontIndirectExW(MemorySegment x0) {
        var mh$ = CreateFontIndirectExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExW", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *PENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *LPENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *PENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *LPENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMTEXTMETRICA PENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout PENUMTEXTMETRIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRIC = freeglut_h.C_POINTER;

    private static class GetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetViewportExtEx$descriptor() {
        return GetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetViewportExtEx$handle() {
        return GetViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetViewportExtEx$address() {
        return GetViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetViewportExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetViewportOrgEx$descriptor() {
        return GetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetViewportOrgEx$handle() {
        return GetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MemorySegment GetViewportOrgEx$address() {
        return GetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetViewportOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetWindowExtEx$descriptor() {
        return GetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetWindowExtEx$handle() {
        return GetWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MemorySegment GetWindowExtEx$address() {
        return GetWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetWindowExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetWindowOrgEx$descriptor() {
        return GetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetWindowOrgEx$handle() {
        return GetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MemorySegment GetWindowOrgEx$address() {
        return GetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetWindowOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IntersectClipRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor IntersectClipRect$descriptor() {
        return IntersectClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle IntersectClipRect$handle() {
        return IntersectClipRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment IntersectClipRect$address() {
        return IntersectClipRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int IntersectClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = IntersectClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvertRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InvertRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor InvertRgn$descriptor() {
        return InvertRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle InvertRgn$handle() {
        return InvertRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment InvertRgn$address() {
        return InvertRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int InvertRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = InvertRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvertRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineDDA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LineDDA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static FunctionDescriptor LineDDA$descriptor() {
        return LineDDA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static MethodHandle LineDDA$handle() {
        return LineDDA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static MemorySegment LineDDA$address() {
        return LineDDA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static int LineDDA(int xStart, int yStart, int xEnd, int yEnd, MemorySegment lpProc, long data) {
        var mh$ = LineDDA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineDDA", xStart, yStart, xEnd, yEnd, lpProc, data);
            }
            return (int)mh$.invokeExact(xStart, yStart, xEnd, yEnd, lpProc, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LineTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor LineTo$descriptor() {
        return LineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle LineTo$handle() {
        return LineTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment LineTo$address() {
        return LineTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static int LineTo(MemorySegment hdc, int x, int y) {
        var mh$ = LineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineTo", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MaskBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MaskBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static FunctionDescriptor MaskBlt$descriptor() {
        return MaskBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static MethodHandle MaskBlt$handle() {
        return MaskBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static MemorySegment MaskBlt$address() {
        return MaskBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static int MaskBlt(MemorySegment hdcDest, int xDest, int yDest, int width, int height, MemorySegment hdcSrc, int xSrc, int ySrc, MemorySegment hbmMask, int xMask, int yMask, int rop) {
        var mh$ = MaskBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MaskBlt", hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlgBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PlgBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static FunctionDescriptor PlgBlt$descriptor() {
        return PlgBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static MethodHandle PlgBlt$handle() {
        return PlgBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static MemorySegment PlgBlt$address() {
        return PlgBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static int PlgBlt(MemorySegment hdcDest, MemorySegment lpPoint, MemorySegment hdcSrc, int xSrc, int ySrc, int width, int height, MemorySegment hbmMask, int xMask, int yMask) {
        var mh$ = PlgBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlgBlt", hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
            }
            return (int)mh$.invokeExact(hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OffsetClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetClipRgn$descriptor() {
        return OffsetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle OffsetClipRgn$handle() {
        return OffsetClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment OffsetClipRgn$address() {
        return OffsetClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static int OffsetClipRgn(MemorySegment hdc, int x, int y) {
        var mh$ = OffsetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetClipRgn", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OffsetRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetRgn$descriptor() {
        return OffsetRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle OffsetRgn$handle() {
        return OffsetRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static MemorySegment OffsetRgn$address() {
        return OffsetRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static int OffsetRgn(MemorySegment hrgn, int x, int y) {
        var mh$ = OffsetRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetRgn", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PatBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PatBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static FunctionDescriptor PatBlt$descriptor() {
        return PatBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static MethodHandle PatBlt$handle() {
        return PatBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static MemorySegment PatBlt$address() {
        return PatBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static int PatBlt(MemorySegment hdc, int x, int y, int w, int h, int rop) {
        var mh$ = PatBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PatBlt", hdc, x, y, w, h, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, w, h, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Pie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Pie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor Pie$descriptor() {
        return Pie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle Pie$handle() {
        return Pie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MemorySegment Pie$address() {
        return Pie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int Pie(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = Pie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Pie", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PlayMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor PlayMetaFile$descriptor() {
        return PlayMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static MethodHandle PlayMetaFile$handle() {
        return PlayMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static MemorySegment PlayMetaFile$address() {
        return PlayMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static int PlayMetaFile(MemorySegment hdc, MemorySegment hmf) {
        var mh$ = PlayMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFile", hdc, hmf);
            }
            return (int)mh$.invokeExact(hdc, hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PaintRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PaintRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor PaintRgn$descriptor() {
        return PaintRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle PaintRgn$handle() {
        return PaintRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment PaintRgn$address() {
        return PaintRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int PaintRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = PaintRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PaintRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolyPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static FunctionDescriptor PolyPolygon$descriptor() {
        return PolyPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static MethodHandle PolyPolygon$handle() {
        return PolyPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static MemorySegment PolyPolygon$address() {
        return PolyPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static int PolyPolygon(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolygon", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PtInRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor PtInRegion$descriptor() {
        return PtInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle PtInRegion$handle() {
        return PtInRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static MemorySegment PtInRegion$address() {
        return PtInRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static int PtInRegion(MemorySegment hrgn, int x, int y) {
        var mh$ = PtInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtInRegion", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PtVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor PtVisible$descriptor() {
        return PtVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle PtVisible$handle() {
        return PtVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static MemorySegment PtVisible$address() {
        return PtVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static int PtVisible(MemorySegment hdc, int x, int y) {
        var mh$ = PtVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtVisible", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RectInRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectInRegion$descriptor() {
        return RectInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static MethodHandle RectInRegion$handle() {
        return RectInRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static MemorySegment RectInRegion$address() {
        return RectInRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static int RectInRegion(MemorySegment hrgn, MemorySegment lprect) {
        var mh$ = RectInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectInRegion", hrgn, lprect);
            }
            return (int)mh$.invokeExact(hrgn, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RectVisible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectVisible$descriptor() {
        return RectVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static MethodHandle RectVisible$handle() {
        return RectVisible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static MemorySegment RectVisible$address() {
        return RectVisible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static int RectVisible(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = RectVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectVisible", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Rectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Rectangle$descriptor() {
        return Rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Rectangle$handle() {
        return Rectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment Rectangle$address() {
        return Rectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Rectangle(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Rectangle", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RestoreDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static FunctionDescriptor RestoreDC$descriptor() {
        return RestoreDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static MethodHandle RestoreDC$handle() {
        return RestoreDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static MemorySegment RestoreDC$address() {
        return RestoreDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static int RestoreDC(MemorySegment hdc, int nSavedDC) {
        var mh$ = RestoreDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreDC", hdc, nSavedDC);
            }
            return (int)mh$.invokeExact(hdc, nSavedDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResetDCA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCA$descriptor() {
        return ResetDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MethodHandle ResetDCA$handle() {
        return ResetDCA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MemorySegment ResetDCA$address() {
        return ResetDCA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MemorySegment ResetDCA(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCA", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResetDCW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCW$descriptor() {
        return ResetDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MethodHandle ResetDCW$handle() {
        return ResetDCW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MemorySegment ResetDCW$address() {
        return ResetDCW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MemorySegment ResetDCW(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCW", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RealizePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor RealizePalette$descriptor() {
        return RealizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static MethodHandle RealizePalette$handle() {
        return RealizePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static MemorySegment RealizePalette$address() {
        return RealizePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static int RealizePalette(MemorySegment hdc) {
        var mh$ = RealizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealizePalette", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveFontResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceA$descriptor() {
        return RemoveFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceA$handle() {
        return RemoveFontResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment RemoveFontResourceA$address() {
        return RemoveFontResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceA(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveFontResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceW$descriptor() {
        return RemoveFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceW$handle() {
        return RemoveFontResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment RemoveFontResourceW$address() {
        return RemoveFontResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceW(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoundRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RoundRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static FunctionDescriptor RoundRect$descriptor() {
        return RoundRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static MethodHandle RoundRect$handle() {
        return RoundRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static MemorySegment RoundRect$address() {
        return RoundRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static int RoundRect(MemorySegment hdc, int left, int top, int right, int bottom, int width, int height) {
        var mh$ = RoundRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoundRect", hdc, left, top, right, bottom, width, height);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResizePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static FunctionDescriptor ResizePalette$descriptor() {
        return ResizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static MethodHandle ResizePalette$handle() {
        return ResizePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static MemorySegment ResizePalette$address() {
        return ResizePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static int ResizePalette(MemorySegment hpal, int n) {
        var mh$ = ResizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizePalette", hpal, n);
            }
            return (int)mh$.invokeExact(hpal, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SaveDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SaveDC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor SaveDC$descriptor() {
        return SaveDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static MethodHandle SaveDC$handle() {
        return SaveDC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static MemorySegment SaveDC$address() {
        return SaveDC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static int SaveDC(MemorySegment hdc) {
        var mh$ = SaveDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SaveDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SelectClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor SelectClipRgn$descriptor() {
        return SelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle SelectClipRgn$handle() {
        return SelectClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MemorySegment SelectClipRgn$address() {
        return SelectClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int SelectClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = SelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtSelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExtSelectClipRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static FunctionDescriptor ExtSelectClipRgn$descriptor() {
        return ExtSelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static MethodHandle ExtSelectClipRgn$handle() {
        return ExtSelectClipRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static MemorySegment ExtSelectClipRgn$address() {
        return ExtSelectClipRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static int ExtSelectClipRgn(MemorySegment hdc, MemorySegment hrgn, int mode) {
        var mh$ = ExtSelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtSelectClipRgn", hdc, hrgn, mode);
            }
            return (int)mh$.invokeExact(hdc, hrgn, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMetaRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static FunctionDescriptor SetMetaRgn$descriptor() {
        return SetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static MethodHandle SetMetaRgn$handle() {
        return SetMetaRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static MemorySegment SetMetaRgn$address() {
        return SetMetaRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static int SetMetaRgn(MemorySegment hdc) {
        var mh$ = SetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaRgn", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SelectObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor SelectObject$descriptor() {
        return SelectObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MethodHandle SelectObject$handle() {
        return SelectObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MemorySegment SelectObject$address() {
        return SelectObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MemorySegment SelectObject(MemorySegment hdc, MemorySegment h) {
        var mh$ = SelectObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectObject", hdc, h);
            }
            return (MemorySegment)mh$.invokeExact(hdc, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SelectPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static FunctionDescriptor SelectPalette$descriptor() {
        return SelectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MethodHandle SelectPalette$handle() {
        return SelectPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MemorySegment SelectPalette$address() {
        return SelectPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MemorySegment SelectPalette(MemorySegment hdc, MemorySegment hPal, int bForceBkgd) {
        var mh$ = SelectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectPalette", hdc, hPal, bForceBkgd);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hPal, bForceBkgd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetBkColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetBkColor$descriptor() {
        return SetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetBkColor$handle() {
        return SetBkColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetBkColor$address() {
        return SetBkColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetBkColor(MemorySegment hdc, int color) {
        var mh$ = SetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDCBrushColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCBrushColor$descriptor() {
        return SetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCBrushColor$handle() {
        return SetDCBrushColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetDCBrushColor$address() {
        return SetDCBrushColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCBrushColor(MemorySegment hdc, int color) {
        var mh$ = SetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCBrushColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDCPenColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCPenColor$descriptor() {
        return SetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCPenColor$handle() {
        return SetDCPenColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetDCPenColor$address() {
        return SetDCPenColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCPenColor(MemorySegment hdc, int color) {
        var mh$ = SetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCPenColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetBkMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetBkMode$descriptor() {
        return SetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetBkMode$handle() {
        return SetBkMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetBkMode$address() {
        return SetBkMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static int SetBkMode(MemorySegment hdc, int mode) {
        var mh$ = SetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetBitmapBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static FunctionDescriptor SetBitmapBits$descriptor() {
        return SetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static MethodHandle SetBitmapBits$handle() {
        return SetBitmapBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static MemorySegment SetBitmapBits$address() {
        return SetBitmapBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static int SetBitmapBits(MemorySegment hbm, int cb, MemorySegment pvBits) {
        var mh$ = SetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapBits", hbm, cb, pvBits);
            }
            return (int)mh$.invokeExact(hbm, cb, pvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetBoundsRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor SetBoundsRect$descriptor() {
        return SetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MethodHandle SetBoundsRect$handle() {
        return SetBoundsRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MemorySegment SetBoundsRect$address() {
        return SetBoundsRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static int SetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = SetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBits$descriptor() {
        return SetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBits$handle() {
        return SetDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MemorySegment SetDIBits$address() {
        return SetDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBits", hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBitsToDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDIBitsToDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBitsToDevice$descriptor() {
        return SetDIBitsToDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBitsToDevice$handle() {
        return SetDIBitsToDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MemorySegment SetDIBitsToDevice$address() {
        return SetDIBitsToDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBitsToDevice(MemorySegment hdc, int xDest, int yDest, int w, int h, int xSrc, int ySrc, int StartScan, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBitsToDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBitsToDevice", hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapperFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMapperFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static FunctionDescriptor SetMapperFlags$descriptor() {
        return SetMapperFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static MethodHandle SetMapperFlags$handle() {
        return SetMapperFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static MemorySegment SetMapperFlags$address() {
        return SetMapperFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static int SetMapperFlags(MemorySegment hdc, int flags) {
        var mh$ = SetMapperFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapperFlags", hdc, flags);
            }
            return (int)mh$.invokeExact(hdc, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetGraphicsMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetGraphicsMode$descriptor() {
        return SetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetGraphicsMode$handle() {
        return SetGraphicsMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static MemorySegment SetGraphicsMode$address() {
        return SetGraphicsMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static int SetGraphicsMode(MemorySegment hdc, int iMode) {
        var mh$ = SetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGraphicsMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMapMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetMapMode$descriptor() {
        return SetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetMapMode$handle() {
        return SetMapMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static MemorySegment SetMapMode$address() {
        return SetMapMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static int SetMapMode(MemorySegment hdc, int iMode) {
        var mh$ = SetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static FunctionDescriptor SetLayout$descriptor() {
        return SetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static MethodHandle SetLayout$handle() {
        return SetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static MemorySegment SetLayout$address() {
        return SetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static int SetLayout(MemorySegment hdc, int l) {
        var mh$ = SetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLayout", hdc, l);
            }
            return (int)mh$.invokeExact(hdc, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetLayout$descriptor() {
        return GetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static MethodHandle GetLayout$handle() {
        return GetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static MemorySegment GetLayout$address() {
        return GetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static int GetLayout(MemorySegment hdc) {
        var mh$ = GetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLayout", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMetaFileBitsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor SetMetaFileBitsEx$descriptor() {
        return SetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MethodHandle SetMetaFileBitsEx$handle() {
        return SetMetaFileBitsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MemorySegment SetMetaFileBitsEx$address() {
        return SetMetaFileBitsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MemorySegment SetMetaFileBitsEx(int cbBuffer, MemorySegment lpData) {
        var mh$ = SetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaFileBitsEx", cbBuffer, lpData);
            }
            return (MemorySegment)mh$.invokeExact(cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static FunctionDescriptor SetPaletteEntries$descriptor() {
        return SetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static MethodHandle SetPaletteEntries$handle() {
        return SetPaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static MemorySegment SetPaletteEntries$address() {
        return SetPaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static int SetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = SetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixel$descriptor() {
        return SetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixel$handle() {
        return SetPixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment SetPixel$address() {
        return SetPixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixel(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixel", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPixelV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixelV$descriptor() {
        return SetPixelV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixelV$handle() {
        return SetPixelV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MemorySegment SetPixelV$address() {
        return SetPixelV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixelV(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixelV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelV", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor SetPixelFormat$descriptor() {
        return SetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle SetPixelFormat$handle() {
        return SetPixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment SetPixelFormat$address() {
        return SetPixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int SetPixelFormat(MemorySegment hdc, int format, MemorySegment ppfd) {
        var mh$ = SetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelFormat", hdc, format, ppfd);
            }
            return (int)mh$.invokeExact(hdc, format, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPolyFillMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetPolyFillMode$descriptor() {
        return SetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetPolyFillMode$handle() {
        return SetPolyFillMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetPolyFillMode$address() {
        return SetPolyFillMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static int SetPolyFillMode(MemorySegment hdc, int mode) {
        var mh$ = SetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPolyFillMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StretchBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchBlt$descriptor() {
        return StretchBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static MethodHandle StretchBlt$handle() {
        return StretchBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static MemorySegment StretchBlt$address() {
        return StretchBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static int StretchBlt(MemorySegment hdcDest, int xDest, int yDest, int wDest, int hDest, MemorySegment hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, int rop) {
        var mh$ = StretchBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchBlt", hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetRectRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor SetRectRgn$descriptor() {
        return SetRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle SetRectRgn$handle() {
        return SetRectRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static MemorySegment SetRectRgn$address() {
        return SetRectRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static int SetRectRgn(MemorySegment hrgn, int left, int top, int right, int bottom) {
        var mh$ = SetRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRectRgn", hrgn, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hrgn, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StretchDIBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchDIBits$descriptor() {
        return StretchDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static MethodHandle StretchDIBits$handle() {
        return StretchDIBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static MemorySegment StretchDIBits$address() {
        return StretchDIBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static int StretchDIBits(MemorySegment hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, MemorySegment lpBits, MemorySegment lpbmi, int iUsage, int rop) {
        var mh$ = StretchDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchDIBits", hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetROP2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static FunctionDescriptor SetROP2$descriptor() {
        return SetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static MethodHandle SetROP2$handle() {
        return SetROP2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static MemorySegment SetROP2$address() {
        return SetROP2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static int SetROP2(MemorySegment hdc, int rop2) {
        var mh$ = SetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetROP2", hdc, rop2);
            }
            return (int)mh$.invokeExact(hdc, rop2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetStretchBltMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetStretchBltMode$descriptor() {
        return SetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetStretchBltMode$handle() {
        return SetStretchBltMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetStretchBltMode$address() {
        return SetStretchBltMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static int SetStretchBltMode(MemorySegment hdc, int mode) {
        var mh$ = SetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStretchBltMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSystemPaletteUse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static FunctionDescriptor SetSystemPaletteUse$descriptor() {
        return SetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static MethodHandle SetSystemPaletteUse$handle() {
        return SetSystemPaletteUse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static MemorySegment SetSystemPaletteUse$address() {
        return SetSystemPaletteUse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static int SetSystemPaletteUse(MemorySegment hdc, int use) {
        var mh$ = SetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPaletteUse", hdc, use);
            }
            return (int)mh$.invokeExact(hdc, use);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTextCharacterExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static FunctionDescriptor SetTextCharacterExtra$descriptor() {
        return SetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static MethodHandle SetTextCharacterExtra$handle() {
        return SetTextCharacterExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static MemorySegment SetTextCharacterExtra$address() {
        return SetTextCharacterExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static int SetTextCharacterExtra(MemorySegment hdc, int extra) {
        var mh$ = SetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextCharacterExtra", hdc, extra);
            }
            return (int)mh$.invokeExact(hdc, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTextColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetTextColor$descriptor() {
        return SetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetTextColor$handle() {
        return SetTextColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static MemorySegment SetTextColor$address() {
        return SetTextColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetTextColor(MemorySegment hdc, int color) {
        var mh$ = SetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTextAlign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static FunctionDescriptor SetTextAlign$descriptor() {
        return SetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static MethodHandle SetTextAlign$handle() {
        return SetTextAlign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static MemorySegment SetTextAlign$address() {
        return SetTextAlign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static int SetTextAlign(MemorySegment hdc, int align) {
        var mh$ = SetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextAlign", hdc, align);
            }
            return (int)mh$.invokeExact(hdc, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextJustification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTextJustification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static FunctionDescriptor SetTextJustification$descriptor() {
        return SetTextJustification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static MethodHandle SetTextJustification$handle() {
        return SetTextJustification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static MemorySegment SetTextJustification$address() {
        return SetTextJustification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static int SetTextJustification(MemorySegment hdc, int extra, int count) {
        var mh$ = SetTextJustification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextJustification", hdc, extra, count);
            }
            return (int)mh$.invokeExact(hdc, extra, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static FunctionDescriptor UpdateColors$descriptor() {
        return UpdateColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static MethodHandle UpdateColors$handle() {
        return UpdateColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static MemorySegment UpdateColors$address() {
        return UpdateColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static int UpdateColors(MemorySegment hdc) {
        var mh$ = UpdateColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateColors", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef USHORT COLOR16
     * }
     */
    public static final OfShort COLOR16 = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *PTRIVERTEX
     * }
     */
    public static final AddressLayout PTRIVERTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *LPTRIVERTEX
     * }
     */
    public static final AddressLayout LPTRIVERTEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *PGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout PGRADIENT_TRIANGLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *LPGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout LPGRADIENT_TRIANGLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *PGRADIENT_RECT
     * }
     */
    public static final AddressLayout PGRADIENT_RECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *LPGRADIENT_RECT
     * }
     */
    public static final AddressLayout LPGRADIENT_RECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BLENDFUNCTION {
     *     BYTE BlendOp;
     *     BYTE BlendFlags;
     *     BYTE SourceConstantAlpha;
     *     BYTE AlphaFormat;
     * } *PBLENDFUNCTION
     * }
     */
    public static final AddressLayout PBLENDFUNCTION = freeglut_h.C_POINTER;

    private static class AlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor AlphaBlend$descriptor() {
        return AlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle AlphaBlend$handle() {
        return AlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MemorySegment AlphaBlend$address() {
        return AlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int AlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = AlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TransparentBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor TransparentBlt$descriptor() {
        return TransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle TransparentBlt$handle() {
        return TransparentBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MemorySegment TransparentBlt$address() {
        return TransparentBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int TransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = TransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GradientFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GradientFill$descriptor() {
        return GradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static MethodHandle GradientFill$handle() {
        return GradientFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static MemorySegment GradientFill$address() {
        return GradientFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static int GradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nMesh, int ulMode) {
        var mh$ = GradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GradientFill", hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiAlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GdiAlphaBlend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor GdiAlphaBlend$descriptor() {
        return GdiAlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle GdiAlphaBlend$handle() {
        return GdiAlphaBlend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MemorySegment GdiAlphaBlend$address() {
        return GdiAlphaBlend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int GdiAlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = GdiAlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiAlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiTransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GdiTransparentBlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor GdiTransparentBlt$descriptor() {
        return GdiTransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle GdiTransparentBlt$handle() {
        return GdiTransparentBlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MemorySegment GdiTransparentBlt$address() {
        return GdiTransparentBlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int GdiTransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = GdiTransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiTransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GdiGradientFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GdiGradientFill$descriptor() {
        return GdiGradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static MethodHandle GdiGradientFill$handle() {
        return GdiGradientFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static MemorySegment GdiGradientFill$address() {
        return GdiGradientFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static int GdiGradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nCount, int ulMode) {
        var mh$ = GdiGradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGradientFill", hdc, pVertex, nVertex, pMesh, nCount, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nCount, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PlayMetaFileRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static FunctionDescriptor PlayMetaFileRecord$descriptor() {
        return PlayMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static MethodHandle PlayMetaFileRecord$handle() {
        return PlayMetaFileRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static MemorySegment PlayMetaFileRecord$address() {
        return PlayMetaFileRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static int PlayMetaFileRecord(MemorySegment hdc, MemorySegment lpHandleTable, MemorySegment lpMR, int noObjs) {
        var mh$ = PlayMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFileRecord", hdc, lpHandleTable, lpMR, noObjs);
            }
            return (int)mh$.invokeExact(hdc, lpHandleTable, lpMR, noObjs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumMetaFile$descriptor() {
        return EnumMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumMetaFile$handle() {
        return EnumMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumMetaFile$address() {
        return EnumMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static int EnumMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, long param) {
        var mh$ = EnumMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumMetaFile", hdc, hmf, proc, param);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseEnhMetaFile$descriptor() {
        return CloseEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseEnhMetaFile$handle() {
        return CloseEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseEnhMetaFile$address() {
        return CloseEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseEnhMetaFile(MemorySegment hdc) {
        var mh$ = CloseEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEnhMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileA$descriptor() {
        return CopyEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileA$handle() {
        return CopyEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileA$address() {
        return CopyEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileA(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileA", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileW$descriptor() {
        return CopyEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileW$handle() {
        return CopyEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileW$address() {
        return CopyEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileW(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileW", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileA$descriptor() {
        return CreateEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileA$handle() {
        return CreateEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileA$address() {
        return CreateEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileA(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileA", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileW$descriptor() {
        return CreateEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileW$handle() {
        return CreateEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileW$address() {
        return CreateEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileW(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileW", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteEnhMetaFile$descriptor() {
        return DeleteEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteEnhMetaFile$handle() {
        return DeleteEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static MemorySegment DeleteEnhMetaFile$address() {
        return DeleteEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static int DeleteEnhMetaFile(MemorySegment hmf) {
        var mh$ = DeleteEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteEnhMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor EnumEnhMetaFile$descriptor() {
        return EnumEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static MethodHandle EnumEnhMetaFile$handle() {
        return EnumEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static MemorySegment EnumEnhMetaFile$address() {
        return EnumEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static int EnumEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, MemorySegment param, MemorySegment lpRect) {
        var mh$ = EnumEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumEnhMetaFile", hdc, hmf, proc, param, lpRect);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileA$descriptor() {
        return GetEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileA$handle() {
        return GetEnhMetaFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileA$address() {
        return GetEnhMetaFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileA(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileW$descriptor() {
        return GetEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileW$handle() {
        return GetEnhMetaFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileW$address() {
        return GetEnhMetaFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileW(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileBits$descriptor() {
        return GetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static MethodHandle GetEnhMetaFileBits$handle() {
        return GetEnhMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static MemorySegment GetEnhMetaFileBits$address() {
        return GetEnhMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static int GetEnhMetaFileBits(MemorySegment hEMF, int nSize, MemorySegment lpData) {
        var mh$ = GetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileBits", hEMF, nSize, lpData);
            }
            return (int)mh$.invokeExact(hEMF, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFileDescriptionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionA$descriptor() {
        return GetEnhMetaFileDescriptionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionA$handle() {
        return GetEnhMetaFileDescriptionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static MemorySegment GetEnhMetaFileDescriptionA$address() {
        return GetEnhMetaFileDescriptionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionA(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionA", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFileDescriptionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionW$descriptor() {
        return GetEnhMetaFileDescriptionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionW$handle() {
        return GetEnhMetaFileDescriptionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static MemorySegment GetEnhMetaFileDescriptionW$address() {
        return GetEnhMetaFileDescriptionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionW(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionW", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFileHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileHeader$descriptor() {
        return GetEnhMetaFileHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static MethodHandle GetEnhMetaFileHeader$handle() {
        return GetEnhMetaFileHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static MemorySegment GetEnhMetaFileHeader$address() {
        return GetEnhMetaFileHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static int GetEnhMetaFileHeader(MemorySegment hemf, int nSize, MemorySegment lpEnhMetaHeader) {
        var mh$ = GetEnhMetaFileHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileHeader", hemf, nSize, lpEnhMetaHeader);
            }
            return (int)mh$.invokeExact(hemf, nSize, lpEnhMetaHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFilePaletteEntries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePaletteEntries$descriptor() {
        return GetEnhMetaFilePaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static MethodHandle GetEnhMetaFilePaletteEntries$handle() {
        return GetEnhMetaFilePaletteEntries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static MemorySegment GetEnhMetaFilePaletteEntries$address() {
        return GetEnhMetaFilePaletteEntries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static int GetEnhMetaFilePaletteEntries(MemorySegment hemf, int nNumEntries, MemorySegment lpPaletteEntries) {
        var mh$ = GetEnhMetaFilePaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePaletteEntries", hemf, nNumEntries, lpPaletteEntries);
            }
            return (int)mh$.invokeExact(hemf, nNumEntries, lpPaletteEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetEnhMetaFilePixelFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePixelFormat$descriptor() {
        return GetEnhMetaFilePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle GetEnhMetaFilePixelFormat$handle() {
        return GetEnhMetaFilePixelFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MemorySegment GetEnhMetaFilePixelFormat$address() {
        return GetEnhMetaFilePixelFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int GetEnhMetaFilePixelFormat(MemorySegment hemf, int cbBuffer, MemorySegment ppfd) {
        var mh$ = GetEnhMetaFilePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePixelFormat", hemf, cbBuffer, ppfd);
            }
            return (int)mh$.invokeExact(hemf, cbBuffer, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWinMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static FunctionDescriptor GetWinMetaFileBits$descriptor() {
        return GetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static MethodHandle GetWinMetaFileBits$handle() {
        return GetWinMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static MemorySegment GetWinMetaFileBits$address() {
        return GetWinMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static int GetWinMetaFileBits(MemorySegment hemf, int cbData16, MemorySegment pData16, int iMapMode, MemorySegment hdcRef) {
        var mh$ = GetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWinMetaFileBits", hemf, cbData16, pData16, iMapMode, hdcRef);
            }
            return (int)mh$.invokeExact(hemf, cbData16, pData16, iMapMode, hdcRef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PlayEnhMetaFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFile$descriptor() {
        return PlayEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static MethodHandle PlayEnhMetaFile$handle() {
        return PlayEnhMetaFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static MemorySegment PlayEnhMetaFile$address() {
        return PlayEnhMetaFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static int PlayEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment lprect) {
        var mh$ = PlayEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFile", hdc, hmf, lprect);
            }
            return (int)mh$.invokeExact(hdc, hmf, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PlayEnhMetaFileRecord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFileRecord$descriptor() {
        return PlayEnhMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static MethodHandle PlayEnhMetaFileRecord$handle() {
        return PlayEnhMetaFileRecord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static MemorySegment PlayEnhMetaFileRecord$address() {
        return PlayEnhMetaFileRecord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static int PlayEnhMetaFileRecord(MemorySegment hdc, MemorySegment pht, MemorySegment pmr, int cht) {
        var mh$ = PlayEnhMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFileRecord", hdc, pht, pmr, cht);
            }
            return (int)mh$.invokeExact(hdc, pht, pmr, cht);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetEnhMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static FunctionDescriptor SetEnhMetaFileBits$descriptor() {
        return SetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MethodHandle SetEnhMetaFileBits$handle() {
        return SetEnhMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MemorySegment SetEnhMetaFileBits$address() {
        return SetEnhMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MemorySegment SetEnhMetaFileBits(int nSize, MemorySegment pb) {
        var mh$ = SetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnhMetaFileBits", nSize, pb);
            }
            return (MemorySegment)mh$.invokeExact(nSize, pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWinMetaFileBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static FunctionDescriptor SetWinMetaFileBits$descriptor() {
        return SetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MethodHandle SetWinMetaFileBits$handle() {
        return SetWinMetaFileBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MemorySegment SetWinMetaFileBits$address() {
        return SetWinMetaFileBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MemorySegment SetWinMetaFileBits(int nSize, MemorySegment lpMeta16Data, MemorySegment hdcRef, MemorySegment lpMFP) {
        var mh$ = SetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWinMetaFileBits", nSize, lpMeta16Data, hdcRef, lpMFP);
            }
            return (MemorySegment)mh$.invokeExact(nSize, lpMeta16Data, hdcRef, lpMFP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiComment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GdiComment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor GdiComment$descriptor() {
        return GdiComment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static MethodHandle GdiComment$handle() {
        return GdiComment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static MemorySegment GdiComment$address() {
        return GdiComment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static int GdiComment(MemorySegment hdc, int nSize, MemorySegment lpData) {
        var mh$ = GdiComment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiComment", hdc, nSize, lpData);
            }
            return (int)mh$.invokeExact(hdc, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextMetricsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsA$descriptor() {
        return GetTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static MethodHandle GetTextMetricsA$handle() {
        return GetTextMetricsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static MemorySegment GetTextMetricsA$address() {
        return GetTextMetricsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static int GetTextMetricsA(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsA", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextMetricsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsW$descriptor() {
        return GetTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static MethodHandle GetTextMetricsW$handle() {
        return GetTextMetricsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static MemorySegment GetTextMetricsW$address() {
        return GetTextMetricsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static int GetTextMetricsW(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsW", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *LPDIBSECTION
     * }
     */
    public static final AddressLayout LPDIBSECTION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *PDIBSECTION
     * }
     */
    public static final AddressLayout PDIBSECTION = freeglut_h.C_POINTER;

    private static class AngleArc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AngleArc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static FunctionDescriptor AngleArc$descriptor() {
        return AngleArc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static MethodHandle AngleArc$handle() {
        return AngleArc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static MemorySegment AngleArc$address() {
        return AngleArc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static int AngleArc(MemorySegment hdc, int x, int y, int r, float StartAngle, float SweepAngle) {
        var mh$ = AngleArc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AngleArc", hdc, x, y, r, StartAngle, SweepAngle);
            }
            return (int)mh$.invokeExact(hdc, x, y, r, StartAngle, SweepAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolyPolyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static FunctionDescriptor PolyPolyline$descriptor() {
        return PolyPolyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static MethodHandle PolyPolyline$handle() {
        return PolyPolyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static MemorySegment PolyPolyline$address() {
        return PolyPolyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static int PolyPolyline(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolyline", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static FunctionDescriptor GetWorldTransform$descriptor() {
        return GetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static MethodHandle GetWorldTransform$handle() {
        return GetWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static MemorySegment GetWorldTransform$address() {
        return GetWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static int GetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = GetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static FunctionDescriptor SetWorldTransform$descriptor() {
        return SetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static MethodHandle SetWorldTransform$handle() {
        return SetWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static MemorySegment SetWorldTransform$address() {
        return SetWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static int SetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = SetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ModifyWorldTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static FunctionDescriptor ModifyWorldTransform$descriptor() {
        return ModifyWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static MethodHandle ModifyWorldTransform$handle() {
        return ModifyWorldTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static MemorySegment ModifyWorldTransform$address() {
        return ModifyWorldTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static int ModifyWorldTransform(MemorySegment hdc, MemorySegment lpxf, int mode) {
        var mh$ = ModifyWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyWorldTransform", hdc, lpxf, mode);
            }
            return (int)mh$.invokeExact(hdc, lpxf, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CombineTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static FunctionDescriptor CombineTransform$descriptor() {
        return CombineTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static MethodHandle CombineTransform$handle() {
        return CombineTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static MemorySegment CombineTransform$address() {
        return CombineTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static int CombineTransform(MemorySegment lpxfOut, MemorySegment lpxf1, MemorySegment lpxf2) {
        var mh$ = CombineTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineTransform", lpxfOut, lpxf1, lpxf2);
            }
            return (int)mh$.invokeExact(lpxfOut, lpxf1, lpxf2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDIBSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static FunctionDescriptor CreateDIBSection$descriptor() {
        return CreateDIBSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MethodHandle CreateDIBSection$handle() {
        return CreateDIBSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MemorySegment CreateDIBSection$address() {
        return CreateDIBSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MemorySegment CreateDIBSection(MemorySegment hdc, MemorySegment pbmi, int usage, MemorySegment ppvBits, MemorySegment hSection, int offset) {
        var mh$ = CreateDIBSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBSection", hdc, pbmi, usage, ppvBits, hSection, offset);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmi, usage, ppvBits, hSection, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDIBColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor GetDIBColorTable$descriptor() {
        return GetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle GetDIBColorTable$handle() {
        return GetDIBColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static MemorySegment GetDIBColorTable$address() {
        return GetDIBColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static int GetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = GetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDIBColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor SetDIBColorTable$descriptor() {
        return SetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle SetDIBColorTable$handle() {
        return SetDIBColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static MemorySegment SetDIBColorTable$address() {
        return SetDIBColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static int SetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = SetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *PCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PCOLORADJUSTMENT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *LPCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout LPCOLORADJUSTMENT = freeglut_h.C_POINTER;

    private static class SetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetColorAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static FunctionDescriptor SetColorAdjustment$descriptor() {
        return SetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static MethodHandle SetColorAdjustment$handle() {
        return SetColorAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static MemorySegment SetColorAdjustment$address() {
        return SetColorAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static int SetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = SetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetColorAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static FunctionDescriptor GetColorAdjustment$descriptor() {
        return GetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static MethodHandle GetColorAdjustment$handle() {
        return GetColorAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static MemorySegment GetColorAdjustment$address() {
        return GetColorAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static int GetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = GetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHalftonePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateHalftonePalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateHalftonePalette$descriptor() {
        return CreateHalftonePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MethodHandle CreateHalftonePalette$handle() {
        return CreateHalftonePalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MemorySegment CreateHalftonePalette$address() {
        return CreateHalftonePalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MemorySegment CreateHalftonePalette(MemorySegment hdc) {
        var mh$ = CreateHalftonePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHalftonePalette", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOA {
     *     int cbSize;
     *     LPCSTR lpszDocName;
     *     LPCSTR lpszOutput;
     *     LPCSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOA
     * }
     */
    public static final AddressLayout LPDOCINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOW {
     *     int cbSize;
     *     LPCWSTR lpszDocName;
     *     LPCWSTR lpszOutput;
     *     LPCWSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOW
     * }
     */
    public static final AddressLayout LPDOCINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDOCINFOA LPDOCINFO
     * }
     */
    public static final AddressLayout LPDOCINFO = freeglut_h.C_POINTER;

    private static class StartDocA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartDocA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocA$descriptor() {
        return StartDocA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static MethodHandle StartDocA$handle() {
        return StartDocA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static MemorySegment StartDocA$address() {
        return StartDocA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static int StartDocA(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocA", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartDocW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartDocW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocW$descriptor() {
        return StartDocW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static MethodHandle StartDocW$handle() {
        return StartDocW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static MemorySegment StartDocW$address() {
        return StartDocW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static int StartDocW(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocW", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndDoc$descriptor() {
        return EndDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static MethodHandle EndDoc$handle() {
        return EndDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static MemorySegment EndDoc$address() {
        return EndDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static int EndDoc(MemorySegment hdc) {
        var mh$ = EndDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartPage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor StartPage$descriptor() {
        return StartPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static MethodHandle StartPage$handle() {
        return StartPage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static MemorySegment StartPage$address() {
        return StartPage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static int StartPage(MemorySegment hdc) {
        var mh$ = StartPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndPage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPage$descriptor() {
        return EndPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static MethodHandle EndPage$handle() {
        return EndPage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static MemorySegment EndPage$address() {
        return EndPage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static int EndPage(MemorySegment hdc) {
        var mh$ = EndPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AbortDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortDoc$descriptor() {
        return AbortDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static MethodHandle AbortDoc$handle() {
        return AbortDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static MemorySegment AbortDoc$address() {
        return AbortDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static int AbortDoc(MemorySegment hdc) {
        var mh$ = AbortDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAbortProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetAbortProc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static FunctionDescriptor SetAbortProc$descriptor() {
        return SetAbortProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static MethodHandle SetAbortProc$handle() {
        return SetAbortProc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static MemorySegment SetAbortProc$address() {
        return SetAbortProc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static int SetAbortProc(MemorySegment hdc, MemorySegment proc) {
        var mh$ = SetAbortProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAbortProc", hdc, proc);
            }
            return (int)mh$.invokeExact(hdc, proc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AbortPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortPath$descriptor() {
        return AbortPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static MethodHandle AbortPath$handle() {
        return AbortPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static MemorySegment AbortPath$address() {
        return AbortPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static int AbortPath(MemorySegment hdc) {
        var mh$ = AbortPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ArcTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ArcTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor ArcTo$descriptor() {
        return ArcTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle ArcTo$handle() {
        return ArcTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MemorySegment ArcTo$address() {
        return ArcTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int ArcTo(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = ArcTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ArcTo", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BeginPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor BeginPath$descriptor() {
        return BeginPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static MethodHandle BeginPath$handle() {
        return BeginPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static MemorySegment BeginPath$address() {
        return BeginPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static int BeginPath(MemorySegment hdc) {
        var mh$ = BeginPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseFigure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseFigure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseFigure$descriptor() {
        return CloseFigure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static MethodHandle CloseFigure$handle() {
        return CloseFigure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static MemorySegment CloseFigure$address() {
        return CloseFigure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static int CloseFigure(MemorySegment hdc) {
        var mh$ = CloseFigure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseFigure", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPath$descriptor() {
        return EndPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static MethodHandle EndPath$handle() {
        return EndPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static MemorySegment EndPath$address() {
        return EndPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static int EndPath(MemorySegment hdc) {
        var mh$ = EndPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FillPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FillPath$descriptor() {
        return FillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static MethodHandle FillPath$handle() {
        return FillPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static MemorySegment FillPath$address() {
        return FillPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static int FillPath(MemorySegment hdc) {
        var mh$ = FillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlattenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlattenPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FlattenPath$descriptor() {
        return FlattenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static MethodHandle FlattenPath$handle() {
        return FlattenPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static MemorySegment FlattenPath$address() {
        return FlattenPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static int FlattenPath(MemorySegment hdc) {
        var mh$ = FlattenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlattenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static FunctionDescriptor GetPath$descriptor() {
        return GetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static MethodHandle GetPath$handle() {
        return GetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static MemorySegment GetPath$address() {
        return GetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static int GetPath(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = GetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPath", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PathToRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PathToRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static FunctionDescriptor PathToRegion$descriptor() {
        return PathToRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MethodHandle PathToRegion$handle() {
        return PathToRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MemorySegment PathToRegion$address() {
        return PathToRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MemorySegment PathToRegion(MemorySegment hdc) {
        var mh$ = PathToRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PathToRegion", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolyDraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static FunctionDescriptor PolyDraw$descriptor() {
        return PolyDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static MethodHandle PolyDraw$handle() {
        return PolyDraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static MemorySegment PolyDraw$address() {
        return PolyDraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static int PolyDraw(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = PolyDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyDraw", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SelectClipPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SelectClipPath$descriptor() {
        return SelectClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SelectClipPath$handle() {
        return SelectClipPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SelectClipPath$address() {
        return SelectClipPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static int SelectClipPath(MemorySegment hdc, int mode) {
        var mh$ = SelectClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipPath", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetArcDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static FunctionDescriptor SetArcDirection$descriptor() {
        return SetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static MethodHandle SetArcDirection$handle() {
        return SetArcDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static MemorySegment SetArcDirection$address() {
        return SetArcDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static int SetArcDirection(MemorySegment hdc, int dir) {
        var mh$ = SetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetArcDirection", hdc, dir);
            }
            return (int)mh$.invokeExact(hdc, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static FunctionDescriptor SetMiterLimit$descriptor() {
        return SetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static MethodHandle SetMiterLimit$handle() {
        return SetMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static MemorySegment SetMiterLimit$address() {
        return SetMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static int SetMiterLimit(MemorySegment hdc, float limit, MemorySegment old) {
        var mh$ = SetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMiterLimit", hdc, limit, old);
            }
            return (int)mh$.invokeExact(hdc, limit, old);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokeAndFillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StrokeAndFillPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokeAndFillPath$descriptor() {
        return StrokeAndFillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static MethodHandle StrokeAndFillPath$handle() {
        return StrokeAndFillPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static MemorySegment StrokeAndFillPath$address() {
        return StrokeAndFillPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static int StrokeAndFillPath(MemorySegment hdc) {
        var mh$ = StrokeAndFillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokeAndFillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokePath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StrokePath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokePath$descriptor() {
        return StrokePath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static MethodHandle StrokePath$handle() {
        return StrokePath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static MemorySegment StrokePath$address() {
        return StrokePath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static int StrokePath(MemorySegment hdc) {
        var mh$ = StrokePath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokePath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WidenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WidenPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor WidenPath$descriptor() {
        return WidenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static MethodHandle WidenPath$handle() {
        return WidenPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static MemorySegment WidenPath$address() {
        return WidenPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static int WidenPath(MemorySegment hdc) {
        var mh$ = WidenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WidenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExtCreatePen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static FunctionDescriptor ExtCreatePen$descriptor() {
        return ExtCreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MethodHandle ExtCreatePen$handle() {
        return ExtCreatePen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MemorySegment ExtCreatePen$address() {
        return ExtCreatePen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MemorySegment ExtCreatePen(int iPenStyle, int cWidth, MemorySegment plbrush, int cStyle, MemorySegment pstyle) {
        var mh$ = ExtCreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreatePen", iPenStyle, cWidth, plbrush, cStyle, pstyle);
            }
            return (MemorySegment)mh$.invokeExact(iPenStyle, cWidth, plbrush, cStyle, pstyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMiterLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static FunctionDescriptor GetMiterLimit$descriptor() {
        return GetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static MethodHandle GetMiterLimit$handle() {
        return GetMiterLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static MemorySegment GetMiterLimit$address() {
        return GetMiterLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static int GetMiterLimit(MemorySegment hdc, MemorySegment plimit) {
        var mh$ = GetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMiterLimit", hdc, plimit);
            }
            return (int)mh$.invokeExact(hdc, plimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetArcDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetArcDirection$descriptor() {
        return GetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static MethodHandle GetArcDirection$handle() {
        return GetArcDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static MemorySegment GetArcDirection$address() {
        return GetArcDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static int GetArcDirection(MemorySegment hdc) {
        var mh$ = GetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetArcDirection", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetObjectA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectA$descriptor() {
        return GetObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectA$handle() {
        return GetObjectA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MemorySegment GetObjectA$address() {
        return GetObjectA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectA(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectA", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetObjectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectW$descriptor() {
        return GetObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectW$handle() {
        return GetObjectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MemorySegment GetObjectW$address() {
        return GetObjectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectW(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectW", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveToEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveToEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor MoveToEx$descriptor() {
        return MoveToEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle MoveToEx$handle() {
        return MoveToEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment MoveToEx$address() {
        return MoveToEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int MoveToEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = MoveToEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveToEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutA$descriptor() {
        return TextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutA$handle() {
        return TextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static MemorySegment TextOutA$address() {
        return TextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static int TextOutA(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutA", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutW$descriptor() {
        return TextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutW$handle() {
        return TextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static MemorySegment TextOutW$address() {
        return TextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static int TextOutW(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutW", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExtTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutA$descriptor() {
        return ExtTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutA$handle() {
        return ExtTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MemorySegment ExtTextOutA$address() {
        return ExtTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutA(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutA", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExtTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutW$descriptor() {
        return ExtTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutW$handle() {
        return ExtTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MemorySegment ExtTextOutW$address() {
        return ExtTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutW(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutW", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolyTextOutA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutA$descriptor() {
        return PolyTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutA$handle() {
        return PolyTextOutA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static MemorySegment PolyTextOutA$address() {
        return PolyTextOutA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutA(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutA", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolyTextOutW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutW$descriptor() {
        return PolyTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutW$handle() {
        return PolyTextOutW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static MemorySegment PolyTextOutW$address() {
        return PolyTextOutW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutW(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutW", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePolygonRgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolygonRgn$descriptor() {
        return CreatePolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MethodHandle CreatePolygonRgn$handle() {
        return CreatePolygonRgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MemorySegment CreatePolygonRgn$address() {
        return CreatePolygonRgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MemorySegment CreatePolygonRgn(MemorySegment pptl, int cPoint, int iMode) {
        var mh$ = CreatePolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolygonRgn", pptl, cPoint, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, cPoint, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DPtoLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DPtoLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor DPtoLP$descriptor() {
        return DPtoLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle DPtoLP$handle() {
        return DPtoLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MemorySegment DPtoLP$address() {
        return DPtoLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int DPtoLP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = DPtoLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DPtoLP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LPtoDP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LPtoDP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor LPtoDP$descriptor() {
        return LPtoDP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle LPtoDP$handle() {
        return LPtoDP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MemorySegment LPtoDP$address() {
        return LPtoDP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int LPtoDP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = LPtoDP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LPtoDP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Polygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polygon$descriptor() {
        return Polygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polygon$handle() {
        return Polygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MemorySegment Polygon$address() {
        return Polygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polygon(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polygon", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Polyline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polyline$descriptor() {
        return Polyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polyline$handle() {
        return Polyline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MemorySegment Polyline$address() {
        return Polyline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polyline(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polyline", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolyBezier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezier$descriptor() {
        return PolyBezier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezier$handle() {
        return PolyBezier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolyBezier$address() {
        return PolyBezier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezier(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezier", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezierTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolyBezierTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezierTo$descriptor() {
        return PolyBezierTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezierTo$handle() {
        return PolyBezierTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolyBezierTo$address() {
        return PolyBezierTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezierTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezierTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezierTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolylineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PolylineTo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolylineTo$descriptor() {
        return PolylineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolylineTo$handle() {
        return PolylineTo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MemorySegment PolylineTo$address() {
        return PolylineTo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolylineTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolylineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolylineTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetViewportExtEx$descriptor() {
        return SetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetViewportExtEx$handle() {
        return SetViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetViewportExtEx$address() {
        return SetViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetViewportExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetViewportOrgEx$descriptor() {
        return SetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetViewportOrgEx$handle() {
        return SetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetViewportOrgEx$address() {
        return SetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetWindowExtEx$descriptor() {
        return SetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetWindowExtEx$handle() {
        return SetWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetWindowExtEx$address() {
        return SetWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetWindowExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetWindowOrgEx$descriptor() {
        return SetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetWindowOrgEx$handle() {
        return SetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetWindowOrgEx$address() {
        return SetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OffsetViewportOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetViewportOrgEx$descriptor() {
        return OffsetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetViewportOrgEx$handle() {
        return OffsetViewportOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment OffsetViewportOrgEx$address() {
        return OffsetViewportOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OffsetWindowOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetWindowOrgEx$descriptor() {
        return OffsetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetWindowOrgEx$handle() {
        return OffsetWindowOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment OffsetWindowOrgEx$address() {
        return OffsetWindowOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScaleViewportExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleViewportExtEx$descriptor() {
        return ScaleViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleViewportExtEx$handle() {
        return ScaleViewportExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MemorySegment ScaleViewportExtEx$address() {
        return ScaleViewportExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleViewportExtEx(MemorySegment hdc, int xn, int dx, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleViewportExtEx", hdc, xn, dx, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, dx, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScaleWindowExtEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleWindowExtEx$descriptor() {
        return ScaleWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleWindowExtEx$handle() {
        return ScaleWindowExtEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MemorySegment ScaleWindowExtEx$address() {
        return ScaleWindowExtEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleWindowExtEx(MemorySegment hdc, int xn, int xd, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleWindowExtEx", hdc, xn, xd, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, xd, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetBitmapDimensionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetBitmapDimensionEx$descriptor() {
        return SetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetBitmapDimensionEx$handle() {
        return SetBitmapDimensionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static MemorySegment SetBitmapDimensionEx$address() {
        return SetBitmapDimensionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static int SetBitmapDimensionEx(MemorySegment hbm, int w, int h, MemorySegment lpsz) {
        var mh$ = SetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapDimensionEx", hbm, w, h, lpsz);
            }
            return (int)mh$.invokeExact(hbm, w, h, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetBrushOrgEx$descriptor() {
        return SetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetBrushOrgEx$handle() {
        return SetBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MemorySegment SetBrushOrgEx$address() {
        return SetBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBrushOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextFaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceA$descriptor() {
        return GetTextFaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceA$handle() {
        return GetTextFaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static MemorySegment GetTextFaceA$address() {
        return GetTextFaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static int GetTextFaceA(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceA", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTextFaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceW$descriptor() {
        return GetTextFaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceW$handle() {
        return GetTextFaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static MemorySegment GetTextFaceW$address() {
        return GetTextFaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static int GetTextFaceW(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceW", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagKERNINGPAIR {
     *     WORD wFirst;
     *     WORD wSecond;
     *     int iKernAmount;
     * } *LPKERNINGPAIR
     * }
     */
    public static final AddressLayout LPKERNINGPAIR = freeglut_h.C_POINTER;

    private static class GetKerningPairsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKerningPairsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsA$descriptor() {
        return GetKerningPairsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsA$handle() {
        return GetKerningPairsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MemorySegment GetKerningPairsA$address() {
        return GetKerningPairsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsA(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsA", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKerningPairsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKerningPairsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsW$descriptor() {
        return GetKerningPairsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsW$handle() {
        return GetKerningPairsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MemorySegment GetKerningPairsW$address() {
        return GetKerningPairsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsW(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsW", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDCOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetDCOrgEx$descriptor() {
        return GetDCOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetDCOrgEx$handle() {
        return GetDCOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MemorySegment GetDCOrgEx$address() {
        return GetDCOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetDCOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetDCOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FixBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FixBrushOrgEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static FunctionDescriptor FixBrushOrgEx$descriptor() {
        return FixBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static MethodHandle FixBrushOrgEx$handle() {
        return FixBrushOrgEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static MemorySegment FixBrushOrgEx$address() {
        return FixBrushOrgEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static int FixBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment ptl) {
        var mh$ = FixBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FixBrushOrgEx", hdc, x, y, ptl);
            }
            return (int)mh$.invokeExact(hdc, x, y, ptl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnrealizeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnrealizeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor UnrealizeObject$descriptor() {
        return UnrealizeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static MethodHandle UnrealizeObject$handle() {
        return UnrealizeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static MemorySegment UnrealizeObject$address() {
        return UnrealizeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static int UnrealizeObject(MemorySegment h) {
        var mh$ = UnrealizeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnrealizeObject", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GdiFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static FunctionDescriptor GdiFlush$descriptor() {
        return GdiFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static MethodHandle GdiFlush$handle() {
        return GdiFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static MemorySegment GdiFlush$address() {
        return GdiFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static int GdiFlush() {
        var mh$ = GdiFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiFlush");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiSetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GdiSetBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static FunctionDescriptor GdiSetBatchLimit$descriptor() {
        return GdiSetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static MethodHandle GdiSetBatchLimit$handle() {
        return GdiSetBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static MemorySegment GdiSetBatchLimit$address() {
        return GdiSetBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static int GdiSetBatchLimit(int dw) {
        var mh$ = GdiSetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiSetBatchLimit", dw);
            }
            return (int)mh$.invokeExact(dw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GdiGetBatchLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static FunctionDescriptor GdiGetBatchLimit$descriptor() {
        return GdiGetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static MethodHandle GdiGetBatchLimit$handle() {
        return GdiGetBatchLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static MemorySegment GdiGetBatchLimit$address() {
        return GdiGetBatchLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static int GdiGetBatchLimit() {
        var mh$ = GdiGetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGetBatchLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetICMMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetICMMode$descriptor() {
        return SetICMMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetICMMode$handle() {
        return SetICMMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static MemorySegment SetICMMode$address() {
        return SetICMMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static int SetICMMode(MemorySegment hdc, int mode) {
        var mh$ = SetICMMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckColorsInGamut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckColorsInGamut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static FunctionDescriptor CheckColorsInGamut$descriptor() {
        return CheckColorsInGamut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static MethodHandle CheckColorsInGamut$handle() {
        return CheckColorsInGamut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static MemorySegment CheckColorsInGamut$address() {
        return CheckColorsInGamut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static int CheckColorsInGamut(MemorySegment hdc, MemorySegment lpRGBTriple, MemorySegment dlpBuffer, int nCount) {
        var mh$ = CheckColorsInGamut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckColorsInGamut", hdc, lpRGBTriple, dlpBuffer, nCount);
            }
            return (int)mh$.invokeExact(hdc, lpRGBTriple, dlpBuffer, nCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetColorSpace$descriptor() {
        return GetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MethodHandle GetColorSpace$handle() {
        return GetColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MemorySegment GetColorSpace$address() {
        return GetColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MemorySegment GetColorSpace(MemorySegment hdc) {
        var mh$ = GetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorSpace", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLogColorSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceA$descriptor() {
        return GetLogColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceA$handle() {
        return GetLogColorSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetLogColorSpaceA$address() {
        return GetLogColorSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceA(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceA", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLogColorSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceW$descriptor() {
        return GetLogColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceW$handle() {
        return GetLogColorSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetLogColorSpaceW$address() {
        return GetLogColorSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceW(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceW", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateColorSpaceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceA$descriptor() {
        return CreateColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceA$handle() {
        return CreateColorSpaceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceA$address() {
        return CreateColorSpaceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceA(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceA", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateColorSpaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceW$descriptor() {
        return CreateColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceW$handle() {
        return CreateColorSpaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceW$address() {
        return CreateColorSpaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceW(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceW", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor SetColorSpace$descriptor() {
        return SetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle SetColorSpace$handle() {
        return SetColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment SetColorSpace$address() {
        return SetColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment SetColorSpace(MemorySegment hdc, MemorySegment hcs) {
        var mh$ = SetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorSpace", hdc, hcs);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteColorSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor DeleteColorSpace$descriptor() {
        return DeleteColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle DeleteColorSpace$handle() {
        return DeleteColorSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment DeleteColorSpace$address() {
        return DeleteColorSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static int DeleteColorSpace(MemorySegment hcs) {
        var mh$ = DeleteColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteColorSpace", hcs);
            }
            return (int)mh$.invokeExact(hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetICMProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileA$descriptor() {
        return GetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileA$handle() {
        return GetICMProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static MemorySegment GetICMProfileA$address() {
        return GetICMProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static int GetICMProfileA(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileA", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetICMProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileW$descriptor() {
        return GetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileW$handle() {
        return GetICMProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static MemorySegment GetICMProfileW$address() {
        return GetICMProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static int GetICMProfileW(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileW", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetICMProfileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileA$descriptor() {
        return SetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileA$handle() {
        return SetICMProfileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static MemorySegment SetICMProfileA$address() {
        return SetICMProfileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static int SetICMProfileA(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileA", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetICMProfileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileW$descriptor() {
        return SetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileW$handle() {
        return SetICMProfileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static MemorySegment SetICMProfileW$address() {
        return SetICMProfileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static int SetICMProfileW(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileW", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDeviceGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor GetDeviceGammaRamp$descriptor() {
        return GetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle GetDeviceGammaRamp$handle() {
        return GetDeviceGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MemorySegment GetDeviceGammaRamp$address() {
        return GetDeviceGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int GetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = GetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDeviceGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor SetDeviceGammaRamp$descriptor() {
        return SetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle SetDeviceGammaRamp$handle() {
        return SetDeviceGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MemorySegment SetDeviceGammaRamp$address() {
        return SetDeviceGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int SetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = SetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorMatchToTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ColorMatchToTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static FunctionDescriptor ColorMatchToTarget$descriptor() {
        return ColorMatchToTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static MethodHandle ColorMatchToTarget$handle() {
        return ColorMatchToTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static MemorySegment ColorMatchToTarget$address() {
        return ColorMatchToTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static int ColorMatchToTarget(MemorySegment hdc, MemorySegment hdcTarget, int action) {
        var mh$ = ColorMatchToTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorMatchToTarget", hdc, hdcTarget, action);
            }
            return (int)mh$.invokeExact(hdc, hdcTarget, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumICMProfilesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesA$descriptor() {
        return EnumICMProfilesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesA$handle() {
        return EnumICMProfilesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumICMProfilesA$address() {
        return EnumICMProfilesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesA(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesA", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumICMProfilesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesW$descriptor() {
        return EnumICMProfilesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesW$handle() {
        return EnumICMProfilesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static MemorySegment EnumICMProfilesW$address() {
        return EnumICMProfilesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesW(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesW", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateICMRegKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyA$descriptor() {
        return UpdateICMRegKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyA$handle() {
        return UpdateICMRegKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static MemorySegment UpdateICMRegKeyA$address() {
        return UpdateICMRegKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyA(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyA", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateICMRegKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyW$descriptor() {
        return UpdateICMRegKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyW$handle() {
        return UpdateICMRegKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static MemorySegment UpdateICMRegKeyW$address() {
        return UpdateICMRegKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyW(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyW", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorCorrectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ColorCorrectPalette");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static FunctionDescriptor ColorCorrectPalette$descriptor() {
        return ColorCorrectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static MethodHandle ColorCorrectPalette$handle() {
        return ColorCorrectPalette.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static MemorySegment ColorCorrectPalette$address() {
        return ColorCorrectPalette.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static int ColorCorrectPalette(MemorySegment hdc, MemorySegment hPal, int deFirst, int num) {
        var mh$ = ColorCorrectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorCorrectPalette", hdc, hPal, deFirst, num);
            }
            return (int)mh$.invokeExact(hdc, hPal, deFirst, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagEMR {
     *     DWORD iType;
     *     DWORD nSize;
     * } *PEMR
     * }
     */
    public static final AddressLayout PEMR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTEXT {
     *     POINTL ptlReference;
     *     DWORD nChars;
     *     DWORD offString;
     *     DWORD fOptions;
     *     RECTL rcl;
     *     DWORD offDx;
     * } *PEMRTEXT
     * }
     */
    public static final AddressLayout PEMRTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRABORTPATH
     * }
     */
    public static final AddressLayout PEMRABORTPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRBEGINPATH
     * }
     */
    public static final AddressLayout PEMRBEGINPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRENDPATH
     * }
     */
    public static final AddressLayout PEMRENDPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRCLOSEFIGURE
     * }
     */
    public static final AddressLayout PEMRCLOSEFIGURE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRFLATTENPATH
     * }
     */
    public static final AddressLayout PEMRFLATTENPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRWIDENPATH
     * }
     */
    public static final AddressLayout PEMRWIDENPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSETMETARGN
     * }
     */
    public static final AddressLayout PEMRSETMETARGN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSAVEDC
     * }
     */
    public static final AddressLayout PEMRSAVEDC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRREALIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRREALIZEPALETTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSELECTCLIPPATH
     * }
     */
    public static final AddressLayout PEMRSELECTCLIPPATH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETBKMODE
     * }
     */
    public static final AddressLayout PEMRSETBKMODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETMAPMODE
     * }
     */
    public static final AddressLayout PEMRSETMAPMODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETLAYOUT
     * }
     */
    public static final AddressLayout PEMRSETLAYOUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETPOLYFILLMODE
     * }
     */
    public static final AddressLayout PEMRSETPOLYFILLMODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETROP2
     * }
     */
    public static final AddressLayout PEMRSETROP2 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETSTRETCHBLTMODE
     * }
     */
    public static final AddressLayout PEMRSETSTRETCHBLTMODE = freeglut_h.C_POINTER;
}

