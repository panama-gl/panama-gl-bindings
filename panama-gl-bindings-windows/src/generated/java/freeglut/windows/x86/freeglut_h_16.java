// Generated by jextract

package freeglut.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h_16 extends freeglut_h_17 {

    freeglut_h_16() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef const __unaligned WCHAR *PCUWCHAR
     * }
     */
    public static final AddressLayout PCUWCHAR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long UCSCHAR
     * }
     */
    public static final OfInt UCSCHAR = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef UCSCHAR *PUCSCHAR
     * }
     */
    public static final AddressLayout PUCSCHAR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const UCSCHAR *PCUCSCHAR
     * }
     */
    public static final AddressLayout PCUCSCHAR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef UCSCHAR *PUCSSTR
     * }
     */
    public static final AddressLayout PUCSSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned UCSCHAR *PUUCSSTR
     * }
     */
    public static final AddressLayout PUUCSSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const UCSCHAR *PCUCSSTR
     * }
     */
    public static final AddressLayout PCUCSSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const __unaligned UCSCHAR *PCUUCSSTR
     * }
     */
    public static final AddressLayout PCUUCSSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned UCSCHAR *PUUCSCHAR
     * }
     */
    public static final AddressLayout PUUCSCHAR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const __unaligned UCSCHAR *PCUUCSCHAR
     * }
     */
    public static final AddressLayout PCUUCSCHAR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *PCHAR
     * }
     */
    public static final AddressLayout PCHAR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *LPCH
     * }
     */
    public static final AddressLayout LPCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *PCH
     * }
     */
    public static final AddressLayout PCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHAR *LPCCH
     * }
     */
    public static final AddressLayout LPCCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHAR *PCCH
     * }
     */
    public static final AddressLayout PCCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *NPSTR
     * }
     */
    public static final AddressLayout NPSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *LPSTR
     * }
     */
    public static final AddressLayout LPSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *PSTR
     * }
     */
    public static final AddressLayout PSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSTR *PZPSTR
     * }
     */
    public static final AddressLayout PZPSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const PSTR *PCZPSTR
     * }
     */
    public static final AddressLayout PCZPSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHAR *LPCSTR
     * }
     */
    public static final AddressLayout LPCSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHAR *PCSTR
     * }
     */
    public static final AddressLayout PCSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCSTR *PZPCSTR
     * }
     */
    public static final AddressLayout PZPCSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const PCSTR *PCZPCSTR
     * }
     */
    public static final AddressLayout PCZPCSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *PZZSTR
     * }
     */
    public static final AddressLayout PZZSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHAR *PCZZSTR
     * }
     */
    public static final AddressLayout PCZZSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CHAR *PNZCH
     * }
     */
    public static final AddressLayout PNZCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CHAR *PCNZCH
     * }
     */
    public static final AddressLayout PCNZCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char TCHAR
     * }
     */
    public static final OfByte TCHAR = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef char *PTCHAR
     * }
     */
    public static final AddressLayout PTCHAR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned char TBYTE
     * }
     */
    public static final OfByte TBYTE = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char *PTBYTE
     * }
     */
    public static final AddressLayout PTBYTE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCH LPTCH
     * }
     */
    public static final AddressLayout LPTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCH PTCH
     * }
     */
    public static final AddressLayout PTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCCH LPCTCH
     * }
     */
    public static final AddressLayout LPCTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCCH PCTCH
     * }
     */
    public static final AddressLayout PCTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTR PTSTR
     * }
     */
    public static final AddressLayout PTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTR LPTSTR
     * }
     */
    public static final AddressLayout LPTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTR PUTSTR
     * }
     */
    public static final AddressLayout PUTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTR LPUTSTR
     * }
     */
    public static final AddressLayout LPUTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCSTR PCTSTR
     * }
     */
    public static final AddressLayout PCTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCSTR LPCTSTR
     * }
     */
    public static final AddressLayout LPCTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCSTR PCUTSTR
     * }
     */
    public static final AddressLayout PCUTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCSTR LPCUTSTR
     * }
     */
    public static final AddressLayout LPCUTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PZZSTR PZZTSTR
     * }
     */
    public static final AddressLayout PZZTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PZZSTR PUZZTSTR
     * }
     */
    public static final AddressLayout PUZZTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCZZSTR PCZZTSTR
     * }
     */
    public static final AddressLayout PCZZTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCZZSTR PCUZZTSTR
     * }
     */
    public static final AddressLayout PCUZZTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PZPSTR PZPTSTR
     * }
     */
    public static final AddressLayout PZPTSTR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNZCH PNZTCH
     * }
     */
    public static final AddressLayout PNZTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNZCH PUNZTCH
     * }
     */
    public static final AddressLayout PUNZTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCNZCH PCNZTCH
     * }
     */
    public static final AddressLayout PCNZTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCNZCH PCUNZTCH
     * }
     */
    public static final AddressLayout PCUNZTCH = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SHORT *PSHORT
     * }
     */
    public static final AddressLayout PSHORT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG *PLONG
     * }
     */
    public static final AddressLayout PLONG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESSOR_NUMBER {
     *     WORD Group;
     *     BYTE Number;
     *     BYTE Reserved;
     * } *PPROCESSOR_NUMBER
     * }
     */
    public static final AddressLayout PPROCESSOR_NUMBER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GROUP_AFFINITY {
     *     KAFFINITY Mask;
     *     WORD Group;
     *     WORD Reserved[3];
     * } *PGROUP_AFFINITY
     * }
     */
    public static final AddressLayout PGROUP_AFFINITY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HANDLE
     * }
     */
    public static final AddressLayout HANDLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *PHANDLE
     * }
     */
    public static final AddressLayout PHANDLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BYTE FCHAR
     * }
     */
    public static final OfByte FCHAR = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef WORD FSHORT
     * }
     */
    public static final OfShort FSHORT = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef DWORD FLONG
     * }
     */
    public static final OfInt FLONG = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long HRESULT
     * }
     */
    public static final OfInt HRESULT = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char CCHAR
     * }
     */
    public static final OfByte CCHAR = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef DWORD LCID
     * }
     */
    public static final OfInt LCID = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef PDWORD PLCID
     * }
     */
    public static final AddressLayout PLCID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD LANGID
     * }
     */
    public static final OfShort LANGID = freeglut_h.C_SHORT;
    private static final int UNSPECIFIED_COMPARTMENT_ID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UNSPECIFIED_COMPARTMENT_ID = 0
     * }
     */
    public static int UNSPECIFIED_COMPARTMENT_ID() {
        return UNSPECIFIED_COMPARTMENT_ID;
    }
    private static final int DEFAULT_COMPARTMENT_ID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DEFAULT_COMPARTMENT_ID = 1
     * }
     */
    public static int DEFAULT_COMPARTMENT_ID() {
        return DEFAULT_COMPARTMENT_ID;
    }
    /**
     * {@snippet lang=c :
     * typedef enum {
     *     UNSPECIFIED_COMPARTMENT_ID = 0,
     *     DEFAULT_COMPARTMENT_ID
     * } *PCOMPARTMENT_ID
     * }
     */
    public static final AddressLayout PCOMPARTMENT_ID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef FLOAT128 *PFLOAT128
     * }
     */
    public static final AddressLayout PFLOAT128 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long LONGLONG
     * }
     */
    public static final OfLong LONGLONG = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long ULONGLONG
     * }
     */
    public static final OfLong ULONGLONG = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONGLONG *PLONGLONG
     * }
     */
    public static final AddressLayout PLONGLONG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONGLONG *PULONGLONG
     * }
     */
    public static final AddressLayout PULONGLONG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONGLONG USN
     * }
     */
    public static final OfLong USN = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LARGE_INTEGER *PLARGE_INTEGER
     * }
     */
    public static final AddressLayout PLARGE_INTEGER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULARGE_INTEGER *PULARGE_INTEGER
     * }
     */
    public static final AddressLayout PULARGE_INTEGER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR RTL_REFERENCE_COUNT
     * }
     */
    public static final OfLong RTL_REFERENCE_COUNT = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR *PRTL_REFERENCE_COUNT
     * }
     */
    public static final AddressLayout PRTL_REFERENCE_COUNT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG RTL_REFERENCE_COUNT32
     * }
     */
    public static final OfInt RTL_REFERENCE_COUNT32 = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG *PRTL_REFERENCE_COUNT32
     * }
     */
    public static final AddressLayout PRTL_REFERENCE_COUNT32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _LUID {
     *     DWORD LowPart;
     *     LONG HighPart;
     * } *PLUID
     * }
     */
    public static final AddressLayout PLUID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONGLONG DWORDLONG
     * }
     */
    public static final OfLong DWORDLONG = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORDLONG *PDWORDLONG
     * }
     */
    public static final AddressLayout PDWORDLONG = freeglut_h.C_POINTER;

    private static class _rotl8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotl8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _rotl8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static FunctionDescriptor _rotl8$descriptor() {
        return _rotl8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _rotl8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static MethodHandle _rotl8$handle() {
        return _rotl8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _rotl8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static MemorySegment _rotl8$address() {
        return _rotl8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _rotl8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static byte _rotl8(byte Value, byte Shift) {
        var mh$ = _rotl8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl8", Value, Shift);
            }
            return (byte)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotl16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short _rotl16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static FunctionDescriptor _rotl16$descriptor() {
        return _rotl16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short _rotl16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static MethodHandle _rotl16$handle() {
        return _rotl16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short _rotl16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static MemorySegment _rotl16$address() {
        return _rotl16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short _rotl16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static short _rotl16(short Value, byte Shift) {
        var mh$ = _rotl16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl16", Value, Shift);
            }
            return (short)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotr8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _rotr8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static FunctionDescriptor _rotr8$descriptor() {
        return _rotr8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _rotr8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static MethodHandle _rotr8$handle() {
        return _rotr8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _rotr8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static MemorySegment _rotr8$address() {
        return _rotr8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _rotr8(unsigned char Value, unsigned char Shift)
     * }
     */
    public static byte _rotr8(byte Value, byte Shift) {
        var mh$ = _rotr8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr8", Value, Shift);
            }
            return (byte)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotr16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short _rotr16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static FunctionDescriptor _rotr16$descriptor() {
        return _rotr16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short _rotr16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static MethodHandle _rotr16$handle() {
        return _rotr16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short _rotr16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static MemorySegment _rotr16$address() {
        return _rotr16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short _rotr16(unsigned short Value, unsigned char Shift)
     * }
     */
    public static short _rotr16(short Value, byte Shift) {
        var mh$ = _rotr16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr16", Value, Shift);
            }
            return (short)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int Value, int Shift)
     * }
     */
    public static FunctionDescriptor _rotl$descriptor() {
        return _rotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int Value, int Shift)
     * }
     */
    public static MethodHandle _rotl$handle() {
        return _rotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int Value, int Shift)
     * }
     */
    public static MemorySegment _rotl$address() {
        return _rotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int Value, int Shift)
     * }
     */
    public static int _rotl(int Value, int Shift) {
        var mh$ = _rotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl", Value, Shift);
            }
            return (int)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long Value, int Shift)
     * }
     */
    public static FunctionDescriptor _rotl64$descriptor() {
        return _rotl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long Value, int Shift)
     * }
     */
    public static MethodHandle _rotl64$handle() {
        return _rotl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long Value, int Shift)
     * }
     */
    public static MemorySegment _rotl64$address() {
        return _rotl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long Value, int Shift)
     * }
     */
    public static long _rotl64(long Value, int Shift) {
        var mh$ = _rotl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl64", Value, Shift);
            }
            return (long)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int Value, int Shift)
     * }
     */
    public static FunctionDescriptor _rotr$descriptor() {
        return _rotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int Value, int Shift)
     * }
     */
    public static MethodHandle _rotr$handle() {
        return _rotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int Value, int Shift)
     * }
     */
    public static MemorySegment _rotr$address() {
        return _rotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int Value, int Shift)
     * }
     */
    public static int _rotr(int Value, int Shift) {
        var mh$ = _rotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr", Value, Shift);
            }
            return (int)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_rotr64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long Value, int Shift)
     * }
     */
    public static FunctionDescriptor _rotr64$descriptor() {
        return _rotr64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long Value, int Shift)
     * }
     */
    public static MethodHandle _rotr64$handle() {
        return _rotr64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long Value, int Shift)
     * }
     */
    public static MemorySegment _rotr64$address() {
        return _rotr64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long Value, int Shift)
     * }
     */
    public static long _rotr64(long Value, int Shift) {
        var mh$ = _rotr64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr64", Value, Shift);
            }
            return (long)mh$.invokeExact(Value, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef BYTE BOOLEAN
     * }
     */
    public static final OfByte BOOLEAN = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN *PBOOLEAN
     * }
     */
    public static final AddressLayout PBOOLEAN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _LIST_ENTRY {
     *     struct _LIST_ENTRY *Flink;
     *     struct _LIST_ENTRY *Blink;
     * } *PLIST_ENTRY
     * }
     */
    public static final AddressLayout PLIST_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _LIST_ENTRY {
     *     struct _LIST_ENTRY *Flink;
     *     struct _LIST_ENTRY *Blink;
     * } *PRLIST_ENTRY
     * }
     */
    public static final AddressLayout PRLIST_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SINGLE_LIST_ENTRY {
     *     struct _SINGLE_LIST_ENTRY *Next;
     * } *PSINGLE_LIST_ENTRY
     * }
     */
    public static final AddressLayout PSINGLE_LIST_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LIST_ENTRY32 *PLIST_ENTRY32
     * }
     */
    public static final AddressLayout PLIST_ENTRY32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LIST_ENTRY64 *PLIST_ENTRY64
     * }
     */
    public static final AddressLayout PLIST_ENTRY64 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GUID *LPGUID
     * }
     */
    public static final AddressLayout LPGUID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const GUID *LPCGUID
     * }
     */
    public static final AddressLayout LPCGUID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IID *LPIID
     * }
     */
    public static final AddressLayout LPIID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CLSID *LPCLSID
     * }
     */
    public static final AddressLayout LPCLSID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef FMTID *LPFMTID
     * }
     */
    public static final AddressLayout LPFMTID = freeglut_h.C_POINTER;

    private static class _errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static FunctionDescriptor _errno$descriptor() {
        return _errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MethodHandle _errno$handle() {
        return _errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno$address() {
        return _errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno() {
        var mh$ = _errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_errno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static FunctionDescriptor _set_errno$descriptor() {
        return _set_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MethodHandle _set_errno$handle() {
        return _set_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MemorySegment _set_errno$address() {
        return _set_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static int _set_errno(int _Value) {
        var mh$ = _set_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static FunctionDescriptor _get_errno$descriptor() {
        return _get_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MethodHandle _get_errno$handle() {
        return _get_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MemorySegment _get_errno$address() {
        return _get_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static int _get_errno(MemorySegment _Value) {
        var mh$ = _get_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static FunctionDescriptor __doserrno$descriptor() {
        return __doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MethodHandle __doserrno$handle() {
        return __doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno$address() {
        return __doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno() {
        var mh$ = __doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__doserrno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static FunctionDescriptor _set_doserrno$descriptor() {
        return _set_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MethodHandle _set_doserrno$handle() {
        return _set_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MemorySegment _set_doserrno$address() {
        return _set_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static int _set_doserrno(int _Value) {
        var mh$ = _set_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static FunctionDescriptor _get_doserrno$descriptor() {
        return _get_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MethodHandle _get_doserrno$handle() {
        return _get_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MemorySegment _get_doserrno$address() {
        return _get_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static int _get_doserrno(MemorySegment _Value) {
        var mh$ = _get_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr(MemorySegment _Buf, int _Val, long _MaxCount) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", _Buf, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buf, _Val, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memcmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset(MemorySegment _Dst, int _Val, long _Size) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", _Dst, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Val, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr(MemorySegment _Str, int _Val) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", _Str, _Val);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr(MemorySegment _Str, int _Ch) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr(MemorySegment _Str, short _Ch) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment _Str, short _Ch) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor _memicmp$descriptor() {
        return _memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle _memicmp$handle() {
        return _memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment _memicmp$address() {
        return _memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int _memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = _memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_memicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _memicmp_l$descriptor() {
        return _memicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _memicmp_l$handle() {
        return _memicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _memicmp_l$address() {
        return _memicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _memicmp_l(MemorySegment _Buf1, MemorySegment _Buf2, long _Size, MemorySegment _Locale) {
        var mh$ = _memicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp_l", _Buf1, _Buf2, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _Size) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", _Dst, _Src, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memicmp$descriptor() {
        return memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memicmp$handle() {
        return memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memicmp$address() {
        return memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcscat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat_s$descriptor() {
        return wcscat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat_s$handle() {
        return wcscat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat_s$address() {
        return wcscat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcscpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy_s$descriptor() {
        return wcscpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy_s$handle() {
        return wcscpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy_s$address() {
        return wcscpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncat_s$descriptor() {
        return wcsncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncat_s$handle() {
        return wcsncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncat_s$address() {
        return wcsncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncpy_s$descriptor() {
        return wcsncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncpy_s$handle() {
        return wcsncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncpy_s$address() {
        return wcsncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok_s$descriptor() {
        return wcstok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok_s$handle() {
        return wcstok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s$address() {
        return wcstok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsdup$descriptor() {
        return _wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsdup$handle() {
        return _wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup$address() {
        return _wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup(MemorySegment _String) {
        var mh$ = _wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcscspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static long wcslen(MemorySegment _String) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsnlen(MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsncmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", _String, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcsspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror$descriptor() {
        return _wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror$handle() {
        return _wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror$address() {
        return _wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror(int _ErrorNumber) {
        var mh$ = _wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror", _ErrorNumber);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror_s$descriptor() {
        return _wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror_s$handle() {
        return _wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror_s$address() {
        return _wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static int _wcserror_s(MemorySegment _Buffer, long _SizeInWords, int _ErrorNumber) {
        var mh$ = _wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror_s", _Buffer, _SizeInWords, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor __wcserror$descriptor() {
        return __wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MethodHandle __wcserror$handle() {
        return __wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror$address() {
        return __wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror(MemorySegment _String) {
        var mh$ = __wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor __wcserror_s$descriptor() {
        return __wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle __wcserror_s$handle() {
        return __wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment __wcserror_s$address() {
        return __wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static int __wcserror_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _ErrorMessage) {
        var mh$ = __wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror_s", _Buffer, _SizeInWords, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicmp$descriptor() {
        return _wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicmp$handle() {
        return _wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicmp$address() {
        return _wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicmp_l$descriptor() {
        return _wcsicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicmp_l$handle() {
        return _wcsicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicmp_l$address() {
        return _wcsicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicmp$descriptor() {
        return _wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicmp$handle() {
        return _wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicmp$address() {
        return _wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicmp_l$descriptor() {
        return _wcsnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicmp_l$handle() {
        return _wcsnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicmp_l$address() {
        return _wcsnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset_s$descriptor() {
        return _wcsnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset_s$handle() {
        return _wcsnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset_s$address() {
        return _wcsnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static int _wcsnset_s(MemorySegment _Destination, long _SizeInWords, short _Value, long _MaxCount) {
        var mh$ = _wcsnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset_s", _Destination, _SizeInWords, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset$descriptor() {
        return _wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset$handle() {
        return _wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset$address() {
        return _wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = _wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsrev$descriptor() {
        return _wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsrev$handle() {
        return _wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev$address() {
        return _wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev(MemorySegment _String) {
        var mh$ = _wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset_s$descriptor() {
        return _wcsset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset_s$handle() {
        return _wcsset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset_s$address() {
        return _wcsset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static int _wcsset_s(MemorySegment _Destination, long _SizeInWords, short _Value) {
        var mh$ = _wcsset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset_s", _Destination, _SizeInWords, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset$descriptor() {
        return _wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset$handle() {
        return _wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset$address() {
        return _wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset(MemorySegment _String, short _Value) {
        var mh$ = _wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcslwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wcslwr_s$descriptor() {
        return _wcslwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wcslwr_s$handle() {
        return _wcslwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wcslwr_s$address() {
        return _wcslwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static int _wcslwr_s(MemorySegment _String, long _SizeInWords) {
        var mh$ = _wcslwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s", _String, _SizeInWords);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcslwr$descriptor() {
        return _wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcslwr$handle() {
        return _wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr$address() {
        return _wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr(MemorySegment _String) {
        var mh$ = _wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcslwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_s_l$descriptor() {
        return _wcslwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_s_l$handle() {
        return _wcslwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_s_l$address() {
        return _wcslwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static int _wcslwr_s_l(MemorySegment _String, long _SizeInWords, MemorySegment _Locale) {
        var mh$ = _wcslwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s_l", _String, _SizeInWords, _Locale);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcslwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_l$descriptor() {
        return _wcslwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_l$handle() {
        return _wcslwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l$address() {
        return _wcslwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcslwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _wcsupr_s$descriptor() {
        return _wcsupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MethodHandle _wcsupr_s$handle() {
        return _wcsupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MemorySegment _wcsupr_s$address() {
        return _wcsupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static int _wcsupr_s(MemorySegment _String, long _Size) {
        var mh$ = _wcsupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsupr$descriptor() {
        return _wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsupr$handle() {
        return _wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr$address() {
        return _wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr(MemorySegment _String) {
        var mh$ = _wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_s_l$descriptor() {
        return _wcsupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_s_l$handle() {
        return _wcsupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_s_l$address() {
        return _wcsupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _wcsupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _wcsupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_l$descriptor() {
        return _wcsupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_l$handle() {
        return _wcsupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l$address() {
        return _wcsupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcsupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsxfrm_l$descriptor() {
        return _wcsxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsxfrm_l$handle() {
        return _wcsxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsxfrm_l$address() {
        return _wcsxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcsxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcscoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcscoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcscoll_l$descriptor() {
        return _wcscoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcscoll_l$handle() {
        return _wcscoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcscoll_l$address() {
        return _wcscoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcscoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcscoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcscoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicoll$descriptor() {
        return _wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicoll$handle() {
        return _wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicoll$address() {
        return _wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicoll_l$descriptor() {
        return _wcsicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicoll_l$handle() {
        return _wcsicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicoll_l$address() {
        return _wcsicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsncoll$descriptor() {
        return _wcsncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsncoll$handle() {
        return _wcsncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsncoll$address() {
        return _wcsncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsncoll_l$descriptor() {
        return _wcsncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsncoll_l$handle() {
        return _wcsncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsncoll_l$address() {
        return _wcsncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicoll$descriptor() {
        return _wcsnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicoll$handle() {
        return _wcsnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicoll$address() {
        return _wcsnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcsnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicoll_l$descriptor() {
        return _wcsnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicoll_l$handle() {
        return _wcsnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicoll_l$address() {
        return _wcsnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment _String) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicmp$descriptor() {
        return wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicmp$handle() {
        return wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicmp$address() {
        return wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnicmp$descriptor() {
        return wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnicmp$handle() {
        return wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnicmp$address() {
        return wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnset$descriptor() {
        return wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnset$handle() {
        return wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset$address() {
        return wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsrev$descriptor() {
        return wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsrev$handle() {
        return wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev$address() {
        return wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev(MemorySegment _String) {
        var mh$ = wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor wcsset$descriptor() {
        return wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle wcsset$handle() {
        return wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset$address() {
        return wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset(MemorySegment _String, short _Value) {
        var mh$ = wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslwr$descriptor() {
        return wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcslwr$handle() {
        return wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr$address() {
        return wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr(MemorySegment _String) {
        var mh$ = wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsupr$descriptor() {
        return wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsupr$handle() {
        return wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr$address() {
        return wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr(MemorySegment _String) {
        var mh$ = wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicoll$descriptor() {
        return wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicoll$handle() {
        return wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicoll$address() {
        return wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy_s$descriptor() {
        return strcpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcpy_s$handle() {
        return strcpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcpy_s$address() {
        return strcpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat_s$descriptor() {
        return strcat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcat_s$handle() {
        return strcat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcat_s$address() {
        return strcat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor strerror_s$descriptor() {
        return strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MethodHandle strerror_s$handle() {
        return strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MemorySegment strerror_s$address() {
        return strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static int strerror_s(MemorySegment _Buffer, long _SizeInBytes, int _ErrorNumber) {
        var mh$ = strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_s", _Buffer, _SizeInBytes, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncat_s$descriptor() {
        return strncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncat_s$handle() {
        return strncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncat_s$address() {
        return strncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncpy_s$descriptor() {
        return strncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncpy_s$handle() {
        return strncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncpy_s$address() {
        return strncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static FunctionDescriptor strtok_s$descriptor() {
        return strtok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MethodHandle strtok_s$handle() {
        return strtok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s$address() {
        return strtok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = strtok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _memccpy$descriptor() {
        return _memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle _memccpy$handle() {
        return _memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy$address() {
        return _memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _MaxCount) {
        var mh$ = _memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memccpy", _Dst, _Src, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static int strcmp(MemorySegment _Str1, MemorySegment _Str2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", _Str1, _Str2);
            }
            return (int)mh$.invokeExact(_Str1, _Str2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _strcmpi$descriptor() {
        return _strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _strcmpi$handle() {
        return _strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _strcmpi$address() {
        return _strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int _strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static int strcoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strcoll_l$descriptor() {
        return _strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strcoll_l$handle() {
        return _strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strcoll_l$address() {
        return _strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _strcoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strcspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static FunctionDescriptor _strdup$descriptor() {
        return _strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MethodHandle _strdup$handle() {
        return _strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup$address() {
        return _strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup(MemorySegment _Source) {
        var mh$ = _strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdup", _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror$descriptor() {
        return _strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror$handle() {
        return _strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror$address() {
        return _strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror(MemorySegment _ErrorMessage) {
        var mh$ = _strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror_s$descriptor() {
        return _strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror_s$handle() {
        return _strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror_s$address() {
        return _strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static int _strerror_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _ErrorMessage) {
        var mh$ = _strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror_s", _Buffer, _SizeInBytes, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror(int _ErrorMessage) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricmp$descriptor() {
        return _stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricmp$handle() {
        return _stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricmp$address() {
        return _stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_stricoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricoll$descriptor() {
        return _stricoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricoll$handle() {
        return _stricoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricoll$address() {
        return _stricoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_stricoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricoll_l$descriptor() {
        return _stricoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricoll_l$handle() {
        return _stricoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricoll_l$address() {
        return _stricoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_stricmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricmp_l$descriptor() {
        return _stricmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricmp_l$handle() {
        return _stricmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricmp_l$address() {
        return _stricmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static long strlen(MemorySegment _Str) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", _Str);
            }
            return (long)mh$.invokeExact(_Str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strlwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strlwr_s$descriptor() {
        return _strlwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strlwr_s$handle() {
        return _strlwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strlwr_s$address() {
        return _strlwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strlwr_s(MemorySegment _String, long _Size) {
        var mh$ = _strlwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor _strlwr$descriptor() {
        return _strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MethodHandle _strlwr$handle() {
        return _strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr$address() {
        return _strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr(MemorySegment _String) {
        var mh$ = _strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strlwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_s_l$descriptor() {
        return _strlwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_s_l$handle() {
        return _strlwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_s_l$address() {
        return _strlwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strlwr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strlwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strlwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_l$descriptor() {
        return _strlwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_l$handle() {
        return _strlwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l$address() {
        return _strlwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strlwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static int strncmp(MemorySegment _Str1, MemorySegment _Str2, long _MaxCount) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", _Str1, _Str2, _MaxCount);
            }
            return (int)mh$.invokeExact(_Str1, _Str2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicmp$descriptor() {
        return _strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicmp$handle() {
        return _strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicmp$address() {
        return _strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicmp_l$descriptor() {
        return _strnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicmp_l$handle() {
        return _strnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicmp_l$address() {
        return _strnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicoll$descriptor() {
        return _strnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicoll$handle() {
        return _strnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicoll$address() {
        return _strnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicoll_l$descriptor() {
        return _strnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicoll_l$handle() {
        return _strnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicoll_l$address() {
        return _strnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strncoll$descriptor() {
        return _strncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strncoll$handle() {
        return _strncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strncoll$address() {
        return _strncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strncoll_l$descriptor() {
        return _strncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strncoll_l$handle() {
        return _strncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strncoll_l$address() {
        return _strncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strncnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__strncnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static FunctionDescriptor __strncnt$descriptor() {
        return __strncnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MethodHandle __strncnt$handle() {
        return __strncnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MemorySegment __strncnt$address() {
        return __strncnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static long __strncnt(MemorySegment _String, long _Count) {
        var mh$ = __strncnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strncnt", _String, _Count);
            }
            return (long)mh$.invokeExact(_String, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long strnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnset_s$descriptor() {
        return _strnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnset_s$handle() {
        return _strnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnset_s$address() {
        return _strnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static int _strnset_s(MemorySegment _String, long _SizeInBytes, int _Value, long _MaxCount) {
        var mh$ = _strnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset_s", _String, _SizeInBytes, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_String, _SizeInBytes, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static FunctionDescriptor _strnset$descriptor() {
        return _strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MethodHandle _strnset$handle() {
        return _strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset$address() {
        return _strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset(MemorySegment _Destination, int _Value, long _Count) {
        var mh$ = _strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset", _Destination, _Value, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", _Str, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static FunctionDescriptor _strrev$descriptor() {
        return _strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MethodHandle _strrev$handle() {
        return _strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev$address() {
        return _strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev(MemorySegment _Str) {
        var mh$ = _strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strrev", _Str);
            }
            return (MemorySegment)mh$.invokeExact(_Str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static FunctionDescriptor _strset_s$descriptor() {
        return _strset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MethodHandle _strset_s$handle() {
        return _strset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MemorySegment _strset_s$address() {
        return _strset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static int _strset_s(MemorySegment _Destination, long _DestinationSize, int _Value) {
        var mh$ = _strset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset_s", _Destination, _DestinationSize, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _DestinationSize, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static FunctionDescriptor _strset$descriptor() {
        return _strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MethodHandle _strset$handle() {
        return _strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset$address() {
        return _strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset(MemorySegment _Destination, int _Value) {
        var mh$ = _strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset", _Destination, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok(MemorySegment _String, MemorySegment _Delimiter) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", _String, _Delimiter);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strupr_s$descriptor() {
        return _strupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strupr_s$handle() {
        return _strupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strupr_s$address() {
        return _strupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strupr_s(MemorySegment _String, long _Size) {
        var mh$ = _strupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static FunctionDescriptor _strupr$descriptor() {
        return _strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MethodHandle _strupr$handle() {
        return _strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr$address() {
        return _strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr(MemorySegment _String) {
        var mh$ = _strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_s_l$descriptor() {
        return _strupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_s_l$handle() {
        return _strupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_s_l$address() {
        return _strupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_l$descriptor() {
        return _strupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_l$handle() {
        return _strupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l$address() {
        return _strupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long strxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strxfrm_l$descriptor() {
        return _strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strxfrm_l$handle() {
        return _strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strxfrm_l$address() {
        return _strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _strxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup(MemorySegment _String) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcmpi$descriptor() {
        return strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcmpi$handle() {
        return strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcmpi$address() {
        return strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor stricmp$descriptor() {
        return stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle stricmp$handle() {
        return stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment stricmp$address() {
        return stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor strlwr$descriptor() {
        return strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MethodHandle strlwr$handle() {
        return strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr$address() {
        return strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr(MemorySegment _String) {
        var mh$ = strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnicmp$descriptor() {
        return strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnicmp$handle() {
        return strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnicmp$address() {
        return strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnset$descriptor() {
        return strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnset$handle() {
        return strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset$address() {
        return strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset(MemorySegment _String, int _Value, long _MaxCount) {
        var mh$ = strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static FunctionDescriptor strrev$descriptor() {
        return strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MethodHandle strrev$handle() {
        return strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev$address() {
        return strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev(MemorySegment _String) {
        var mh$ = strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static FunctionDescriptor strset$descriptor() {
        return strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MethodHandle strset$handle() {
        return strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset$address() {
        return strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset(MemorySegment _String, int _Value) {
        var mh$ = strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static FunctionDescriptor strupr$descriptor() {
        return strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MethodHandle strupr$handle() {
        return strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr$address() {
        return strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr(MemorySegment _String) {
        var mh$ = strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR KSPIN_LOCK
     * }
     */
    public static final OfLong KSPIN_LOCK = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef KSPIN_LOCK *PKSPIN_LOCK
     * }
     */
    public static final AddressLayout PKSPIN_LOCK = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _M128A {
     *     ULONGLONG Low;
     *     LONGLONG High;
     * } *PM128A
     * }
     */
    public static final AddressLayout PM128A = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XSAVE_FORMAT {
     *     WORD ControlWord;
     *     WORD StatusWord;
     *     BYTE TagWord;
     *     BYTE Reserved1;
     *     WORD ErrorOpcode;
     *     DWORD ErrorOffset;
     *     WORD ErrorSelector;
     *     WORD Reserved2;
     *     DWORD DataOffset;
     *     WORD DataSelector;
     *     WORD Reserved3;
     *     DWORD MxCsr;
     *     DWORD MxCsr_Mask;
     *     M128A FloatRegisters[8];
     *     M128A XmmRegisters[16];
     *     BYTE Reserved4[96];
     * } *PXSAVE_FORMAT
     * }
     */
    public static final AddressLayout PXSAVE_FORMAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XSAVE_CET_U_FORMAT {
     *     DWORD64 Ia32CetUMsr;
     *     DWORD64 Ia32Pl3SspMsr;
     * } *PXSAVE_CET_U_FORMAT
     * }
     */
    public static final AddressLayout PXSAVE_CET_U_FORMAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XSAVE_AREA_HEADER {
     *     DWORD64 Mask;
     *     DWORD64 CompactionMask;
     *     DWORD64 Reserved2[6];
     * } *PXSAVE_AREA_HEADER
     * }
     */
    public static final AddressLayout PXSAVE_AREA_HEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XSAVE_AREA {
     *     XSAVE_FORMAT LegacyState;
     *     XSAVE_AREA_HEADER Header;
     * } *PXSAVE_AREA
     * }
     */
    public static final AddressLayout PXSAVE_AREA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XSTATE_CONTEXT {
     *     DWORD64 Mask;
     *     DWORD Length;
     *     DWORD Reserved1;
     *     PXSAVE_AREA Area;
     *     PVOID Buffer;
     * } *PXSTATE_CONTEXT
     * }
     */
    public static final AddressLayout PXSTATE_CONTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCOPE_TABLE_AMD64 {
     *     DWORD Count;
     *     struct {
     *         DWORD BeginAddress;
     *         DWORD EndAddress;
     *         DWORD HandlerAddress;
     *         DWORD JumpTarget;
     *     } ScopeRecord[1];
     * } *PSCOPE_TABLE_AMD64
     * }
     */
    public static final AddressLayout PSCOPE_TABLE_AMD64 = freeglut_h.C_POINTER;

    private static class _bittest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittest(const LONG *Base, LONG Offset)
     * }
     */
    public static FunctionDescriptor _bittest$descriptor() {
        return _bittest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittest(const LONG *Base, LONG Offset)
     * }
     */
    public static MethodHandle _bittest$handle() {
        return _bittest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittest(const LONG *Base, LONG Offset)
     * }
     */
    public static MemorySegment _bittest$address() {
        return _bittest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittest(const LONG *Base, LONG Offset)
     * }
     */
    public static byte _bittest(MemorySegment Base, int Offset) {
        var mh$ = _bittest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittest", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _bittestandcomplement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittestandcomplement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement(LONG *Base, LONG Offset)
     * }
     */
    public static FunctionDescriptor _bittestandcomplement$descriptor() {
        return _bittestandcomplement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement(LONG *Base, LONG Offset)
     * }
     */
    public static MethodHandle _bittestandcomplement$handle() {
        return _bittestandcomplement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement(LONG *Base, LONG Offset)
     * }
     */
    public static MemorySegment _bittestandcomplement$address() {
        return _bittestandcomplement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement(LONG *Base, LONG Offset)
     * }
     */
    public static byte _bittestandcomplement(MemorySegment Base, int Offset) {
        var mh$ = _bittestandcomplement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittestandcomplement", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _bittestandset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittestandset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittestandset(LONG *Base, LONG Offset)
     * }
     */
    public static FunctionDescriptor _bittestandset$descriptor() {
        return _bittestandset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittestandset(LONG *Base, LONG Offset)
     * }
     */
    public static MethodHandle _bittestandset$handle() {
        return _bittestandset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittestandset(LONG *Base, LONG Offset)
     * }
     */
    public static MemorySegment _bittestandset$address() {
        return _bittestandset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittestandset(LONG *Base, LONG Offset)
     * }
     */
    public static byte _bittestandset(MemorySegment Base, int Offset) {
        var mh$ = _bittestandset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittestandset", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _bittestandreset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittestandreset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittestandreset(LONG *Base, LONG Offset)
     * }
     */
    public static FunctionDescriptor _bittestandreset$descriptor() {
        return _bittestandreset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittestandreset(LONG *Base, LONG Offset)
     * }
     */
    public static MethodHandle _bittestandreset$handle() {
        return _bittestandreset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittestandreset(LONG *Base, LONG Offset)
     * }
     */
    public static MemorySegment _bittestandreset$address() {
        return _bittestandreset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittestandreset(LONG *Base, LONG Offset)
     * }
     */
    public static byte _bittestandreset(MemorySegment Base, int Offset) {
        var mh$ = _bittestandreset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittestandreset", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _interlockedbittestandset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_interlockedbittestandset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static FunctionDescriptor _interlockedbittestandset$descriptor() {
        return _interlockedbittestandset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static MethodHandle _interlockedbittestandset$handle() {
        return _interlockedbittestandset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static MemorySegment _interlockedbittestandset$address() {
        return _interlockedbittestandset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static byte _interlockedbittestandset(MemorySegment Base, int Offset) {
        var mh$ = _interlockedbittestandset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_interlockedbittestandset", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _interlockedbittestandreset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_interlockedbittestandreset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static FunctionDescriptor _interlockedbittestandreset$descriptor() {
        return _interlockedbittestandreset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static MethodHandle _interlockedbittestandreset$handle() {
        return _interlockedbittestandreset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static MemorySegment _interlockedbittestandreset$address() {
        return _interlockedbittestandreset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset(volatile LONG *Base, LONG Offset)
     * }
     */
    public static byte _interlockedbittestandreset(MemorySegment Base, int Offset) {
        var mh$ = _interlockedbittestandreset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_interlockedbittestandreset", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _bittest64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittest64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittest64(const LONG64 *Base, LONG64 Offset)
     * }
     */
    public static FunctionDescriptor _bittest64$descriptor() {
        return _bittest64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittest64(const LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MethodHandle _bittest64$handle() {
        return _bittest64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittest64(const LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MemorySegment _bittest64$address() {
        return _bittest64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittest64(const LONG64 *Base, LONG64 Offset)
     * }
     */
    public static byte _bittest64(MemorySegment Base, long Offset) {
        var mh$ = _bittest64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittest64", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _bittestandcomplement64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittestandcomplement64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static FunctionDescriptor _bittestandcomplement64$descriptor() {
        return _bittestandcomplement64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MethodHandle _bittestandcomplement64$handle() {
        return _bittestandcomplement64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MemorySegment _bittestandcomplement64$address() {
        return _bittestandcomplement64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittestandcomplement64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static byte _bittestandcomplement64(MemorySegment Base, long Offset) {
        var mh$ = _bittestandcomplement64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittestandcomplement64", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _bittestandset64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittestandset64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittestandset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static FunctionDescriptor _bittestandset64$descriptor() {
        return _bittestandset64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittestandset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MethodHandle _bittestandset64$handle() {
        return _bittestandset64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittestandset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MemorySegment _bittestandset64$address() {
        return _bittestandset64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittestandset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static byte _bittestandset64(MemorySegment Base, long Offset) {
        var mh$ = _bittestandset64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittestandset64", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _bittestandreset64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_bittestandreset64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _bittestandreset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static FunctionDescriptor _bittestandreset64$descriptor() {
        return _bittestandreset64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _bittestandreset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MethodHandle _bittestandreset64$handle() {
        return _bittestandreset64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _bittestandreset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MemorySegment _bittestandreset64$address() {
        return _bittestandreset64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _bittestandreset64(LONG64 *Base, LONG64 Offset)
     * }
     */
    public static byte _bittestandreset64(MemorySegment Base, long Offset) {
        var mh$ = _bittestandreset64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_bittestandreset64", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _interlockedbittestandset64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_interlockedbittestandset64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static FunctionDescriptor _interlockedbittestandset64$descriptor() {
        return _interlockedbittestandset64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MethodHandle _interlockedbittestandset64$handle() {
        return _interlockedbittestandset64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MemorySegment _interlockedbittestandset64$address() {
        return _interlockedbittestandset64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static byte _interlockedbittestandset64(MemorySegment Base, long Offset) {
        var mh$ = _interlockedbittestandset64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_interlockedbittestandset64", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _interlockedbittestandreset64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_interlockedbittestandreset64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static FunctionDescriptor _interlockedbittestandreset64$descriptor() {
        return _interlockedbittestandreset64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MethodHandle _interlockedbittestandreset64$handle() {
        return _interlockedbittestandreset64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static MemorySegment _interlockedbittestandreset64$address() {
        return _interlockedbittestandreset64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _interlockedbittestandreset64(volatile LONG64 *Base, LONG64 Offset)
     * }
     */
    public static byte _interlockedbittestandreset64(MemorySegment Base, long Offset) {
        var mh$ = _interlockedbittestandreset64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_interlockedbittestandreset64", Base, Offset);
            }
            return (byte)mh$.invokeExact(Base, Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _BitScanForward {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_BitScanForward");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _BitScanForward(DWORD *Index, DWORD Mask)
     * }
     */
    public static FunctionDescriptor _BitScanForward$descriptor() {
        return _BitScanForward.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _BitScanForward(DWORD *Index, DWORD Mask)
     * }
     */
    public static MethodHandle _BitScanForward$handle() {
        return _BitScanForward.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _BitScanForward(DWORD *Index, DWORD Mask)
     * }
     */
    public static MemorySegment _BitScanForward$address() {
        return _BitScanForward.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _BitScanForward(DWORD *Index, DWORD Mask)
     * }
     */
    public static byte _BitScanForward(MemorySegment Index, int Mask) {
        var mh$ = _BitScanForward.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_BitScanForward", Index, Mask);
            }
            return (byte)mh$.invokeExact(Index, Mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _BitScanReverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_BitScanReverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _BitScanReverse(DWORD *Index, DWORD Mask)
     * }
     */
    public static FunctionDescriptor _BitScanReverse$descriptor() {
        return _BitScanReverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _BitScanReverse(DWORD *Index, DWORD Mask)
     * }
     */
    public static MethodHandle _BitScanReverse$handle() {
        return _BitScanReverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _BitScanReverse(DWORD *Index, DWORD Mask)
     * }
     */
    public static MemorySegment _BitScanReverse$address() {
        return _BitScanReverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _BitScanReverse(DWORD *Index, DWORD Mask)
     * }
     */
    public static byte _BitScanReverse(MemorySegment Index, int Mask) {
        var mh$ = _BitScanReverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_BitScanReverse", Index, Mask);
            }
            return (byte)mh$.invokeExact(Index, Mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _BitScanForward64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_BitScanForward64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _BitScanForward64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static FunctionDescriptor _BitScanForward64$descriptor() {
        return _BitScanForward64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _BitScanForward64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static MethodHandle _BitScanForward64$handle() {
        return _BitScanForward64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _BitScanForward64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static MemorySegment _BitScanForward64$address() {
        return _BitScanForward64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _BitScanForward64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static byte _BitScanForward64(MemorySegment Index, long Mask) {
        var mh$ = _BitScanForward64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_BitScanForward64", Index, Mask);
            }
            return (byte)mh$.invokeExact(Index, Mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _BitScanReverse64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_BitScanReverse64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _BitScanReverse64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static FunctionDescriptor _BitScanReverse64$descriptor() {
        return _BitScanReverse64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _BitScanReverse64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static MethodHandle _BitScanReverse64$handle() {
        return _BitScanReverse64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _BitScanReverse64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static MemorySegment _BitScanReverse64$address() {
        return _BitScanReverse64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _BitScanReverse64(DWORD *Index, DWORD64 Mask)
     * }
     */
    public static byte _BitScanReverse64(MemorySegment Index, long Mask) {
        var mh$ = _BitScanReverse64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_BitScanReverse64", Index, Mask);
            }
            return (byte)mh$.invokeExact(Index, Mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedIncrement16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedIncrement16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _InterlockedIncrement16(volatile SHORT *Addend)
     * }
     */
    public static FunctionDescriptor _InterlockedIncrement16$descriptor() {
        return _InterlockedIncrement16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _InterlockedIncrement16(volatile SHORT *Addend)
     * }
     */
    public static MethodHandle _InterlockedIncrement16$handle() {
        return _InterlockedIncrement16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _InterlockedIncrement16(volatile SHORT *Addend)
     * }
     */
    public static MemorySegment _InterlockedIncrement16$address() {
        return _InterlockedIncrement16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _InterlockedIncrement16(volatile SHORT *Addend)
     * }
     */
    public static short _InterlockedIncrement16(MemorySegment Addend) {
        var mh$ = _InterlockedIncrement16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedIncrement16", Addend);
            }
            return (short)mh$.invokeExact(Addend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedDecrement16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedDecrement16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _InterlockedDecrement16(volatile SHORT *Addend)
     * }
     */
    public static FunctionDescriptor _InterlockedDecrement16$descriptor() {
        return _InterlockedDecrement16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _InterlockedDecrement16(volatile SHORT *Addend)
     * }
     */
    public static MethodHandle _InterlockedDecrement16$handle() {
        return _InterlockedDecrement16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _InterlockedDecrement16(volatile SHORT *Addend)
     * }
     */
    public static MemorySegment _InterlockedDecrement16$address() {
        return _InterlockedDecrement16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _InterlockedDecrement16(volatile SHORT *Addend)
     * }
     */
    public static short _InterlockedDecrement16(MemorySegment Addend) {
        var mh$ = _InterlockedDecrement16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedDecrement16", Addend);
            }
            return (short)mh$.invokeExact(Addend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedCompareExchange16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedCompareExchange16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _InterlockedCompareExchange16(volatile SHORT *Destination, SHORT ExChange, SHORT Comperand)
     * }
     */
    public static FunctionDescriptor _InterlockedCompareExchange16$descriptor() {
        return _InterlockedCompareExchange16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _InterlockedCompareExchange16(volatile SHORT *Destination, SHORT ExChange, SHORT Comperand)
     * }
     */
    public static MethodHandle _InterlockedCompareExchange16$handle() {
        return _InterlockedCompareExchange16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _InterlockedCompareExchange16(volatile SHORT *Destination, SHORT ExChange, SHORT Comperand)
     * }
     */
    public static MemorySegment _InterlockedCompareExchange16$address() {
        return _InterlockedCompareExchange16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _InterlockedCompareExchange16(volatile SHORT *Destination, SHORT ExChange, SHORT Comperand)
     * }
     */
    public static short _InterlockedCompareExchange16(MemorySegment Destination, short ExChange, short Comperand) {
        var mh$ = _InterlockedCompareExchange16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedCompareExchange16", Destination, ExChange, Comperand);
            }
            return (short)mh$.invokeExact(Destination, ExChange, Comperand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedAnd(volatile LONG *Destination, LONG Value)
     * }
     */
    public static FunctionDescriptor _InterlockedAnd$descriptor() {
        return _InterlockedAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedAnd(volatile LONG *Destination, LONG Value)
     * }
     */
    public static MethodHandle _InterlockedAnd$handle() {
        return _InterlockedAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedAnd(volatile LONG *Destination, LONG Value)
     * }
     */
    public static MemorySegment _InterlockedAnd$address() {
        return _InterlockedAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedAnd(volatile LONG *Destination, LONG Value)
     * }
     */
    public static int _InterlockedAnd(MemorySegment Destination, int Value) {
        var mh$ = _InterlockedAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedAnd", Destination, Value);
            }
            return (int)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedOr(volatile LONG *Destination, LONG Value)
     * }
     */
    public static FunctionDescriptor _InterlockedOr$descriptor() {
        return _InterlockedOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedOr(volatile LONG *Destination, LONG Value)
     * }
     */
    public static MethodHandle _InterlockedOr$handle() {
        return _InterlockedOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedOr(volatile LONG *Destination, LONG Value)
     * }
     */
    public static MemorySegment _InterlockedOr$address() {
        return _InterlockedOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedOr(volatile LONG *Destination, LONG Value)
     * }
     */
    public static int _InterlockedOr(MemorySegment Destination, int Value) {
        var mh$ = _InterlockedOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedOr", Destination, Value);
            }
            return (int)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedXor(volatile LONG *Destination, LONG Value)
     * }
     */
    public static FunctionDescriptor _InterlockedXor$descriptor() {
        return _InterlockedXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedXor(volatile LONG *Destination, LONG Value)
     * }
     */
    public static MethodHandle _InterlockedXor$handle() {
        return _InterlockedXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedXor(volatile LONG *Destination, LONG Value)
     * }
     */
    public static MemorySegment _InterlockedXor$address() {
        return _InterlockedXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedXor(volatile LONG *Destination, LONG Value)
     * }
     */
    public static int _InterlockedXor(MemorySegment Destination, int Value) {
        var mh$ = _InterlockedXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedXor", Destination, Value);
            }
            return (int)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedAnd64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedAnd64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedAnd64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static FunctionDescriptor _InterlockedAnd64$descriptor() {
        return _InterlockedAnd64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedAnd64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static MethodHandle _InterlockedAnd64$handle() {
        return _InterlockedAnd64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedAnd64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static MemorySegment _InterlockedAnd64$address() {
        return _InterlockedAnd64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedAnd64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static long _InterlockedAnd64(MemorySegment Destination, long Value) {
        var mh$ = _InterlockedAnd64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedAnd64", Destination, Value);
            }
            return (long)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedOr64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedOr64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedOr64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static FunctionDescriptor _InterlockedOr64$descriptor() {
        return _InterlockedOr64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedOr64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static MethodHandle _InterlockedOr64$handle() {
        return _InterlockedOr64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedOr64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static MemorySegment _InterlockedOr64$address() {
        return _InterlockedOr64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedOr64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static long _InterlockedOr64(MemorySegment Destination, long Value) {
        var mh$ = _InterlockedOr64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedOr64", Destination, Value);
            }
            return (long)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedXor64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedXor64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedXor64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static FunctionDescriptor _InterlockedXor64$descriptor() {
        return _InterlockedXor64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedXor64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static MethodHandle _InterlockedXor64$handle() {
        return _InterlockedXor64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedXor64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static MemorySegment _InterlockedXor64$address() {
        return _InterlockedXor64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedXor64(volatile LONG64 *Destination, LONG64 Value)
     * }
     */
    public static long _InterlockedXor64(MemorySegment Destination, long Value) {
        var mh$ = _InterlockedXor64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedXor64", Destination, Value);
            }
            return (long)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedIncrement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedIncrement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedIncrement(volatile LONG *Addend)
     * }
     */
    public static FunctionDescriptor _InterlockedIncrement$descriptor() {
        return _InterlockedIncrement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedIncrement(volatile LONG *Addend)
     * }
     */
    public static MethodHandle _InterlockedIncrement$handle() {
        return _InterlockedIncrement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedIncrement(volatile LONG *Addend)
     * }
     */
    public static MemorySegment _InterlockedIncrement$address() {
        return _InterlockedIncrement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedIncrement(volatile LONG *Addend)
     * }
     */
    public static int _InterlockedIncrement(MemorySegment Addend) {
        var mh$ = _InterlockedIncrement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedIncrement", Addend);
            }
            return (int)mh$.invokeExact(Addend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedDecrement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedDecrement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedDecrement(volatile LONG *Addend)
     * }
     */
    public static FunctionDescriptor _InterlockedDecrement$descriptor() {
        return _InterlockedDecrement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedDecrement(volatile LONG *Addend)
     * }
     */
    public static MethodHandle _InterlockedDecrement$handle() {
        return _InterlockedDecrement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedDecrement(volatile LONG *Addend)
     * }
     */
    public static MemorySegment _InterlockedDecrement$address() {
        return _InterlockedDecrement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedDecrement(volatile LONG *Addend)
     * }
     */
    public static int _InterlockedDecrement(MemorySegment Addend) {
        var mh$ = _InterlockedDecrement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedDecrement", Addend);
            }
            return (int)mh$.invokeExact(Addend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedExchange(volatile LONG *Target, LONG Value)
     * }
     */
    public static FunctionDescriptor _InterlockedExchange$descriptor() {
        return _InterlockedExchange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedExchange(volatile LONG *Target, LONG Value)
     * }
     */
    public static MethodHandle _InterlockedExchange$handle() {
        return _InterlockedExchange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedExchange(volatile LONG *Target, LONG Value)
     * }
     */
    public static MemorySegment _InterlockedExchange$address() {
        return _InterlockedExchange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedExchange(volatile LONG *Target, LONG Value)
     * }
     */
    public static int _InterlockedExchange(MemorySegment Target, int Value) {
        var mh$ = _InterlockedExchange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchange", Target, Value);
            }
            return (int)mh$.invokeExact(Target, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchangeAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchangeAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedExchangeAdd(volatile LONG *Addend, LONG Value)
     * }
     */
    public static FunctionDescriptor _InterlockedExchangeAdd$descriptor() {
        return _InterlockedExchangeAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedExchangeAdd(volatile LONG *Addend, LONG Value)
     * }
     */
    public static MethodHandle _InterlockedExchangeAdd$handle() {
        return _InterlockedExchangeAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedExchangeAdd(volatile LONG *Addend, LONG Value)
     * }
     */
    public static MemorySegment _InterlockedExchangeAdd$address() {
        return _InterlockedExchangeAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedExchangeAdd(volatile LONG *Addend, LONG Value)
     * }
     */
    public static int _InterlockedExchangeAdd(MemorySegment Addend, int Value) {
        var mh$ = _InterlockedExchangeAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchangeAdd", Addend, Value);
            }
            return (int)mh$.invokeExact(Addend, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedCompareExchange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedCompareExchange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _InterlockedCompareExchange(volatile LONG *Destination, LONG ExChange, LONG Comperand)
     * }
     */
    public static FunctionDescriptor _InterlockedCompareExchange$descriptor() {
        return _InterlockedCompareExchange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _InterlockedCompareExchange(volatile LONG *Destination, LONG ExChange, LONG Comperand)
     * }
     */
    public static MethodHandle _InterlockedCompareExchange$handle() {
        return _InterlockedCompareExchange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _InterlockedCompareExchange(volatile LONG *Destination, LONG ExChange, LONG Comperand)
     * }
     */
    public static MemorySegment _InterlockedCompareExchange$address() {
        return _InterlockedCompareExchange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _InterlockedCompareExchange(volatile LONG *Destination, LONG ExChange, LONG Comperand)
     * }
     */
    public static int _InterlockedCompareExchange(MemorySegment Destination, int ExChange, int Comperand) {
        var mh$ = _InterlockedCompareExchange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedCompareExchange", Destination, ExChange, Comperand);
            }
            return (int)mh$.invokeExact(Destination, ExChange, Comperand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedIncrement64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedIncrement64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedIncrement64(volatile LONG64 *Addend)
     * }
     */
    public static FunctionDescriptor _InterlockedIncrement64$descriptor() {
        return _InterlockedIncrement64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedIncrement64(volatile LONG64 *Addend)
     * }
     */
    public static MethodHandle _InterlockedIncrement64$handle() {
        return _InterlockedIncrement64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedIncrement64(volatile LONG64 *Addend)
     * }
     */
    public static MemorySegment _InterlockedIncrement64$address() {
        return _InterlockedIncrement64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedIncrement64(volatile LONG64 *Addend)
     * }
     */
    public static long _InterlockedIncrement64(MemorySegment Addend) {
        var mh$ = _InterlockedIncrement64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedIncrement64", Addend);
            }
            return (long)mh$.invokeExact(Addend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedDecrement64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedDecrement64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedDecrement64(volatile LONG64 *Addend)
     * }
     */
    public static FunctionDescriptor _InterlockedDecrement64$descriptor() {
        return _InterlockedDecrement64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedDecrement64(volatile LONG64 *Addend)
     * }
     */
    public static MethodHandle _InterlockedDecrement64$handle() {
        return _InterlockedDecrement64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedDecrement64(volatile LONG64 *Addend)
     * }
     */
    public static MemorySegment _InterlockedDecrement64$address() {
        return _InterlockedDecrement64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedDecrement64(volatile LONG64 *Addend)
     * }
     */
    public static long _InterlockedDecrement64(MemorySegment Addend) {
        var mh$ = _InterlockedDecrement64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedDecrement64", Addend);
            }
            return (long)mh$.invokeExact(Addend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchange64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchange64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedExchange64(volatile LONG64 *Target, LONG64 Value)
     * }
     */
    public static FunctionDescriptor _InterlockedExchange64$descriptor() {
        return _InterlockedExchange64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedExchange64(volatile LONG64 *Target, LONG64 Value)
     * }
     */
    public static MethodHandle _InterlockedExchange64$handle() {
        return _InterlockedExchange64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedExchange64(volatile LONG64 *Target, LONG64 Value)
     * }
     */
    public static MemorySegment _InterlockedExchange64$address() {
        return _InterlockedExchange64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedExchange64(volatile LONG64 *Target, LONG64 Value)
     * }
     */
    public static long _InterlockedExchange64(MemorySegment Target, long Value) {
        var mh$ = _InterlockedExchange64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchange64", Target, Value);
            }
            return (long)mh$.invokeExact(Target, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchangeAdd64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchangeAdd64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedExchangeAdd64(volatile LONG64 *Addend, LONG64 Value)
     * }
     */
    public static FunctionDescriptor _InterlockedExchangeAdd64$descriptor() {
        return _InterlockedExchangeAdd64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedExchangeAdd64(volatile LONG64 *Addend, LONG64 Value)
     * }
     */
    public static MethodHandle _InterlockedExchangeAdd64$handle() {
        return _InterlockedExchangeAdd64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedExchangeAdd64(volatile LONG64 *Addend, LONG64 Value)
     * }
     */
    public static MemorySegment _InterlockedExchangeAdd64$address() {
        return _InterlockedExchangeAdd64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedExchangeAdd64(volatile LONG64 *Addend, LONG64 Value)
     * }
     */
    public static long _InterlockedExchangeAdd64(MemorySegment Addend, long Value) {
        var mh$ = _InterlockedExchangeAdd64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchangeAdd64", Addend, Value);
            }
            return (long)mh$.invokeExact(Addend, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedCompareExchange64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedCompareExchange64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _InterlockedCompareExchange64(volatile LONG64 *Destination, LONG64 ExChange, LONG64 Comperand)
     * }
     */
    public static FunctionDescriptor _InterlockedCompareExchange64$descriptor() {
        return _InterlockedCompareExchange64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _InterlockedCompareExchange64(volatile LONG64 *Destination, LONG64 ExChange, LONG64 Comperand)
     * }
     */
    public static MethodHandle _InterlockedCompareExchange64$handle() {
        return _InterlockedCompareExchange64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _InterlockedCompareExchange64(volatile LONG64 *Destination, LONG64 ExChange, LONG64 Comperand)
     * }
     */
    public static MemorySegment _InterlockedCompareExchange64$address() {
        return _InterlockedCompareExchange64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _InterlockedCompareExchange64(volatile LONG64 *Destination, LONG64 ExChange, LONG64 Comperand)
     * }
     */
    public static long _InterlockedCompareExchange64(MemorySegment Destination, long ExChange, long Comperand) {
        var mh$ = _InterlockedCompareExchange64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedCompareExchange64", Destination, ExChange, Comperand);
            }
            return (long)mh$.invokeExact(Destination, ExChange, Comperand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedCompareExchange128 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedCompareExchange128");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char _InterlockedCompareExchange128(volatile LONG64 *Destination, LONG64 ExchangeHigh, LONG64 ExchangeLow, LONG64 *ComparandResult)
     * }
     */
    public static FunctionDescriptor _InterlockedCompareExchange128$descriptor() {
        return _InterlockedCompareExchange128.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char _InterlockedCompareExchange128(volatile LONG64 *Destination, LONG64 ExchangeHigh, LONG64 ExchangeLow, LONG64 *ComparandResult)
     * }
     */
    public static MethodHandle _InterlockedCompareExchange128$handle() {
        return _InterlockedCompareExchange128.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char _InterlockedCompareExchange128(volatile LONG64 *Destination, LONG64 ExchangeHigh, LONG64 ExchangeLow, LONG64 *ComparandResult)
     * }
     */
    public static MemorySegment _InterlockedCompareExchange128$address() {
        return _InterlockedCompareExchange128.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char _InterlockedCompareExchange128(volatile LONG64 *Destination, LONG64 ExchangeHigh, LONG64 ExchangeLow, LONG64 *ComparandResult)
     * }
     */
    public static byte _InterlockedCompareExchange128(MemorySegment Destination, long ExchangeHigh, long ExchangeLow, MemorySegment ComparandResult) {
        var mh$ = _InterlockedCompareExchange128.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedCompareExchange128", Destination, ExchangeHigh, ExchangeLow, ComparandResult);
            }
            return (byte)mh$.invokeExact(Destination, ExchangeHigh, ExchangeLow, ComparandResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedCompareExchangePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedCompareExchangePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_InterlockedCompareExchangePointer(volatile PVOID *Destination, PVOID Exchange, PVOID Comperand)
     * }
     */
    public static FunctionDescriptor _InterlockedCompareExchangePointer$descriptor() {
        return _InterlockedCompareExchangePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_InterlockedCompareExchangePointer(volatile PVOID *Destination, PVOID Exchange, PVOID Comperand)
     * }
     */
    public static MethodHandle _InterlockedCompareExchangePointer$handle() {
        return _InterlockedCompareExchangePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_InterlockedCompareExchangePointer(volatile PVOID *Destination, PVOID Exchange, PVOID Comperand)
     * }
     */
    public static MemorySegment _InterlockedCompareExchangePointer$address() {
        return _InterlockedCompareExchangePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_InterlockedCompareExchangePointer(volatile PVOID *Destination, PVOID Exchange, PVOID Comperand)
     * }
     */
    public static MemorySegment _InterlockedCompareExchangePointer(MemorySegment Destination, MemorySegment Exchange, MemorySegment Comperand) {
        var mh$ = _InterlockedCompareExchangePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedCompareExchangePointer", Destination, Exchange, Comperand);
            }
            return (MemorySegment)mh$.invokeExact(Destination, Exchange, Comperand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchangePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchangePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_InterlockedExchangePointer(volatile PVOID *Target, PVOID Value)
     * }
     */
    public static FunctionDescriptor _InterlockedExchangePointer$descriptor() {
        return _InterlockedExchangePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_InterlockedExchangePointer(volatile PVOID *Target, PVOID Value)
     * }
     */
    public static MethodHandle _InterlockedExchangePointer$handle() {
        return _InterlockedExchangePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_InterlockedExchangePointer(volatile PVOID *Target, PVOID Value)
     * }
     */
    public static MemorySegment _InterlockedExchangePointer$address() {
        return _InterlockedExchangePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_InterlockedExchangePointer(volatile PVOID *Target, PVOID Value)
     * }
     */
    public static MemorySegment _InterlockedExchangePointer(MemorySegment Target, MemorySegment Value) {
        var mh$ = _InterlockedExchangePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchangePointer", Target, Value);
            }
            return (MemorySegment)mh$.invokeExact(Target, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchange8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchange8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char _InterlockedExchange8(volatile CHAR *Target, CHAR Value)
     * }
     */
    public static FunctionDescriptor _InterlockedExchange8$descriptor() {
        return _InterlockedExchange8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char _InterlockedExchange8(volatile CHAR *Target, CHAR Value)
     * }
     */
    public static MethodHandle _InterlockedExchange8$handle() {
        return _InterlockedExchange8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char _InterlockedExchange8(volatile CHAR *Target, CHAR Value)
     * }
     */
    public static MemorySegment _InterlockedExchange8$address() {
        return _InterlockedExchange8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char _InterlockedExchange8(volatile CHAR *Target, CHAR Value)
     * }
     */
    public static byte _InterlockedExchange8(MemorySegment Target, byte Value) {
        var mh$ = _InterlockedExchange8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchange8", Target, Value);
            }
            return (byte)mh$.invokeExact(Target, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchange16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchange16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _InterlockedExchange16(volatile SHORT *Destination, SHORT ExChange)
     * }
     */
    public static FunctionDescriptor _InterlockedExchange16$descriptor() {
        return _InterlockedExchange16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _InterlockedExchange16(volatile SHORT *Destination, SHORT ExChange)
     * }
     */
    public static MethodHandle _InterlockedExchange16$handle() {
        return _InterlockedExchange16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _InterlockedExchange16(volatile SHORT *Destination, SHORT ExChange)
     * }
     */
    public static MemorySegment _InterlockedExchange16$address() {
        return _InterlockedExchange16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _InterlockedExchange16(volatile SHORT *Destination, SHORT ExChange)
     * }
     */
    public static short _InterlockedExchange16(MemorySegment Destination, short ExChange) {
        var mh$ = _InterlockedExchange16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchange16", Destination, ExChange);
            }
            return (short)mh$.invokeExact(Destination, ExChange);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedExchangeAdd8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedExchangeAdd8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char _InterlockedExchangeAdd8(volatile char *_Addend, char _Value)
     * }
     */
    public static FunctionDescriptor _InterlockedExchangeAdd8$descriptor() {
        return _InterlockedExchangeAdd8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char _InterlockedExchangeAdd8(volatile char *_Addend, char _Value)
     * }
     */
    public static MethodHandle _InterlockedExchangeAdd8$handle() {
        return _InterlockedExchangeAdd8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char _InterlockedExchangeAdd8(volatile char *_Addend, char _Value)
     * }
     */
    public static MemorySegment _InterlockedExchangeAdd8$address() {
        return _InterlockedExchangeAdd8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char _InterlockedExchangeAdd8(volatile char *_Addend, char _Value)
     * }
     */
    public static byte _InterlockedExchangeAdd8(MemorySegment _Addend, byte _Value) {
        var mh$ = _InterlockedExchangeAdd8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedExchangeAdd8", _Addend, _Value);
            }
            return (byte)mh$.invokeExact(_Addend, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedAnd8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedAnd8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char _InterlockedAnd8(volatile char *Destination, char Value)
     * }
     */
    public static FunctionDescriptor _InterlockedAnd8$descriptor() {
        return _InterlockedAnd8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char _InterlockedAnd8(volatile char *Destination, char Value)
     * }
     */
    public static MethodHandle _InterlockedAnd8$handle() {
        return _InterlockedAnd8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char _InterlockedAnd8(volatile char *Destination, char Value)
     * }
     */
    public static MemorySegment _InterlockedAnd8$address() {
        return _InterlockedAnd8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char _InterlockedAnd8(volatile char *Destination, char Value)
     * }
     */
    public static byte _InterlockedAnd8(MemorySegment Destination, byte Value) {
        var mh$ = _InterlockedAnd8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedAnd8", Destination, Value);
            }
            return (byte)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedOr8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedOr8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char _InterlockedOr8(volatile char *Destination, char Value)
     * }
     */
    public static FunctionDescriptor _InterlockedOr8$descriptor() {
        return _InterlockedOr8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char _InterlockedOr8(volatile char *Destination, char Value)
     * }
     */
    public static MethodHandle _InterlockedOr8$handle() {
        return _InterlockedOr8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char _InterlockedOr8(volatile char *Destination, char Value)
     * }
     */
    public static MemorySegment _InterlockedOr8$address() {
        return _InterlockedOr8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char _InterlockedOr8(volatile char *Destination, char Value)
     * }
     */
    public static byte _InterlockedOr8(MemorySegment Destination, byte Value) {
        var mh$ = _InterlockedOr8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedOr8", Destination, Value);
            }
            return (byte)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedXor8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedXor8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char _InterlockedXor8(volatile char *Destination, char Value)
     * }
     */
    public static FunctionDescriptor _InterlockedXor8$descriptor() {
        return _InterlockedXor8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char _InterlockedXor8(volatile char *Destination, char Value)
     * }
     */
    public static MethodHandle _InterlockedXor8$handle() {
        return _InterlockedXor8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char _InterlockedXor8(volatile char *Destination, char Value)
     * }
     */
    public static MemorySegment _InterlockedXor8$address() {
        return _InterlockedXor8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char _InterlockedXor8(volatile char *Destination, char Value)
     * }
     */
    public static byte _InterlockedXor8(MemorySegment Destination, byte Value) {
        var mh$ = _InterlockedXor8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedXor8", Destination, Value);
            }
            return (byte)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedAnd16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedAnd16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _InterlockedAnd16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static FunctionDescriptor _InterlockedAnd16$descriptor() {
        return _InterlockedAnd16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _InterlockedAnd16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static MethodHandle _InterlockedAnd16$handle() {
        return _InterlockedAnd16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _InterlockedAnd16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static MemorySegment _InterlockedAnd16$address() {
        return _InterlockedAnd16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _InterlockedAnd16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static short _InterlockedAnd16(MemorySegment Destination, short Value) {
        var mh$ = _InterlockedAnd16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedAnd16", Destination, Value);
            }
            return (short)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedOr16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedOr16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _InterlockedOr16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static FunctionDescriptor _InterlockedOr16$descriptor() {
        return _InterlockedOr16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _InterlockedOr16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static MethodHandle _InterlockedOr16$handle() {
        return _InterlockedOr16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _InterlockedOr16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static MemorySegment _InterlockedOr16$address() {
        return _InterlockedOr16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _InterlockedOr16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static short _InterlockedOr16(MemorySegment Destination, short Value) {
        var mh$ = _InterlockedOr16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedOr16", Destination, Value);
            }
            return (short)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _InterlockedXor16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_InterlockedXor16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _InterlockedXor16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static FunctionDescriptor _InterlockedXor16$descriptor() {
        return _InterlockedXor16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _InterlockedXor16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static MethodHandle _InterlockedXor16$handle() {
        return _InterlockedXor16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _InterlockedXor16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static MemorySegment _InterlockedXor16$address() {
        return _InterlockedXor16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _InterlockedXor16(volatile SHORT *Destination, SHORT Value)
     * }
     */
    public static short _InterlockedXor16(MemorySegment Destination, short Value) {
        var mh$ = _InterlockedXor16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_InterlockedXor16", Destination, Value);
            }
            return (short)mh$.invokeExact(Destination, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpuidex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__cpuidex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __cpuidex(int CPUInfo[4], int Function, int SubLeaf)
     * }
     */
    public static FunctionDescriptor __cpuidex$descriptor() {
        return __cpuidex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __cpuidex(int CPUInfo[4], int Function, int SubLeaf)
     * }
     */
    public static MethodHandle __cpuidex$handle() {
        return __cpuidex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __cpuidex(int CPUInfo[4], int Function, int SubLeaf)
     * }
     */
    public static MemorySegment __cpuidex$address() {
        return __cpuidex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __cpuidex(int CPUInfo[4], int Function, int SubLeaf)
     * }
     */
    public static void __cpuidex(MemorySegment CPUInfo, int Function, int SubLeaf) {
        var mh$ = __cpuidex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpuidex", CPUInfo, Function, SubLeaf);
            }
            mh$.invokeExact(CPUInfo, Function, SubLeaf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_clflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_clflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_clflush(const void *Address)
     * }
     */
    public static FunctionDescriptor _mm_clflush$descriptor() {
        return _mm_clflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_clflush(const void *Address)
     * }
     */
    public static MethodHandle _mm_clflush$handle() {
        return _mm_clflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _mm_clflush(const void *Address)
     * }
     */
    public static MemorySegment _mm_clflush$address() {
        return _mm_clflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _mm_clflush(const void *Address)
     * }
     */
    public static void _mm_clflush(MemorySegment Address) {
        var mh$ = _mm_clflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_clflush", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ReadWriteBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ReadWriteBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _ReadWriteBarrier()
     * }
     */
    public static FunctionDescriptor _ReadWriteBarrier$descriptor() {
        return _ReadWriteBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _ReadWriteBarrier()
     * }
     */
    public static MethodHandle _ReadWriteBarrier$handle() {
        return _ReadWriteBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _ReadWriteBarrier()
     * }
     */
    public static MemorySegment _ReadWriteBarrier$address() {
        return _ReadWriteBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _ReadWriteBarrier()
     * }
     */
    public static void _ReadWriteBarrier() {
        var mh$ = _ReadWriteBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ReadWriteBarrier");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __faststorefence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__faststorefence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __faststorefence()
     * }
     */
    public static FunctionDescriptor __faststorefence$descriptor() {
        return __faststorefence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __faststorefence()
     * }
     */
    public static MethodHandle __faststorefence$handle() {
        return __faststorefence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __faststorefence()
     * }
     */
    public static MemorySegment __faststorefence$address() {
        return __faststorefence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __faststorefence()
     * }
     */
    public static void __faststorefence() {
        var mh$ = __faststorefence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__faststorefence");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_lfence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_lfence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_lfence()
     * }
     */
    public static FunctionDescriptor _mm_lfence$descriptor() {
        return _mm_lfence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_lfence()
     * }
     */
    public static MethodHandle _mm_lfence$handle() {
        return _mm_lfence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _mm_lfence()
     * }
     */
    public static MemorySegment _mm_lfence$address() {
        return _mm_lfence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _mm_lfence()
     * }
     */
    public static void _mm_lfence() {
        var mh$ = _mm_lfence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_lfence");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_mfence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_mfence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_mfence()
     * }
     */
    public static FunctionDescriptor _mm_mfence$descriptor() {
        return _mm_mfence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_mfence()
     * }
     */
    public static MethodHandle _mm_mfence$handle() {
        return _mm_mfence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _mm_mfence()
     * }
     */
    public static MemorySegment _mm_mfence$address() {
        return _mm_mfence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _mm_mfence()
     * }
     */
    public static void _mm_mfence() {
        var mh$ = _mm_mfence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_mfence");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_sfence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_sfence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_sfence()
     * }
     */
    public static FunctionDescriptor _mm_sfence$descriptor() {
        return _mm_sfence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_sfence()
     * }
     */
    public static MethodHandle _mm_sfence$handle() {
        return _mm_sfence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _mm_sfence()
     * }
     */
    public static MemorySegment _mm_sfence$address() {
        return _mm_sfence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _mm_sfence()
     * }
     */
    public static void _mm_sfence() {
        var mh$ = _mm_sfence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_sfence");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_pause()
     * }
     */
    public static FunctionDescriptor _mm_pause$descriptor() {
        return _mm_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_pause()
     * }
     */
    public static MethodHandle _mm_pause$handle() {
        return _mm_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _mm_pause()
     * }
     */
    public static MemorySegment _mm_pause$address() {
        return _mm_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _mm_pause()
     * }
     */
    public static void _mm_pause() {
        var mh$ = _mm_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_pause");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_prefetch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_prefetch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_prefetch(const CHAR *a, int sel)
     * }
     */
    public static FunctionDescriptor _mm_prefetch$descriptor() {
        return _mm_prefetch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_prefetch(const CHAR *a, int sel)
     * }
     */
    public static MethodHandle _mm_prefetch$handle() {
        return _mm_prefetch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _mm_prefetch(const CHAR *a, int sel)
     * }
     */
    public static MemorySegment _mm_prefetch$address() {
        return _mm_prefetch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _mm_prefetch(const CHAR *a, int sel)
     * }
     */
    public static void _mm_prefetch(MemorySegment a, int sel) {
        var mh$ = _mm_prefetch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_prefetch", a, sel);
            }
            mh$.invokeExact(a, sel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _m_prefetchw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_m_prefetchw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _m_prefetchw(const volatile void *Source)
     * }
     */
    public static FunctionDescriptor _m_prefetchw$descriptor() {
        return _m_prefetchw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _m_prefetchw(const volatile void *Source)
     * }
     */
    public static MethodHandle _m_prefetchw$handle() {
        return _m_prefetchw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _m_prefetchw(const volatile void *Source)
     * }
     */
    public static MemorySegment _m_prefetchw$address() {
        return _m_prefetchw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _m_prefetchw(const volatile void *Source)
     * }
     */
    public static void _m_prefetchw(MemorySegment Source) {
        var mh$ = _m_prefetchw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_m_prefetchw", Source);
            }
            mh$.invokeExact(Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_getcsr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_getcsr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _mm_getcsr()
     * }
     */
    public static FunctionDescriptor _mm_getcsr$descriptor() {
        return _mm_getcsr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _mm_getcsr()
     * }
     */
    public static MethodHandle _mm_getcsr$handle() {
        return _mm_getcsr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _mm_getcsr()
     * }
     */
    public static MemorySegment _mm_getcsr$address() {
        return _mm_getcsr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _mm_getcsr()
     * }
     */
    public static int _mm_getcsr() {
        var mh$ = _mm_getcsr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_getcsr");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_setcsr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mm_setcsr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_setcsr(unsigned int MxCsr)
     * }
     */
    public static FunctionDescriptor _mm_setcsr$descriptor() {
        return _mm_setcsr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_setcsr(unsigned int MxCsr)
     * }
     */
    public static MethodHandle _mm_setcsr$handle() {
        return _mm_setcsr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _mm_setcsr(unsigned int MxCsr)
     * }
     */
    public static MemorySegment _mm_setcsr$address() {
        return _mm_setcsr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _mm_setcsr(unsigned int MxCsr)
     * }
     */
    public static void _mm_setcsr(int MxCsr) {
        var mh$ = _mm_setcsr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_setcsr", MxCsr);
            }
            mh$.invokeExact(MxCsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getcallerseflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__getcallerseflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int __getcallerseflags()
     * }
     */
    public static FunctionDescriptor __getcallerseflags$descriptor() {
        return __getcallerseflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int __getcallerseflags()
     * }
     */
    public static MethodHandle __getcallerseflags$handle() {
        return __getcallerseflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int __getcallerseflags()
     * }
     */
    public static MemorySegment __getcallerseflags$address() {
        return __getcallerseflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int __getcallerseflags()
     * }
     */
    public static int __getcallerseflags() {
        var mh$ = __getcallerseflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getcallerseflags");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __segmentlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__segmentlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD __segmentlimit(DWORD Selector)
     * }
     */
    public static FunctionDescriptor __segmentlimit$descriptor() {
        return __segmentlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD __segmentlimit(DWORD Selector)
     * }
     */
    public static MethodHandle __segmentlimit$handle() {
        return __segmentlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD __segmentlimit(DWORD Selector)
     * }
     */
    public static MemorySegment __segmentlimit$address() {
        return __segmentlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD __segmentlimit(DWORD Selector)
     * }
     */
    public static int __segmentlimit(int Selector) {
        var mh$ = __segmentlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__segmentlimit", Selector);
            }
            return (int)mh$.invokeExact(Selector);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __readpmc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__readpmc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD64 __readpmc(DWORD Counter)
     * }
     */
    public static FunctionDescriptor __readpmc$descriptor() {
        return __readpmc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD64 __readpmc(DWORD Counter)
     * }
     */
    public static MethodHandle __readpmc$handle() {
        return __readpmc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD64 __readpmc(DWORD Counter)
     * }
     */
    public static MemorySegment __readpmc$address() {
        return __readpmc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD64 __readpmc(DWORD Counter)
     * }
     */
    public static long __readpmc(int Counter) {
        var mh$ = __readpmc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__readpmc", Counter);
            }
            return (long)mh$.invokeExact(Counter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __rdtsc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__rdtsc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long __rdtsc()
     * }
     */
    public static FunctionDescriptor __rdtsc$descriptor() {
        return __rdtsc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long __rdtsc()
     * }
     */
    public static MethodHandle __rdtsc$handle() {
        return __rdtsc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long __rdtsc()
     * }
     */
    public static MemorySegment __rdtsc$address() {
        return __rdtsc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long __rdtsc()
     * }
     */
    public static long __rdtsc() {
        var mh$ = __rdtsc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__rdtsc");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __movsb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__movsb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __movsb(PBYTE Destination, const BYTE *Source, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __movsb$descriptor() {
        return __movsb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __movsb(PBYTE Destination, const BYTE *Source, SIZE_T Count)
     * }
     */
    public static MethodHandle __movsb$handle() {
        return __movsb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __movsb(PBYTE Destination, const BYTE *Source, SIZE_T Count)
     * }
     */
    public static MemorySegment __movsb$address() {
        return __movsb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __movsb(PBYTE Destination, const BYTE *Source, SIZE_T Count)
     * }
     */
    public static void __movsb(MemorySegment Destination, MemorySegment Source, long Count) {
        var mh$ = __movsb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__movsb", Destination, Source, Count);
            }
            mh$.invokeExact(Destination, Source, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __movsw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__movsw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __movsw(PWORD Destination, const WORD *Source, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __movsw$descriptor() {
        return __movsw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __movsw(PWORD Destination, const WORD *Source, SIZE_T Count)
     * }
     */
    public static MethodHandle __movsw$handle() {
        return __movsw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __movsw(PWORD Destination, const WORD *Source, SIZE_T Count)
     * }
     */
    public static MemorySegment __movsw$address() {
        return __movsw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __movsw(PWORD Destination, const WORD *Source, SIZE_T Count)
     * }
     */
    public static void __movsw(MemorySegment Destination, MemorySegment Source, long Count) {
        var mh$ = __movsw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__movsw", Destination, Source, Count);
            }
            mh$.invokeExact(Destination, Source, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __movsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__movsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __movsd(PDWORD Destination, const DWORD *Source, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __movsd$descriptor() {
        return __movsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __movsd(PDWORD Destination, const DWORD *Source, SIZE_T Count)
     * }
     */
    public static MethodHandle __movsd$handle() {
        return __movsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __movsd(PDWORD Destination, const DWORD *Source, SIZE_T Count)
     * }
     */
    public static MemorySegment __movsd$address() {
        return __movsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __movsd(PDWORD Destination, const DWORD *Source, SIZE_T Count)
     * }
     */
    public static void __movsd(MemorySegment Destination, MemorySegment Source, long Count) {
        var mh$ = __movsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__movsd", Destination, Source, Count);
            }
            mh$.invokeExact(Destination, Source, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __movsq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__movsq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __movsq(PDWORD64 Destination, const DWORD64 *Source, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __movsq$descriptor() {
        return __movsq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __movsq(PDWORD64 Destination, const DWORD64 *Source, SIZE_T Count)
     * }
     */
    public static MethodHandle __movsq$handle() {
        return __movsq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __movsq(PDWORD64 Destination, const DWORD64 *Source, SIZE_T Count)
     * }
     */
    public static MemorySegment __movsq$address() {
        return __movsq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __movsq(PDWORD64 Destination, const DWORD64 *Source, SIZE_T Count)
     * }
     */
    public static void __movsq(MemorySegment Destination, MemorySegment Source, long Count) {
        var mh$ = __movsq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__movsq", Destination, Source, Count);
            }
            mh$.invokeExact(Destination, Source, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stosb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__stosb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __stosb(PBYTE Destination, BYTE Value, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __stosb$descriptor() {
        return __stosb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __stosb(PBYTE Destination, BYTE Value, SIZE_T Count)
     * }
     */
    public static MethodHandle __stosb$handle() {
        return __stosb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __stosb(PBYTE Destination, BYTE Value, SIZE_T Count)
     * }
     */
    public static MemorySegment __stosb$address() {
        return __stosb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __stosb(PBYTE Destination, BYTE Value, SIZE_T Count)
     * }
     */
    public static void __stosb(MemorySegment Destination, byte Value, long Count) {
        var mh$ = __stosb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stosb", Destination, Value, Count);
            }
            mh$.invokeExact(Destination, Value, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stosw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__stosw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __stosw(PWORD Destination, WORD Value, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __stosw$descriptor() {
        return __stosw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __stosw(PWORD Destination, WORD Value, SIZE_T Count)
     * }
     */
    public static MethodHandle __stosw$handle() {
        return __stosw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __stosw(PWORD Destination, WORD Value, SIZE_T Count)
     * }
     */
    public static MemorySegment __stosw$address() {
        return __stosw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __stosw(PWORD Destination, WORD Value, SIZE_T Count)
     * }
     */
    public static void __stosw(MemorySegment Destination, short Value, long Count) {
        var mh$ = __stosw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stosw", Destination, Value, Count);
            }
            mh$.invokeExact(Destination, Value, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stosd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__stosd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __stosd(PDWORD Destination, DWORD Value, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __stosd$descriptor() {
        return __stosd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __stosd(PDWORD Destination, DWORD Value, SIZE_T Count)
     * }
     */
    public static MethodHandle __stosd$handle() {
        return __stosd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __stosd(PDWORD Destination, DWORD Value, SIZE_T Count)
     * }
     */
    public static MemorySegment __stosd$address() {
        return __stosd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __stosd(PDWORD Destination, DWORD Value, SIZE_T Count)
     * }
     */
    public static void __stosd(MemorySegment Destination, int Value, long Count) {
        var mh$ = __stosd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stosd", Destination, Value, Count);
            }
            mh$.invokeExact(Destination, Value, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stosq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__stosq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __stosq(PDWORD64 Destination, DWORD64 Value, SIZE_T Count)
     * }
     */
    public static FunctionDescriptor __stosq$descriptor() {
        return __stosq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __stosq(PDWORD64 Destination, DWORD64 Value, SIZE_T Count)
     * }
     */
    public static MethodHandle __stosq$handle() {
        return __stosq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __stosq(PDWORD64 Destination, DWORD64 Value, SIZE_T Count)
     * }
     */
    public static MemorySegment __stosq$address() {
        return __stosq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __stosq(PDWORD64 Destination, DWORD64 Value, SIZE_T Count)
     * }
     */
    public static void __stosq(MemorySegment Destination, long Value, long Count) {
        var mh$ = __stosq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stosq", Destination, Value, Count);
            }
            mh$.invokeExact(Destination, Value, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mulh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__mulh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long __mulh(LONG64 Multiplier, LONG64 Multiplicand)
     * }
     */
    public static FunctionDescriptor __mulh$descriptor() {
        return __mulh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long __mulh(LONG64 Multiplier, LONG64 Multiplicand)
     * }
     */
    public static MethodHandle __mulh$handle() {
        return __mulh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long __mulh(LONG64 Multiplier, LONG64 Multiplicand)
     * }
     */
    public static MemorySegment __mulh$address() {
        return __mulh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long __mulh(LONG64 Multiplier, LONG64 Multiplicand)
     * }
     */
    public static long __mulh(long Multiplier, long Multiplicand) {
        var mh$ = __mulh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__mulh", Multiplier, Multiplicand);
            }
            return (long)mh$.invokeExact(Multiplier, Multiplicand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __umulh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__umulh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long __umulh(DWORD64 Multiplier, DWORD64 Multiplicand)
     * }
     */
    public static FunctionDescriptor __umulh$descriptor() {
        return __umulh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long __umulh(DWORD64 Multiplier, DWORD64 Multiplicand)
     * }
     */
    public static MethodHandle __umulh$handle() {
        return __umulh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long __umulh(DWORD64 Multiplier, DWORD64 Multiplicand)
     * }
     */
    public static MemorySegment __umulh$address() {
        return __umulh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long __umulh(DWORD64 Multiplier, DWORD64 Multiplicand)
     * }
     */
    public static long __umulh(long Multiplier, long Multiplicand) {
        var mh$ = __umulh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__umulh", Multiplier, Multiplicand);
            }
            return (long)mh$.invokeExact(Multiplier, Multiplicand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __popcnt64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__popcnt64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long __popcnt64(DWORD64 operand)
     * }
     */
    public static FunctionDescriptor __popcnt64$descriptor() {
        return __popcnt64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long __popcnt64(DWORD64 operand)
     * }
     */
    public static MethodHandle __popcnt64$handle() {
        return __popcnt64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long __popcnt64(DWORD64 operand)
     * }
     */
    public static MemorySegment __popcnt64$address() {
        return __popcnt64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long __popcnt64(DWORD64 operand)
     * }
     */
    public static long __popcnt64(long operand) {
        var mh$ = __popcnt64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__popcnt64", operand);
            }
            return (long)mh$.invokeExact(operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __shiftleft128 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__shiftleft128");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long __shiftleft128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static FunctionDescriptor __shiftleft128$descriptor() {
        return __shiftleft128.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long __shiftleft128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static MethodHandle __shiftleft128$handle() {
        return __shiftleft128.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long __shiftleft128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static MemorySegment __shiftleft128$address() {
        return __shiftleft128.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long __shiftleft128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static long __shiftleft128(long LowPart, long HighPart, byte Shift) {
        var mh$ = __shiftleft128.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__shiftleft128", LowPart, HighPart, Shift);
            }
            return (long)mh$.invokeExact(LowPart, HighPart, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __shiftright128 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__shiftright128");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long __shiftright128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static FunctionDescriptor __shiftright128$descriptor() {
        return __shiftright128.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long __shiftright128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static MethodHandle __shiftright128$handle() {
        return __shiftright128.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long __shiftright128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static MemorySegment __shiftright128$address() {
        return __shiftright128.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long __shiftright128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift)
     * }
     */
    public static long __shiftright128(long LowPart, long HighPart, byte Shift) {
        var mh$ = __shiftright128.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__shiftright128", LowPart, HighPart, Shift);
            }
            return (long)mh$.invokeExact(LowPart, HighPart, Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mul128 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mul128");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _mul128(LONG64 Multiplier, LONG64 Multiplicand, LONG64 *HighProduct)
     * }
     */
    public static FunctionDescriptor _mul128$descriptor() {
        return _mul128.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _mul128(LONG64 Multiplier, LONG64 Multiplicand, LONG64 *HighProduct)
     * }
     */
    public static MethodHandle _mul128$handle() {
        return _mul128.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _mul128(LONG64 Multiplier, LONG64 Multiplicand, LONG64 *HighProduct)
     * }
     */
    public static MemorySegment _mul128$address() {
        return _mul128.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _mul128(LONG64 Multiplier, LONG64 Multiplicand, LONG64 *HighProduct)
     * }
     */
    public static long _mul128(long Multiplier, long Multiplicand, MemorySegment HighProduct) {
        var mh$ = _mul128.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mul128", Multiplier, Multiplicand, HighProduct);
            }
            return (long)mh$.invokeExact(Multiplier, Multiplicand, HighProduct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _umul128 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_umul128");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _umul128(DWORD64 Multiplier, DWORD64 Multiplicand, DWORD64 *HighProduct)
     * }
     */
    public static FunctionDescriptor _umul128$descriptor() {
        return _umul128.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _umul128(DWORD64 Multiplier, DWORD64 Multiplicand, DWORD64 *HighProduct)
     * }
     */
    public static MethodHandle _umul128$handle() {
        return _umul128.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _umul128(DWORD64 Multiplier, DWORD64 Multiplicand, DWORD64 *HighProduct)
     * }
     */
    public static MemorySegment _umul128$address() {
        return _umul128.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _umul128(DWORD64 Multiplier, DWORD64 Multiplicand, DWORD64 *HighProduct)
     * }
     */
    public static long _umul128(long Multiplier, long Multiplicand, MemorySegment HighProduct) {
        var mh$ = _umul128.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_umul128", Multiplier, Multiplicand, HighProduct);
            }
            return (long)mh$.invokeExact(Multiplier, Multiplicand, HighProduct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __readgsbyte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__readgsbyte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned char __readgsbyte(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __readgsbyte$descriptor() {
        return __readgsbyte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned char __readgsbyte(DWORD Offset)
     * }
     */
    public static MethodHandle __readgsbyte$handle() {
        return __readgsbyte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned char __readgsbyte(DWORD Offset)
     * }
     */
    public static MemorySegment __readgsbyte$address() {
        return __readgsbyte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned char __readgsbyte(DWORD Offset)
     * }
     */
    public static byte __readgsbyte(int Offset) {
        var mh$ = __readgsbyte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__readgsbyte", Offset);
            }
            return (byte)mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __readgsword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__readgsword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short __readgsword(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __readgsword$descriptor() {
        return __readgsword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short __readgsword(DWORD Offset)
     * }
     */
    public static MethodHandle __readgsword$handle() {
        return __readgsword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short __readgsword(DWORD Offset)
     * }
     */
    public static MemorySegment __readgsword$address() {
        return __readgsword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short __readgsword(DWORD Offset)
     * }
     */
    public static short __readgsword(int Offset) {
        var mh$ = __readgsword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__readgsword", Offset);
            }
            return (short)mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __readgsdword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__readgsdword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __readgsdword(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __readgsdword$descriptor() {
        return __readgsdword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __readgsdword(DWORD Offset)
     * }
     */
    public static MethodHandle __readgsdword$handle() {
        return __readgsdword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __readgsdword(DWORD Offset)
     * }
     */
    public static MemorySegment __readgsdword$address() {
        return __readgsdword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __readgsdword(DWORD Offset)
     * }
     */
    public static int __readgsdword(int Offset) {
        var mh$ = __readgsdword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__readgsdword", Offset);
            }
            return (int)mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __readgsqword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__readgsqword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long __readgsqword(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __readgsqword$descriptor() {
        return __readgsqword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long __readgsqword(DWORD Offset)
     * }
     */
    public static MethodHandle __readgsqword$handle() {
        return __readgsqword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long __readgsqword(DWORD Offset)
     * }
     */
    public static MemorySegment __readgsqword$address() {
        return __readgsqword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long __readgsqword(DWORD Offset)
     * }
     */
    public static long __readgsqword(int Offset) {
        var mh$ = __readgsqword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__readgsqword", Offset);
            }
            return (long)mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __writegsbyte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__writegsbyte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __writegsbyte(DWORD Offset, BYTE Data)
     * }
     */
    public static FunctionDescriptor __writegsbyte$descriptor() {
        return __writegsbyte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __writegsbyte(DWORD Offset, BYTE Data)
     * }
     */
    public static MethodHandle __writegsbyte$handle() {
        return __writegsbyte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __writegsbyte(DWORD Offset, BYTE Data)
     * }
     */
    public static MemorySegment __writegsbyte$address() {
        return __writegsbyte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __writegsbyte(DWORD Offset, BYTE Data)
     * }
     */
    public static void __writegsbyte(int Offset, byte Data) {
        var mh$ = __writegsbyte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__writegsbyte", Offset, Data);
            }
            mh$.invokeExact(Offset, Data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __writegsword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__writegsword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __writegsword(DWORD Offset, WORD Data)
     * }
     */
    public static FunctionDescriptor __writegsword$descriptor() {
        return __writegsword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __writegsword(DWORD Offset, WORD Data)
     * }
     */
    public static MethodHandle __writegsword$handle() {
        return __writegsword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __writegsword(DWORD Offset, WORD Data)
     * }
     */
    public static MemorySegment __writegsword$address() {
        return __writegsword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __writegsword(DWORD Offset, WORD Data)
     * }
     */
    public static void __writegsword(int Offset, short Data) {
        var mh$ = __writegsword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__writegsword", Offset, Data);
            }
            mh$.invokeExact(Offset, Data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __writegsdword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__writegsdword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __writegsdword(DWORD Offset, DWORD Data)
     * }
     */
    public static FunctionDescriptor __writegsdword$descriptor() {
        return __writegsdword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __writegsdword(DWORD Offset, DWORD Data)
     * }
     */
    public static MethodHandle __writegsdword$handle() {
        return __writegsdword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __writegsdword(DWORD Offset, DWORD Data)
     * }
     */
    public static MemorySegment __writegsdword$address() {
        return __writegsdword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __writegsdword(DWORD Offset, DWORD Data)
     * }
     */
    public static void __writegsdword(int Offset, int Data) {
        var mh$ = __writegsdword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__writegsdword", Offset, Data);
            }
            mh$.invokeExact(Offset, Data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __writegsqword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__writegsqword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __writegsqword(DWORD Offset, DWORD64 Data)
     * }
     */
    public static FunctionDescriptor __writegsqword$descriptor() {
        return __writegsqword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __writegsqword(DWORD Offset, DWORD64 Data)
     * }
     */
    public static MethodHandle __writegsqword$handle() {
        return __writegsqword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __writegsqword(DWORD Offset, DWORD64 Data)
     * }
     */
    public static MemorySegment __writegsqword$address() {
        return __writegsqword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __writegsqword(DWORD Offset, DWORD64 Data)
     * }
     */
    public static void __writegsqword(int Offset, long Data) {
        var mh$ = __writegsqword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__writegsqword", Offset, Data);
            }
            mh$.invokeExact(Offset, Data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __incgsbyte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__incgsbyte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __incgsbyte(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __incgsbyte$descriptor() {
        return __incgsbyte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __incgsbyte(DWORD Offset)
     * }
     */
    public static MethodHandle __incgsbyte$handle() {
        return __incgsbyte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __incgsbyte(DWORD Offset)
     * }
     */
    public static MemorySegment __incgsbyte$address() {
        return __incgsbyte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __incgsbyte(DWORD Offset)
     * }
     */
    public static void __incgsbyte(int Offset) {
        var mh$ = __incgsbyte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__incgsbyte", Offset);
            }
            mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __addgsbyte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__addgsbyte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __addgsbyte(DWORD Offset, BYTE Value)
     * }
     */
    public static FunctionDescriptor __addgsbyte$descriptor() {
        return __addgsbyte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __addgsbyte(DWORD Offset, BYTE Value)
     * }
     */
    public static MethodHandle __addgsbyte$handle() {
        return __addgsbyte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __addgsbyte(DWORD Offset, BYTE Value)
     * }
     */
    public static MemorySegment __addgsbyte$address() {
        return __addgsbyte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __addgsbyte(DWORD Offset, BYTE Value)
     * }
     */
    public static void __addgsbyte(int Offset, byte Value) {
        var mh$ = __addgsbyte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__addgsbyte", Offset, Value);
            }
            mh$.invokeExact(Offset, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __incgsword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__incgsword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __incgsword(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __incgsword$descriptor() {
        return __incgsword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __incgsword(DWORD Offset)
     * }
     */
    public static MethodHandle __incgsword$handle() {
        return __incgsword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __incgsword(DWORD Offset)
     * }
     */
    public static MemorySegment __incgsword$address() {
        return __incgsword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __incgsword(DWORD Offset)
     * }
     */
    public static void __incgsword(int Offset) {
        var mh$ = __incgsword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__incgsword", Offset);
            }
            mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __addgsword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__addgsword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __addgsword(DWORD Offset, WORD Value)
     * }
     */
    public static FunctionDescriptor __addgsword$descriptor() {
        return __addgsword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __addgsword(DWORD Offset, WORD Value)
     * }
     */
    public static MethodHandle __addgsword$handle() {
        return __addgsword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __addgsword(DWORD Offset, WORD Value)
     * }
     */
    public static MemorySegment __addgsword$address() {
        return __addgsword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __addgsword(DWORD Offset, WORD Value)
     * }
     */
    public static void __addgsword(int Offset, short Value) {
        var mh$ = __addgsword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__addgsword", Offset, Value);
            }
            mh$.invokeExact(Offset, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __incgsdword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__incgsdword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __incgsdword(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __incgsdword$descriptor() {
        return __incgsdword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __incgsdword(DWORD Offset)
     * }
     */
    public static MethodHandle __incgsdword$handle() {
        return __incgsdword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __incgsdword(DWORD Offset)
     * }
     */
    public static MemorySegment __incgsdword$address() {
        return __incgsdword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __incgsdword(DWORD Offset)
     * }
     */
    public static void __incgsdword(int Offset) {
        var mh$ = __incgsdword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__incgsdword", Offset);
            }
            mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __addgsdword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__addgsdword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __addgsdword(DWORD Offset, DWORD Value)
     * }
     */
    public static FunctionDescriptor __addgsdword$descriptor() {
        return __addgsdword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __addgsdword(DWORD Offset, DWORD Value)
     * }
     */
    public static MethodHandle __addgsdword$handle() {
        return __addgsdword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __addgsdword(DWORD Offset, DWORD Value)
     * }
     */
    public static MemorySegment __addgsdword$address() {
        return __addgsdword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __addgsdword(DWORD Offset, DWORD Value)
     * }
     */
    public static void __addgsdword(int Offset, int Value) {
        var mh$ = __addgsdword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__addgsdword", Offset, Value);
            }
            mh$.invokeExact(Offset, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __incgsqword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__incgsqword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __incgsqword(DWORD Offset)
     * }
     */
    public static FunctionDescriptor __incgsqword$descriptor() {
        return __incgsqword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __incgsqword(DWORD Offset)
     * }
     */
    public static MethodHandle __incgsqword$handle() {
        return __incgsqword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __incgsqword(DWORD Offset)
     * }
     */
    public static MemorySegment __incgsqword$address() {
        return __incgsqword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __incgsqword(DWORD Offset)
     * }
     */
    public static void __incgsqword(int Offset) {
        var mh$ = __incgsqword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__incgsqword", Offset);
            }
            mh$.invokeExact(Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __addgsqword {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__addgsqword");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __addgsqword(DWORD Offset, DWORD64 Value)
     * }
     */
    public static FunctionDescriptor __addgsqword$descriptor() {
        return __addgsqword.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __addgsqword(DWORD Offset, DWORD64 Value)
     * }
     */
    public static MethodHandle __addgsqword$handle() {
        return __addgsqword.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __addgsqword(DWORD Offset, DWORD64 Value)
     * }
     */
    public static MemorySegment __addgsqword$address() {
        return __addgsqword.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __addgsqword(DWORD Offset, DWORD64 Value)
     * }
     */
    public static void __addgsqword(int Offset, long Value) {
        var mh$ = __addgsqword.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__addgsqword", Offset, Value);
            }
            mh$.invokeExact(Offset, Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef XSAVE_FORMAT *PXMM_SAVE_AREA32
     * }
     */
    public static final AddressLayout PXMM_SAVE_AREA32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CONTEXT {
     *     DWORD64 P1Home;
     *     DWORD64 P2Home;
     *     DWORD64 P3Home;
     *     DWORD64 P4Home;
     *     DWORD64 P5Home;
     *     DWORD64 P6Home;
     *     DWORD ContextFlags;
     *     DWORD MxCsr;
     *     WORD SegCs;
     *     WORD SegDs;
     *     WORD SegEs;
     *     WORD SegFs;
     *     WORD SegGs;
     *     WORD SegSs;
     *     DWORD EFlags;
     *     DWORD64 Dr0;
     *     DWORD64 Dr1;
     *     DWORD64 Dr2;
     *     DWORD64 Dr3;
     *     DWORD64 Dr6;
     *     DWORD64 Dr7;
     *     DWORD64 Rax;
     *     DWORD64 Rcx;
     *     DWORD64 Rdx;
     *     DWORD64 Rbx;
     *     DWORD64 Rsp;
     *     DWORD64 Rbp;
     *     DWORD64 Rsi;
     *     DWORD64 Rdi;
     *     DWORD64 R8;
     *     DWORD64 R9;
     *     DWORD64 R10;
     *     DWORD64 R11;
     *     DWORD64 R12;
     *     DWORD64 R13;
     *     DWORD64 R14;
     *     DWORD64 R15;
     *     DWORD64 Rip;
     *     union {
     *         XMM_SAVE_AREA32 FltSave;
     *         struct {
     *             M128A Header[2];
     *             M128A Legacy[8];
     *             M128A Xmm0;
     *             M128A Xmm1;
     *             M128A Xmm2;
     *             M128A Xmm3;
     *             M128A Xmm4;
     *             M128A Xmm5;
     *             M128A Xmm6;
     *             M128A Xmm7;
     *             M128A Xmm8;
     *             M128A Xmm9;
     *             M128A Xmm10;
     *             M128A Xmm11;
     *             M128A Xmm12;
     *             M128A Xmm13;
     *             M128A Xmm14;
     *             M128A Xmm15;
     *         };
     *     };
     *     M128A VectorRegister[26];
     *     DWORD64 VectorControl;
     *     DWORD64 DebugControl;
     *     DWORD64 LastBranchToRip;
     *     DWORD64 LastBranchFromRip;
     *     DWORD64 LastExceptionToRip;
     *     DWORD64 LastExceptionFromRip;
     * } *PCONTEXT
     * }
     */
    public static final AddressLayout PCONTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY *PRUNTIME_FUNCTION
     * }
     */
    public static final AddressLayout PRUNTIME_FUNCTION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SCOPE_TABLE_AMD64 *PSCOPE_TABLE
     * }
     */
    public static final AddressLayout PSCOPE_TABLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNWIND_HISTORY_TABLE_ENTRY {
     *     DWORD64 ImageBase;
     *     PRUNTIME_FUNCTION FunctionEntry;
     * } *PUNWIND_HISTORY_TABLE_ENTRY
     * }
     */
    public static final AddressLayout PUNWIND_HISTORY_TABLE_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNWIND_HISTORY_TABLE {
     *     DWORD Count;
     *     BYTE LocalHint;
     *     BYTE GlobalHint;
     *     BYTE Search;
     *     BYTE Once;
     *     DWORD64 LowAddress;
     *     DWORD64 HighAddress;
     *     UNWIND_HISTORY_TABLE_ENTRY Entry[12];
     * } *PUNWIND_HISTORY_TABLE
     * }
     */
    public static final AddressLayout PUNWIND_HISTORY_TABLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPATCHER_CONTEXT {
     *     DWORD64 ControlPc;
     *     DWORD64 ImageBase;
     *     PRUNTIME_FUNCTION FunctionEntry;
     *     DWORD64 EstablisherFrame;
     *     DWORD64 TargetIp;
     *     PCONTEXT ContextRecord;
     *     PEXCEPTION_ROUTINE LanguageHandler;
     *     PVOID HandlerData;
     *     PUNWIND_HISTORY_TABLE HistoryTable;
     *     DWORD ScopeIndex;
     *     DWORD Fill0;
     * } *PDISPATCHER_CONTEXT
     * }
     */
    public static final AddressLayout PDISPATCHER_CONTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
     *     union {
     *         PM128A FloatingContext[16];
     *         struct {
     *             PM128A Xmm0;
     *             PM128A Xmm1;
     *             PM128A Xmm2;
     *             PM128A Xmm3;
     *             PM128A Xmm4;
     *             PM128A Xmm5;
     *             PM128A Xmm6;
     *             PM128A Xmm7;
     *             PM128A Xmm8;
     *             PM128A Xmm9;
     *             PM128A Xmm10;
     *             PM128A Xmm11;
     *             PM128A Xmm12;
     *             PM128A Xmm13;
     *             PM128A Xmm14;
     *             PM128A Xmm15;
     *         };
     *     };
     *     union {
     *         PDWORD64 IntegerContext[16];
     *         struct {
     *             PDWORD64 Rax;
     *             PDWORD64 Rcx;
     *             PDWORD64 Rdx;
     *             PDWORD64 Rbx;
     *             PDWORD64 Rsp;
     *             PDWORD64 Rbp;
     *             PDWORD64 Rsi;
     *             PDWORD64 Rdi;
     *             PDWORD64 R8;
     *             PDWORD64 R9;
     *             PDWORD64 R10;
     *             PDWORD64 R11;
     *             PDWORD64 R12;
     *             PDWORD64 R13;
     *             PDWORD64 R14;
     *             PDWORD64 R15;
     *         };
     *     };
     * } *PKNONVOLATILE_CONTEXT_POINTERS
     * }
     */
    public static final AddressLayout PKNONVOLATILE_CONTEXT_POINTERS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCOPE_TABLE_ARM {
     *     DWORD Count;
     *     struct {
     *         DWORD BeginAddress;
     *         DWORD EndAddress;
     *         DWORD HandlerAddress;
     *         DWORD JumpTarget;
     *     } ScopeRecord[1];
     * } *PSCOPE_TABLE_ARM
     * }
     */
    public static final AddressLayout PSCOPE_TABLE_ARM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCOPE_TABLE_ARM64 {
     *     DWORD Count;
     *     struct {
     *         DWORD BeginAddress;
     *         DWORD EndAddress;
     *         DWORD HandlerAddress;
     *         DWORD JumpTarget;
     *     } ScopeRecord[1];
     * } *PSCOPE_TABLE_ARM64
     * }
     */
    public static final AddressLayout PSCOPE_TABLE_ARM64 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
     *     PDWORD64 X19;
     *     PDWORD64 X20;
     *     PDWORD64 X21;
     *     PDWORD64 X22;
     *     PDWORD64 X23;
     *     PDWORD64 X24;
     *     PDWORD64 X25;
     *     PDWORD64 X26;
     *     PDWORD64 X27;
     *     PDWORD64 X28;
     *     PDWORD64 Fp;
     *     PDWORD64 Lr;
     *     PDWORD64 D8;
     *     PDWORD64 D9;
     *     PDWORD64 D10;
     *     PDWORD64 D11;
     *     PDWORD64 D12;
     *     PDWORD64 D13;
     *     PDWORD64 D14;
     *     PDWORD64 D15;
     * } *PKNONVOLATILE_CONTEXT_POINTERS_ARM64
     * }
     */
    public static final AddressLayout PKNONVOLATILE_CONTEXT_POINTERS_ARM64 = freeglut_h.C_POINTER;

    private static class __int2c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__int2c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __int2c()
     * }
     */
    public static FunctionDescriptor __int2c$descriptor() {
        return __int2c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __int2c()
     * }
     */
    public static MethodHandle __int2c$handle() {
        return __int2c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __int2c()
     * }
     */
    public static MemorySegment __int2c$address() {
        return __int2c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __int2c()
     * }
     */
    public static void __int2c() {
        var mh$ = __int2c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__int2c");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _LDT_ENTRY {
     *     WORD LimitLow;
     *     WORD BaseLow;
     *     union {
     *         struct {
     *             BYTE BaseMid;
     *             BYTE Flags1;
     *             BYTE Flags2;
     *             BYTE BaseHi;
     *         } Bytes;
     *         struct {
     *             DWORD BaseMid : 8;
     *             DWORD Type : 5;
     *             DWORD Dpl : 2;
     *             DWORD Pres : 1;
     *             DWORD LimitHi : 4;
     *             DWORD Sys : 1;
     *             DWORD Reserved_0 : 1;
     *             DWORD Default_Big : 1;
     *             DWORD Granularity : 1;
     *             DWORD BaseHi : 8;
     *         } Bits;
     *     } HighWord;
     * } *PLDT_ENTRY
     * }
     */
    public static final AddressLayout PLDT_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA
     * }
     */
    public static final AddressLayout PWOW64_FLOATING_SAVE_AREA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WOW64_CONTEXT *PWOW64_CONTEXT
     * }
     */
    public static final AddressLayout PWOW64_CONTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WOW64_LDT_ENTRY {
     *     WORD LimitLow;
     *     WORD BaseLow;
     *     union {
     *         struct {
     *             BYTE BaseMid;
     *             BYTE Flags1;
     *             BYTE Flags2;
     *             BYTE BaseHi;
     *         } Bytes;
     *         struct {
     *             DWORD BaseMid : 8;
     *             DWORD Type : 5;
     *             DWORD Dpl : 2;
     *             DWORD Pres : 1;
     *             DWORD LimitHi : 4;
     *             DWORD Sys : 1;
     *             DWORD Reserved_0 : 1;
     *             DWORD Default_Big : 1;
     *             DWORD Granularity : 1;
     *             DWORD BaseHi : 8;
     *         } Bits;
     *     } HighWord;
     * } *PWOW64_LDT_ENTRY
     * }
     */
    public static final AddressLayout PWOW64_LDT_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
     *     DWORD Selector;
     *     WOW64_LDT_ENTRY Descriptor;
     * } *PWOW64_DESCRIPTOR_TABLE_ENTRY
     * }
     */
    public static final AddressLayout PWOW64_DESCRIPTOR_TABLE_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef EXCEPTION_RECORD *PEXCEPTION_RECORD
     * }
     */
    public static final AddressLayout PEXCEPTION_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXCEPTION_RECORD32 {
     *     DWORD ExceptionCode;
     *     DWORD ExceptionFlags;
     *     DWORD ExceptionRecord;
     *     DWORD ExceptionAddress;
     *     DWORD NumberParameters;
     *     DWORD ExceptionInformation[15];
     * } *PEXCEPTION_RECORD32
     * }
     */
    public static final AddressLayout PEXCEPTION_RECORD32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXCEPTION_RECORD64 {
     *     DWORD ExceptionCode;
     *     DWORD ExceptionFlags;
     *     DWORD64 ExceptionRecord;
     *     DWORD64 ExceptionAddress;
     *     DWORD NumberParameters;
     *     DWORD __unusedAlignment;
     *     DWORD64 ExceptionInformation[15];
     * } *PEXCEPTION_RECORD64
     * }
     */
    public static final AddressLayout PEXCEPTION_RECORD64 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXCEPTION_POINTERS {
     *     PEXCEPTION_RECORD ExceptionRecord;
     *     PCONTEXT ContextRecord;
     * } *PEXCEPTION_POINTERS
     * }
     */
    public static final AddressLayout PEXCEPTION_POINTERS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID PACCESS_TOKEN
     * }
     */
    public static final AddressLayout PACCESS_TOKEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID PSECURITY_DESCRIPTOR
     * }
     */
    public static final AddressLayout PSECURITY_DESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID PSID
     * }
     */
    public static final AddressLayout PSID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID PCLAIMS_BLOB
     * }
     */
    public static final AddressLayout PCLAIMS_BLOB = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD ACCESS_MASK
     * }
     */
    public static final OfInt ACCESS_MASK = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ACCESS_MASK *PACCESS_MASK
     * }
     */
    public static final AddressLayout PACCESS_MASK = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GENERIC_MAPPING *PGENERIC_MAPPING
     * }
     */
    public static final AddressLayout PGENERIC_MAPPING = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _LUID_AND_ATTRIBUTES {
     *     LUID Luid;
     *     DWORD Attributes;
     * } *PLUID_AND_ATTRIBUTES
     * }
     */
    public static final AddressLayout PLUID_AND_ATTRIBUTES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY
     * }
     */
    public static final AddressLayout PLUID_AND_ATTRIBUTES_ARRAY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SID_IDENTIFIER_AUTHORITY {
     *     BYTE Value[6];
     * } *PSID_IDENTIFIER_AUTHORITY
     * }
     */
    public static final AddressLayout PSID_IDENTIFIER_AUTHORITY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SID {
     *     BYTE Revision;
     *     BYTE SubAuthorityCount;
     *     SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
     *     DWORD SubAuthority[1];
     * } *PISID
     * }
     */
    public static final AddressLayout PISID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef union _SE_SID {
     *     SID Sid;
     *     BYTE Buffer[68];
     * } *PSE_SID
     * }
     */
    public static final AddressLayout PSE_SID = freeglut_h.C_POINTER;
    private static final int SidTypeUser = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeUser = 1
     * }
     */
    public static int SidTypeUser() {
        return SidTypeUser;
    }
    private static final int SidTypeGroup = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeGroup = 2
     * }
     */
    public static int SidTypeGroup() {
        return SidTypeGroup;
    }
    private static final int SidTypeDomain = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeDomain = 3
     * }
     */
    public static int SidTypeDomain() {
        return SidTypeDomain;
    }
    private static final int SidTypeAlias = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeAlias = 4
     * }
     */
    public static int SidTypeAlias() {
        return SidTypeAlias;
    }
    private static final int SidTypeWellKnownGroup = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeWellKnownGroup = 5
     * }
     */
    public static int SidTypeWellKnownGroup() {
        return SidTypeWellKnownGroup;
    }
    private static final int SidTypeDeletedAccount = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeDeletedAccount = 6
     * }
     */
    public static int SidTypeDeletedAccount() {
        return SidTypeDeletedAccount;
    }
    private static final int SidTypeInvalid = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeInvalid = 7
     * }
     */
    public static int SidTypeInvalid() {
        return SidTypeInvalid;
    }
    private static final int SidTypeUnknown = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeUnknown = 8
     * }
     */
    public static int SidTypeUnknown() {
        return SidTypeUnknown;
    }
    private static final int SidTypeComputer = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeComputer = 9
     * }
     */
    public static int SidTypeComputer() {
        return SidTypeComputer;
    }
    private static final int SidTypeLabel = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeLabel = 10
     * }
     */
    public static int SidTypeLabel() {
        return SidTypeLabel;
    }
    private static final int SidTypeLogonSession = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _SID_NAME_USE.SidTypeLogonSession = 11
     * }
     */
    public static int SidTypeLogonSession() {
        return SidTypeLogonSession;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _SID_NAME_USE {
     *     SidTypeUser = 1,
     *     SidTypeGroup,
     *     SidTypeDomain,
     *     SidTypeAlias,
     *     SidTypeWellKnownGroup,
     *     SidTypeDeletedAccount,
     *     SidTypeInvalid,
     *     SidTypeUnknown,
     *     SidTypeComputer,
     *     SidTypeLabel,
     *     SidTypeLogonSession
     * } *PSID_NAME_USE
     * }
     */
    public static final AddressLayout PSID_NAME_USE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SID_AND_ATTRIBUTES {
     *     PSID Sid;
     *     DWORD Attributes;
     * } *PSID_AND_ATTRIBUTES
     * }
     */
    public static final AddressLayout PSID_AND_ATTRIBUTES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY
     * }
     */
    public static final AddressLayout PSID_AND_ATTRIBUTES_ARRAY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR SID_HASH_ENTRY
     * }
     */
    public static final OfLong SID_HASH_ENTRY = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR *PSID_HASH_ENTRY
     * }
     */
    public static final AddressLayout PSID_HASH_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SID_AND_ATTRIBUTES_HASH {
     *     DWORD SidCount;
     *     PSID_AND_ATTRIBUTES SidAttr;
     *     SID_HASH_ENTRY Hash[32];
     * } *PSID_AND_ATTRIBUTES_HASH
     * }
     */
    public static final AddressLayout PSID_AND_ATTRIBUTES_HASH = freeglut_h.C_POINTER;
    private static final int WinNullSid = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinNullSid = 0
     * }
     */
    public static int WinNullSid() {
        return WinNullSid;
    }
    private static final int WinWorldSid = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinWorldSid = 1
     * }
     */
    public static int WinWorldSid() {
        return WinWorldSid;
    }
    private static final int WinLocalSid = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLocalSid = 2
     * }
     */
    public static int WinLocalSid() {
        return WinLocalSid;
    }
    private static final int WinCreatorOwnerSid = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCreatorOwnerSid = 3
     * }
     */
    public static int WinCreatorOwnerSid() {
        return WinCreatorOwnerSid;
    }
    private static final int WinCreatorGroupSid = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCreatorGroupSid = 4
     * }
     */
    public static int WinCreatorGroupSid() {
        return WinCreatorGroupSid;
    }
    private static final int WinCreatorOwnerServerSid = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCreatorOwnerServerSid = 5
     * }
     */
    public static int WinCreatorOwnerServerSid() {
        return WinCreatorOwnerServerSid;
    }
    private static final int WinCreatorGroupServerSid = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCreatorGroupServerSid = 6
     * }
     */
    public static int WinCreatorGroupServerSid() {
        return WinCreatorGroupServerSid;
    }
    private static final int WinNtAuthoritySid = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinNtAuthoritySid = 7
     * }
     */
    public static int WinNtAuthoritySid() {
        return WinNtAuthoritySid;
    }
    private static final int WinDialupSid = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinDialupSid = 8
     * }
     */
    public static int WinDialupSid() {
        return WinDialupSid;
    }
    private static final int WinNetworkSid = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinNetworkSid = 9
     * }
     */
    public static int WinNetworkSid() {
        return WinNetworkSid;
    }
    private static final int WinBatchSid = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBatchSid = 10
     * }
     */
    public static int WinBatchSid() {
        return WinBatchSid;
    }
    private static final int WinInteractiveSid = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinInteractiveSid = 11
     * }
     */
    public static int WinInteractiveSid() {
        return WinInteractiveSid;
    }
    private static final int WinServiceSid = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinServiceSid = 12
     * }
     */
    public static int WinServiceSid() {
        return WinServiceSid;
    }
    private static final int WinAnonymousSid = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAnonymousSid = 13
     * }
     */
    public static int WinAnonymousSid() {
        return WinAnonymousSid;
    }
    private static final int WinProxySid = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinProxySid = 14
     * }
     */
    public static int WinProxySid() {
        return WinProxySid;
    }
    private static final int WinEnterpriseControllersSid = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinEnterpriseControllersSid = 15
     * }
     */
    public static int WinEnterpriseControllersSid() {
        return WinEnterpriseControllersSid;
    }
    private static final int WinSelfSid = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinSelfSid = 16
     * }
     */
    public static int WinSelfSid() {
        return WinSelfSid;
    }
    private static final int WinAuthenticatedUserSid = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAuthenticatedUserSid = 17
     * }
     */
    public static int WinAuthenticatedUserSid() {
        return WinAuthenticatedUserSid;
    }
    private static final int WinRestrictedCodeSid = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinRestrictedCodeSid = 18
     * }
     */
    public static int WinRestrictedCodeSid() {
        return WinRestrictedCodeSid;
    }
    private static final int WinTerminalServerSid = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinTerminalServerSid = 19
     * }
     */
    public static int WinTerminalServerSid() {
        return WinTerminalServerSid;
    }
    private static final int WinRemoteLogonIdSid = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinRemoteLogonIdSid = 20
     * }
     */
    public static int WinRemoteLogonIdSid() {
        return WinRemoteLogonIdSid;
    }
    private static final int WinLogonIdsSid = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLogonIdsSid = 21
     * }
     */
    public static int WinLogonIdsSid() {
        return WinLogonIdsSid;
    }
    private static final int WinLocalSystemSid = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLocalSystemSid = 22
     * }
     */
    public static int WinLocalSystemSid() {
        return WinLocalSystemSid;
    }
    private static final int WinLocalServiceSid = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLocalServiceSid = 23
     * }
     */
    public static int WinLocalServiceSid() {
        return WinLocalServiceSid;
    }
    private static final int WinNetworkServiceSid = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinNetworkServiceSid = 24
     * }
     */
    public static int WinNetworkServiceSid() {
        return WinNetworkServiceSid;
    }
    private static final int WinBuiltinDomainSid = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinDomainSid = 25
     * }
     */
    public static int WinBuiltinDomainSid() {
        return WinBuiltinDomainSid;
    }
    private static final int WinBuiltinAdministratorsSid = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinAdministratorsSid = 26
     * }
     */
    public static int WinBuiltinAdministratorsSid() {
        return WinBuiltinAdministratorsSid;
    }
    private static final int WinBuiltinUsersSid = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinUsersSid = 27
     * }
     */
    public static int WinBuiltinUsersSid() {
        return WinBuiltinUsersSid;
    }
    private static final int WinBuiltinGuestsSid = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinGuestsSid = 28
     * }
     */
    public static int WinBuiltinGuestsSid() {
        return WinBuiltinGuestsSid;
    }
    private static final int WinBuiltinPowerUsersSid = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinPowerUsersSid = 29
     * }
     */
    public static int WinBuiltinPowerUsersSid() {
        return WinBuiltinPowerUsersSid;
    }
    private static final int WinBuiltinAccountOperatorsSid = (int)30L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinAccountOperatorsSid = 30
     * }
     */
    public static int WinBuiltinAccountOperatorsSid() {
        return WinBuiltinAccountOperatorsSid;
    }
    private static final int WinBuiltinSystemOperatorsSid = (int)31L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinSystemOperatorsSid = 31
     * }
     */
    public static int WinBuiltinSystemOperatorsSid() {
        return WinBuiltinSystemOperatorsSid;
    }
    private static final int WinBuiltinPrintOperatorsSid = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinPrintOperatorsSid = 32
     * }
     */
    public static int WinBuiltinPrintOperatorsSid() {
        return WinBuiltinPrintOperatorsSid;
    }
    private static final int WinBuiltinBackupOperatorsSid = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinBackupOperatorsSid = 33
     * }
     */
    public static int WinBuiltinBackupOperatorsSid() {
        return WinBuiltinBackupOperatorsSid;
    }
    private static final int WinBuiltinReplicatorSid = (int)34L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinReplicatorSid = 34
     * }
     */
    public static int WinBuiltinReplicatorSid() {
        return WinBuiltinReplicatorSid;
    }
    private static final int WinBuiltinPreWindows2000CompatibleAccessSid = (int)35L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinPreWindows2000CompatibleAccessSid = 35
     * }
     */
    public static int WinBuiltinPreWindows2000CompatibleAccessSid() {
        return WinBuiltinPreWindows2000CompatibleAccessSid;
    }
    private static final int WinBuiltinRemoteDesktopUsersSid = (int)36L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinRemoteDesktopUsersSid = 36
     * }
     */
    public static int WinBuiltinRemoteDesktopUsersSid() {
        return WinBuiltinRemoteDesktopUsersSid;
    }
    private static final int WinBuiltinNetworkConfigurationOperatorsSid = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinNetworkConfigurationOperatorsSid = 37
     * }
     */
    public static int WinBuiltinNetworkConfigurationOperatorsSid() {
        return WinBuiltinNetworkConfigurationOperatorsSid;
    }
    private static final int WinAccountAdministratorSid = (int)38L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountAdministratorSid = 38
     * }
     */
    public static int WinAccountAdministratorSid() {
        return WinAccountAdministratorSid;
    }
    private static final int WinAccountGuestSid = (int)39L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountGuestSid = 39
     * }
     */
    public static int WinAccountGuestSid() {
        return WinAccountGuestSid;
    }
    private static final int WinAccountKrbtgtSid = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountKrbtgtSid = 40
     * }
     */
    public static int WinAccountKrbtgtSid() {
        return WinAccountKrbtgtSid;
    }
    private static final int WinAccountDomainAdminsSid = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountDomainAdminsSid = 41
     * }
     */
    public static int WinAccountDomainAdminsSid() {
        return WinAccountDomainAdminsSid;
    }
    private static final int WinAccountDomainUsersSid = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountDomainUsersSid = 42
     * }
     */
    public static int WinAccountDomainUsersSid() {
        return WinAccountDomainUsersSid;
    }
    private static final int WinAccountDomainGuestsSid = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountDomainGuestsSid = 43
     * }
     */
    public static int WinAccountDomainGuestsSid() {
        return WinAccountDomainGuestsSid;
    }
    private static final int WinAccountComputersSid = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountComputersSid = 44
     * }
     */
    public static int WinAccountComputersSid() {
        return WinAccountComputersSid;
    }
    private static final int WinAccountControllersSid = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountControllersSid = 45
     * }
     */
    public static int WinAccountControllersSid() {
        return WinAccountControllersSid;
    }
    private static final int WinAccountCertAdminsSid = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountCertAdminsSid = 46
     * }
     */
    public static int WinAccountCertAdminsSid() {
        return WinAccountCertAdminsSid;
    }
    private static final int WinAccountSchemaAdminsSid = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountSchemaAdminsSid = 47
     * }
     */
    public static int WinAccountSchemaAdminsSid() {
        return WinAccountSchemaAdminsSid;
    }
    private static final int WinAccountEnterpriseAdminsSid = (int)48L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountEnterpriseAdminsSid = 48
     * }
     */
    public static int WinAccountEnterpriseAdminsSid() {
        return WinAccountEnterpriseAdminsSid;
    }
    private static final int WinAccountPolicyAdminsSid = (int)49L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountPolicyAdminsSid = 49
     * }
     */
    public static int WinAccountPolicyAdminsSid() {
        return WinAccountPolicyAdminsSid;
    }
    private static final int WinAccountRasAndIasServersSid = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountRasAndIasServersSid = 50
     * }
     */
    public static int WinAccountRasAndIasServersSid() {
        return WinAccountRasAndIasServersSid;
    }
    private static final int WinNTLMAuthenticationSid = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinNTLMAuthenticationSid = 51
     * }
     */
    public static int WinNTLMAuthenticationSid() {
        return WinNTLMAuthenticationSid;
    }
    private static final int WinDigestAuthenticationSid = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinDigestAuthenticationSid = 52
     * }
     */
    public static int WinDigestAuthenticationSid() {
        return WinDigestAuthenticationSid;
    }
    private static final int WinSChannelAuthenticationSid = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinSChannelAuthenticationSid = 53
     * }
     */
    public static int WinSChannelAuthenticationSid() {
        return WinSChannelAuthenticationSid;
    }
    private static final int WinThisOrganizationSid = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinThisOrganizationSid = 54
     * }
     */
    public static int WinThisOrganizationSid() {
        return WinThisOrganizationSid;
    }
    private static final int WinOtherOrganizationSid = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinOtherOrganizationSid = 55
     * }
     */
    public static int WinOtherOrganizationSid() {
        return WinOtherOrganizationSid;
    }
    private static final int WinBuiltinIncomingForestTrustBuildersSid = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinIncomingForestTrustBuildersSid = 56
     * }
     */
    public static int WinBuiltinIncomingForestTrustBuildersSid() {
        return WinBuiltinIncomingForestTrustBuildersSid;
    }
    private static final int WinBuiltinPerfMonitoringUsersSid = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinPerfMonitoringUsersSid = 57
     * }
     */
    public static int WinBuiltinPerfMonitoringUsersSid() {
        return WinBuiltinPerfMonitoringUsersSid;
    }
    private static final int WinBuiltinPerfLoggingUsersSid = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinPerfLoggingUsersSid = 58
     * }
     */
    public static int WinBuiltinPerfLoggingUsersSid() {
        return WinBuiltinPerfLoggingUsersSid;
    }
    private static final int WinBuiltinAuthorizationAccessSid = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinAuthorizationAccessSid = 59
     * }
     */
    public static int WinBuiltinAuthorizationAccessSid() {
        return WinBuiltinAuthorizationAccessSid;
    }
    private static final int WinBuiltinTerminalServerLicenseServersSid = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinTerminalServerLicenseServersSid = 60
     * }
     */
    public static int WinBuiltinTerminalServerLicenseServersSid() {
        return WinBuiltinTerminalServerLicenseServersSid;
    }
    private static final int WinBuiltinDCOMUsersSid = (int)61L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinDCOMUsersSid = 61
     * }
     */
    public static int WinBuiltinDCOMUsersSid() {
        return WinBuiltinDCOMUsersSid;
    }
    private static final int WinBuiltinIUsersSid = (int)62L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinIUsersSid = 62
     * }
     */
    public static int WinBuiltinIUsersSid() {
        return WinBuiltinIUsersSid;
    }
    private static final int WinIUserSid = (int)63L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinIUserSid = 63
     * }
     */
    public static int WinIUserSid() {
        return WinIUserSid;
    }
    private static final int WinBuiltinCryptoOperatorsSid = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinCryptoOperatorsSid = 64
     * }
     */
    public static int WinBuiltinCryptoOperatorsSid() {
        return WinBuiltinCryptoOperatorsSid;
    }
    private static final int WinUntrustedLabelSid = (int)65L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinUntrustedLabelSid = 65
     * }
     */
    public static int WinUntrustedLabelSid() {
        return WinUntrustedLabelSid;
    }
    private static final int WinLowLabelSid = (int)66L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLowLabelSid = 66
     * }
     */
    public static int WinLowLabelSid() {
        return WinLowLabelSid;
    }
    private static final int WinMediumLabelSid = (int)67L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinMediumLabelSid = 67
     * }
     */
    public static int WinMediumLabelSid() {
        return WinMediumLabelSid;
    }
    private static final int WinHighLabelSid = (int)68L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinHighLabelSid = 68
     * }
     */
    public static int WinHighLabelSid() {
        return WinHighLabelSid;
    }
    private static final int WinSystemLabelSid = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinSystemLabelSid = 69
     * }
     */
    public static int WinSystemLabelSid() {
        return WinSystemLabelSid;
    }
    private static final int WinWriteRestrictedCodeSid = (int)70L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinWriteRestrictedCodeSid = 70
     * }
     */
    public static int WinWriteRestrictedCodeSid() {
        return WinWriteRestrictedCodeSid;
    }
    private static final int WinCreatorOwnerRightsSid = (int)71L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCreatorOwnerRightsSid = 71
     * }
     */
    public static int WinCreatorOwnerRightsSid() {
        return WinCreatorOwnerRightsSid;
    }
    private static final int WinCacheablePrincipalsGroupSid = (int)72L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCacheablePrincipalsGroupSid = 72
     * }
     */
    public static int WinCacheablePrincipalsGroupSid() {
        return WinCacheablePrincipalsGroupSid;
    }
    private static final int WinNonCacheablePrincipalsGroupSid = (int)73L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinNonCacheablePrincipalsGroupSid = 73
     * }
     */
    public static int WinNonCacheablePrincipalsGroupSid() {
        return WinNonCacheablePrincipalsGroupSid;
    }
    private static final int WinEnterpriseReadonlyControllersSid = (int)74L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinEnterpriseReadonlyControllersSid = 74
     * }
     */
    public static int WinEnterpriseReadonlyControllersSid() {
        return WinEnterpriseReadonlyControllersSid;
    }
    private static final int WinAccountReadonlyControllersSid = (int)75L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountReadonlyControllersSid = 75
     * }
     */
    public static int WinAccountReadonlyControllersSid() {
        return WinAccountReadonlyControllersSid;
    }
    private static final int WinBuiltinEventLogReadersGroup = (int)76L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinEventLogReadersGroup = 76
     * }
     */
    public static int WinBuiltinEventLogReadersGroup() {
        return WinBuiltinEventLogReadersGroup;
    }
    private static final int WinNewEnterpriseReadonlyControllersSid = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinNewEnterpriseReadonlyControllersSid = 77
     * }
     */
    public static int WinNewEnterpriseReadonlyControllersSid() {
        return WinNewEnterpriseReadonlyControllersSid;
    }
    private static final int WinBuiltinCertSvcDComAccessGroup = (int)78L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinCertSvcDComAccessGroup = 78
     * }
     */
    public static int WinBuiltinCertSvcDComAccessGroup() {
        return WinBuiltinCertSvcDComAccessGroup;
    }
    private static final int WinMediumPlusLabelSid = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinMediumPlusLabelSid = 79
     * }
     */
    public static int WinMediumPlusLabelSid() {
        return WinMediumPlusLabelSid;
    }
    private static final int WinLocalLogonSid = (int)80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLocalLogonSid = 80
     * }
     */
    public static int WinLocalLogonSid() {
        return WinLocalLogonSid;
    }
    private static final int WinConsoleLogonSid = (int)81L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinConsoleLogonSid = 81
     * }
     */
    public static int WinConsoleLogonSid() {
        return WinConsoleLogonSid;
    }
    private static final int WinThisOrganizationCertificateSid = (int)82L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinThisOrganizationCertificateSid = 82
     * }
     */
    public static int WinThisOrganizationCertificateSid() {
        return WinThisOrganizationCertificateSid;
    }
    private static final int WinApplicationPackageAuthoritySid = (int)83L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinApplicationPackageAuthoritySid = 83
     * }
     */
    public static int WinApplicationPackageAuthoritySid() {
        return WinApplicationPackageAuthoritySid;
    }
    private static final int WinBuiltinAnyPackageSid = (int)84L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinAnyPackageSid = 84
     * }
     */
    public static int WinBuiltinAnyPackageSid() {
        return WinBuiltinAnyPackageSid;
    }
    private static final int WinCapabilityInternetClientSid = (int)85L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityInternetClientSid = 85
     * }
     */
    public static int WinCapabilityInternetClientSid() {
        return WinCapabilityInternetClientSid;
    }
    private static final int WinCapabilityInternetClientServerSid = (int)86L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityInternetClientServerSid = 86
     * }
     */
    public static int WinCapabilityInternetClientServerSid() {
        return WinCapabilityInternetClientServerSid;
    }
    private static final int WinCapabilityPrivateNetworkClientServerSid = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityPrivateNetworkClientServerSid = 87
     * }
     */
    public static int WinCapabilityPrivateNetworkClientServerSid() {
        return WinCapabilityPrivateNetworkClientServerSid;
    }
    private static final int WinCapabilityPicturesLibrarySid = (int)88L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityPicturesLibrarySid = 88
     * }
     */
    public static int WinCapabilityPicturesLibrarySid() {
        return WinCapabilityPicturesLibrarySid;
    }
    private static final int WinCapabilityVideosLibrarySid = (int)89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityVideosLibrarySid = 89
     * }
     */
    public static int WinCapabilityVideosLibrarySid() {
        return WinCapabilityVideosLibrarySid;
    }
    private static final int WinCapabilityMusicLibrarySid = (int)90L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityMusicLibrarySid = 90
     * }
     */
    public static int WinCapabilityMusicLibrarySid() {
        return WinCapabilityMusicLibrarySid;
    }
    private static final int WinCapabilityDocumentsLibrarySid = (int)91L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityDocumentsLibrarySid = 91
     * }
     */
    public static int WinCapabilityDocumentsLibrarySid() {
        return WinCapabilityDocumentsLibrarySid;
    }
    private static final int WinCapabilitySharedUserCertificatesSid = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilitySharedUserCertificatesSid = 92
     * }
     */
    public static int WinCapabilitySharedUserCertificatesSid() {
        return WinCapabilitySharedUserCertificatesSid;
    }
    private static final int WinCapabilityEnterpriseAuthenticationSid = (int)93L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityEnterpriseAuthenticationSid = 93
     * }
     */
    public static int WinCapabilityEnterpriseAuthenticationSid() {
        return WinCapabilityEnterpriseAuthenticationSid;
    }
    private static final int WinCapabilityRemovableStorageSid = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityRemovableStorageSid = 94
     * }
     */
    public static int WinCapabilityRemovableStorageSid() {
        return WinCapabilityRemovableStorageSid;
    }
    private static final int WinBuiltinRDSRemoteAccessServersSid = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinRDSRemoteAccessServersSid = 95
     * }
     */
    public static int WinBuiltinRDSRemoteAccessServersSid() {
        return WinBuiltinRDSRemoteAccessServersSid;
    }
    private static final int WinBuiltinRDSEndpointServersSid = (int)96L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinRDSEndpointServersSid = 96
     * }
     */
    public static int WinBuiltinRDSEndpointServersSid() {
        return WinBuiltinRDSEndpointServersSid;
    }
    private static final int WinBuiltinRDSManagementServersSid = (int)97L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinRDSManagementServersSid = 97
     * }
     */
    public static int WinBuiltinRDSManagementServersSid() {
        return WinBuiltinRDSManagementServersSid;
    }
    private static final int WinUserModeDriversSid = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinUserModeDriversSid = 98
     * }
     */
    public static int WinUserModeDriversSid() {
        return WinUserModeDriversSid;
    }
    private static final int WinBuiltinHyperVAdminsSid = (int)99L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinHyperVAdminsSid = 99
     * }
     */
    public static int WinBuiltinHyperVAdminsSid() {
        return WinBuiltinHyperVAdminsSid;
    }
    private static final int WinAccountCloneableControllersSid = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountCloneableControllersSid = 100
     * }
     */
    public static int WinAccountCloneableControllersSid() {
        return WinAccountCloneableControllersSid;
    }
    private static final int WinBuiltinAccessControlAssistanceOperatorsSid = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinAccessControlAssistanceOperatorsSid = 101
     * }
     */
    public static int WinBuiltinAccessControlAssistanceOperatorsSid() {
        return WinBuiltinAccessControlAssistanceOperatorsSid;
    }
    private static final int WinBuiltinRemoteManagementUsersSid = (int)102L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinRemoteManagementUsersSid = 102
     * }
     */
    public static int WinBuiltinRemoteManagementUsersSid() {
        return WinBuiltinRemoteManagementUsersSid;
    }
    private static final int WinAuthenticationAuthorityAssertedSid = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAuthenticationAuthorityAssertedSid = 103
     * }
     */
    public static int WinAuthenticationAuthorityAssertedSid() {
        return WinAuthenticationAuthorityAssertedSid;
    }
    private static final int WinAuthenticationServiceAssertedSid = (int)104L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAuthenticationServiceAssertedSid = 104
     * }
     */
    public static int WinAuthenticationServiceAssertedSid() {
        return WinAuthenticationServiceAssertedSid;
    }
    private static final int WinLocalAccountSid = (int)105L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLocalAccountSid = 105
     * }
     */
    public static int WinLocalAccountSid() {
        return WinLocalAccountSid;
    }
    private static final int WinLocalAccountAndAdministratorSid = (int)106L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinLocalAccountAndAdministratorSid = 106
     * }
     */
    public static int WinLocalAccountAndAdministratorSid() {
        return WinLocalAccountAndAdministratorSid;
    }
    private static final int WinAccountProtectedUsersSid = (int)107L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountProtectedUsersSid = 107
     * }
     */
    public static int WinAccountProtectedUsersSid() {
        return WinAccountProtectedUsersSid;
    }
    private static final int WinCapabilityAppointmentsSid = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityAppointmentsSid = 108
     * }
     */
    public static int WinCapabilityAppointmentsSid() {
        return WinCapabilityAppointmentsSid;
    }
    private static final int WinCapabilityContactsSid = (int)109L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinCapabilityContactsSid = 109
     * }
     */
    public static int WinCapabilityContactsSid() {
        return WinCapabilityContactsSid;
    }
    private static final int WinAccountDefaultSystemManagedSid = (int)110L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountDefaultSystemManagedSid = 110
     * }
     */
    public static int WinAccountDefaultSystemManagedSid() {
        return WinAccountDefaultSystemManagedSid;
    }
    private static final int WinBuiltinDefaultSystemManagedGroupSid = (int)111L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinDefaultSystemManagedGroupSid = 111
     * }
     */
    public static int WinBuiltinDefaultSystemManagedGroupSid() {
        return WinBuiltinDefaultSystemManagedGroupSid;
    }
    private static final int WinBuiltinStorageReplicaAdminsSid = (int)112L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinStorageReplicaAdminsSid = 112
     * }
     */
    public static int WinBuiltinStorageReplicaAdminsSid() {
        return WinBuiltinStorageReplicaAdminsSid;
    }
    private static final int WinAccountKeyAdminsSid = (int)113L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountKeyAdminsSid = 113
     * }
     */
    public static int WinAccountKeyAdminsSid() {
        return WinAccountKeyAdminsSid;
    }
    private static final int WinAccountEnterpriseKeyAdminsSid = (int)114L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAccountEnterpriseKeyAdminsSid = 114
     * }
     */
    public static int WinAccountEnterpriseKeyAdminsSid() {
        return WinAccountEnterpriseKeyAdminsSid;
    }
    private static final int WinAuthenticationKeyTrustSid = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAuthenticationKeyTrustSid = 115
     * }
     */
    public static int WinAuthenticationKeyTrustSid() {
        return WinAuthenticationKeyTrustSid;
    }
    private static final int WinAuthenticationKeyPropertyMFASid = (int)116L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAuthenticationKeyPropertyMFASid = 116
     * }
     */
    public static int WinAuthenticationKeyPropertyMFASid() {
        return WinAuthenticationKeyPropertyMFASid;
    }
    private static final int WinAuthenticationKeyPropertyAttestationSid = (int)117L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAuthenticationKeyPropertyAttestationSid = 117
     * }
     */
    public static int WinAuthenticationKeyPropertyAttestationSid() {
        return WinAuthenticationKeyPropertyAttestationSid;
    }
    private static final int WinAuthenticationFreshKeyAuthSid = (int)118L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinAuthenticationFreshKeyAuthSid = 118
     * }
     */
    public static int WinAuthenticationFreshKeyAuthSid() {
        return WinAuthenticationFreshKeyAuthSid;
    }
    private static final int WinBuiltinDeviceOwnersSid = (int)119L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WinBuiltinDeviceOwnersSid = 119
     * }
     */
    public static int WinBuiltinDeviceOwnersSid() {
        return WinBuiltinDeviceOwnersSid;
    }
    /**
     * {@snippet lang=c :
     * typedef ACL *PACL
     * }
     */
    public static final AddressLayout PACL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ACE_HEADER *PACE_HEADER
     * }
     */
    public static final AddressLayout PACE_HEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE
     * }
     */
    public static final AddressLayout PACCESS_ALLOWED_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE
     * }
     */
    public static final AddressLayout PACCESS_DENIED_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_AUDIT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_ALARM_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PSYSTEM_RESOURCE_ATTRIBUTE_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_RESOURCE_ATTRIBUTE_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PSYSTEM_SCOPED_POLICY_ID_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_SCOPED_POLICY_ID_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PSYSTEM_MANDATORY_LABEL_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_MANDATORY_LABEL_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PSYSTEM_PROCESS_TRUST_LABEL_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_PROCESS_TRUST_LABEL_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_ACCESS_FILTER_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PSYSTEM_ACCESS_FILTER_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_ACCESS_FILTER_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PACCESS_ALLOWED_OBJECT_ACE
     * }
     */
    public static final AddressLayout PACCESS_ALLOWED_OBJECT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACCESS_DENIED_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PACCESS_DENIED_OBJECT_ACE
     * }
     */
    public static final AddressLayout PACCESS_DENIED_OBJECT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PSYSTEM_AUDIT_OBJECT_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_AUDIT_OBJECT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_ALARM_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PSYSTEM_ALARM_OBJECT_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_ALARM_OBJECT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PACCESS_ALLOWED_CALLBACK_ACE
     * }
     */
    public static final AddressLayout PACCESS_ALLOWED_CALLBACK_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACCESS_DENIED_CALLBACK_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PACCESS_DENIED_CALLBACK_ACE
     * }
     */
    public static final AddressLayout PACCESS_DENIED_CALLBACK_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PSYSTEM_AUDIT_CALLBACK_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_AUDIT_CALLBACK_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD SidStart;
     * } *PSYSTEM_ALARM_CALLBACK_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_ALARM_CALLBACK_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE
     * }
     */
    public static final AddressLayout PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PACCESS_DENIED_CALLBACK_OBJECT_ACE
     * }
     */
    public static final AddressLayout PACCESS_DENIED_CALLBACK_OBJECT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
     *     ACE_HEADER Header;
     *     ACCESS_MASK Mask;
     *     DWORD Flags;
     *     GUID ObjectType;
     *     GUID InheritedObjectType;
     *     DWORD SidStart;
     * } *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE
     * }
     */
    public static final AddressLayout PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = freeglut_h.C_POINTER;
    private static final int AclRevisionInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _ACL_INFORMATION_CLASS.AclRevisionInformation = 1
     * }
     */
    public static int AclRevisionInformation() {
        return AclRevisionInformation;
    }
    private static final int AclSizeInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _ACL_INFORMATION_CLASS.AclSizeInformation = 2
     * }
     */
    public static int AclSizeInformation() {
        return AclSizeInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION
     * }
     */
    public static final AddressLayout PACL_REVISION_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION
     * }
     */
    public static final AddressLayout PACL_SIZE_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD SECURITY_DESCRIPTOR_CONTROL
     * }
     */
    public static final OfShort SECURITY_DESCRIPTOR_CONTROL = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef WORD *PSECURITY_DESCRIPTOR_CONTROL
     * }
     */
    public static final AddressLayout PSECURITY_DESCRIPTOR_CONTROL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
     *     BYTE Revision;
     *     BYTE Sbz1;
     *     SECURITY_DESCRIPTOR_CONTROL Control;
     *     DWORD Owner;
     *     DWORD Group;
     *     DWORD Sacl;
     *     DWORD Dacl;
     * } *PISECURITY_DESCRIPTOR_RELATIVE
     * }
     */
    public static final AddressLayout PISECURITY_DESCRIPTOR_RELATIVE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_DESCRIPTOR {
     *     BYTE Revision;
     *     BYTE Sbz1;
     *     SECURITY_DESCRIPTOR_CONTROL Control;
     *     PSID Owner;
     *     PSID Group;
     *     PACL Sacl;
     *     PACL Dacl;
     * } *PISECURITY_DESCRIPTOR
     * }
     */
    public static final AddressLayout PISECURITY_DESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_OBJECT_AI_PARAMS {
     *     DWORD Size;
     *     DWORD ConstraintMask;
     * } *PSECURITY_OBJECT_AI_PARAMS
     * }
     */
    public static final AddressLayout PSECURITY_OBJECT_AI_PARAMS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OBJECT_TYPE_LIST {
     *     WORD Level;
     *     WORD Sbz;
     *     GUID *ObjectType;
     * } *POBJECT_TYPE_LIST
     * }
     */
    public static final AddressLayout POBJECT_TYPE_LIST = freeglut_h.C_POINTER;
    private static final int AuditEventObjectAccess = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _AUDIT_EVENT_TYPE.AuditEventObjectAccess = 0
     * }
     */
    public static int AuditEventObjectAccess() {
        return AuditEventObjectAccess;
    }
    private static final int AuditEventDirectoryServiceAccess = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _AUDIT_EVENT_TYPE.AuditEventDirectoryServiceAccess = 1
     * }
     */
    public static int AuditEventDirectoryServiceAccess() {
        return AuditEventDirectoryServiceAccess;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _AUDIT_EVENT_TYPE {
     *     AuditEventObjectAccess,
     *     AuditEventDirectoryServiceAccess
     * } *PAUDIT_EVENT_TYPE
     * }
     */
    public static final AddressLayout PAUDIT_EVENT_TYPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PRIVILEGE_SET {
     *     DWORD PrivilegeCount;
     *     DWORD Control;
     *     LUID_AND_ATTRIBUTES Privilege[1];
     * } *PPRIVILEGE_SET
     * }
     */
    public static final AddressLayout PPRIVILEGE_SET = freeglut_h.C_POINTER;
    private static final int AccessReasonNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonNone = 0
     * }
     */
    public static int AccessReasonNone() {
        return AccessReasonNone;
    }
    private static final int AccessReasonAllowedAce = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonAllowedAce = 65536
     * }
     */
    public static int AccessReasonAllowedAce() {
        return AccessReasonAllowedAce;
    }
    private static final int AccessReasonDeniedAce = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonDeniedAce = 131072
     * }
     */
    public static int AccessReasonDeniedAce() {
        return AccessReasonDeniedAce;
    }
    private static final int AccessReasonAllowedParentAce = (int)196608L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonAllowedParentAce = 196608
     * }
     */
    public static int AccessReasonAllowedParentAce() {
        return AccessReasonAllowedParentAce;
    }
    private static final int AccessReasonDeniedParentAce = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonDeniedParentAce = 262144
     * }
     */
    public static int AccessReasonDeniedParentAce() {
        return AccessReasonDeniedParentAce;
    }
    private static final int AccessReasonNotGrantedByCape = (int)327680L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonNotGrantedByCape = 327680
     * }
     */
    public static int AccessReasonNotGrantedByCape() {
        return AccessReasonNotGrantedByCape;
    }
    private static final int AccessReasonNotGrantedByParentCape = (int)393216L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonNotGrantedByParentCape = 393216
     * }
     */
    public static int AccessReasonNotGrantedByParentCape() {
        return AccessReasonNotGrantedByParentCape;
    }
    private static final int AccessReasonNotGrantedToAppContainer = (int)458752L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonNotGrantedToAppContainer = 458752
     * }
     */
    public static int AccessReasonNotGrantedToAppContainer() {
        return AccessReasonNotGrantedToAppContainer;
    }
    private static final int AccessReasonMissingPrivilege = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonMissingPrivilege = 1048576
     * }
     */
    public static int AccessReasonMissingPrivilege() {
        return AccessReasonMissingPrivilege;
    }
    private static final int AccessReasonFromPrivilege = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonFromPrivilege = 2097152
     * }
     */
    public static int AccessReasonFromPrivilege() {
        return AccessReasonFromPrivilege;
    }
    private static final int AccessReasonIntegrityLevel = (int)3145728L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonIntegrityLevel = 3145728
     * }
     */
    public static int AccessReasonIntegrityLevel() {
        return AccessReasonIntegrityLevel;
    }
    private static final int AccessReasonOwnership = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonOwnership = 4194304
     * }
     */
    public static int AccessReasonOwnership() {
        return AccessReasonOwnership;
    }
    private static final int AccessReasonNullDacl = (int)5242880L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonNullDacl = 5242880
     * }
     */
    public static int AccessReasonNullDacl() {
        return AccessReasonNullDacl;
    }
    private static final int AccessReasonEmptyDacl = (int)6291456L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonEmptyDacl = 6291456
     * }
     */
    public static int AccessReasonEmptyDacl() {
        return AccessReasonEmptyDacl;
    }
    private static final int AccessReasonNoSD = (int)7340032L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonNoSD = 7340032
     * }
     */
    public static int AccessReasonNoSD() {
        return AccessReasonNoSD;
    }
    private static final int AccessReasonNoGrant = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonNoGrant = 8388608
     * }
     */
    public static int AccessReasonNoGrant() {
        return AccessReasonNoGrant;
    }
    private static final int AccessReasonTrustLabel = (int)9437184L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonTrustLabel = 9437184
     * }
     */
    public static int AccessReasonTrustLabel() {
        return AccessReasonTrustLabel;
    }
    private static final int AccessReasonFilterAce = (int)10485760L;
    /**
     * {@snippet lang=c :
     * enum _ACCESS_REASON_TYPE.AccessReasonFilterAce = 10485760
     * }
     */
    public static int AccessReasonFilterAce() {
        return AccessReasonFilterAce;
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD ACCESS_REASON
     * }
     */
    public static final OfInt ACCESS_REASON = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _ACCESS_REASONS {
     *     ACCESS_REASON Data[32];
     * } *PACCESS_REASONS
     * }
     */
    public static final AddressLayout PACCESS_REASONS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SE_SECURITY_DESCRIPTOR {
     *     DWORD Size;
     *     DWORD Flags;
     *     PSECURITY_DESCRIPTOR SecurityDescriptor;
     * } *PSE_SECURITY_DESCRIPTOR
     * }
     */
    public static final AddressLayout PSE_SECURITY_DESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SE_ACCESS_REQUEST {
     *     DWORD Size;
     *     PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
     *     ACCESS_MASK DesiredAccess;
     *     ACCESS_MASK PreviouslyGrantedAccess;
     *     PSID PrincipalSelfSid;
     *     PGENERIC_MAPPING GenericMapping;
     *     DWORD ObjectTypeListCount;
     *     POBJECT_TYPE_LIST ObjectTypeList;
     * } *PSE_ACCESS_REQUEST
     * }
     */
    public static final AddressLayout PSE_ACCESS_REQUEST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SE_ACCESS_REPLY {
     *     DWORD Size;
     *     DWORD ResultListCount;
     *     PACCESS_MASK GrantedAccess;
     *     PDWORD AccessStatus;
     *     PACCESS_REASONS AccessReason;
     *     PPRIVILEGE_SET *Privileges;
     * } *PSE_ACCESS_REPLY
     * }
     */
    public static final AddressLayout PSE_ACCESS_REPLY = freeglut_h.C_POINTER;
    private static final int SecurityAnonymous = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous = 0
     * }
     */
    public static int SecurityAnonymous() {
        return SecurityAnonymous;
    }
    private static final int SecurityIdentification = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SECURITY_IMPERSONATION_LEVEL.SecurityIdentification = 1
     * }
     */
    public static int SecurityIdentification() {
        return SecurityIdentification;
    }
    private static final int SecurityImpersonation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation = 2
     * }
     */
    public static int SecurityImpersonation() {
        return SecurityImpersonation;
    }
    private static final int SecurityDelegation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SECURITY_IMPERSONATION_LEVEL.SecurityDelegation = 3
     * }
     */
    public static int SecurityDelegation() {
        return SecurityDelegation;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _SECURITY_IMPERSONATION_LEVEL {
     *     SecurityAnonymous,
     *     SecurityIdentification,
     *     SecurityImpersonation,
     *     SecurityDelegation
     * } *PSECURITY_IMPERSONATION_LEVEL
     * }
     */
    public static final AddressLayout PSECURITY_IMPERSONATION_LEVEL = freeglut_h.C_POINTER;
    private static final int TokenPrimary = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_TYPE.TokenPrimary = 1
     * }
     */
    public static int TokenPrimary() {
        return TokenPrimary;
    }
    private static final int TokenImpersonation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_TYPE.TokenImpersonation = 2
     * }
     */
    public static int TokenImpersonation() {
        return TokenImpersonation;
    }
    /**
     * {@snippet lang=c :
     * typedef TOKEN_TYPE *PTOKEN_TYPE
     * }
     */
    public static final AddressLayout PTOKEN_TYPE = freeglut_h.C_POINTER;
    private static final int TokenElevationTypeDefault = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_ELEVATION_TYPE.TokenElevationTypeDefault = 1
     * }
     */
    public static int TokenElevationTypeDefault() {
        return TokenElevationTypeDefault;
    }
    private static final int TokenElevationTypeFull = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_ELEVATION_TYPE.TokenElevationTypeFull = 2
     * }
     */
    public static int TokenElevationTypeFull() {
        return TokenElevationTypeFull;
    }
    private static final int TokenElevationTypeLimited = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_ELEVATION_TYPE.TokenElevationTypeLimited = 3
     * }
     */
    public static int TokenElevationTypeLimited() {
        return TokenElevationTypeLimited;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _TOKEN_ELEVATION_TYPE {
     *     TokenElevationTypeDefault = 1,
     *     TokenElevationTypeFull,
     *     TokenElevationTypeLimited
     * } *PTOKEN_ELEVATION_TYPE
     * }
     */
    public static final AddressLayout PTOKEN_ELEVATION_TYPE = freeglut_h.C_POINTER;
    private static final int TokenUser = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenUser = 1
     * }
     */
    public static int TokenUser() {
        return TokenUser;
    }
    private static final int TokenGroups = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenGroups = 2
     * }
     */
    public static int TokenGroups() {
        return TokenGroups;
    }
    private static final int TokenPrivileges = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenPrivileges = 3
     * }
     */
    public static int TokenPrivileges() {
        return TokenPrivileges;
    }
    private static final int TokenOwner = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenOwner = 4
     * }
     */
    public static int TokenOwner() {
        return TokenOwner;
    }
    private static final int TokenPrimaryGroup = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenPrimaryGroup = 5
     * }
     */
    public static int TokenPrimaryGroup() {
        return TokenPrimaryGroup;
    }
    private static final int TokenDefaultDacl = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenDefaultDacl = 6
     * }
     */
    public static int TokenDefaultDacl() {
        return TokenDefaultDacl;
    }
    private static final int TokenSource = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenSource = 7
     * }
     */
    public static int TokenSource() {
        return TokenSource;
    }
    private static final int TokenType = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenType = 8
     * }
     */
    public static int TokenType() {
        return TokenType;
    }
    private static final int TokenImpersonationLevel = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenImpersonationLevel = 9
     * }
     */
    public static int TokenImpersonationLevel() {
        return TokenImpersonationLevel;
    }
    private static final int TokenStatistics = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenStatistics = 10
     * }
     */
    public static int TokenStatistics() {
        return TokenStatistics;
    }
    private static final int TokenRestrictedSids = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenRestrictedSids = 11
     * }
     */
    public static int TokenRestrictedSids() {
        return TokenRestrictedSids;
    }
    private static final int TokenSessionId = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenSessionId = 12
     * }
     */
    public static int TokenSessionId() {
        return TokenSessionId;
    }
    private static final int TokenGroupsAndPrivileges = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenGroupsAndPrivileges = 13
     * }
     */
    public static int TokenGroupsAndPrivileges() {
        return TokenGroupsAndPrivileges;
    }
    private static final int TokenSessionReference = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenSessionReference = 14
     * }
     */
    public static int TokenSessionReference() {
        return TokenSessionReference;
    }
    private static final int TokenSandBoxInert = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenSandBoxInert = 15
     * }
     */
    public static int TokenSandBoxInert() {
        return TokenSandBoxInert;
    }
    private static final int TokenAuditPolicy = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenAuditPolicy = 16
     * }
     */
    public static int TokenAuditPolicy() {
        return TokenAuditPolicy;
    }
    private static final int TokenOrigin = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenOrigin = 17
     * }
     */
    public static int TokenOrigin() {
        return TokenOrigin;
    }
    private static final int TokenElevationType = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenElevationType = 18
     * }
     */
    public static int TokenElevationType() {
        return TokenElevationType;
    }
    private static final int TokenLinkedToken = (int)19L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenLinkedToken = 19
     * }
     */
    public static int TokenLinkedToken() {
        return TokenLinkedToken;
    }
    private static final int TokenElevation = (int)20L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenElevation = 20
     * }
     */
    public static int TokenElevation() {
        return TokenElevation;
    }
    private static final int TokenHasRestrictions = (int)21L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenHasRestrictions = 21
     * }
     */
    public static int TokenHasRestrictions() {
        return TokenHasRestrictions;
    }
    private static final int TokenAccessInformation = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenAccessInformation = 22
     * }
     */
    public static int TokenAccessInformation() {
        return TokenAccessInformation;
    }
    private static final int TokenVirtualizationAllowed = (int)23L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenVirtualizationAllowed = 23
     * }
     */
    public static int TokenVirtualizationAllowed() {
        return TokenVirtualizationAllowed;
    }
    private static final int TokenVirtualizationEnabled = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenVirtualizationEnabled = 24
     * }
     */
    public static int TokenVirtualizationEnabled() {
        return TokenVirtualizationEnabled;
    }
    private static final int TokenIntegrityLevel = (int)25L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenIntegrityLevel = 25
     * }
     */
    public static int TokenIntegrityLevel() {
        return TokenIntegrityLevel;
    }
    private static final int TokenUIAccess = (int)26L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenUIAccess = 26
     * }
     */
    public static int TokenUIAccess() {
        return TokenUIAccess;
    }
    private static final int TokenMandatoryPolicy = (int)27L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenMandatoryPolicy = 27
     * }
     */
    public static int TokenMandatoryPolicy() {
        return TokenMandatoryPolicy;
    }
    private static final int TokenLogonSid = (int)28L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenLogonSid = 28
     * }
     */
    public static int TokenLogonSid() {
        return TokenLogonSid;
    }
    private static final int TokenIsAppContainer = (int)29L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenIsAppContainer = 29
     * }
     */
    public static int TokenIsAppContainer() {
        return TokenIsAppContainer;
    }
    private static final int TokenCapabilities = (int)30L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenCapabilities = 30
     * }
     */
    public static int TokenCapabilities() {
        return TokenCapabilities;
    }
    private static final int TokenAppContainerSid = (int)31L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenAppContainerSid = 31
     * }
     */
    public static int TokenAppContainerSid() {
        return TokenAppContainerSid;
    }
    private static final int TokenAppContainerNumber = (int)32L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenAppContainerNumber = 32
     * }
     */
    public static int TokenAppContainerNumber() {
        return TokenAppContainerNumber;
    }
    private static final int TokenUserClaimAttributes = (int)33L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenUserClaimAttributes = 33
     * }
     */
    public static int TokenUserClaimAttributes() {
        return TokenUserClaimAttributes;
    }
    private static final int TokenDeviceClaimAttributes = (int)34L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenDeviceClaimAttributes = 34
     * }
     */
    public static int TokenDeviceClaimAttributes() {
        return TokenDeviceClaimAttributes;
    }
    private static final int TokenRestrictedUserClaimAttributes = (int)35L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenRestrictedUserClaimAttributes = 35
     * }
     */
    public static int TokenRestrictedUserClaimAttributes() {
        return TokenRestrictedUserClaimAttributes;
    }
    private static final int TokenRestrictedDeviceClaimAttributes = (int)36L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceClaimAttributes = 36
     * }
     */
    public static int TokenRestrictedDeviceClaimAttributes() {
        return TokenRestrictedDeviceClaimAttributes;
    }
    private static final int TokenDeviceGroups = (int)37L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenDeviceGroups = 37
     * }
     */
    public static int TokenDeviceGroups() {
        return TokenDeviceGroups;
    }
    private static final int TokenRestrictedDeviceGroups = (int)38L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceGroups = 38
     * }
     */
    public static int TokenRestrictedDeviceGroups() {
        return TokenRestrictedDeviceGroups;
    }
    private static final int TokenSecurityAttributes = (int)39L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenSecurityAttributes = 39
     * }
     */
    public static int TokenSecurityAttributes() {
        return TokenSecurityAttributes;
    }
    private static final int TokenIsRestricted = (int)40L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenIsRestricted = 40
     * }
     */
    public static int TokenIsRestricted() {
        return TokenIsRestricted;
    }
    private static final int TokenProcessTrustLevel = (int)41L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenProcessTrustLevel = 41
     * }
     */
    public static int TokenProcessTrustLevel() {
        return TokenProcessTrustLevel;
    }
    private static final int TokenPrivateNameSpace = (int)42L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenPrivateNameSpace = 42
     * }
     */
    public static int TokenPrivateNameSpace() {
        return TokenPrivateNameSpace;
    }
    private static final int TokenSingletonAttributes = (int)43L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenSingletonAttributes = 43
     * }
     */
    public static int TokenSingletonAttributes() {
        return TokenSingletonAttributes;
    }
    private static final int TokenBnoIsolation = (int)44L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenBnoIsolation = 44
     * }
     */
    public static int TokenBnoIsolation() {
        return TokenBnoIsolation;
    }
    private static final int TokenChildProcessFlags = (int)45L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenChildProcessFlags = 45
     * }
     */
    public static int TokenChildProcessFlags() {
        return TokenChildProcessFlags;
    }
    private static final int TokenIsLessPrivilegedAppContainer = (int)46L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenIsLessPrivilegedAppContainer = 46
     * }
     */
    public static int TokenIsLessPrivilegedAppContainer() {
        return TokenIsLessPrivilegedAppContainer;
    }
    private static final int TokenIsSandboxed = (int)47L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenIsSandboxed = 47
     * }
     */
    public static int TokenIsSandboxed() {
        return TokenIsSandboxed;
    }
    private static final int TokenOriginatingProcessTrustLevel = (int)48L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.TokenOriginatingProcessTrustLevel = 48
     * }
     */
    public static int TokenOriginatingProcessTrustLevel() {
        return TokenOriginatingProcessTrustLevel;
    }
    private static final int MaxTokenInfoClass = (int)49L;
    /**
     * {@snippet lang=c :
     * enum _TOKEN_INFORMATION_CLASS.MaxTokenInfoClass = 49
     * }
     */
    public static int MaxTokenInfoClass() {
        return MaxTokenInfoClass;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _TOKEN_INFORMATION_CLASS {
     *     TokenUser = 1,
     *     TokenGroups,
     *     TokenPrivileges,
     *     TokenOwner,
     *     TokenPrimaryGroup,
     *     TokenDefaultDacl,
     *     TokenSource,
     *     TokenType,
     *     TokenImpersonationLevel,
     *     TokenStatistics,
     *     TokenRestrictedSids,
     *     TokenSessionId,
     *     TokenGroupsAndPrivileges,
     *     TokenSessionReference,
     *     TokenSandBoxInert,
     *     TokenAuditPolicy,
     *     TokenOrigin,
     *     TokenElevationType,
     *     TokenLinkedToken,
     *     TokenElevation,
     *     TokenHasRestrictions,
     *     TokenAccessInformation,
     *     TokenVirtualizationAllowed,
     *     TokenVirtualizationEnabled,
     *     TokenIntegrityLevel,
     *     TokenUIAccess,
     *     TokenMandatoryPolicy,
     *     TokenLogonSid,
     *     TokenIsAppContainer,
     *     TokenCapabilities,
     *     TokenAppContainerSid,
     *     TokenAppContainerNumber,
     *     TokenUserClaimAttributes,
     *     TokenDeviceClaimAttributes,
     *     TokenRestrictedUserClaimAttributes,
     *     TokenRestrictedDeviceClaimAttributes,
     *     TokenDeviceGroups,
     *     TokenRestrictedDeviceGroups,
     *     TokenSecurityAttributes,
     *     TokenIsRestricted,
     *     TokenProcessTrustLevel,
     *     TokenPrivateNameSpace,
     *     TokenSingletonAttributes,
     *     TokenBnoIsolation,
     *     TokenChildProcessFlags,
     *     TokenIsLessPrivilegedAppContainer,
     *     TokenIsSandboxed,
     *     TokenOriginatingProcessTrustLevel,
     *     MaxTokenInfoClass
     * } *PTOKEN_INFORMATION_CLASS
     * }
     */
    public static final AddressLayout PTOKEN_INFORMATION_CLASS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_USER {
     *     SID_AND_ATTRIBUTES User;
     * } *PTOKEN_USER
     * }
     */
    public static final AddressLayout PTOKEN_USER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_GROUPS {
     *     DWORD GroupCount;
     *     SID_AND_ATTRIBUTES Groups[1];
     * } *PTOKEN_GROUPS
     * }
     */
    public static final AddressLayout PTOKEN_GROUPS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_PRIVILEGES {
     *     DWORD PrivilegeCount;
     *     LUID_AND_ATTRIBUTES Privileges[1];
     * } *PTOKEN_PRIVILEGES
     * }
     */
    public static final AddressLayout PTOKEN_PRIVILEGES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_OWNER {
     *     PSID Owner;
     * } *PTOKEN_OWNER
     * }
     */
    public static final AddressLayout PTOKEN_OWNER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_PRIMARY_GROUP {
     *     PSID PrimaryGroup;
     * } *PTOKEN_PRIMARY_GROUP
     * }
     */
    public static final AddressLayout PTOKEN_PRIMARY_GROUP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_DEFAULT_DACL {
     *     PACL DefaultDacl;
     * } *PTOKEN_DEFAULT_DACL
     * }
     */
    public static final AddressLayout PTOKEN_DEFAULT_DACL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_USER_CLAIMS {
     *     PCLAIMS_BLOB UserClaims;
     * } *PTOKEN_USER_CLAIMS
     * }
     */
    public static final AddressLayout PTOKEN_USER_CLAIMS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_DEVICE_CLAIMS {
     *     PCLAIMS_BLOB DeviceClaims;
     * } *PTOKEN_DEVICE_CLAIMS
     * }
     */
    public static final AddressLayout PTOKEN_DEVICE_CLAIMS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
     *     DWORD SidCount;
     *     DWORD SidLength;
     *     PSID_AND_ATTRIBUTES Sids;
     *     DWORD RestrictedSidCount;
     *     DWORD RestrictedSidLength;
     *     PSID_AND_ATTRIBUTES RestrictedSids;
     *     DWORD PrivilegeCount;
     *     DWORD PrivilegeLength;
     *     PLUID_AND_ATTRIBUTES Privileges;
     *     LUID AuthenticationId;
     * } *PTOKEN_GROUPS_AND_PRIVILEGES
     * }
     */
    public static final AddressLayout PTOKEN_GROUPS_AND_PRIVILEGES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_LINKED_TOKEN {
     *     HANDLE LinkedToken;
     * } *PTOKEN_LINKED_TOKEN
     * }
     */
    public static final AddressLayout PTOKEN_LINKED_TOKEN = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_ELEVATION {
     *     DWORD TokenIsElevated;
     * } *PTOKEN_ELEVATION
     * }
     */
    public static final AddressLayout PTOKEN_ELEVATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_MANDATORY_LABEL {
     *     SID_AND_ATTRIBUTES Label;
     * } *PTOKEN_MANDATORY_LABEL
     * }
     */
    public static final AddressLayout PTOKEN_MANDATORY_LABEL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_MANDATORY_POLICY {
     *     DWORD Policy;
     * } *PTOKEN_MANDATORY_POLICY
     * }
     */
    public static final AddressLayout PTOKEN_MANDATORY_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID PSECURITY_ATTRIBUTES_OPAQUE
     * }
     */
    public static final AddressLayout PSECURITY_ATTRIBUTES_OPAQUE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_ACCESS_INFORMATION {
     *     PSID_AND_ATTRIBUTES_HASH SidHash;
     *     PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
     *     PTOKEN_PRIVILEGES Privileges;
     *     LUID AuthenticationId;
     *     TOKEN_TYPE TokenType;
     *     SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
     *     TOKEN_MANDATORY_POLICY MandatoryPolicy;
     *     DWORD Flags;
     *     DWORD AppContainerNumber;
     *     PSID PackageSid;
     *     PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
     *     PSID TrustLevelSid;
     *     PSECURITY_ATTRIBUTES_OPAQUE SecurityAttributes;
     * } *PTOKEN_ACCESS_INFORMATION
     * }
     */
    public static final AddressLayout PTOKEN_ACCESS_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_AUDIT_POLICY {
     *     BYTE PerUserPolicy[30];
     * } *PTOKEN_AUDIT_POLICY
     * }
     */
    public static final AddressLayout PTOKEN_AUDIT_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_SOURCE {
     *     CHAR SourceName[8];
     *     LUID SourceIdentifier;
     * } *PTOKEN_SOURCE
     * }
     */
    public static final AddressLayout PTOKEN_SOURCE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_STATISTICS {
     *     LUID TokenId;
     *     LUID AuthenticationId;
     *     LARGE_INTEGER ExpirationTime;
     *     TOKEN_TYPE TokenType;
     *     SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
     *     DWORD DynamicCharged;
     *     DWORD DynamicAvailable;
     *     DWORD GroupCount;
     *     DWORD PrivilegeCount;
     *     LUID ModifiedId;
     * } *PTOKEN_STATISTICS
     * }
     */
    public static final AddressLayout PTOKEN_STATISTICS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_CONTROL {
     *     LUID TokenId;
     *     LUID AuthenticationId;
     *     LUID ModifiedId;
     *     TOKEN_SOURCE TokenSource;
     * } *PTOKEN_CONTROL
     * }
     */
    public static final AddressLayout PTOKEN_CONTROL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_ORIGIN {
     *     LUID OriginatingLogonSession;
     * } *PTOKEN_ORIGIN
     * }
     */
    public static final AddressLayout PTOKEN_ORIGIN = freeglut_h.C_POINTER;
    private static final int MandatoryLevelUntrusted = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _MANDATORY_LEVEL.MandatoryLevelUntrusted = 0
     * }
     */
    public static int MandatoryLevelUntrusted() {
        return MandatoryLevelUntrusted;
    }
    private static final int MandatoryLevelLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _MANDATORY_LEVEL.MandatoryLevelLow = 1
     * }
     */
    public static int MandatoryLevelLow() {
        return MandatoryLevelLow;
    }
    private static final int MandatoryLevelMedium = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _MANDATORY_LEVEL.MandatoryLevelMedium = 2
     * }
     */
    public static int MandatoryLevelMedium() {
        return MandatoryLevelMedium;
    }
    private static final int MandatoryLevelHigh = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _MANDATORY_LEVEL.MandatoryLevelHigh = 3
     * }
     */
    public static int MandatoryLevelHigh() {
        return MandatoryLevelHigh;
    }
    private static final int MandatoryLevelSystem = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _MANDATORY_LEVEL.MandatoryLevelSystem = 4
     * }
     */
    public static int MandatoryLevelSystem() {
        return MandatoryLevelSystem;
    }
    private static final int MandatoryLevelSecureProcess = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _MANDATORY_LEVEL.MandatoryLevelSecureProcess = 5
     * }
     */
    public static int MandatoryLevelSecureProcess() {
        return MandatoryLevelSecureProcess;
    }
    private static final int MandatoryLevelCount = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _MANDATORY_LEVEL.MandatoryLevelCount = 6
     * }
     */
    public static int MandatoryLevelCount() {
        return MandatoryLevelCount;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _MANDATORY_LEVEL {
     *     MandatoryLevelUntrusted = 0,
     *     MandatoryLevelLow,
     *     MandatoryLevelMedium,
     *     MandatoryLevelHigh,
     *     MandatoryLevelSystem,
     *     MandatoryLevelSecureProcess,
     *     MandatoryLevelCount
     * } *PMANDATORY_LEVEL
     * }
     */
    public static final AddressLayout PMANDATORY_LEVEL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_APPCONTAINER_INFORMATION {
     *     PSID TokenAppContainer;
     * } *PTOKEN_APPCONTAINER_INFORMATION
     * }
     */
    public static final AddressLayout PTOKEN_APPCONTAINER_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_SID_INFORMATION {
     *     PSID Sid;
     * } *PTOKEN_SID_INFORMATION
     * }
     */
    public static final AddressLayout PTOKEN_SID_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TOKEN_BNO_ISOLATION_INFORMATION {
     *     PWSTR IsolationPrefix;
     *     BOOLEAN IsolationEnabled;
     * } *PTOKEN_BNO_ISOLATION_INFORMATION
     * }
     */
    public static final AddressLayout PTOKEN_BNO_ISOLATION_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
     *     DWORD64 Version;
     *     PWSTR Name;
     * } *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE
     * }
     */
    public static final AddressLayout PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
     *     PVOID pValue;
     *     DWORD ValueLength;
     * } *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
     * }
     */
    public static final AddressLayout PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
     *     PWSTR Name;
     *     WORD ValueType;
     *     WORD Reserved;
     *     DWORD Flags;
     *     DWORD ValueCount;
     *     union {
     *         PLONG64 pInt64;
     *         PDWORD64 pUint64;
     *         PWSTR *ppString;
     *         PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
     *         PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
     *     } Values;
     * } *PCLAIM_SECURITY_ATTRIBUTE_V1
     * }
     */
    public static final AddressLayout PCLAIM_SECURITY_ATTRIBUTE_V1 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
     *     DWORD Name;
     *     WORD ValueType;
     *     WORD Reserved;
     *     DWORD Flags;
     *     DWORD ValueCount;
     *     union {
     *         DWORD pInt64[1];
     *         DWORD pUint64[1];
     *         DWORD ppString[1];
     *         DWORD pFqbn[1];
     *         DWORD pOctetString[1];
     *     } Values;
     * } *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1
     * }
     */
    public static final AddressLayout PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
     *     WORD Version;
     *     WORD Reserved;
     *     DWORD AttributeCount;
     *     union {
     *         PCLAIM_SECURITY_ATTRIBUTE_V1 pAttributeV1;
     *     } Attribute;
     * } *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION
     * }
     */
    public static final AddressLayout PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE
     * }
     */
    public static final OfByte SECURITY_CONTEXT_TRACKING_MODE = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN *PSECURITY_CONTEXT_TRACKING_MODE
     * }
     */
    public static final AddressLayout PSECURITY_CONTEXT_TRACKING_MODE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_QUALITY_OF_SERVICE {
     *     DWORD Length;
     *     SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
     *     SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
     *     BOOLEAN EffectiveOnly;
     * } *PSECURITY_QUALITY_OF_SERVICE
     * }
     */
    public static final AddressLayout PSECURITY_QUALITY_OF_SERVICE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SE_IMPERSONATION_STATE {
     *     PACCESS_TOKEN Token;
     *     BOOLEAN CopyOnOpen;
     *     BOOLEAN EffectiveOnly;
     *     SECURITY_IMPERSONATION_LEVEL Level;
     * } *PSE_IMPERSONATION_STATE
     * }
     */
    public static final AddressLayout PSE_IMPERSONATION_STATE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD SECURITY_INFORMATION
     * }
     */
    public static final OfInt SECURITY_INFORMATION = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD *PSECURITY_INFORMATION
     * }
     */
    public static final AddressLayout PSECURITY_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BYTE SE_SIGNING_LEVEL
     * }
     */
    public static final OfByte SE_SIGNING_LEVEL = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef BYTE *PSE_SIGNING_LEVEL
     * }
     */
    public static final AddressLayout PSE_SIGNING_LEVEL = freeglut_h.C_POINTER;
    private static final int SeImageSignatureNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureNone = 0
     * }
     */
    public static int SeImageSignatureNone() {
        return SeImageSignatureNone;
    }
    private static final int SeImageSignatureEmbedded = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureEmbedded = 1
     * }
     */
    public static int SeImageSignatureEmbedded() {
        return SeImageSignatureEmbedded;
    }
    private static final int SeImageSignatureCache = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCache = 2
     * }
     */
    public static int SeImageSignatureCache() {
        return SeImageSignatureCache;
    }
    private static final int SeImageSignatureCatalogCached = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogCached = 3
     * }
     */
    public static int SeImageSignatureCatalogCached() {
        return SeImageSignatureCatalogCached;
    }
    private static final int SeImageSignatureCatalogNotCached = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogNotCached = 4
     * }
     */
    public static int SeImageSignatureCatalogNotCached() {
        return SeImageSignatureCatalogNotCached;
    }
    private static final int SeImageSignatureCatalogHint = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogHint = 5
     * }
     */
    public static int SeImageSignatureCatalogHint() {
        return SeImageSignatureCatalogHint;
    }
    private static final int SeImageSignaturePackageCatalog = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _SE_IMAGE_SIGNATURE_TYPE.SeImageSignaturePackageCatalog = 6
     * }
     */
    public static int SeImageSignaturePackageCatalog() {
        return SeImageSignaturePackageCatalog;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _SE_IMAGE_SIGNATURE_TYPE {
     *     SeImageSignatureNone = 0,
     *     SeImageSignatureEmbedded,
     *     SeImageSignatureCache,
     *     SeImageSignatureCatalogCached,
     *     SeImageSignatureCatalogNotCached,
     *     SeImageSignatureCatalogHint,
     *     SeImageSignaturePackageCatalog
     * } *PSE_IMAGE_SIGNATURE_TYPE
     * }
     */
    public static final AddressLayout PSE_IMAGE_SIGNATURE_TYPE = freeglut_h.C_POINTER;
    private static final int SeLearningModeInvalidType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SE_LEARNING_MODE_DATA_TYPE.SeLearningModeInvalidType = 0
     * }
     */
    public static int SeLearningModeInvalidType() {
        return SeLearningModeInvalidType;
    }
    private static final int SeLearningModeSettings = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SE_LEARNING_MODE_DATA_TYPE.SeLearningModeSettings = 1
     * }
     */
    public static int SeLearningModeSettings() {
        return SeLearningModeSettings;
    }
    private static final int SeLearningModeMax = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SE_LEARNING_MODE_DATA_TYPE.SeLearningModeMax = 2
     * }
     */
    public static int SeLearningModeMax() {
        return SeLearningModeMax;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_CAPABILITIES {
     *     PSID AppContainerSid;
     *     PSID_AND_ATTRIBUTES Capabilities;
     *     DWORD CapabilityCount;
     *     DWORD Reserved;
     * } *PSECURITY_CAPABILITIES
     * }
     */
    public static final AddressLayout PSECURITY_CAPABILITIES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_CAPABILITIES {
     *     PSID AppContainerSid;
     *     PSID_AND_ATTRIBUTES Capabilities;
     *     DWORD CapabilityCount;
     *     DWORD Reserved;
     * } *LPSECURITY_CAPABILITIES
     * }
     */
    public static final AddressLayout LPSECURITY_CAPABILITIES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOB_SET_ARRAY {
     *     HANDLE JobHandle;
     *     DWORD MemberLevel;
     *     DWORD Flags;
     * } *PJOB_SET_ARRAY
     * }
     */
    public static final AddressLayout PJOB_SET_ARRAY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD
     * }
     */
    public static final AddressLayout PEXCEPTION_REGISTRATION_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NT_TIB *PNT_TIB
     * }
     */
    public static final AddressLayout PNT_TIB = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NT_TIB32 {
     *     DWORD ExceptionList;
     *     DWORD StackBase;
     *     DWORD StackLimit;
     *     DWORD SubSystemTib;
     *     union {
     *         DWORD FiberData;
     *         DWORD Version;
     *     };
     *     DWORD ArbitraryUserPointer;
     *     DWORD Self;
     * } *PNT_TIB32
     * }
     */
    public static final AddressLayout PNT_TIB32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NT_TIB64 {
     *     DWORD64 ExceptionList;
     *     DWORD64 StackBase;
     *     DWORD64 StackLimit;
     *     DWORD64 SubSystemTib;
     *     union {
     *         DWORD64 FiberData;
     *         DWORD Version;
     *     };
     *     DWORD64 ArbitraryUserPointer;
     *     DWORD64 Self;
     * } *PNT_TIB64
     * }
     */
    public static final AddressLayout PNT_TIB64 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {
     *     DWORD UmsVersion;
     *     PVOID UmsContext;
     *     PVOID UmsCompletionList;
     * } *PUMS_CREATE_THREAD_ATTRIBUTES
     * }
     */
    public static final AddressLayout PUMS_CREATE_THREAD_ATTRIBUTES = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
     *     ULONG_PTR TargetAddress;
     *     ULONG_PTR Flags;
     * } *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET
     * }
     */
    public static final AddressLayout PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
     *     WORD NumberOfTargets;
     *     WORD Reserved;
     *     DWORD Reserved2;
     *     PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets;
     * } *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION
     * }
     */
    public static final AddressLayout PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
     *     ULONG_PTR BaseAddress;
     *     SIZE_T Size;
     *     DWORD Flags;
     * } *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE
     * }
     */
    public static final AddressLayout PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
     *     WORD NumberOfRanges;
     *     WORD Reserved;
     *     DWORD Reserved2;
     *     PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges;
     * } *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION
     * }
     */
    public static final AddressLayout PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUOTA_LIMITS {
     *     SIZE_T PagedPoolLimit;
     *     SIZE_T NonPagedPoolLimit;
     *     SIZE_T MinimumWorkingSetSize;
     *     SIZE_T MaximumWorkingSetSize;
     *     SIZE_T PagefileLimit;
     *     LARGE_INTEGER TimeLimit;
     * } *PQUOTA_LIMITS
     * }
     */
    public static final AddressLayout PQUOTA_LIMITS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef union _RATE_QUOTA_LIMIT {
     *     DWORD RateData;
     *     struct {
     *         DWORD RatePercent : 7;
     *         DWORD Reserved0 : 25;
     *     };
     * } *PRATE_QUOTA_LIMIT
     * }
     */
    public static final AddressLayout PRATE_QUOTA_LIMIT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUOTA_LIMITS_EX {
     *     SIZE_T PagedPoolLimit;
     *     SIZE_T NonPagedPoolLimit;
     *     SIZE_T MinimumWorkingSetSize;
     *     SIZE_T MaximumWorkingSetSize;
     *     SIZE_T PagefileLimit;
     *     LARGE_INTEGER TimeLimit;
     *     SIZE_T WorkingSetLimit;
     *     SIZE_T Reserved2;
     *     SIZE_T Reserved3;
     *     SIZE_T Reserved4;
     *     DWORD Flags;
     *     RATE_QUOTA_LIMIT CpuRateLimit;
     * } *PQUOTA_LIMITS_EX
     * }
     */
    public static final AddressLayout PQUOTA_LIMITS_EX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef IO_COUNTERS *PIO_COUNTERS
     * }
     */
    public static final AddressLayout PIO_COUNTERS = freeglut_h.C_POINTER;
    private static final int PMCCounter = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _HARDWARE_COUNTER_TYPE.PMCCounter = 0
     * }
     */
    public static int PMCCounter() {
        return PMCCounter;
    }
    private static final int MaxHardwareCounterType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _HARDWARE_COUNTER_TYPE.MaxHardwareCounterType = 1
     * }
     */
    public static int MaxHardwareCounterType() {
        return MaxHardwareCounterType;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _HARDWARE_COUNTER_TYPE {
     *     PMCCounter,
     *     MaxHardwareCounterType
     * } *PHARDWARE_COUNTER_TYPE
     * }
     */
    public static final AddressLayout PHARDWARE_COUNTER_TYPE = freeglut_h.C_POINTER;
    private static final int ProcessDEPPolicy = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessDEPPolicy = 0
     * }
     */
    public static int ProcessDEPPolicy() {
        return ProcessDEPPolicy;
    }
    private static final int ProcessASLRPolicy = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessASLRPolicy = 1
     * }
     */
    public static int ProcessASLRPolicy() {
        return ProcessASLRPolicy;
    }
    private static final int ProcessDynamicCodePolicy = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessDynamicCodePolicy = 2
     * }
     */
    public static int ProcessDynamicCodePolicy() {
        return ProcessDynamicCodePolicy;
    }
    private static final int ProcessStrictHandleCheckPolicy = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessStrictHandleCheckPolicy = 3
     * }
     */
    public static int ProcessStrictHandleCheckPolicy() {
        return ProcessStrictHandleCheckPolicy;
    }
    private static final int ProcessSystemCallDisablePolicy = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessSystemCallDisablePolicy = 4
     * }
     */
    public static int ProcessSystemCallDisablePolicy() {
        return ProcessSystemCallDisablePolicy;
    }
    private static final int ProcessMitigationOptionsMask = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessMitigationOptionsMask = 5
     * }
     */
    public static int ProcessMitigationOptionsMask() {
        return ProcessMitigationOptionsMask;
    }
    private static final int ProcessExtensionPointDisablePolicy = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessExtensionPointDisablePolicy = 6
     * }
     */
    public static int ProcessExtensionPointDisablePolicy() {
        return ProcessExtensionPointDisablePolicy;
    }
    private static final int ProcessControlFlowGuardPolicy = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessControlFlowGuardPolicy = 7
     * }
     */
    public static int ProcessControlFlowGuardPolicy() {
        return ProcessControlFlowGuardPolicy;
    }
    private static final int ProcessSignaturePolicy = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessSignaturePolicy = 8
     * }
     */
    public static int ProcessSignaturePolicy() {
        return ProcessSignaturePolicy;
    }
    private static final int ProcessFontDisablePolicy = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessFontDisablePolicy = 9
     * }
     */
    public static int ProcessFontDisablePolicy() {
        return ProcessFontDisablePolicy;
    }
    private static final int ProcessImageLoadPolicy = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessImageLoadPolicy = 10
     * }
     */
    public static int ProcessImageLoadPolicy() {
        return ProcessImageLoadPolicy;
    }
    private static final int ProcessSystemCallFilterPolicy = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessSystemCallFilterPolicy = 11
     * }
     */
    public static int ProcessSystemCallFilterPolicy() {
        return ProcessSystemCallFilterPolicy;
    }
    private static final int ProcessPayloadRestrictionPolicy = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessPayloadRestrictionPolicy = 12
     * }
     */
    public static int ProcessPayloadRestrictionPolicy() {
        return ProcessPayloadRestrictionPolicy;
    }
    private static final int ProcessChildProcessPolicy = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessChildProcessPolicy = 13
     * }
     */
    public static int ProcessChildProcessPolicy() {
        return ProcessChildProcessPolicy;
    }
    private static final int ProcessSideChannelIsolationPolicy = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessSideChannelIsolationPolicy = 14
     * }
     */
    public static int ProcessSideChannelIsolationPolicy() {
        return ProcessSideChannelIsolationPolicy;
    }
    private static final int ProcessUserShadowStackPolicy = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.ProcessUserShadowStackPolicy = 15
     * }
     */
    public static int ProcessUserShadowStackPolicy() {
        return ProcessUserShadowStackPolicy;
    }
    private static final int MaxProcessMitigationPolicy = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MITIGATION_POLICY.MaxProcessMitigationPolicy = 16
     * }
     */
    public static int MaxProcessMitigationPolicy() {
        return MaxProcessMitigationPolicy;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _PROCESS_MITIGATION_POLICY {
     *     ProcessDEPPolicy,
     *     ProcessASLRPolicy,
     *     ProcessDynamicCodePolicy,
     *     ProcessStrictHandleCheckPolicy,
     *     ProcessSystemCallDisablePolicy,
     *     ProcessMitigationOptionsMask,
     *     ProcessExtensionPointDisablePolicy,
     *     ProcessControlFlowGuardPolicy,
     *     ProcessSignaturePolicy,
     *     ProcessFontDisablePolicy,
     *     ProcessImageLoadPolicy,
     *     ProcessSystemCallFilterPolicy,
     *     ProcessPayloadRestrictionPolicy,
     *     ProcessChildProcessPolicy,
     *     ProcessSideChannelIsolationPolicy,
     *     ProcessUserShadowStackPolicy,
     *     MaxProcessMitigationPolicy
     * } *PPROCESS_MITIGATION_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD EnableBottomUpRandomization : 1;
     *             DWORD EnableForceRelocateImages : 1;
     *             DWORD EnableHighEntropy : 1;
     *             DWORD DisallowStrippedImages : 1;
     *             DWORD ReservedFlags : 28;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_ASLR_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_ASLR_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_DEP_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD Enable : 1;
     *             DWORD DisableAtlThunkEmulation : 1;
     *             DWORD ReservedFlags : 30;
     *         };
     *     };
     *     BOOLEAN Permanent;
     * } *PPROCESS_MITIGATION_DEP_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_DEP_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD RaiseExceptionOnInvalidHandleReference : 1;
     *             DWORD HandleExceptionsPermanentlyEnabled : 1;
     *             DWORD ReservedFlags : 30;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD DisallowWin32kSystemCalls : 1;
     *             DWORD AuditDisallowWin32kSystemCalls : 1;
     *             DWORD ReservedFlags : 30;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD DisableExtensionPoints : 1;
     *             DWORD ReservedFlags : 31;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD ProhibitDynamicCode : 1;
     *             DWORD AllowThreadOptOut : 1;
     *             DWORD AllowRemoteDowngrade : 1;
     *             DWORD AuditProhibitDynamicCode : 1;
     *             DWORD ReservedFlags : 28;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD EnableControlFlowGuard : 1;
     *             DWORD EnableExportSuppression : 1;
     *             DWORD StrictMode : 1;
     *             DWORD ReservedFlags : 29;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD MicrosoftSignedOnly : 1;
     *             DWORD StoreSignedOnly : 1;
     *             DWORD MitigationOptIn : 1;
     *             DWORD AuditMicrosoftSignedOnly : 1;
     *             DWORD AuditStoreSignedOnly : 1;
     *             DWORD ReservedFlags : 27;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD DisableNonSystemFonts : 1;
     *             DWORD AuditNonSystemFontLoading : 1;
     *             DWORD ReservedFlags : 30;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_FONT_DISABLE_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_FONT_DISABLE_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD NoRemoteImages : 1;
     *             DWORD NoLowMandatoryLabelImages : 1;
     *             DWORD PreferSystem32Images : 1;
     *             DWORD AuditNoRemoteImages : 1;
     *             DWORD AuditNoLowMandatoryLabelImages : 1;
     *             DWORD ReservedFlags : 27;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD FilterId : 4;
     *             DWORD ReservedFlags : 28;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD EnableExportAddressFilter : 1;
     *             DWORD AuditExportAddressFilter : 1;
     *             DWORD EnableExportAddressFilterPlus : 1;
     *             DWORD AuditExportAddressFilterPlus : 1;
     *             DWORD EnableImportAddressFilter : 1;
     *             DWORD AuditImportAddressFilter : 1;
     *             DWORD EnableRopStackPivot : 1;
     *             DWORD AuditRopStackPivot : 1;
     *             DWORD EnableRopCallerCheck : 1;
     *             DWORD AuditRopCallerCheck : 1;
     *             DWORD EnableRopSimExec : 1;
     *             DWORD AuditRopSimExec : 1;
     *             DWORD ReservedFlags : 20;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD NoChildProcessCreation : 1;
     *             DWORD AuditNoChildProcessCreation : 1;
     *             DWORD AllowSecureProcessCreation : 1;
     *             DWORD ReservedFlags : 29;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD SmtBranchTargetIsolation : 1;
     *             DWORD IsolateSecurityDomain : 1;
     *             DWORD DisablePageCombine : 1;
     *             DWORD SpeculativeStoreBypassDisable : 1;
     *             DWORD ReservedFlags : 28;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
     *     union {
     *         DWORD Flags;
     *         struct {
     *             DWORD EnableUserShadowStack : 1;
     *             DWORD AuditUserShadowStack : 1;
     *             DWORD SetContextIpValidation : 1;
     *             DWORD AuditSetContextIpValidation : 1;
     *             DWORD EnableUserShadowStackStrictMode : 1;
     *             DWORD BlockNonCetBinaries : 1;
     *             DWORD BlockNonCetBinariesNonEhcont : 1;
     *             DWORD AuditBlockNonCetBinaries : 1;
     *             DWORD CetDynamicApisOutOfProcOnly : 1;
     *             DWORD SetContextIpValidationRelaxedMode : 1;
     *             DWORD ReservedFlags : 22;
     *         };
     *     };
     * } *PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY
     * }
     */
    public static final AddressLayout PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
     *     LARGE_INTEGER TotalUserTime;
     *     LARGE_INTEGER TotalKernelTime;
     *     LARGE_INTEGER ThisPeriodTotalUserTime;
     *     LARGE_INTEGER ThisPeriodTotalKernelTime;
     *     DWORD TotalPageFaultCount;
     *     DWORD TotalProcesses;
     *     DWORD ActiveProcesses;
     *     DWORD TotalTerminatedProcesses;
     * } *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
     *     LARGE_INTEGER PerProcessUserTimeLimit;
     *     LARGE_INTEGER PerJobUserTimeLimit;
     *     DWORD LimitFlags;
     *     SIZE_T MinimumWorkingSetSize;
     *     SIZE_T MaximumWorkingSetSize;
     *     DWORD ActiveProcessLimit;
     *     ULONG_PTR Affinity;
     *     DWORD PriorityClass;
     *     DWORD SchedulingClass;
     * } *PJOBOBJECT_BASIC_LIMIT_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_BASIC_LIMIT_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
     *     JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
     *     IO_COUNTERS IoInfo;
     *     SIZE_T ProcessMemoryLimit;
     *     SIZE_T JobMemoryLimit;
     *     SIZE_T PeakProcessMemoryUsed;
     *     SIZE_T PeakJobMemoryUsed;
     * } *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
     *     DWORD NumberOfAssignedProcesses;
     *     DWORD NumberOfProcessIdsInList;
     *     ULONG_PTR ProcessIdList[1];
     * } *PJOBOBJECT_BASIC_PROCESS_ID_LIST
     * }
     */
    public static final AddressLayout PJOBOBJECT_BASIC_PROCESS_ID_LIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
     *     DWORD UIRestrictionsClass;
     * } *PJOBOBJECT_BASIC_UI_RESTRICTIONS
     * }
     */
    public static final AddressLayout PJOBOBJECT_BASIC_UI_RESTRICTIONS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
     *     DWORD SecurityLimitFlags;
     *     HANDLE JobToken;
     *     PTOKEN_GROUPS SidsToDisable;
     *     PTOKEN_PRIVILEGES PrivilegesToDelete;
     *     PTOKEN_GROUPS RestrictedSids;
     * } *PJOBOBJECT_SECURITY_LIMIT_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_SECURITY_LIMIT_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
     *     DWORD EndOfJobTimeAction;
     * } *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
     *     PVOID CompletionKey;
     *     HANDLE CompletionPort;
     * } *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT
     * }
     */
    public static final AddressLayout PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
     *     JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
     *     IO_COUNTERS IoInfo;
     * } *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_JOBSET_INFORMATION {
     *     DWORD MemberLevel;
     * } *PJOBOBJECT_JOBSET_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_JOBSET_INFORMATION = freeglut_h.C_POINTER;
    private static final int ToleranceLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceLow = 1
     * }
     */
    public static int ToleranceLow() {
        return ToleranceLow;
    }
    private static final int ToleranceMedium = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceMedium = 2
     * }
     */
    public static int ToleranceMedium() {
        return ToleranceMedium;
    }
    private static final int ToleranceHigh = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceHigh = 3
     * }
     */
    public static int ToleranceHigh() {
        return ToleranceHigh;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
     *     ToleranceLow = 1,
     *     ToleranceMedium,
     *     ToleranceHigh
     * } *PJOBOBJECT_RATE_CONTROL_TOLERANCE
     * }
     */
    public static final AddressLayout PJOBOBJECT_RATE_CONTROL_TOLERANCE = freeglut_h.C_POINTER;
    private static final int ToleranceIntervalShort = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalShort = 1
     * }
     */
    public static int ToleranceIntervalShort() {
        return ToleranceIntervalShort;
    }
    private static final int ToleranceIntervalMedium = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalMedium = 2
     * }
     */
    public static int ToleranceIntervalMedium() {
        return ToleranceIntervalMedium;
    }
    private static final int ToleranceIntervalLong = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalLong = 3
     * }
     */
    public static int ToleranceIntervalLong() {
        return ToleranceIntervalLong;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
     *     ToleranceIntervalShort = 1,
     *     ToleranceIntervalMedium,
     *     ToleranceIntervalLong
     * } *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
     * }
     */
    public static final AddressLayout PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
     *     DWORD64 IoReadBytesLimit;
     *     DWORD64 IoWriteBytesLimit;
     *     LARGE_INTEGER PerJobUserTimeLimit;
     *     DWORD64 JobMemoryLimit;
     *     JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
     *     JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
     *     DWORD LimitFlags;
     * } *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
     *     DWORD LimitFlags;
     *     DWORD ViolationLimitFlags;
     *     DWORD64 IoReadBytes;
     *     DWORD64 IoReadBytesLimit;
     *     DWORD64 IoWriteBytes;
     *     DWORD64 IoWriteBytesLimit;
     *     LARGE_INTEGER PerJobUserTime;
     *     LARGE_INTEGER PerJobUserTimeLimit;
     *     DWORD64 JobMemory;
     *     DWORD64 JobMemoryLimit;
     *     JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
     *     JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
     * } *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
     *     DWORD ControlFlags;
     *     union {
     *         DWORD CpuRate;
     *         DWORD Weight;
     *         struct {
     *             WORD MinRate;
     *             WORD MaxRate;
     *         };
     *     };
     * } *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = freeglut_h.C_POINTER;
    private static final int JOB_OBJECT_NET_RATE_CONTROL_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 1
     * }
     */
    public static int JOB_OBJECT_NET_RATE_CONTROL_ENABLE() {
        return JOB_OBJECT_NET_RATE_CONTROL_ENABLE;
    }
    private static final int JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 2
     * }
     */
    public static int JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH() {
        return JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH;
    }
    private static final int JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = (int)4L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 4
     * }
     */
    public static int JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG() {
        return JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG;
    }
    private static final int JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = (int)7L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 7
     * }
     */
    public static int JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS() {
        return JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS;
    }
    private static final int JOB_OBJECT_IO_RATE_CONTROL_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 1
     * }
     */
    public static int JOB_OBJECT_IO_RATE_CONTROL_ENABLE() {
        return JOB_OBJECT_IO_RATE_CONTROL_ENABLE;
    }
    private static final int JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = (int)2L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 2
     * }
     */
    public static int JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME() {
        return JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME;
    }
    private static final int JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 4
     * }
     */
    public static int JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL() {
        return JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL;
    }
    private static final int JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 8
     * }
     */
    public static int JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP() {
        return JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP;
    }
    private static final int JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = (int)15L;
    /**
     * {@snippet lang=c :
     * enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = 15
     * }
     */
    public static int JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS() {
        return JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS;
    }
    private static final int JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 1
     * }
     */
    public static int JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE() {
        return JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE;
    }
    private static final int JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 2
     * }
     */
    public static int JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE() {
        return JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE;
    }
    private static final int JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 3
     * }
     */
    public static int JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS() {
        return JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_IO_ATTRIBUTION_STATS {
     *     ULONG_PTR IoCount;
     *     ULONGLONG TotalNonOverlappedQueueTime;
     *     ULONGLONG TotalNonOverlappedServiceTime;
     *     ULONGLONG TotalSize;
     * } *PJOBOBJECT_IO_ATTRIBUTION_STATS
     * }
     */
    public static final AddressLayout PJOBOBJECT_IO_ATTRIBUTION_STATS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
     *     DWORD ControlFlags;
     *     JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
     *     JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;
     * } *PJOBOBJECT_IO_ATTRIBUTION_INFORMATION
     * }
     */
    public static final AddressLayout PJOBOBJECT_IO_ATTRIBUTION_INFORMATION = freeglut_h.C_POINTER;
    private static final int JobObjectBasicAccountingInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectBasicAccountingInformation = 1
     * }
     */
    public static int JobObjectBasicAccountingInformation() {
        return JobObjectBasicAccountingInformation;
    }
    private static final int JobObjectBasicLimitInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectBasicLimitInformation = 2
     * }
     */
    public static int JobObjectBasicLimitInformation() {
        return JobObjectBasicLimitInformation;
    }
    private static final int JobObjectBasicProcessIdList = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectBasicProcessIdList = 3
     * }
     */
    public static int JobObjectBasicProcessIdList() {
        return JobObjectBasicProcessIdList;
    }
    private static final int JobObjectBasicUIRestrictions = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectBasicUIRestrictions = 4
     * }
     */
    public static int JobObjectBasicUIRestrictions() {
        return JobObjectBasicUIRestrictions;
    }
    private static final int JobObjectSecurityLimitInformation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectSecurityLimitInformation = 5
     * }
     */
    public static int JobObjectSecurityLimitInformation() {
        return JobObjectSecurityLimitInformation;
    }
    private static final int JobObjectEndOfJobTimeInformation = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectEndOfJobTimeInformation = 6
     * }
     */
    public static int JobObjectEndOfJobTimeInformation() {
        return JobObjectEndOfJobTimeInformation;
    }
    private static final int JobObjectAssociateCompletionPortInformation = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectAssociateCompletionPortInformation = 7
     * }
     */
    public static int JobObjectAssociateCompletionPortInformation() {
        return JobObjectAssociateCompletionPortInformation;
    }
    private static final int JobObjectBasicAndIoAccountingInformation = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectBasicAndIoAccountingInformation = 8
     * }
     */
    public static int JobObjectBasicAndIoAccountingInformation() {
        return JobObjectBasicAndIoAccountingInformation;
    }
    private static final int JobObjectExtendedLimitInformation = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectExtendedLimitInformation = 9
     * }
     */
    public static int JobObjectExtendedLimitInformation() {
        return JobObjectExtendedLimitInformation;
    }
    private static final int JobObjectJobSetInformation = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectJobSetInformation = 10
     * }
     */
    public static int JobObjectJobSetInformation() {
        return JobObjectJobSetInformation;
    }
    private static final int JobObjectGroupInformation = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectGroupInformation = 11
     * }
     */
    public static int JobObjectGroupInformation() {
        return JobObjectGroupInformation;
    }
    private static final int JobObjectNotificationLimitInformation = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation = 12
     * }
     */
    public static int JobObjectNotificationLimitInformation() {
        return JobObjectNotificationLimitInformation;
    }
    private static final int JobObjectLimitViolationInformation = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation = 13
     * }
     */
    public static int JobObjectLimitViolationInformation() {
        return JobObjectLimitViolationInformation;
    }
    private static final int JobObjectGroupInformationEx = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectGroupInformationEx = 14
     * }
     */
    public static int JobObjectGroupInformationEx() {
        return JobObjectGroupInformationEx;
    }
    private static final int JobObjectCpuRateControlInformation = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectCpuRateControlInformation = 15
     * }
     */
    public static int JobObjectCpuRateControlInformation() {
        return JobObjectCpuRateControlInformation;
    }
    private static final int JobObjectCompletionFilter = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectCompletionFilter = 16
     * }
     */
    public static int JobObjectCompletionFilter() {
        return JobObjectCompletionFilter;
    }
    private static final int JobObjectCompletionCounter = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectCompletionCounter = 17
     * }
     */
    public static int JobObjectCompletionCounter() {
        return JobObjectCompletionCounter;
    }
    private static final int JobObjectReserved1Information = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved1Information = 18
     * }
     */
    public static int JobObjectReserved1Information() {
        return JobObjectReserved1Information;
    }
    private static final int JobObjectReserved2Information = (int)19L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved2Information = 19
     * }
     */
    public static int JobObjectReserved2Information() {
        return JobObjectReserved2Information;
    }
    private static final int JobObjectReserved3Information = (int)20L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved3Information = 20
     * }
     */
    public static int JobObjectReserved3Information() {
        return JobObjectReserved3Information;
    }
    private static final int JobObjectReserved4Information = (int)21L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved4Information = 21
     * }
     */
    public static int JobObjectReserved4Information() {
        return JobObjectReserved4Information;
    }
    private static final int JobObjectReserved5Information = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved5Information = 22
     * }
     */
    public static int JobObjectReserved5Information() {
        return JobObjectReserved5Information;
    }
    private static final int JobObjectReserved6Information = (int)23L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved6Information = 23
     * }
     */
    public static int JobObjectReserved6Information() {
        return JobObjectReserved6Information;
    }
    private static final int JobObjectReserved7Information = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved7Information = 24
     * }
     */
    public static int JobObjectReserved7Information() {
        return JobObjectReserved7Information;
    }
    private static final int JobObjectReserved8Information = (int)25L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved8Information = 25
     * }
     */
    public static int JobObjectReserved8Information() {
        return JobObjectReserved8Information;
    }
    private static final int JobObjectReserved9Information = (int)26L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved9Information = 26
     * }
     */
    public static int JobObjectReserved9Information() {
        return JobObjectReserved9Information;
    }
    private static final int JobObjectReserved10Information = (int)27L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved10Information = 27
     * }
     */
    public static int JobObjectReserved10Information() {
        return JobObjectReserved10Information;
    }
    private static final int JobObjectReserved11Information = (int)28L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved11Information = 28
     * }
     */
    public static int JobObjectReserved11Information() {
        return JobObjectReserved11Information;
    }
    private static final int JobObjectReserved12Information = (int)29L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved12Information = 29
     * }
     */
    public static int JobObjectReserved12Information() {
        return JobObjectReserved12Information;
    }
    private static final int JobObjectReserved13Information = (int)30L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved13Information = 30
     * }
     */
    public static int JobObjectReserved13Information() {
        return JobObjectReserved13Information;
    }
    private static final int JobObjectReserved14Information = (int)31L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved14Information = 31
     * }
     */
    public static int JobObjectReserved14Information() {
        return JobObjectReserved14Information;
    }
    private static final int JobObjectNetRateControlInformation = (int)32L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectNetRateControlInformation = 32
     * }
     */
    public static int JobObjectNetRateControlInformation() {
        return JobObjectNetRateControlInformation;
    }
    private static final int JobObjectNotificationLimitInformation2 = (int)33L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation2 = 33
     * }
     */
    public static int JobObjectNotificationLimitInformation2() {
        return JobObjectNotificationLimitInformation2;
    }
    private static final int JobObjectLimitViolationInformation2 = (int)34L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation2 = 34
     * }
     */
    public static int JobObjectLimitViolationInformation2() {
        return JobObjectLimitViolationInformation2;
    }
    private static final int JobObjectCreateSilo = (int)35L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectCreateSilo = 35
     * }
     */
    public static int JobObjectCreateSilo() {
        return JobObjectCreateSilo;
    }
    private static final int JobObjectSiloBasicInformation = (int)36L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectSiloBasicInformation = 36
     * }
     */
    public static int JobObjectSiloBasicInformation() {
        return JobObjectSiloBasicInformation;
    }
    private static final int JobObjectReserved15Information = (int)37L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved15Information = 37
     * }
     */
    public static int JobObjectReserved15Information() {
        return JobObjectReserved15Information;
    }
    private static final int JobObjectReserved16Information = (int)38L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved16Information = 38
     * }
     */
    public static int JobObjectReserved16Information() {
        return JobObjectReserved16Information;
    }
    private static final int JobObjectReserved17Information = (int)39L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved17Information = 39
     * }
     */
    public static int JobObjectReserved17Information() {
        return JobObjectReserved17Information;
    }
    private static final int JobObjectReserved18Information = (int)40L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved18Information = 40
     * }
     */
    public static int JobObjectReserved18Information() {
        return JobObjectReserved18Information;
    }
    private static final int JobObjectReserved19Information = (int)41L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved19Information = 41
     * }
     */
    public static int JobObjectReserved19Information() {
        return JobObjectReserved19Information;
    }
    private static final int JobObjectReserved20Information = (int)42L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved20Information = 42
     * }
     */
    public static int JobObjectReserved20Information() {
        return JobObjectReserved20Information;
    }
    private static final int JobObjectReserved21Information = (int)43L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved21Information = 43
     * }
     */
    public static int JobObjectReserved21Information() {
        return JobObjectReserved21Information;
    }
    private static final int JobObjectReserved22Information = (int)44L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved22Information = 44
     * }
     */
    public static int JobObjectReserved22Information() {
        return JobObjectReserved22Information;
    }
    private static final int JobObjectReserved23Information = (int)45L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved23Information = 45
     * }
     */
    public static int JobObjectReserved23Information() {
        return JobObjectReserved23Information;
    }
    private static final int JobObjectReserved24Information = (int)46L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved24Information = 46
     * }
     */
    public static int JobObjectReserved24Information() {
        return JobObjectReserved24Information;
    }
    private static final int JobObjectReserved25Information = (int)47L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.JobObjectReserved25Information = 47
     * }
     */
    public static int JobObjectReserved25Information() {
        return JobObjectReserved25Information;
    }
    private static final int MaxJobObjectInfoClass = (int)48L;
    /**
     * {@snippet lang=c :
     * enum _JOBOBJECTINFOCLASS.MaxJobObjectInfoClass = 48
     * }
     */
    public static int MaxJobObjectInfoClass() {
        return MaxJobObjectInfoClass;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SILOOBJECT_BASIC_INFORMATION {
     *     DWORD SiloId;
     *     DWORD SiloParentId;
     *     DWORD NumberOfProcesses;
     *     BOOLEAN IsInServerSilo;
     *     BYTE Reserved[3];
     * } *PSILOOBJECT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PSILOOBJECT_BASIC_INFORMATION = freeglut_h.C_POINTER;
    private static final int SERVERSILO_INITING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SERVERSILO_STATE.SERVERSILO_INITING = 0
     * }
     */
    public static int SERVERSILO_INITING() {
        return SERVERSILO_INITING;
    }
    private static final int SERVERSILO_STARTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SERVERSILO_STATE.SERVERSILO_STARTED = 1
     * }
     */
    public static int SERVERSILO_STARTED() {
        return SERVERSILO_STARTED;
    }
    private static final int SERVERSILO_SHUTTING_DOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SERVERSILO_STATE.SERVERSILO_SHUTTING_DOWN = 2
     * }
     */
    public static int SERVERSILO_SHUTTING_DOWN() {
        return SERVERSILO_SHUTTING_DOWN;
    }
    private static final int SERVERSILO_TERMINATING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SERVERSILO_STATE.SERVERSILO_TERMINATING = 3
     * }
     */
    public static int SERVERSILO_TERMINATING() {
        return SERVERSILO_TERMINATING;
    }
    private static final int SERVERSILO_TERMINATED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _SERVERSILO_STATE.SERVERSILO_TERMINATED = 4
     * }
     */
    public static int SERVERSILO_TERMINATED() {
        return SERVERSILO_TERMINATED;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _SERVERSILO_STATE {
     *     SERVERSILO_INITING = 0,
     *     SERVERSILO_STARTED,
     *     SERVERSILO_SHUTTING_DOWN,
     *     SERVERSILO_TERMINATING,
     *     SERVERSILO_TERMINATED
     * } *PSERVERSILO_STATE
     * }
     */
    public static final AddressLayout PSERVERSILO_STATE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVERSILO_BASIC_INFORMATION {
     *     DWORD ServiceSessionId;
     *     SERVERSILO_STATE State;
     *     DWORD ExitStatus;
     *     BOOLEAN IsDownlevelContainer;
     *     PVOID ApiSetSchema;
     *     PVOID HostApiSetSchema;
     * } *PSERVERSILO_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PSERVERSILO_BASIC_INFORMATION = freeglut_h.C_POINTER;
    private static final int FirmwareTypeUnknown = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FIRMWARE_TYPE.FirmwareTypeUnknown = 0
     * }
     */
    public static int FirmwareTypeUnknown() {
        return FirmwareTypeUnknown;
    }
    private static final int FirmwareTypeBios = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FIRMWARE_TYPE.FirmwareTypeBios = 1
     * }
     */
    public static int FirmwareTypeBios() {
        return FirmwareTypeBios;
    }
    private static final int FirmwareTypeUefi = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FIRMWARE_TYPE.FirmwareTypeUefi = 2
     * }
     */
    public static int FirmwareTypeUefi() {
        return FirmwareTypeUefi;
    }
    private static final int FirmwareTypeMax = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FIRMWARE_TYPE.FirmwareTypeMax = 3
     * }
     */
    public static int FirmwareTypeMax() {
        return FirmwareTypeMax;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FIRMWARE_TYPE {
     *     FirmwareTypeUnknown,
     *     FirmwareTypeBios,
     *     FirmwareTypeUefi,
     *     FirmwareTypeMax
     * } *PFIRMWARE_TYPE
     * }
     */
    public static final AddressLayout PFIRMWARE_TYPE = freeglut_h.C_POINTER;
    private static final int RelationProcessorCore = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore = 0
     * }
     */
    public static int RelationProcessorCore() {
        return RelationProcessorCore;
    }
    private static final int RelationNumaNode = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _LOGICAL_PROCESSOR_RELATIONSHIP.RelationNumaNode = 1
     * }
     */
    public static int RelationNumaNode() {
        return RelationNumaNode;
    }
    private static final int RelationCache = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _LOGICAL_PROCESSOR_RELATIONSHIP.RelationCache = 2
     * }
     */
    public static int RelationCache() {
        return RelationCache;
    }
    private static final int RelationProcessorPackage = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorPackage = 3
     * }
     */
    public static int RelationProcessorPackage() {
        return RelationProcessorPackage;
    }
    private static final int RelationGroup = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup = 4
     * }
     */
    public static int RelationGroup() {
        return RelationGroup;
    }
    private static final int RelationAll = (int)65535L;
    /**
     * {@snippet lang=c :
     * enum _LOGICAL_PROCESSOR_RELATIONSHIP.RelationAll = 65535
     * }
     */
    public static int RelationAll() {
        return RelationAll;
    }
    private static final int CacheUnified = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESSOR_CACHE_TYPE.CacheUnified = 0
     * }
     */
    public static int CacheUnified() {
        return CacheUnified;
    }
    private static final int CacheInstruction = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESSOR_CACHE_TYPE.CacheInstruction = 1
     * }
     */
    public static int CacheInstruction() {
        return CacheInstruction;
    }
    private static final int CacheData = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROCESSOR_CACHE_TYPE.CacheData = 2
     * }
     */
    public static int CacheData() {
        return CacheData;
    }
    private static final int CacheTrace = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROCESSOR_CACHE_TYPE.CacheTrace = 3
     * }
     */
    public static int CacheTrace() {
        return CacheTrace;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CACHE_DESCRIPTOR {
     *     BYTE Level;
     *     BYTE Associativity;
     *     WORD LineSize;
     *     DWORD Size;
     *     PROCESSOR_CACHE_TYPE Type;
     * } *PCACHE_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCACHE_DESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
     *     ULONG_PTR ProcessorMask;
     *     LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
     *     union {
     *         struct {
     *             BYTE Flags;
     *         } ProcessorCore;
     *         struct {
     *             DWORD NodeNumber;
     *         } NumaNode;
     *         CACHE_DESCRIPTOR Cache;
     *         ULONGLONG Reserved[2];
     *     };
     * } *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
     * }
     */
    public static final AddressLayout PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESSOR_RELATIONSHIP {
     *     BYTE Flags;
     *     BYTE EfficiencyClass;
     *     BYTE Reserved[20];
     *     WORD GroupCount;
     *     GROUP_AFFINITY GroupMask[1];
     * } *PPROCESSOR_RELATIONSHIP
     * }
     */
    public static final AddressLayout PPROCESSOR_RELATIONSHIP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NUMA_NODE_RELATIONSHIP {
     *     DWORD NodeNumber;
     *     BYTE Reserved[20];
     *     GROUP_AFFINITY GroupMask;
     * } *PNUMA_NODE_RELATIONSHIP
     * }
     */
    public static final AddressLayout PNUMA_NODE_RELATIONSHIP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CACHE_RELATIONSHIP {
     *     BYTE Level;
     *     BYTE Associativity;
     *     WORD LineSize;
     *     DWORD CacheSize;
     *     PROCESSOR_CACHE_TYPE Type;
     *     BYTE Reserved[20];
     *     GROUP_AFFINITY GroupMask;
     * } *PCACHE_RELATIONSHIP
     * }
     */
    public static final AddressLayout PCACHE_RELATIONSHIP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESSOR_GROUP_INFO {
     *     BYTE MaximumProcessorCount;
     *     BYTE ActiveProcessorCount;
     *     BYTE Reserved[38];
     *     KAFFINITY ActiveProcessorMask;
     * } *PPROCESSOR_GROUP_INFO
     * }
     */
    public static final AddressLayout PPROCESSOR_GROUP_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GROUP_RELATIONSHIP {
     *     WORD MaximumGroupCount;
     *     WORD ActiveGroupCount;
     *     BYTE Reserved[20];
     *     PROCESSOR_GROUP_INFO GroupInfo[1];
     * } *PGROUP_RELATIONSHIP
     * }
     */
    public static final AddressLayout PGROUP_RELATIONSHIP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
     *     LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
     *     DWORD Size;
     *     union {
     *         PROCESSOR_RELATIONSHIP Processor;
     *         NUMA_NODE_RELATIONSHIP NumaNode;
     *         CACHE_RELATIONSHIP Cache;
     *         GROUP_RELATIONSHIP Group;
     *     };
     * } *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
     * }
     */
    public static final AddressLayout PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = freeglut_h.C_POINTER;
    private static final int CpuSetInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _CPU_SET_INFORMATION_TYPE.CpuSetInformation = 0
     * }
     */
    public static int CpuSetInformation() {
        return CpuSetInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _CPU_SET_INFORMATION_TYPE {
     *     CpuSetInformation
     * } *PCPU_SET_INFORMATION_TYPE
     * }
     */
    public static final AddressLayout PCPU_SET_INFORMATION_TYPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_CPU_SET_INFORMATION {
     *     DWORD Size;
     *     CPU_SET_INFORMATION_TYPE Type;
     *     union {
     *         struct {
     *             DWORD Id;
     *             WORD Group;
     *             BYTE LogicalProcessorIndex;
     *             BYTE CoreIndex;
     *             BYTE LastLevelCacheIndex;
     *             BYTE NumaNodeIndex;
     *             BYTE EfficiencyClass;
     *             union {
     *                 BYTE AllFlags;
     *                 struct {
     *                     BYTE Parked : 1;
     *                     BYTE Allocated : 1;
     *                     BYTE AllocatedToTargetProcess : 1;
     *                     BYTE RealTime : 1;
     *                     BYTE ReservedFlags : 4;
     *                 };
     *             };
     *             union {
     *                 DWORD Reserved;
     *                 BYTE SchedulingClass;
     *             };
     *             DWORD64 AllocationTag;
     *         } CpuSet;
     *     };
     * } *PSYSTEM_CPU_SET_INFORMATION
     * }
     */
    public static final AddressLayout PSYSTEM_CPU_SET_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_POOL_ZEROING_INFORMATION {
     *     BOOLEAN PoolZeroingSupportPresent;
     * } *PSYSTEM_POOL_ZEROING_INFORMATION
     * }
     */
    public static final AddressLayout PSYSTEM_POOL_ZEROING_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
     *     DWORD64 CycleTime;
     * } *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION
     * }
     */
    public static final AddressLayout PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XSTATE_FEATURE {
     *     DWORD Offset;
     *     DWORD Size;
     * } *PXSTATE_FEATURE
     * }
     */
    public static final AddressLayout PXSTATE_FEATURE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _XSTATE_CONFIGURATION {
     *     DWORD64 EnabledFeatures;
     *     DWORD64 EnabledVolatileFeatures;
     *     DWORD Size;
     *     union {
     *         DWORD ControlFlags;
     *         struct {
     *             DWORD OptimizedSave : 1;
     *             DWORD CompactionEnabled : 1;
     *         };
     *     };
     *     XSTATE_FEATURE Features[64];
     *     DWORD64 EnabledSupervisorFeatures;
     *     DWORD64 AlignedFeatures;
     *     DWORD AllFeatureSize;
     *     DWORD AllFeatures[64];
     *     DWORD64 EnabledUserVisibleSupervisorFeatures;
     * } *PXSTATE_CONFIGURATION
     * }
     */
    public static final AddressLayout PXSTATE_CONFIGURATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORY_BASIC_INFORMATION {
     *     PVOID BaseAddress;
     *     PVOID AllocationBase;
     *     DWORD AllocationProtect;
     *     WORD PartitionId;
     *     SIZE_T RegionSize;
     *     DWORD State;
     *     DWORD Protect;
     *     DWORD Type;
     * } *PMEMORY_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PMEMORY_BASIC_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORY_BASIC_INFORMATION32 {
     *     DWORD BaseAddress;
     *     DWORD AllocationBase;
     *     DWORD AllocationProtect;
     *     DWORD RegionSize;
     *     DWORD State;
     *     DWORD Protect;
     *     DWORD Type;
     * } *PMEMORY_BASIC_INFORMATION32
     * }
     */
    public static final AddressLayout PMEMORY_BASIC_INFORMATION32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORY_BASIC_INFORMATION64 {
     *     ULONGLONG BaseAddress;
     *     ULONGLONG AllocationBase;
     *     DWORD AllocationProtect;
     *     DWORD __alignment1;
     *     ULONGLONG RegionSize;
     *     DWORD State;
     *     DWORD Protect;
     *     DWORD Type;
     *     DWORD __alignment2;
     * } *PMEMORY_BASIC_INFORMATION64
     * }
     */
    public static final AddressLayout PMEMORY_BASIC_INFORMATION64 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CFG_CALL_TARGET_INFO {
     *     ULONG_PTR Offset;
     *     ULONG_PTR Flags;
     * } *PCFG_CALL_TARGET_INFO
     * }
     */
    public static final AddressLayout PCFG_CALL_TARGET_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEM_ADDRESS_REQUIREMENTS {
     *     PVOID LowestStartingAddress;
     *     PVOID HighestEndingAddress;
     *     SIZE_T Alignment;
     * } *PMEM_ADDRESS_REQUIREMENTS
     * }
     */
    public static final AddressLayout PMEM_ADDRESS_REQUIREMENTS = freeglut_h.C_POINTER;
    private static final int MemExtendedParameterInvalidType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterInvalidType = 0
     * }
     */
    public static int MemExtendedParameterInvalidType() {
        return MemExtendedParameterInvalidType;
    }
    private static final int MemExtendedParameterAddressRequirements = (int)1L;
    /**
     * {@snippet lang=c :
     * enum MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterAddressRequirements = 1
     * }
     */
    public static int MemExtendedParameterAddressRequirements() {
        return MemExtendedParameterAddressRequirements;
    }
    private static final int MemExtendedParameterNumaNode = (int)2L;
    /**
     * {@snippet lang=c :
     * enum MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterNumaNode = 2
     * }
     */
    public static int MemExtendedParameterNumaNode() {
        return MemExtendedParameterNumaNode;
    }
    private static final int MemExtendedParameterPartitionHandle = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterPartitionHandle = 3
     * }
     */
    public static int MemExtendedParameterPartitionHandle() {
        return MemExtendedParameterPartitionHandle;
    }
    private static final int MemExtendedParameterUserPhysicalHandle = (int)4L;
    /**
     * {@snippet lang=c :
     * enum MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterUserPhysicalHandle = 4
     * }
     */
    public static int MemExtendedParameterUserPhysicalHandle() {
        return MemExtendedParameterUserPhysicalHandle;
    }
    private static final int MemExtendedParameterAttributeFlags = (int)5L;
    /**
     * {@snippet lang=c :
     * enum MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterAttributeFlags = 5
     * }
     */
    public static int MemExtendedParameterAttributeFlags() {
        return MemExtendedParameterAttributeFlags;
    }
    private static final int MemExtendedParameterMax = (int)6L;
    /**
     * {@snippet lang=c :
     * enum MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterMax = 6
     * }
     */
    public static int MemExtendedParameterMax() {
        return MemExtendedParameterMax;
    }
    /**
     * {@snippet lang=c :
     * typedef enum MEM_EXTENDED_PARAMETER_TYPE {
     *     MemExtendedParameterInvalidType = 0,
     *     MemExtendedParameterAddressRequirements,
     *     MemExtendedParameterNumaNode,
     *     MemExtendedParameterPartitionHandle,
     *     MemExtendedParameterUserPhysicalHandle,
     *     MemExtendedParameterAttributeFlags,
     *     MemExtendedParameterMax
     * } *PMEM_EXTENDED_PARAMETER_TYPE
     * }
     */
    public static final AddressLayout PMEM_EXTENDED_PARAMETER_TYPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct MEM_EXTENDED_PARAMETER {
     *     struct {
     *         DWORD64 Type : 8;
     *         DWORD64 Reserved : 64 - 8;
     *     };
     *     union {
     *         DWORD64 ULong64;
     *         PVOID Pointer;
     *         SIZE_T Size;
     *         HANDLE Handle;
     *         DWORD ULong;
     *     };
     * } *PMEM_EXTENDED_PARAMETER
     * }
     */
    public static final AddressLayout PMEM_EXTENDED_PARAMETER = freeglut_h.C_POINTER;
    private static final int MemSectionExtendedParameterInvalidType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterInvalidType = 0
     * }
     */
    public static int MemSectionExtendedParameterInvalidType() {
        return MemSectionExtendedParameterInvalidType;
    }
    private static final int MemSectionExtendedParameterUserPhysicalFlags = (int)1L;
    /**
     * {@snippet lang=c :
     * enum MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterUserPhysicalFlags = 1
     * }
     */
    public static int MemSectionExtendedParameterUserPhysicalFlags() {
        return MemSectionExtendedParameterUserPhysicalFlags;
    }
    private static final int MemSectionExtendedParameterNumaNode = (int)2L;
    /**
     * {@snippet lang=c :
     * enum MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterNumaNode = 2
     * }
     */
    public static int MemSectionExtendedParameterNumaNode() {
        return MemSectionExtendedParameterNumaNode;
    }
    private static final int MemSectionExtendedParameterMax = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterMax = 3
     * }
     */
    public static int MemSectionExtendedParameterMax() {
        return MemSectionExtendedParameterMax;
    }
    /**
     * {@snippet lang=c :
     * typedef enum MEM_SECTION_EXTENDED_PARAMETER_TYPE {
     *     MemSectionExtendedParameterInvalidType = 0,
     *     MemSectionExtendedParameterUserPhysicalFlags,
     *     MemSectionExtendedParameterNumaNode,
     *     MemSectionExtendedParameterMax
     * } *PMEM_SECTION_EXTENDED_PARAMETER_TYPE
     * }
     */
    public static final AddressLayout PMEM_SECTION_EXTENDED_PARAMETER_TYPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCLAVE_CREATE_INFO_SGX {
     *     BYTE Secs[4096];
     * } *PENCLAVE_CREATE_INFO_SGX
     * }
     */
    public static final AddressLayout PENCLAVE_CREATE_INFO_SGX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCLAVE_INIT_INFO_SGX {
     *     BYTE SigStruct[1808];
     *     BYTE Reserved1[240];
     *     BYTE EInitToken[304];
     *     BYTE Reserved2[1744];
     * } *PENCLAVE_INIT_INFO_SGX
     * }
     */
    public static final AddressLayout PENCLAVE_INIT_INFO_SGX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCLAVE_CREATE_INFO_VBS {
     *     DWORD Flags;
     *     BYTE OwnerID[32];
     * } *PENCLAVE_CREATE_INFO_VBS
     * }
     */
    public static final AddressLayout PENCLAVE_CREATE_INFO_VBS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCLAVE_CREATE_INFO_VBS_BASIC {
     *     DWORD Flags;
     *     BYTE OwnerID[32];
     * } *PENCLAVE_CREATE_INFO_VBS_BASIC
     * }
     */
    public static final AddressLayout PENCLAVE_CREATE_INFO_VBS_BASIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCLAVE_LOAD_DATA_VBS_BASIC {
     *     DWORD PageType;
     * } *PENCLAVE_LOAD_DATA_VBS_BASIC
     * }
     */
    public static final AddressLayout PENCLAVE_LOAD_DATA_VBS_BASIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCLAVE_INIT_INFO_VBS_BASIC {
     *     BYTE FamilyId[16];
     *     BYTE ImageId[16];
     *     ULONGLONG EnclaveSize;
     *     DWORD EnclaveSvn;
     *     DWORD Reserved;
     *     union {
     *         HANDLE SignatureInfoHandle;
     *         ULONGLONG Unused;
     *     };
     * } *PENCLAVE_INIT_INFO_VBS_BASIC
     * }
     */
    public static final AddressLayout PENCLAVE_INIT_INFO_VBS_BASIC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENCLAVE_INIT_INFO_VBS {
     *     DWORD Length;
     *     DWORD ThreadCount;
     * } *PENCLAVE_INIT_INFO_VBS
     * }
     */
    public static final AddressLayout PENCLAVE_INIT_INFO_VBS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_128 {
     *     BYTE Identifier[16];
     * } *PFILE_ID_128
     * }
     */
    public static final AddressLayout PFILE_ID_128 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_NOTIFY_INFORMATION {
     *     DWORD NextEntryOffset;
     *     DWORD Action;
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_NOTIFY_INFORMATION
     * }
     */
    public static final AddressLayout PFILE_NOTIFY_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION {
     *     DWORD NextEntryOffset;
     *     DWORD Action;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastModificationTime;
     *     LARGE_INTEGER LastChangeTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER AllocatedLength;
     *     LARGE_INTEGER FileSize;
     *     DWORD FileAttributes;
     *     DWORD ReparsePointTag;
     *     LARGE_INTEGER FileId;
     *     LARGE_INTEGER ParentFileId;
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_NOTIFY_EXTENDED_INFORMATION
     * }
     */
    public static final AddressLayout PFILE_NOTIFY_EXTENDED_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef union _FILE_SEGMENT_ELEMENT {
     *     PVOID64 Buffer;
     *     ULONGLONG Alignment;
     * } *PFILE_SEGMENT_ELEMENT
     * }
     */
    public static final AddressLayout PFILE_SEGMENT_ELEMENT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REPARSE_GUID_DATA_BUFFER {
     *     DWORD ReparseTag;
     *     WORD ReparseDataLength;
     *     WORD Reserved;
     *     GUID ReparseGuid;
     *     struct {
     *         BYTE DataBuffer[1];
     *     } GenericReparseBuffer;
     * } *PREPARSE_GUID_DATA_BUFFER
     * }
     */
    public static final AddressLayout PREPARSE_GUID_DATA_BUFFER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCRUB_DATA_INPUT {
     *     DWORD Size;
     *     DWORD Flags;
     *     DWORD MaximumIos;
     *     DWORD ObjectId[4];
     *     DWORD Reserved[25];
     *     BYTE ResumeContext[816];
     * } *PSCRUB_DATA_INPUT
     * }
     */
    public static final AddressLayout PSCRUB_DATA_INPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCRUB_PARITY_EXTENT {
     *     LONGLONG Offset;
     *     ULONGLONG Length;
     * } *PSCRUB_PARITY_EXTENT
     * }
     */
    public static final AddressLayout PSCRUB_PARITY_EXTENT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCRUB_PARITY_EXTENT_DATA {
     *     WORD Size;
     *     WORD Flags;
     *     WORD NumberOfParityExtents;
     *     WORD MaximumNumberOfParityExtents;
     *     SCRUB_PARITY_EXTENT ParityExtents[1];
     * } *PSCRUB_PARITY_EXTENT_DATA
     * }
     */
    public static final AddressLayout PSCRUB_PARITY_EXTENT_DATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCRUB_DATA_OUTPUT {
     *     DWORD Size;
     *     DWORD Flags;
     *     DWORD Status;
     *     ULONGLONG ErrorFileOffset;
     *     ULONGLONG ErrorLength;
     *     ULONGLONG NumberOfBytesRepaired;
     *     ULONGLONG NumberOfBytesFailed;
     *     ULONGLONG InternalFileReference;
     *     WORD ResumeContextLength;
     *     WORD ParityExtentDataOffset;
     *     DWORD Reserved[9];
     *     ULONGLONG NumberOfMetadataBytesProcessed;
     *     ULONGLONG NumberOfDataBytesProcessed;
     *     ULONGLONG TotalNumberOfMetadataBytesInUse;
     *     ULONGLONG TotalNumberOfDataBytesInUse;
     *     BYTE ResumeContext[816];
     * } *PSCRUB_DATA_OUTPUT
     * }
     */
    public static final AddressLayout PSCRUB_DATA_OUTPUT = freeglut_h.C_POINTER;
    private static final int SharedVirtualDisksUnsupported = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SharedVirtualDiskSupportType.SharedVirtualDisksUnsupported = 0
     * }
     */
    public static int SharedVirtualDisksUnsupported() {
        return SharedVirtualDisksUnsupported;
    }
    private static final int SharedVirtualDisksSupported = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SharedVirtualDiskSupportType.SharedVirtualDisksSupported = 1
     * }
     */
    public static int SharedVirtualDisksSupported() {
        return SharedVirtualDisksSupported;
    }
    private static final int SharedVirtualDiskSnapshotsSupported = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SharedVirtualDiskSupportType.SharedVirtualDiskSnapshotsSupported = 3
     * }
     */
    public static int SharedVirtualDiskSnapshotsSupported() {
        return SharedVirtualDiskSnapshotsSupported;
    }
    private static final int SharedVirtualDiskCDPSnapshotsSupported = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _SharedVirtualDiskSupportType.SharedVirtualDiskCDPSnapshotsSupported = 7
     * }
     */
    public static int SharedVirtualDiskCDPSnapshotsSupported() {
        return SharedVirtualDiskCDPSnapshotsSupported;
    }
    private static final int SharedVirtualDiskHandleStateNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateNone = 0
     * }
     */
    public static int SharedVirtualDiskHandleStateNone() {
        return SharedVirtualDiskHandleStateNone;
    }
    private static final int SharedVirtualDiskHandleStateFileShared = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateFileShared = 1
     * }
     */
    public static int SharedVirtualDiskHandleStateFileShared() {
        return SharedVirtualDiskHandleStateFileShared;
    }
    private static final int SharedVirtualDiskHandleStateHandleShared = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateHandleShared = 3
     * }
     */
    public static int SharedVirtualDiskHandleStateHandleShared() {
        return SharedVirtualDiskHandleStateHandleShared;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SHARED_VIRTUAL_DISK_SUPPORT {
     *     SharedVirtualDiskSupportType SharedVirtualDiskSupport;
     *     SharedVirtualDiskHandleState HandleState;
     * } *PSHARED_VIRTUAL_DISK_SUPPORT
     * }
     */
    public static final AddressLayout PSHARED_VIRTUAL_DISK_SUPPORT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REARRANGE_FILE_DATA {
     *     ULONGLONG SourceStartingOffset;
     *     ULONGLONG TargetOffset;
     *     HANDLE SourceFileHandle;
     *     DWORD Length;
     *     DWORD Flags;
     * } *PREARRANGE_FILE_DATA
     * }
     */
    public static final AddressLayout PREARRANGE_FILE_DATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REARRANGE_FILE_DATA32 {
     *     ULONGLONG SourceStartingOffset;
     *     ULONGLONG TargetOffset;
     *     UINT32 SourceFileHandle;
     *     DWORD Length;
     *     DWORD Flags;
     * } *PREARRANGE_FILE_DATA32
     * }
     */
    public static final AddressLayout PREARRANGE_FILE_DATA32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SHUFFLE_FILE_DATA {
     *     LONGLONG StartingOffset;
     *     LONGLONG Length;
     *     DWORD Flags;
     * } *PSHUFFLE_FILE_DATA
     * }
     */
    public static final AddressLayout PSHUFFLE_FILE_DATA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NETWORK_APP_INSTANCE_EA {
     *     GUID AppInstanceID;
     *     DWORD CsvFlags;
     * } *PNETWORK_APP_INSTANCE_EA
     * }
     */
    public static final AddressLayout PNETWORK_APP_INSTANCE_EA = freeglut_h.C_POINTER;

    private static class GUID_MAX_POWER_SAVINGS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_MAX_POWER_SAVINGS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MAX_POWER_SAVINGS
     * }
     */
    public static GroupLayout GUID_MAX_POWER_SAVINGS$layout() {
        return GUID_MAX_POWER_SAVINGS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MAX_POWER_SAVINGS
     * }
     */
    public static MemorySegment GUID_MAX_POWER_SAVINGS() {
        return GUID_MAX_POWER_SAVINGS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MAX_POWER_SAVINGS
     * }
     */
    public static void GUID_MAX_POWER_SAVINGS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_MAX_POWER_SAVINGS$constants.SEGMENT, 0L, GUID_MAX_POWER_SAVINGS$constants.LAYOUT.byteSize());
    }

    private static class GUID_MIN_POWER_SAVINGS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_MIN_POWER_SAVINGS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MIN_POWER_SAVINGS
     * }
     */
    public static GroupLayout GUID_MIN_POWER_SAVINGS$layout() {
        return GUID_MIN_POWER_SAVINGS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MIN_POWER_SAVINGS
     * }
     */
    public static MemorySegment GUID_MIN_POWER_SAVINGS() {
        return GUID_MIN_POWER_SAVINGS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MIN_POWER_SAVINGS
     * }
     */
    public static void GUID_MIN_POWER_SAVINGS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_MIN_POWER_SAVINGS$constants.SEGMENT, 0L, GUID_MIN_POWER_SAVINGS$constants.LAYOUT.byteSize());
    }

    private static class GUID_TYPICAL_POWER_SAVINGS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_TYPICAL_POWER_SAVINGS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_TYPICAL_POWER_SAVINGS
     * }
     */
    public static GroupLayout GUID_TYPICAL_POWER_SAVINGS$layout() {
        return GUID_TYPICAL_POWER_SAVINGS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_TYPICAL_POWER_SAVINGS
     * }
     */
    public static MemorySegment GUID_TYPICAL_POWER_SAVINGS() {
        return GUID_TYPICAL_POWER_SAVINGS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_TYPICAL_POWER_SAVINGS
     * }
     */
    public static void GUID_TYPICAL_POWER_SAVINGS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_TYPICAL_POWER_SAVINGS$constants.SEGMENT, 0L, GUID_TYPICAL_POWER_SAVINGS$constants.LAYOUT.byteSize());
    }

    private static class NO_SUBGROUP_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("NO_SUBGROUP_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID NO_SUBGROUP_GUID
     * }
     */
    public static GroupLayout NO_SUBGROUP_GUID$layout() {
        return NO_SUBGROUP_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID NO_SUBGROUP_GUID
     * }
     */
    public static MemorySegment NO_SUBGROUP_GUID() {
        return NO_SUBGROUP_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID NO_SUBGROUP_GUID
     * }
     */
    public static void NO_SUBGROUP_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, NO_SUBGROUP_GUID$constants.SEGMENT, 0L, NO_SUBGROUP_GUID$constants.LAYOUT.byteSize());
    }

    private static class ALL_POWERSCHEMES_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("ALL_POWERSCHEMES_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID ALL_POWERSCHEMES_GUID
     * }
     */
    public static GroupLayout ALL_POWERSCHEMES_GUID$layout() {
        return ALL_POWERSCHEMES_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID ALL_POWERSCHEMES_GUID
     * }
     */
    public static MemorySegment ALL_POWERSCHEMES_GUID() {
        return ALL_POWERSCHEMES_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID ALL_POWERSCHEMES_GUID
     * }
     */
    public static void ALL_POWERSCHEMES_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, ALL_POWERSCHEMES_GUID$constants.SEGMENT, 0L, ALL_POWERSCHEMES_GUID$constants.LAYOUT.byteSize());
    }

    private static class GUID_POWERSCHEME_PERSONALITY$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_POWERSCHEME_PERSONALITY").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWERSCHEME_PERSONALITY
     * }
     */
    public static GroupLayout GUID_POWERSCHEME_PERSONALITY$layout() {
        return GUID_POWERSCHEME_PERSONALITY$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWERSCHEME_PERSONALITY
     * }
     */
    public static MemorySegment GUID_POWERSCHEME_PERSONALITY() {
        return GUID_POWERSCHEME_PERSONALITY$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWERSCHEME_PERSONALITY
     * }
     */
    public static void GUID_POWERSCHEME_PERSONALITY(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_POWERSCHEME_PERSONALITY$constants.SEGMENT, 0L, GUID_POWERSCHEME_PERSONALITY$constants.LAYOUT.byteSize());
    }

    private static class GUID_ACTIVE_POWERSCHEME$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ACTIVE_POWERSCHEME").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ACTIVE_POWERSCHEME
     * }
     */
    public static GroupLayout GUID_ACTIVE_POWERSCHEME$layout() {
        return GUID_ACTIVE_POWERSCHEME$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ACTIVE_POWERSCHEME
     * }
     */
    public static MemorySegment GUID_ACTIVE_POWERSCHEME() {
        return GUID_ACTIVE_POWERSCHEME$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ACTIVE_POWERSCHEME
     * }
     */
    public static void GUID_ACTIVE_POWERSCHEME(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ACTIVE_POWERSCHEME$constants.SEGMENT, 0L, GUID_ACTIVE_POWERSCHEME$constants.LAYOUT.byteSize());
    }

    private static class GUID_IDLE_RESILIENCY_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_IDLE_RESILIENCY_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_IDLE_RESILIENCY_SUBGROUP
     * }
     */
    public static GroupLayout GUID_IDLE_RESILIENCY_SUBGROUP$layout() {
        return GUID_IDLE_RESILIENCY_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_IDLE_RESILIENCY_SUBGROUP
     * }
     */
    public static MemorySegment GUID_IDLE_RESILIENCY_SUBGROUP() {
        return GUID_IDLE_RESILIENCY_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_IDLE_RESILIENCY_SUBGROUP
     * }
     */
    public static void GUID_IDLE_RESILIENCY_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_IDLE_RESILIENCY_SUBGROUP$constants.SEGMENT, 0L, GUID_IDLE_RESILIENCY_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_IDLE_RESILIENCY_PERIOD$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_IDLE_RESILIENCY_PERIOD").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_IDLE_RESILIENCY_PERIOD
     * }
     */
    public static GroupLayout GUID_IDLE_RESILIENCY_PERIOD$layout() {
        return GUID_IDLE_RESILIENCY_PERIOD$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_IDLE_RESILIENCY_PERIOD
     * }
     */
    public static MemorySegment GUID_IDLE_RESILIENCY_PERIOD() {
        return GUID_IDLE_RESILIENCY_PERIOD$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_IDLE_RESILIENCY_PERIOD
     * }
     */
    public static void GUID_IDLE_RESILIENCY_PERIOD(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_IDLE_RESILIENCY_PERIOD$constants.SEGMENT, 0L, GUID_IDLE_RESILIENCY_PERIOD$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEEP_SLEEP_ENABLED$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DEEP_SLEEP_ENABLED").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEEP_SLEEP_ENABLED
     * }
     */
    public static GroupLayout GUID_DEEP_SLEEP_ENABLED$layout() {
        return GUID_DEEP_SLEEP_ENABLED$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEEP_SLEEP_ENABLED
     * }
     */
    public static MemorySegment GUID_DEEP_SLEEP_ENABLED() {
        return GUID_DEEP_SLEEP_ENABLED$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEEP_SLEEP_ENABLED
     * }
     */
    public static void GUID_DEEP_SLEEP_ENABLED(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEEP_SLEEP_ENABLED$constants.SEGMENT, 0L, GUID_DEEP_SLEEP_ENABLED$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEEP_SLEEP_PLATFORM_STATE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DEEP_SLEEP_PLATFORM_STATE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEEP_SLEEP_PLATFORM_STATE
     * }
     */
    public static GroupLayout GUID_DEEP_SLEEP_PLATFORM_STATE$layout() {
        return GUID_DEEP_SLEEP_PLATFORM_STATE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEEP_SLEEP_PLATFORM_STATE
     * }
     */
    public static MemorySegment GUID_DEEP_SLEEP_PLATFORM_STATE() {
        return GUID_DEEP_SLEEP_PLATFORM_STATE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEEP_SLEEP_PLATFORM_STATE
     * }
     */
    public static void GUID_DEEP_SLEEP_PLATFORM_STATE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEEP_SLEEP_PLATFORM_STATE$constants.SEGMENT, 0L, GUID_DEEP_SLEEP_PLATFORM_STATE$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_COALESCING_POWERDOWN_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_COALESCING_POWERDOWN_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT
     * }
     */
    public static GroupLayout GUID_DISK_COALESCING_POWERDOWN_TIMEOUT$layout() {
        return GUID_DISK_COALESCING_POWERDOWN_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT
     * }
     */
    public static MemorySegment GUID_DISK_COALESCING_POWERDOWN_TIMEOUT() {
        return GUID_DISK_COALESCING_POWERDOWN_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT
     * }
     */
    public static void GUID_DISK_COALESCING_POWERDOWN_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_COALESCING_POWERDOWN_TIMEOUT$constants.SEGMENT, 0L, GUID_DISK_COALESCING_POWERDOWN_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT
     * }
     */
    public static GroupLayout GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT$layout() {
        return GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT
     * }
     */
    public static MemorySegment GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT() {
        return GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT
     * }
     */
    public static void GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT$constants.SEGMENT, 0L, GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_SUBGROUP
     * }
     */
    public static GroupLayout GUID_VIDEO_SUBGROUP$layout() {
        return GUID_VIDEO_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_SUBGROUP
     * }
     */
    public static MemorySegment GUID_VIDEO_SUBGROUP() {
        return GUID_VIDEO_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_SUBGROUP
     * }
     */
    public static void GUID_VIDEO_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_SUBGROUP$constants.SEGMENT, 0L, GUID_VIDEO_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_POWERDOWN_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_POWERDOWN_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_POWERDOWN_TIMEOUT
     * }
     */
    public static GroupLayout GUID_VIDEO_POWERDOWN_TIMEOUT$layout() {
        return GUID_VIDEO_POWERDOWN_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_POWERDOWN_TIMEOUT
     * }
     */
    public static MemorySegment GUID_VIDEO_POWERDOWN_TIMEOUT() {
        return GUID_VIDEO_POWERDOWN_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_POWERDOWN_TIMEOUT
     * }
     */
    public static void GUID_VIDEO_POWERDOWN_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_POWERDOWN_TIMEOUT$constants.SEGMENT, 0L, GUID_VIDEO_POWERDOWN_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_ANNOYANCE_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_ANNOYANCE_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT
     * }
     */
    public static GroupLayout GUID_VIDEO_ANNOYANCE_TIMEOUT$layout() {
        return GUID_VIDEO_ANNOYANCE_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT
     * }
     */
    public static MemorySegment GUID_VIDEO_ANNOYANCE_TIMEOUT() {
        return GUID_VIDEO_ANNOYANCE_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT
     * }
     */
    public static void GUID_VIDEO_ANNOYANCE_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_ANNOYANCE_TIMEOUT$constants.SEGMENT, 0L, GUID_VIDEO_ANNOYANCE_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE
     * }
     */
    public static GroupLayout GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE$layout() {
        return GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE
     * }
     */
    public static MemorySegment GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE() {
        return GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE
     * }
     */
    public static void GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE$constants.SEGMENT, 0L, GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_DIM_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_DIM_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_DIM_TIMEOUT
     * }
     */
    public static GroupLayout GUID_VIDEO_DIM_TIMEOUT$layout() {
        return GUID_VIDEO_DIM_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_DIM_TIMEOUT
     * }
     */
    public static MemorySegment GUID_VIDEO_DIM_TIMEOUT() {
        return GUID_VIDEO_DIM_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_DIM_TIMEOUT
     * }
     */
    public static void GUID_VIDEO_DIM_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_DIM_TIMEOUT$constants.SEGMENT, 0L, GUID_VIDEO_DIM_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_ADAPTIVE_POWERDOWN$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_ADAPTIVE_POWERDOWN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN
     * }
     */
    public static GroupLayout GUID_VIDEO_ADAPTIVE_POWERDOWN$layout() {
        return GUID_VIDEO_ADAPTIVE_POWERDOWN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN
     * }
     */
    public static MemorySegment GUID_VIDEO_ADAPTIVE_POWERDOWN() {
        return GUID_VIDEO_ADAPTIVE_POWERDOWN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN
     * }
     */
    public static void GUID_VIDEO_ADAPTIVE_POWERDOWN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_ADAPTIVE_POWERDOWN$constants.SEGMENT, 0L, GUID_VIDEO_ADAPTIVE_POWERDOWN$constants.LAYOUT.byteSize());
    }

    private static class GUID_MONITOR_POWER_ON$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_MONITOR_POWER_ON").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MONITOR_POWER_ON
     * }
     */
    public static GroupLayout GUID_MONITOR_POWER_ON$layout() {
        return GUID_MONITOR_POWER_ON$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MONITOR_POWER_ON
     * }
     */
    public static MemorySegment GUID_MONITOR_POWER_ON() {
        return GUID_MONITOR_POWER_ON$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_MONITOR_POWER_ON
     * }
     */
    public static void GUID_MONITOR_POWER_ON(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_MONITOR_POWER_ON$constants.SEGMENT, 0L, GUID_MONITOR_POWER_ON$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS
     * }
     */
    public static GroupLayout GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS$layout() {
        return GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS
     * }
     */
    public static MemorySegment GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS() {
        return GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS
     * }
     */
    public static void GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS$constants.SEGMENT, 0L, GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS$constants.LAYOUT.byteSize());
    }

    private static class GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS
     * }
     */
    public static GroupLayout GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS$layout() {
        return GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS
     * }
     */
    public static MemorySegment GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS() {
        return GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS
     * }
     */
    public static void GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS$constants.SEGMENT, 0L, GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS
     * }
     */
    public static GroupLayout GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS$layout() {
        return GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS
     * }
     */
    public static MemorySegment GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS() {
        return GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS
     * }
     */
    public static void GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS$constants.SEGMENT, 0L, GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS
     * }
     */
    public static GroupLayout GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS$layout() {
        return GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS
     * }
     */
    public static MemorySegment GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS() {
        return GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS
     * }
     */
    public static void GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS$constants.SEGMENT, 0L, GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS$constants.LAYOUT.byteSize());
    }

    private static class GUID_CONSOLE_DISPLAY_STATE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_CONSOLE_DISPLAY_STATE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_CONSOLE_DISPLAY_STATE
     * }
     */
    public static GroupLayout GUID_CONSOLE_DISPLAY_STATE$layout() {
        return GUID_CONSOLE_DISPLAY_STATE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_CONSOLE_DISPLAY_STATE
     * }
     */
    public static MemorySegment GUID_CONSOLE_DISPLAY_STATE() {
        return GUID_CONSOLE_DISPLAY_STATE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_CONSOLE_DISPLAY_STATE
     * }
     */
    public static void GUID_CONSOLE_DISPLAY_STATE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_CONSOLE_DISPLAY_STATE$constants.SEGMENT, 0L, GUID_CONSOLE_DISPLAY_STATE$constants.LAYOUT.byteSize());
    }

    private static class GUID_ALLOW_DISPLAY_REQUIRED$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ALLOW_DISPLAY_REQUIRED").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_DISPLAY_REQUIRED
     * }
     */
    public static GroupLayout GUID_ALLOW_DISPLAY_REQUIRED$layout() {
        return GUID_ALLOW_DISPLAY_REQUIRED$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_DISPLAY_REQUIRED
     * }
     */
    public static MemorySegment GUID_ALLOW_DISPLAY_REQUIRED() {
        return GUID_ALLOW_DISPLAY_REQUIRED$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_DISPLAY_REQUIRED
     * }
     */
    public static void GUID_ALLOW_DISPLAY_REQUIRED(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ALLOW_DISPLAY_REQUIRED$constants.SEGMENT, 0L, GUID_ALLOW_DISPLAY_REQUIRED$constants.LAYOUT.byteSize());
    }

    private static class GUID_VIDEO_CONSOLE_LOCK_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_VIDEO_CONSOLE_LOCK_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT
     * }
     */
    public static GroupLayout GUID_VIDEO_CONSOLE_LOCK_TIMEOUT$layout() {
        return GUID_VIDEO_CONSOLE_LOCK_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT
     * }
     */
    public static MemorySegment GUID_VIDEO_CONSOLE_LOCK_TIMEOUT() {
        return GUID_VIDEO_CONSOLE_LOCK_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT
     * }
     */
    public static void GUID_VIDEO_CONSOLE_LOCK_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_VIDEO_CONSOLE_LOCK_TIMEOUT$constants.SEGMENT, 0L, GUID_VIDEO_CONSOLE_LOCK_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_ADVANCED_COLOR_QUALITY_BIAS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ADVANCED_COLOR_QUALITY_BIAS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADVANCED_COLOR_QUALITY_BIAS
     * }
     */
    public static GroupLayout GUID_ADVANCED_COLOR_QUALITY_BIAS$layout() {
        return GUID_ADVANCED_COLOR_QUALITY_BIAS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADVANCED_COLOR_QUALITY_BIAS
     * }
     */
    public static MemorySegment GUID_ADVANCED_COLOR_QUALITY_BIAS() {
        return GUID_ADVANCED_COLOR_QUALITY_BIAS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADVANCED_COLOR_QUALITY_BIAS
     * }
     */
    public static void GUID_ADVANCED_COLOR_QUALITY_BIAS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ADVANCED_COLOR_QUALITY_BIAS$constants.SEGMENT, 0L, GUID_ADVANCED_COLOR_QUALITY_BIAS$constants.LAYOUT.byteSize());
    }

    private static class GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP
     * }
     */
    public static GroupLayout GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP$layout() {
        return GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP
     * }
     */
    public static MemorySegment GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP() {
        return GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP
     * }
     */
    public static void GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP$constants.SEGMENT, 0L, GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_NON_ADAPTIVE_INPUT_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_NON_ADAPTIVE_INPUT_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT
     * }
     */
    public static GroupLayout GUID_NON_ADAPTIVE_INPUT_TIMEOUT$layout() {
        return GUID_NON_ADAPTIVE_INPUT_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT
     * }
     */
    public static MemorySegment GUID_NON_ADAPTIVE_INPUT_TIMEOUT() {
        return GUID_NON_ADAPTIVE_INPUT_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT
     * }
     */
    public static void GUID_NON_ADAPTIVE_INPUT_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_NON_ADAPTIVE_INPUT_TIMEOUT$constants.SEGMENT, 0L, GUID_NON_ADAPTIVE_INPUT_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_ADAPTIVE_INPUT_CONTROLLER_STATE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ADAPTIVE_INPUT_CONTROLLER_STATE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADAPTIVE_INPUT_CONTROLLER_STATE
     * }
     */
    public static GroupLayout GUID_ADAPTIVE_INPUT_CONTROLLER_STATE$layout() {
        return GUID_ADAPTIVE_INPUT_CONTROLLER_STATE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADAPTIVE_INPUT_CONTROLLER_STATE
     * }
     */
    public static MemorySegment GUID_ADAPTIVE_INPUT_CONTROLLER_STATE() {
        return GUID_ADAPTIVE_INPUT_CONTROLLER_STATE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ADAPTIVE_INPUT_CONTROLLER_STATE
     * }
     */
    public static void GUID_ADAPTIVE_INPUT_CONTROLLER_STATE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ADAPTIVE_INPUT_CONTROLLER_STATE$constants.SEGMENT, 0L, GUID_ADAPTIVE_INPUT_CONTROLLER_STATE$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_SUBGROUP
     * }
     */
    public static GroupLayout GUID_DISK_SUBGROUP$layout() {
        return GUID_DISK_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_SUBGROUP
     * }
     */
    public static MemorySegment GUID_DISK_SUBGROUP() {
        return GUID_DISK_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_SUBGROUP
     * }
     */
    public static void GUID_DISK_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_SUBGROUP$constants.SEGMENT, 0L, GUID_DISK_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_MAX_POWER$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_MAX_POWER").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_MAX_POWER
     * }
     */
    public static GroupLayout GUID_DISK_MAX_POWER$layout() {
        return GUID_DISK_MAX_POWER$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_MAX_POWER
     * }
     */
    public static MemorySegment GUID_DISK_MAX_POWER() {
        return GUID_DISK_MAX_POWER$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_MAX_POWER
     * }
     */
    public static void GUID_DISK_MAX_POWER(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_MAX_POWER$constants.SEGMENT, 0L, GUID_DISK_MAX_POWER$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_POWERDOWN_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_POWERDOWN_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_POWERDOWN_TIMEOUT
     * }
     */
    public static GroupLayout GUID_DISK_POWERDOWN_TIMEOUT$layout() {
        return GUID_DISK_POWERDOWN_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_POWERDOWN_TIMEOUT
     * }
     */
    public static MemorySegment GUID_DISK_POWERDOWN_TIMEOUT() {
        return GUID_DISK_POWERDOWN_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_POWERDOWN_TIMEOUT
     * }
     */
    public static void GUID_DISK_POWERDOWN_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_POWERDOWN_TIMEOUT$constants.SEGMENT, 0L, GUID_DISK_POWERDOWN_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_IDLE_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_IDLE_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_IDLE_TIMEOUT
     * }
     */
    public static GroupLayout GUID_DISK_IDLE_TIMEOUT$layout() {
        return GUID_DISK_IDLE_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_IDLE_TIMEOUT
     * }
     */
    public static MemorySegment GUID_DISK_IDLE_TIMEOUT() {
        return GUID_DISK_IDLE_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_IDLE_TIMEOUT
     * }
     */
    public static void GUID_DISK_IDLE_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_IDLE_TIMEOUT$constants.SEGMENT, 0L, GUID_DISK_IDLE_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_BURST_IGNORE_THRESHOLD$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_BURST_IGNORE_THRESHOLD").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_BURST_IGNORE_THRESHOLD
     * }
     */
    public static GroupLayout GUID_DISK_BURST_IGNORE_THRESHOLD$layout() {
        return GUID_DISK_BURST_IGNORE_THRESHOLD$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_BURST_IGNORE_THRESHOLD
     * }
     */
    public static MemorySegment GUID_DISK_BURST_IGNORE_THRESHOLD() {
        return GUID_DISK_BURST_IGNORE_THRESHOLD$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_BURST_IGNORE_THRESHOLD
     * }
     */
    public static void GUID_DISK_BURST_IGNORE_THRESHOLD(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_BURST_IGNORE_THRESHOLD$constants.SEGMENT, 0L, GUID_DISK_BURST_IGNORE_THRESHOLD$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_ADAPTIVE_POWERDOWN$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_ADAPTIVE_POWERDOWN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_ADAPTIVE_POWERDOWN
     * }
     */
    public static GroupLayout GUID_DISK_ADAPTIVE_POWERDOWN$layout() {
        return GUID_DISK_ADAPTIVE_POWERDOWN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_ADAPTIVE_POWERDOWN
     * }
     */
    public static MemorySegment GUID_DISK_ADAPTIVE_POWERDOWN() {
        return GUID_DISK_ADAPTIVE_POWERDOWN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_ADAPTIVE_POWERDOWN
     * }
     */
    public static void GUID_DISK_ADAPTIVE_POWERDOWN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_ADAPTIVE_POWERDOWN$constants.SEGMENT, 0L, GUID_DISK_ADAPTIVE_POWERDOWN$constants.LAYOUT.byteSize());
    }

    private static class GUID_DISK_NVME_NOPPME$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_DISK_NVME_NOPPME").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_NVME_NOPPME
     * }
     */
    public static GroupLayout GUID_DISK_NVME_NOPPME$layout() {
        return GUID_DISK_NVME_NOPPME$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_NVME_NOPPME
     * }
     */
    public static MemorySegment GUID_DISK_NVME_NOPPME() {
        return GUID_DISK_NVME_NOPPME$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_DISK_NVME_NOPPME
     * }
     */
    public static void GUID_DISK_NVME_NOPPME(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_DISK_NVME_NOPPME$constants.SEGMENT, 0L, GUID_DISK_NVME_NOPPME$constants.LAYOUT.byteSize());
    }

    private static class GUID_SLEEP_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_SLEEP_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEP_SUBGROUP
     * }
     */
    public static GroupLayout GUID_SLEEP_SUBGROUP$layout() {
        return GUID_SLEEP_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEP_SUBGROUP
     * }
     */
    public static MemorySegment GUID_SLEEP_SUBGROUP() {
        return GUID_SLEEP_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEP_SUBGROUP
     * }
     */
    public static void GUID_SLEEP_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_SLEEP_SUBGROUP$constants.SEGMENT, 0L, GUID_SLEEP_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_SLEEP_IDLE_THRESHOLD$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_SLEEP_IDLE_THRESHOLD").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEP_IDLE_THRESHOLD
     * }
     */
    public static GroupLayout GUID_SLEEP_IDLE_THRESHOLD$layout() {
        return GUID_SLEEP_IDLE_THRESHOLD$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEP_IDLE_THRESHOLD
     * }
     */
    public static MemorySegment GUID_SLEEP_IDLE_THRESHOLD() {
        return GUID_SLEEP_IDLE_THRESHOLD$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEP_IDLE_THRESHOLD
     * }
     */
    public static void GUID_SLEEP_IDLE_THRESHOLD(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_SLEEP_IDLE_THRESHOLD$constants.SEGMENT, 0L, GUID_SLEEP_IDLE_THRESHOLD$constants.LAYOUT.byteSize());
    }

    private static class GUID_STANDBY_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_STANDBY_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_TIMEOUT
     * }
     */
    public static GroupLayout GUID_STANDBY_TIMEOUT$layout() {
        return GUID_STANDBY_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_TIMEOUT
     * }
     */
    public static MemorySegment GUID_STANDBY_TIMEOUT() {
        return GUID_STANDBY_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_TIMEOUT
     * }
     */
    public static void GUID_STANDBY_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_STANDBY_TIMEOUT$constants.SEGMENT, 0L, GUID_STANDBY_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_UNATTEND_SLEEP_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_UNATTEND_SLEEP_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_UNATTEND_SLEEP_TIMEOUT
     * }
     */
    public static GroupLayout GUID_UNATTEND_SLEEP_TIMEOUT$layout() {
        return GUID_UNATTEND_SLEEP_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_UNATTEND_SLEEP_TIMEOUT
     * }
     */
    public static MemorySegment GUID_UNATTEND_SLEEP_TIMEOUT() {
        return GUID_UNATTEND_SLEEP_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_UNATTEND_SLEEP_TIMEOUT
     * }
     */
    public static void GUID_UNATTEND_SLEEP_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_UNATTEND_SLEEP_TIMEOUT$constants.SEGMENT, 0L, GUID_UNATTEND_SLEEP_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_HIBERNATE_TIMEOUT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_HIBERNATE_TIMEOUT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_HIBERNATE_TIMEOUT
     * }
     */
    public static GroupLayout GUID_HIBERNATE_TIMEOUT$layout() {
        return GUID_HIBERNATE_TIMEOUT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_HIBERNATE_TIMEOUT
     * }
     */
    public static MemorySegment GUID_HIBERNATE_TIMEOUT() {
        return GUID_HIBERNATE_TIMEOUT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_HIBERNATE_TIMEOUT
     * }
     */
    public static void GUID_HIBERNATE_TIMEOUT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_HIBERNATE_TIMEOUT$constants.SEGMENT, 0L, GUID_HIBERNATE_TIMEOUT$constants.LAYOUT.byteSize());
    }

    private static class GUID_HIBERNATE_FASTS4_POLICY$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_HIBERNATE_FASTS4_POLICY").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_HIBERNATE_FASTS4_POLICY
     * }
     */
    public static GroupLayout GUID_HIBERNATE_FASTS4_POLICY$layout() {
        return GUID_HIBERNATE_FASTS4_POLICY$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_HIBERNATE_FASTS4_POLICY
     * }
     */
    public static MemorySegment GUID_HIBERNATE_FASTS4_POLICY() {
        return GUID_HIBERNATE_FASTS4_POLICY$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_HIBERNATE_FASTS4_POLICY
     * }
     */
    public static void GUID_HIBERNATE_FASTS4_POLICY(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_HIBERNATE_FASTS4_POLICY$constants.SEGMENT, 0L, GUID_HIBERNATE_FASTS4_POLICY$constants.LAYOUT.byteSize());
    }

    private static class GUID_CRITICAL_POWER_TRANSITION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_CRITICAL_POWER_TRANSITION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_CRITICAL_POWER_TRANSITION
     * }
     */
    public static GroupLayout GUID_CRITICAL_POWER_TRANSITION$layout() {
        return GUID_CRITICAL_POWER_TRANSITION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_CRITICAL_POWER_TRANSITION
     * }
     */
    public static MemorySegment GUID_CRITICAL_POWER_TRANSITION() {
        return GUID_CRITICAL_POWER_TRANSITION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_CRITICAL_POWER_TRANSITION
     * }
     */
    public static void GUID_CRITICAL_POWER_TRANSITION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_CRITICAL_POWER_TRANSITION$constants.SEGMENT, 0L, GUID_CRITICAL_POWER_TRANSITION$constants.LAYOUT.byteSize());
    }

    private static class GUID_SYSTEM_AWAYMODE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_SYSTEM_AWAYMODE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SYSTEM_AWAYMODE
     * }
     */
    public static GroupLayout GUID_SYSTEM_AWAYMODE$layout() {
        return GUID_SYSTEM_AWAYMODE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SYSTEM_AWAYMODE
     * }
     */
    public static MemorySegment GUID_SYSTEM_AWAYMODE() {
        return GUID_SYSTEM_AWAYMODE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SYSTEM_AWAYMODE
     * }
     */
    public static void GUID_SYSTEM_AWAYMODE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_SYSTEM_AWAYMODE$constants.SEGMENT, 0L, GUID_SYSTEM_AWAYMODE$constants.LAYOUT.byteSize());
    }

    private static class GUID_ALLOW_AWAYMODE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ALLOW_AWAYMODE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_AWAYMODE
     * }
     */
    public static GroupLayout GUID_ALLOW_AWAYMODE$layout() {
        return GUID_ALLOW_AWAYMODE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_AWAYMODE
     * }
     */
    public static MemorySegment GUID_ALLOW_AWAYMODE() {
        return GUID_ALLOW_AWAYMODE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_AWAYMODE
     * }
     */
    public static void GUID_ALLOW_AWAYMODE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ALLOW_AWAYMODE$constants.SEGMENT, 0L, GUID_ALLOW_AWAYMODE$constants.LAYOUT.byteSize());
    }

    private static class GUID_USER_PRESENCE_PREDICTION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_USER_PRESENCE_PREDICTION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_USER_PRESENCE_PREDICTION
     * }
     */
    public static GroupLayout GUID_USER_PRESENCE_PREDICTION$layout() {
        return GUID_USER_PRESENCE_PREDICTION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_USER_PRESENCE_PREDICTION
     * }
     */
    public static MemorySegment GUID_USER_PRESENCE_PREDICTION() {
        return GUID_USER_PRESENCE_PREDICTION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_USER_PRESENCE_PREDICTION
     * }
     */
    public static void GUID_USER_PRESENCE_PREDICTION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_USER_PRESENCE_PREDICTION$constants.SEGMENT, 0L, GUID_USER_PRESENCE_PREDICTION$constants.LAYOUT.byteSize());
    }

    private static class GUID_STANDBY_BUDGET_GRACE_PERIOD$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_STANDBY_BUDGET_GRACE_PERIOD").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_BUDGET_GRACE_PERIOD
     * }
     */
    public static GroupLayout GUID_STANDBY_BUDGET_GRACE_PERIOD$layout() {
        return GUID_STANDBY_BUDGET_GRACE_PERIOD$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_BUDGET_GRACE_PERIOD
     * }
     */
    public static MemorySegment GUID_STANDBY_BUDGET_GRACE_PERIOD() {
        return GUID_STANDBY_BUDGET_GRACE_PERIOD$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_BUDGET_GRACE_PERIOD
     * }
     */
    public static void GUID_STANDBY_BUDGET_GRACE_PERIOD(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_STANDBY_BUDGET_GRACE_PERIOD$constants.SEGMENT, 0L, GUID_STANDBY_BUDGET_GRACE_PERIOD$constants.LAYOUT.byteSize());
    }

    private static class GUID_STANDBY_BUDGET_PERCENT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_STANDBY_BUDGET_PERCENT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_BUDGET_PERCENT
     * }
     */
    public static GroupLayout GUID_STANDBY_BUDGET_PERCENT$layout() {
        return GUID_STANDBY_BUDGET_PERCENT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_BUDGET_PERCENT
     * }
     */
    public static MemorySegment GUID_STANDBY_BUDGET_PERCENT() {
        return GUID_STANDBY_BUDGET_PERCENT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_BUDGET_PERCENT
     * }
     */
    public static void GUID_STANDBY_BUDGET_PERCENT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_STANDBY_BUDGET_PERCENT$constants.SEGMENT, 0L, GUID_STANDBY_BUDGET_PERCENT$constants.LAYOUT.byteSize());
    }

    private static class GUID_STANDBY_RESERVE_GRACE_PERIOD$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_STANDBY_RESERVE_GRACE_PERIOD").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESERVE_GRACE_PERIOD
     * }
     */
    public static GroupLayout GUID_STANDBY_RESERVE_GRACE_PERIOD$layout() {
        return GUID_STANDBY_RESERVE_GRACE_PERIOD$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESERVE_GRACE_PERIOD
     * }
     */
    public static MemorySegment GUID_STANDBY_RESERVE_GRACE_PERIOD() {
        return GUID_STANDBY_RESERVE_GRACE_PERIOD$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESERVE_GRACE_PERIOD
     * }
     */
    public static void GUID_STANDBY_RESERVE_GRACE_PERIOD(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_STANDBY_RESERVE_GRACE_PERIOD$constants.SEGMENT, 0L, GUID_STANDBY_RESERVE_GRACE_PERIOD$constants.LAYOUT.byteSize());
    }

    private static class GUID_STANDBY_RESERVE_TIME$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_STANDBY_RESERVE_TIME").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESERVE_TIME
     * }
     */
    public static GroupLayout GUID_STANDBY_RESERVE_TIME$layout() {
        return GUID_STANDBY_RESERVE_TIME$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESERVE_TIME
     * }
     */
    public static MemorySegment GUID_STANDBY_RESERVE_TIME() {
        return GUID_STANDBY_RESERVE_TIME$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESERVE_TIME
     * }
     */
    public static void GUID_STANDBY_RESERVE_TIME(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_STANDBY_RESERVE_TIME$constants.SEGMENT, 0L, GUID_STANDBY_RESERVE_TIME$constants.LAYOUT.byteSize());
    }

    private static class GUID_STANDBY_RESET_PERCENT$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_STANDBY_RESET_PERCENT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESET_PERCENT
     * }
     */
    public static GroupLayout GUID_STANDBY_RESET_PERCENT$layout() {
        return GUID_STANDBY_RESET_PERCENT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESET_PERCENT
     * }
     */
    public static MemorySegment GUID_STANDBY_RESET_PERCENT() {
        return GUID_STANDBY_RESET_PERCENT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_STANDBY_RESET_PERCENT
     * }
     */
    public static void GUID_STANDBY_RESET_PERCENT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_STANDBY_RESET_PERCENT$constants.SEGMENT, 0L, GUID_STANDBY_RESET_PERCENT$constants.LAYOUT.byteSize());
    }

    private static class GUID_ALLOW_STANDBY_STATES$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ALLOW_STANDBY_STATES").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_STANDBY_STATES
     * }
     */
    public static GroupLayout GUID_ALLOW_STANDBY_STATES$layout() {
        return GUID_ALLOW_STANDBY_STATES$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_STANDBY_STATES
     * }
     */
    public static MemorySegment GUID_ALLOW_STANDBY_STATES() {
        return GUID_ALLOW_STANDBY_STATES$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_STANDBY_STATES
     * }
     */
    public static void GUID_ALLOW_STANDBY_STATES(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ALLOW_STANDBY_STATES$constants.SEGMENT, 0L, GUID_ALLOW_STANDBY_STATES$constants.LAYOUT.byteSize());
    }

    private static class GUID_ALLOW_RTC_WAKE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ALLOW_RTC_WAKE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_RTC_WAKE
     * }
     */
    public static GroupLayout GUID_ALLOW_RTC_WAKE$layout() {
        return GUID_ALLOW_RTC_WAKE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_RTC_WAKE
     * }
     */
    public static MemorySegment GUID_ALLOW_RTC_WAKE() {
        return GUID_ALLOW_RTC_WAKE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_RTC_WAKE
     * }
     */
    public static void GUID_ALLOW_RTC_WAKE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ALLOW_RTC_WAKE$constants.SEGMENT, 0L, GUID_ALLOW_RTC_WAKE$constants.LAYOUT.byteSize());
    }

    private static class GUID_LEGACY_RTC_MITIGATION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_LEGACY_RTC_MITIGATION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LEGACY_RTC_MITIGATION
     * }
     */
    public static GroupLayout GUID_LEGACY_RTC_MITIGATION$layout() {
        return GUID_LEGACY_RTC_MITIGATION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LEGACY_RTC_MITIGATION
     * }
     */
    public static MemorySegment GUID_LEGACY_RTC_MITIGATION() {
        return GUID_LEGACY_RTC_MITIGATION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LEGACY_RTC_MITIGATION
     * }
     */
    public static void GUID_LEGACY_RTC_MITIGATION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_LEGACY_RTC_MITIGATION$constants.SEGMENT, 0L, GUID_LEGACY_RTC_MITIGATION$constants.LAYOUT.byteSize());
    }

    private static class GUID_ALLOW_SYSTEM_REQUIRED$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ALLOW_SYSTEM_REQUIRED").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_SYSTEM_REQUIRED
     * }
     */
    public static GroupLayout GUID_ALLOW_SYSTEM_REQUIRED$layout() {
        return GUID_ALLOW_SYSTEM_REQUIRED$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_SYSTEM_REQUIRED
     * }
     */
    public static MemorySegment GUID_ALLOW_SYSTEM_REQUIRED() {
        return GUID_ALLOW_SYSTEM_REQUIRED$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ALLOW_SYSTEM_REQUIRED
     * }
     */
    public static void GUID_ALLOW_SYSTEM_REQUIRED(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ALLOW_SYSTEM_REQUIRED$constants.SEGMENT, 0L, GUID_ALLOW_SYSTEM_REQUIRED$constants.LAYOUT.byteSize());
    }

    private static class GUID_POWER_SAVING_STATUS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_POWER_SAVING_STATUS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWER_SAVING_STATUS
     * }
     */
    public static GroupLayout GUID_POWER_SAVING_STATUS$layout() {
        return GUID_POWER_SAVING_STATUS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWER_SAVING_STATUS
     * }
     */
    public static MemorySegment GUID_POWER_SAVING_STATUS() {
        return GUID_POWER_SAVING_STATUS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWER_SAVING_STATUS
     * }
     */
    public static void GUID_POWER_SAVING_STATUS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_POWER_SAVING_STATUS$constants.SEGMENT, 0L, GUID_POWER_SAVING_STATUS$constants.LAYOUT.byteSize());
    }

    private static class GUID_ENERGY_SAVER_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ENERGY_SAVER_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_SUBGROUP
     * }
     */
    public static GroupLayout GUID_ENERGY_SAVER_SUBGROUP$layout() {
        return GUID_ENERGY_SAVER_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_SUBGROUP
     * }
     */
    public static MemorySegment GUID_ENERGY_SAVER_SUBGROUP() {
        return GUID_ENERGY_SAVER_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_SUBGROUP
     * }
     */
    public static void GUID_ENERGY_SAVER_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ENERGY_SAVER_SUBGROUP$constants.SEGMENT, 0L, GUID_ENERGY_SAVER_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_ENERGY_SAVER_BATTERY_THRESHOLD$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ENERGY_SAVER_BATTERY_THRESHOLD").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_BATTERY_THRESHOLD
     * }
     */
    public static GroupLayout GUID_ENERGY_SAVER_BATTERY_THRESHOLD$layout() {
        return GUID_ENERGY_SAVER_BATTERY_THRESHOLD$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_BATTERY_THRESHOLD
     * }
     */
    public static MemorySegment GUID_ENERGY_SAVER_BATTERY_THRESHOLD() {
        return GUID_ENERGY_SAVER_BATTERY_THRESHOLD$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_BATTERY_THRESHOLD
     * }
     */
    public static void GUID_ENERGY_SAVER_BATTERY_THRESHOLD(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ENERGY_SAVER_BATTERY_THRESHOLD$constants.SEGMENT, 0L, GUID_ENERGY_SAVER_BATTERY_THRESHOLD$constants.LAYOUT.byteSize());
    }

    private static class GUID_ENERGY_SAVER_BRIGHTNESS$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ENERGY_SAVER_BRIGHTNESS").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_BRIGHTNESS
     * }
     */
    public static GroupLayout GUID_ENERGY_SAVER_BRIGHTNESS$layout() {
        return GUID_ENERGY_SAVER_BRIGHTNESS$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_BRIGHTNESS
     * }
     */
    public static MemorySegment GUID_ENERGY_SAVER_BRIGHTNESS() {
        return GUID_ENERGY_SAVER_BRIGHTNESS$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_BRIGHTNESS
     * }
     */
    public static void GUID_ENERGY_SAVER_BRIGHTNESS(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ENERGY_SAVER_BRIGHTNESS$constants.SEGMENT, 0L, GUID_ENERGY_SAVER_BRIGHTNESS$constants.LAYOUT.byteSize());
    }

    private static class GUID_ENERGY_SAVER_POLICY$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_ENERGY_SAVER_POLICY").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_POLICY
     * }
     */
    public static GroupLayout GUID_ENERGY_SAVER_POLICY$layout() {
        return GUID_ENERGY_SAVER_POLICY$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_POLICY
     * }
     */
    public static MemorySegment GUID_ENERGY_SAVER_POLICY() {
        return GUID_ENERGY_SAVER_POLICY$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_ENERGY_SAVER_POLICY
     * }
     */
    public static void GUID_ENERGY_SAVER_POLICY(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_ENERGY_SAVER_POLICY$constants.SEGMENT, 0L, GUID_ENERGY_SAVER_POLICY$constants.LAYOUT.byteSize());
    }

    private static class GUID_SYSTEM_BUTTON_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_SYSTEM_BUTTON_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SYSTEM_BUTTON_SUBGROUP
     * }
     */
    public static GroupLayout GUID_SYSTEM_BUTTON_SUBGROUP$layout() {
        return GUID_SYSTEM_BUTTON_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SYSTEM_BUTTON_SUBGROUP
     * }
     */
    public static MemorySegment GUID_SYSTEM_BUTTON_SUBGROUP() {
        return GUID_SYSTEM_BUTTON_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SYSTEM_BUTTON_SUBGROUP
     * }
     */
    public static void GUID_SYSTEM_BUTTON_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_SYSTEM_BUTTON_SUBGROUP$constants.SEGMENT, 0L, GUID_SYSTEM_BUTTON_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_POWERBUTTON_ACTION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_POWERBUTTON_ACTION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWERBUTTON_ACTION
     * }
     */
    public static GroupLayout GUID_POWERBUTTON_ACTION$layout() {
        return GUID_POWERBUTTON_ACTION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWERBUTTON_ACTION
     * }
     */
    public static MemorySegment GUID_POWERBUTTON_ACTION() {
        return GUID_POWERBUTTON_ACTION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_POWERBUTTON_ACTION
     * }
     */
    public static void GUID_POWERBUTTON_ACTION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_POWERBUTTON_ACTION$constants.SEGMENT, 0L, GUID_POWERBUTTON_ACTION$constants.LAYOUT.byteSize());
    }

    private static class GUID_SLEEPBUTTON_ACTION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_SLEEPBUTTON_ACTION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEPBUTTON_ACTION
     * }
     */
    public static GroupLayout GUID_SLEEPBUTTON_ACTION$layout() {
        return GUID_SLEEPBUTTON_ACTION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEPBUTTON_ACTION
     * }
     */
    public static MemorySegment GUID_SLEEPBUTTON_ACTION() {
        return GUID_SLEEPBUTTON_ACTION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_SLEEPBUTTON_ACTION
     * }
     */
    public static void GUID_SLEEPBUTTON_ACTION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_SLEEPBUTTON_ACTION$constants.SEGMENT, 0L, GUID_SLEEPBUTTON_ACTION$constants.LAYOUT.byteSize());
    }

    private static class GUID_USERINTERFACEBUTTON_ACTION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_USERINTERFACEBUTTON_ACTION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_USERINTERFACEBUTTON_ACTION
     * }
     */
    public static GroupLayout GUID_USERINTERFACEBUTTON_ACTION$layout() {
        return GUID_USERINTERFACEBUTTON_ACTION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_USERINTERFACEBUTTON_ACTION
     * }
     */
    public static MemorySegment GUID_USERINTERFACEBUTTON_ACTION() {
        return GUID_USERINTERFACEBUTTON_ACTION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_USERINTERFACEBUTTON_ACTION
     * }
     */
    public static void GUID_USERINTERFACEBUTTON_ACTION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_USERINTERFACEBUTTON_ACTION$constants.SEGMENT, 0L, GUID_USERINTERFACEBUTTON_ACTION$constants.LAYOUT.byteSize());
    }

    private static class GUID_LIDCLOSE_ACTION$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_LIDCLOSE_ACTION").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LIDCLOSE_ACTION
     * }
     */
    public static GroupLayout GUID_LIDCLOSE_ACTION$layout() {
        return GUID_LIDCLOSE_ACTION$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LIDCLOSE_ACTION
     * }
     */
    public static MemorySegment GUID_LIDCLOSE_ACTION() {
        return GUID_LIDCLOSE_ACTION$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LIDCLOSE_ACTION
     * }
     */
    public static void GUID_LIDCLOSE_ACTION(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_LIDCLOSE_ACTION$constants.SEGMENT, 0L, GUID_LIDCLOSE_ACTION$constants.LAYOUT.byteSize());
    }

    private static class GUID_LIDOPEN_POWERSTATE$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_LIDOPEN_POWERSTATE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LIDOPEN_POWERSTATE
     * }
     */
    public static GroupLayout GUID_LIDOPEN_POWERSTATE$layout() {
        return GUID_LIDOPEN_POWERSTATE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LIDOPEN_POWERSTATE
     * }
     */
    public static MemorySegment GUID_LIDOPEN_POWERSTATE() {
        return GUID_LIDOPEN_POWERSTATE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_LIDOPEN_POWERSTATE
     * }
     */
    public static void GUID_LIDOPEN_POWERSTATE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_LIDOPEN_POWERSTATE$constants.SEGMENT, 0L, GUID_LIDOPEN_POWERSTATE$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_SUBGROUP
     * }
     */
    public static GroupLayout GUID_BATTERY_SUBGROUP$layout() {
        return GUID_BATTERY_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_SUBGROUP
     * }
     */
    public static MemorySegment GUID_BATTERY_SUBGROUP() {
        return GUID_BATTERY_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_SUBGROUP
     * }
     */
    public static void GUID_BATTERY_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_SUBGROUP$constants.SEGMENT, 0L, GUID_BATTERY_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_ACTION_0$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_ACTION_0").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_0
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_ACTION_0$layout() {
        return GUID_BATTERY_DISCHARGE_ACTION_0$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_0
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_ACTION_0() {
        return GUID_BATTERY_DISCHARGE_ACTION_0$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_0
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_ACTION_0(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_ACTION_0$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_ACTION_0$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_LEVEL_0$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_LEVEL_0").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_0
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_LEVEL_0$layout() {
        return GUID_BATTERY_DISCHARGE_LEVEL_0$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_0
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_LEVEL_0() {
        return GUID_BATTERY_DISCHARGE_LEVEL_0$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_0
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_LEVEL_0(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_LEVEL_0$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_LEVEL_0$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_FLAGS_0$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_FLAGS_0").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_0
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_FLAGS_0$layout() {
        return GUID_BATTERY_DISCHARGE_FLAGS_0$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_0
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_FLAGS_0() {
        return GUID_BATTERY_DISCHARGE_FLAGS_0$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_0
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_FLAGS_0(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_FLAGS_0$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_FLAGS_0$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_ACTION_1$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_ACTION_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_1
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_ACTION_1$layout() {
        return GUID_BATTERY_DISCHARGE_ACTION_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_1
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_ACTION_1() {
        return GUID_BATTERY_DISCHARGE_ACTION_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_1
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_ACTION_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_ACTION_1$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_ACTION_1$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_LEVEL_1$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_LEVEL_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_1
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_LEVEL_1$layout() {
        return GUID_BATTERY_DISCHARGE_LEVEL_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_1
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_LEVEL_1() {
        return GUID_BATTERY_DISCHARGE_LEVEL_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_1
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_LEVEL_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_LEVEL_1$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_LEVEL_1$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_FLAGS_1$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_FLAGS_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_1
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_FLAGS_1$layout() {
        return GUID_BATTERY_DISCHARGE_FLAGS_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_1
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_FLAGS_1() {
        return GUID_BATTERY_DISCHARGE_FLAGS_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_1
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_FLAGS_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_FLAGS_1$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_FLAGS_1$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_ACTION_2$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_ACTION_2").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_2
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_ACTION_2$layout() {
        return GUID_BATTERY_DISCHARGE_ACTION_2$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_2
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_ACTION_2() {
        return GUID_BATTERY_DISCHARGE_ACTION_2$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_2
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_ACTION_2(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_ACTION_2$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_ACTION_2$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_LEVEL_2$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_LEVEL_2").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_2
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_LEVEL_2$layout() {
        return GUID_BATTERY_DISCHARGE_LEVEL_2$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_2
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_LEVEL_2() {
        return GUID_BATTERY_DISCHARGE_LEVEL_2$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_2
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_LEVEL_2(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_LEVEL_2$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_LEVEL_2$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_FLAGS_2$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_FLAGS_2").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_2
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_FLAGS_2$layout() {
        return GUID_BATTERY_DISCHARGE_FLAGS_2$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_2
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_FLAGS_2() {
        return GUID_BATTERY_DISCHARGE_FLAGS_2$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_2
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_FLAGS_2(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_FLAGS_2$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_FLAGS_2$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_ACTION_3$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_ACTION_3").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_3
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_ACTION_3$layout() {
        return GUID_BATTERY_DISCHARGE_ACTION_3$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_3
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_ACTION_3() {
        return GUID_BATTERY_DISCHARGE_ACTION_3$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_ACTION_3
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_ACTION_3(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_ACTION_3$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_ACTION_3$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_LEVEL_3$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_LEVEL_3").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_3
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_LEVEL_3$layout() {
        return GUID_BATTERY_DISCHARGE_LEVEL_3$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_3
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_LEVEL_3() {
        return GUID_BATTERY_DISCHARGE_LEVEL_3$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_3
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_LEVEL_3(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_LEVEL_3$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_LEVEL_3$constants.LAYOUT.byteSize());
    }

    private static class GUID_BATTERY_DISCHARGE_FLAGS_3$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_BATTERY_DISCHARGE_FLAGS_3").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_3
     * }
     */
    public static GroupLayout GUID_BATTERY_DISCHARGE_FLAGS_3$layout() {
        return GUID_BATTERY_DISCHARGE_FLAGS_3$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_3
     * }
     */
    public static MemorySegment GUID_BATTERY_DISCHARGE_FLAGS_3() {
        return GUID_BATTERY_DISCHARGE_FLAGS_3$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_3
     * }
     */
    public static void GUID_BATTERY_DISCHARGE_FLAGS_3(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_BATTERY_DISCHARGE_FLAGS_3$constants.SEGMENT, 0L, GUID_BATTERY_DISCHARGE_FLAGS_3$constants.LAYOUT.byteSize());
    }

    private static class GUID_PROCESSOR_SETTINGS_SUBGROUP$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_PROCESSOR_SETTINGS_SUBGROUP").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP
     * }
     */
    public static GroupLayout GUID_PROCESSOR_SETTINGS_SUBGROUP$layout() {
        return GUID_PROCESSOR_SETTINGS_SUBGROUP$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP
     * }
     */
    public static MemorySegment GUID_PROCESSOR_SETTINGS_SUBGROUP() {
        return GUID_PROCESSOR_SETTINGS_SUBGROUP$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP
     * }
     */
    public static void GUID_PROCESSOR_SETTINGS_SUBGROUP(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_PROCESSOR_SETTINGS_SUBGROUP$constants.SEGMENT, 0L, GUID_PROCESSOR_SETTINGS_SUBGROUP$constants.LAYOUT.byteSize());
    }

    private static class GUID_PROCESSOR_THROTTLE_POLICY$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_PROCESSOR_THROTTLE_POLICY").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_POLICY
     * }
     */
    public static GroupLayout GUID_PROCESSOR_THROTTLE_POLICY$layout() {
        return GUID_PROCESSOR_THROTTLE_POLICY$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_POLICY
     * }
     */
    public static MemorySegment GUID_PROCESSOR_THROTTLE_POLICY() {
        return GUID_PROCESSOR_THROTTLE_POLICY$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_POLICY
     * }
     */
    public static void GUID_PROCESSOR_THROTTLE_POLICY(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_PROCESSOR_THROTTLE_POLICY$constants.SEGMENT, 0L, GUID_PROCESSOR_THROTTLE_POLICY$constants.LAYOUT.byteSize());
    }

    private static class GUID_PROCESSOR_THROTTLE_MAXIMUM$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_PROCESSOR_THROTTLE_MAXIMUM").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM
     * }
     */
    public static GroupLayout GUID_PROCESSOR_THROTTLE_MAXIMUM$layout() {
        return GUID_PROCESSOR_THROTTLE_MAXIMUM$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM
     * }
     */
    public static MemorySegment GUID_PROCESSOR_THROTTLE_MAXIMUM() {
        return GUID_PROCESSOR_THROTTLE_MAXIMUM$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM
     * }
     */
    public static void GUID_PROCESSOR_THROTTLE_MAXIMUM(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_PROCESSOR_THROTTLE_MAXIMUM$constants.SEGMENT, 0L, GUID_PROCESSOR_THROTTLE_MAXIMUM$constants.LAYOUT.byteSize());
    }

    private static class GUID_PROCESSOR_THROTTLE_MAXIMUM_1$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("GUID_PROCESSOR_THROTTLE_MAXIMUM_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM_1
     * }
     */
    public static GroupLayout GUID_PROCESSOR_THROTTLE_MAXIMUM_1$layout() {
        return GUID_PROCESSOR_THROTTLE_MAXIMUM_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM_1
     * }
     */
    public static MemorySegment GUID_PROCESSOR_THROTTLE_MAXIMUM_1() {
        return GUID_PROCESSOR_THROTTLE_MAXIMUM_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM_1
     * }
     */
    public static void GUID_PROCESSOR_THROTTLE_MAXIMUM_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, GUID_PROCESSOR_THROTTLE_MAXIMUM_1$constants.SEGMENT, 0L, GUID_PROCESSOR_THROTTLE_MAXIMUM_1$constants.LAYOUT.byteSize());
    }
}

