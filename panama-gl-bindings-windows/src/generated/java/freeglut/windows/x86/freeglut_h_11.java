// Generated by jextract

package freeglut.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h_11 extends freeglut_h_12 {

    freeglut_h_11() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagSOUNDSENTRYW {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iFSTextEffect;
     *     DWORD iFSTextEffectMSec;
     *     DWORD iFSTextEffectColorBits;
     *     DWORD iFSGrafEffect;
     *     DWORD iFSGrafEffectMSec;
     *     DWORD iFSGrafEffectColor;
     *     DWORD iWindowsEffect;
     *     DWORD iWindowsEffectMSec;
     *     LPWSTR lpszWindowsEffectDLL;
     *     DWORD iWindowsEffectOrdinal;
     * } *LPSOUNDSENTRYW
     * }
     */
    public static final AddressLayout LPSOUNDSENTRYW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSOUNDSENTRYA LPSOUNDSENTRY
     * }
     */
    public static final AddressLayout LPSOUNDSENTRY = freeglut_h.C_POINTER;

    private static class SoundSentry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SoundSentry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SoundSentry()
     * }
     */
    public static FunctionDescriptor SoundSentry$descriptor() {
        return SoundSentry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SoundSentry()
     * }
     */
    public static MethodHandle SoundSentry$handle() {
        return SoundSentry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SoundSentry()
     * }
     */
    public static MemorySegment SoundSentry$address() {
        return SoundSentry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SoundSentry()
     * }
     */
    public static int SoundSentry() {
        var mh$ = SoundSentry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SoundSentry");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTOGGLEKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     * } *LPTOGGLEKEYS
     * }
     */
    public static final AddressLayout LPTOGGLEKEYS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUDIODESCRIPTION {
     *     UINT cbSize;
     *     BOOL Enabled;
     *     LCID Locale;
     * } *LPAUDIODESCRIPTION
     * }
     */
    public static final AddressLayout LPAUDIODESCRIPTION = freeglut_h.C_POINTER;

    private static class SetDebugErrorLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDebugErrorLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetDebugErrorLevel(DWORD dwLevel)
     * }
     */
    public static FunctionDescriptor SetDebugErrorLevel$descriptor() {
        return SetDebugErrorLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetDebugErrorLevel(DWORD dwLevel)
     * }
     */
    public static MethodHandle SetDebugErrorLevel$handle() {
        return SetDebugErrorLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetDebugErrorLevel(DWORD dwLevel)
     * }
     */
    public static MemorySegment SetDebugErrorLevel$address() {
        return SetDebugErrorLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetDebugErrorLevel(DWORD dwLevel)
     * }
     */
    public static void SetDebugErrorLevel(int dwLevel) {
        var mh$ = SetDebugErrorLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDebugErrorLevel", dwLevel);
            }
            mh$.invokeExact(dwLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLastErrorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetLastErrorEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLastErrorEx(DWORD dwErrCode, DWORD dwType)
     * }
     */
    public static FunctionDescriptor SetLastErrorEx$descriptor() {
        return SetLastErrorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLastErrorEx(DWORD dwErrCode, DWORD dwType)
     * }
     */
    public static MethodHandle SetLastErrorEx$handle() {
        return SetLastErrorEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetLastErrorEx(DWORD dwErrCode, DWORD dwType)
     * }
     */
    public static MemorySegment SetLastErrorEx$address() {
        return SetLastErrorEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetLastErrorEx(DWORD dwErrCode, DWORD dwType)
     * }
     */
    public static void SetLastErrorEx(int dwErrCode, int dwType) {
        var mh$ = SetLastErrorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLastErrorEx", dwErrCode, dwType);
            }
            mh$.invokeExact(dwErrCode, dwType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InternalGetWindowText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InternalGetWindowText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor InternalGetWindowText$descriptor() {
        return InternalGetWindowText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount)
     * }
     */
    public static MethodHandle InternalGetWindowText$handle() {
        return InternalGetWindowText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount)
     * }
     */
    public static MemorySegment InternalGetWindowText$address() {
        return InternalGetWindowText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount)
     * }
     */
    public static int InternalGetWindowText(MemorySegment hWnd, MemorySegment pString, int cchMaxCount) {
        var mh$ = InternalGetWindowText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InternalGetWindowText", hWnd, pString, cchMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, pString, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelShutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelShutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelShutdown()
     * }
     */
    public static FunctionDescriptor CancelShutdown$descriptor() {
        return CancelShutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelShutdown()
     * }
     */
    public static MethodHandle CancelShutdown$handle() {
        return CancelShutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelShutdown()
     * }
     */
    public static MemorySegment CancelShutdown$address() {
        return CancelShutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelShutdown()
     * }
     */
    public static int CancelShutdown() {
        var mh$ = CancelShutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelShutdown");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MonitorFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            tagPOINT.layout(),
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MonitorFromPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MonitorFromPoint$descriptor() {
        return MonitorFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags)
     * }
     */
    public static MethodHandle MonitorFromPoint$handle() {
        return MonitorFromPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromPoint$address() {
        return MonitorFromPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromPoint(MemorySegment pt, int dwFlags) {
        var mh$ = MonitorFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MonitorFromPoint", pt, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(pt, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MonitorFromRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MonitorFromRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MonitorFromRect$descriptor() {
        return MonitorFromRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
     * }
     */
    public static MethodHandle MonitorFromRect$handle() {
        return MonitorFromRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromRect$address() {
        return MonitorFromRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMONITOR MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromRect(MemorySegment lprc, int dwFlags) {
        var mh$ = MonitorFromRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MonitorFromRect", lprc, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lprc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MonitorFromWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MonitorFromWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromWindow(HWND hwnd, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MonitorFromWindow$descriptor() {
        return MonitorFromWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromWindow(HWND hwnd, DWORD dwFlags)
     * }
     */
    public static MethodHandle MonitorFromWindow$handle() {
        return MonitorFromWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromWindow(HWND hwnd, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromWindow$address() {
        return MonitorFromWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMONITOR MonitorFromWindow(HWND hwnd, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromWindow(MemorySegment hwnd, int dwFlags) {
        var mh$ = MonitorFromWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MonitorFromWindow", hwnd, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMONITORINFO {
     *     DWORD cbSize;
     *     RECT rcMonitor;
     *     RECT rcWork;
     *     DWORD dwFlags;
     * } *LPMONITORINFO
     * }
     */
    public static final AddressLayout LPMONITORINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONITORINFOEXA {
     *     CHAR szDevice[32];
     * } *LPMONITORINFOEXA
     * }
     */
    public static final AddressLayout LPMONITORINFOEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONITORINFOEXW {
     *     WCHAR szDevice[32];
     * } *LPMONITORINFOEXW
     * }
     */
    public static final AddressLayout LPMONITORINFOEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMONITORINFOEXA LPMONITORINFOEX
     * }
     */
    public static final AddressLayout LPMONITORINFOEX = freeglut_h.C_POINTER;

    private static class GetMonitorInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMonitorInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static FunctionDescriptor GetMonitorInfoA$descriptor() {
        return GetMonitorInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static MethodHandle GetMonitorInfoA$handle() {
        return GetMonitorInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static MemorySegment GetMonitorInfoA$address() {
        return GetMonitorInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static int GetMonitorInfoA(MemorySegment hMonitor, MemorySegment lpmi) {
        var mh$ = GetMonitorInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorInfoA", hMonitor, lpmi);
            }
            return (int)mh$.invokeExact(hMonitor, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMonitorInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static FunctionDescriptor GetMonitorInfoW$descriptor() {
        return GetMonitorInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static MethodHandle GetMonitorInfoW$handle() {
        return GetMonitorInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static MemorySegment GetMonitorInfoW$address() {
        return GetMonitorInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static int GetMonitorInfoW(MemorySegment hMonitor, MemorySegment lpmi) {
        var mh$ = GetMonitorInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorInfoW", hMonitor, lpmi);
            }
            return (int)mh$.invokeExact(hMonitor, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplayMonitors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDisplayMonitors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)
     * }
     */
    public static FunctionDescriptor EnumDisplayMonitors$descriptor() {
        return EnumDisplayMonitors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)
     * }
     */
    public static MethodHandle EnumDisplayMonitors$handle() {
        return EnumDisplayMonitors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)
     * }
     */
    public static MemorySegment EnumDisplayMonitors$address() {
        return EnumDisplayMonitors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)
     * }
     */
    public static int EnumDisplayMonitors(MemorySegment hdc, MemorySegment lprcClip, MemorySegment lpfnEnum, long dwData) {
        var mh$ = EnumDisplayMonitors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplayMonitors", hdc, lprcClip, lpfnEnum, dwData);
            }
            return (int)mh$.invokeExact(hdc, lprcClip, lpfnEnum, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyWinEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("NotifyWinEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
     * }
     */
    public static FunctionDescriptor NotifyWinEvent$descriptor() {
        return NotifyWinEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
     * }
     */
    public static MethodHandle NotifyWinEvent$handle() {
        return NotifyWinEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
     * }
     */
    public static MemorySegment NotifyWinEvent$address() {
        return NotifyWinEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
     * }
     */
    public static void NotifyWinEvent(int event, MemorySegment hwnd, int idObject, int idChild) {
        var mh$ = NotifyWinEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyWinEvent", event, hwnd, idObject, idChild);
            }
            mh$.invokeExact(event, hwnd, idObject, idChild);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWinEventHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWinEventHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINEVENTHOOK SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetWinEventHook$descriptor() {
        return SetWinEventHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINEVENTHOOK SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetWinEventHook$handle() {
        return SetWinEventHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWINEVENTHOOK SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetWinEventHook$address() {
        return SetWinEventHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWINEVENTHOOK SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetWinEventHook(int eventMin, int eventMax, MemorySegment hmodWinEventProc, MemorySegment pfnWinEventProc, int idProcess, int idThread, int dwFlags) {
        var mh$ = SetWinEventHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWinEventHook", eventMin, eventMax, hmodWinEventProc, pfnWinEventProc, idProcess, idThread, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(eventMin, eventMax, hmodWinEventProc, pfnWinEventProc, idProcess, idThread, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWinEventHookInstalled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWinEventHookInstalled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWinEventHookInstalled(DWORD event)
     * }
     */
    public static FunctionDescriptor IsWinEventHookInstalled$descriptor() {
        return IsWinEventHookInstalled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWinEventHookInstalled(DWORD event)
     * }
     */
    public static MethodHandle IsWinEventHookInstalled$handle() {
        return IsWinEventHookInstalled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWinEventHookInstalled(DWORD event)
     * }
     */
    public static MemorySegment IsWinEventHookInstalled$address() {
        return IsWinEventHookInstalled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWinEventHookInstalled(DWORD event)
     * }
     */
    public static int IsWinEventHookInstalled(int event) {
        var mh$ = IsWinEventHookInstalled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWinEventHookInstalled", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhookWinEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnhookWinEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnhookWinEvent(HWINEVENTHOOK hWinEventHook)
     * }
     */
    public static FunctionDescriptor UnhookWinEvent$descriptor() {
        return UnhookWinEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnhookWinEvent(HWINEVENTHOOK hWinEventHook)
     * }
     */
    public static MethodHandle UnhookWinEvent$handle() {
        return UnhookWinEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnhookWinEvent(HWINEVENTHOOK hWinEventHook)
     * }
     */
    public static MemorySegment UnhookWinEvent$address() {
        return UnhookWinEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnhookWinEvent(HWINEVENTHOOK hWinEventHook)
     * }
     */
    public static int UnhookWinEvent(MemorySegment hWinEventHook) {
        var mh$ = UnhookWinEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhookWinEvent", hWinEventHook);
            }
            return (int)mh$.invokeExact(hWinEventHook);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagGUITHREADINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HWND hwndActive;
     *     HWND hwndFocus;
     *     HWND hwndCapture;
     *     HWND hwndMenuOwner;
     *     HWND hwndMoveSize;
     *     HWND hwndCaret;
     *     RECT rcCaret;
     * } *PGUITHREADINFO
     * }
     */
    public static final AddressLayout PGUITHREADINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGUITHREADINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HWND hwndActive;
     *     HWND hwndFocus;
     *     HWND hwndCapture;
     *     HWND hwndMenuOwner;
     *     HWND hwndMoveSize;
     *     HWND hwndCaret;
     *     RECT rcCaret;
     * } *LPGUITHREADINFO
     * }
     */
    public static final AddressLayout LPGUITHREADINFO = freeglut_h.C_POINTER;

    private static class GetGUIThreadInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGUIThreadInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui)
     * }
     */
    public static FunctionDescriptor GetGUIThreadInfo$descriptor() {
        return GetGUIThreadInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui)
     * }
     */
    public static MethodHandle GetGUIThreadInfo$handle() {
        return GetGUIThreadInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui)
     * }
     */
    public static MemorySegment GetGUIThreadInfo$address() {
        return GetGUIThreadInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui)
     * }
     */
    public static int GetGUIThreadInfo(int idThread, MemorySegment pgui) {
        var mh$ = GetGUIThreadInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGUIThreadInfo", idThread, pgui);
            }
            return (int)mh$.invokeExact(idThread, pgui);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlockInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BlockInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BlockInput(BOOL fBlockIt)
     * }
     */
    public static FunctionDescriptor BlockInput$descriptor() {
        return BlockInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BlockInput(BOOL fBlockIt)
     * }
     */
    public static MethodHandle BlockInput$handle() {
        return BlockInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BlockInput(BOOL fBlockIt)
     * }
     */
    public static MemorySegment BlockInput$address() {
        return BlockInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BlockInput(BOOL fBlockIt)
     * }
     */
    public static int BlockInput(int fBlockIt) {
        var mh$ = BlockInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlockInput", fBlockIt);
            }
            return (int)mh$.invokeExact(fBlockIt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDPIAware {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessDPIAware");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDPIAware()
     * }
     */
    public static FunctionDescriptor SetProcessDPIAware$descriptor() {
        return SetProcessDPIAware.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDPIAware()
     * }
     */
    public static MethodHandle SetProcessDPIAware$handle() {
        return SetProcessDPIAware.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDPIAware()
     * }
     */
    public static MemorySegment SetProcessDPIAware$address() {
        return SetProcessDPIAware.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDPIAware()
     * }
     */
    public static int SetProcessDPIAware() {
        var mh$ = SetProcessDPIAware.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDPIAware");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessDPIAware {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsProcessDPIAware");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessDPIAware()
     * }
     */
    public static FunctionDescriptor IsProcessDPIAware$descriptor() {
        return IsProcessDPIAware.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessDPIAware()
     * }
     */
    public static MethodHandle IsProcessDPIAware$handle() {
        return IsProcessDPIAware.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsProcessDPIAware()
     * }
     */
    public static MemorySegment IsProcessDPIAware$address() {
        return IsProcessDPIAware.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsProcessDPIAware()
     * }
     */
    public static int IsProcessDPIAware() {
        var mh$ = IsProcessDPIAware.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessDPIAware");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadDpiAwarenessContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext)
     * }
     */
    public static FunctionDescriptor SetThreadDpiAwarenessContext$descriptor() {
        return SetThreadDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext)
     * }
     */
    public static MethodHandle SetThreadDpiAwarenessContext$handle() {
        return SetThreadDpiAwarenessContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext)
     * }
     */
    public static MemorySegment SetThreadDpiAwarenessContext$address() {
        return SetThreadDpiAwarenessContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext)
     * }
     */
    public static MemorySegment SetThreadDpiAwarenessContext(MemorySegment dpiContext) {
        var mh$ = SetThreadDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDpiAwarenessContext", dpiContext);
            }
            return (MemorySegment)mh$.invokeExact(dpiContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadDpiAwarenessContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext()
     * }
     */
    public static FunctionDescriptor GetThreadDpiAwarenessContext$descriptor() {
        return GetThreadDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext()
     * }
     */
    public static MethodHandle GetThreadDpiAwarenessContext$handle() {
        return GetThreadDpiAwarenessContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext()
     * }
     */
    public static MemorySegment GetThreadDpiAwarenessContext$address() {
        return GetThreadDpiAwarenessContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext()
     * }
     */
    public static MemorySegment GetThreadDpiAwarenessContext() {
        var mh$ = GetThreadDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDpiAwarenessContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowDpiAwarenessContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetWindowDpiAwarenessContext$descriptor() {
        return GetWindowDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(HWND hwnd)
     * }
     */
    public static MethodHandle GetWindowDpiAwarenessContext$handle() {
        return GetWindowDpiAwarenessContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(HWND hwnd)
     * }
     */
    public static MemorySegment GetWindowDpiAwarenessContext$address() {
        return GetWindowDpiAwarenessContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(HWND hwnd)
     * }
     */
    public static MemorySegment GetWindowDpiAwarenessContext(MemorySegment hwnd) {
        var mh$ = GetWindowDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDpiAwarenessContext", hwnd);
            }
            return (MemorySegment)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAwarenessFromDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAwarenessFromDpiAwarenessContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor GetAwarenessFromDpiAwarenessContext$descriptor() {
        return GetAwarenessFromDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle GetAwarenessFromDpiAwarenessContext$handle() {
        return GetAwarenessFromDpiAwarenessContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MemorySegment GetAwarenessFromDpiAwarenessContext$address() {
        return GetAwarenessFromDpiAwarenessContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int GetAwarenessFromDpiAwarenessContext(MemorySegment value) {
        var mh$ = GetAwarenessFromDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAwarenessFromDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiFromDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDpiFromDpiAwarenessContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor GetDpiFromDpiAwarenessContext$descriptor() {
        return GetDpiFromDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle GetDpiFromDpiAwarenessContext$handle() {
        return GetDpiFromDpiAwarenessContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MemorySegment GetDpiFromDpiAwarenessContext$address() {
        return GetDpiFromDpiAwarenessContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int GetDpiFromDpiAwarenessContext(MemorySegment value) {
        var mh$ = GetDpiFromDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiFromDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreDpiAwarenessContextsEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AreDpiAwarenessContextsEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB)
     * }
     */
    public static FunctionDescriptor AreDpiAwarenessContextsEqual$descriptor() {
        return AreDpiAwarenessContextsEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB)
     * }
     */
    public static MethodHandle AreDpiAwarenessContextsEqual$handle() {
        return AreDpiAwarenessContextsEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB)
     * }
     */
    public static MemorySegment AreDpiAwarenessContextsEqual$address() {
        return AreDpiAwarenessContextsEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB)
     * }
     */
    public static int AreDpiAwarenessContextsEqual(MemorySegment dpiContextA, MemorySegment dpiContextB) {
        var mh$ = AreDpiAwarenessContextsEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreDpiAwarenessContextsEqual", dpiContextA, dpiContextB);
            }
            return (int)mh$.invokeExact(dpiContextA, dpiContextB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidDpiAwarenessContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor IsValidDpiAwarenessContext$descriptor() {
        return IsValidDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle IsValidDpiAwarenessContext$handle() {
        return IsValidDpiAwarenessContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MemorySegment IsValidDpiAwarenessContext$address() {
        return IsValidDpiAwarenessContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int IsValidDpiAwarenessContext(MemorySegment value) {
        var mh$ = IsValidDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiForWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDpiForWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDpiForWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetDpiForWindow$descriptor() {
        return GetDpiForWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDpiForWindow(HWND hwnd)
     * }
     */
    public static MethodHandle GetDpiForWindow$handle() {
        return GetDpiForWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDpiForWindow(HWND hwnd)
     * }
     */
    public static MemorySegment GetDpiForWindow$address() {
        return GetDpiForWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDpiForWindow(HWND hwnd)
     * }
     */
    public static int GetDpiForWindow(MemorySegment hwnd) {
        var mh$ = GetDpiForWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiForWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiForSystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDpiForSystem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDpiForSystem()
     * }
     */
    public static FunctionDescriptor GetDpiForSystem$descriptor() {
        return GetDpiForSystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDpiForSystem()
     * }
     */
    public static MethodHandle GetDpiForSystem$handle() {
        return GetDpiForSystem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDpiForSystem()
     * }
     */
    public static MemorySegment GetDpiForSystem$address() {
        return GetDpiForSystem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDpiForSystem()
     * }
     */
    public static int GetDpiForSystem() {
        var mh$ = GetDpiForSystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiForSystem");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDpiForProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDpiForProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDpiForProcess(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor GetSystemDpiForProcess$descriptor() {
        return GetSystemDpiForProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDpiForProcess(HANDLE hProcess)
     * }
     */
    public static MethodHandle GetSystemDpiForProcess$handle() {
        return GetSystemDpiForProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemDpiForProcess(HANDLE hProcess)
     * }
     */
    public static MemorySegment GetSystemDpiForProcess$address() {
        return GetSystemDpiForProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemDpiForProcess(HANDLE hProcess)
     * }
     */
    public static int GetSystemDpiForProcess(MemorySegment hProcess) {
        var mh$ = GetSystemDpiForProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDpiForProcess", hProcess);
            }
            return (int)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableNonClientDpiScaling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnableNonClientDpiScaling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableNonClientDpiScaling(HWND hwnd)
     * }
     */
    public static FunctionDescriptor EnableNonClientDpiScaling$descriptor() {
        return EnableNonClientDpiScaling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableNonClientDpiScaling(HWND hwnd)
     * }
     */
    public static MethodHandle EnableNonClientDpiScaling$handle() {
        return EnableNonClientDpiScaling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnableNonClientDpiScaling(HWND hwnd)
     * }
     */
    public static MemorySegment EnableNonClientDpiScaling$address() {
        return EnableNonClientDpiScaling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnableNonClientDpiScaling(HWND hwnd)
     * }
     */
    public static int EnableNonClientDpiScaling(MemorySegment hwnd) {
        var mh$ = EnableNonClientDpiScaling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableNonClientDpiScaling", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InheritWindowMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InheritWindowMonitor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InheritWindowMonitor(HWND hwnd, HWND hwndInherit)
     * }
     */
    public static FunctionDescriptor InheritWindowMonitor$descriptor() {
        return InheritWindowMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InheritWindowMonitor(HWND hwnd, HWND hwndInherit)
     * }
     */
    public static MethodHandle InheritWindowMonitor$handle() {
        return InheritWindowMonitor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InheritWindowMonitor(HWND hwnd, HWND hwndInherit)
     * }
     */
    public static MemorySegment InheritWindowMonitor$address() {
        return InheritWindowMonitor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InheritWindowMonitor(HWND hwnd, HWND hwndInherit)
     * }
     */
    public static int InheritWindowMonitor(MemorySegment hwnd, MemorySegment hwndInherit) {
        var mh$ = InheritWindowMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InheritWindowMonitor", hwnd, hwndInherit);
            }
            return (int)mh$.invokeExact(hwnd, hwndInherit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessDpiAwarenessContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor SetProcessDpiAwarenessContext$descriptor() {
        return SetProcessDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle SetProcessDpiAwarenessContext$handle() {
        return SetProcessDpiAwarenessContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MemorySegment SetProcessDpiAwarenessContext$address() {
        return SetProcessDpiAwarenessContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int SetProcessDpiAwarenessContext(MemorySegment value) {
        var mh$ = SetProcessDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiAwarenessContextForProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDpiAwarenessContextForProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor GetDpiAwarenessContextForProcess$descriptor() {
        return GetDpiAwarenessContextForProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(HANDLE hProcess)
     * }
     */
    public static MethodHandle GetDpiAwarenessContextForProcess$handle() {
        return GetDpiAwarenessContextForProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(HANDLE hProcess)
     * }
     */
    public static MemorySegment GetDpiAwarenessContextForProcess$address() {
        return GetDpiAwarenessContextForProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(HANDLE hProcess)
     * }
     */
    public static MemorySegment GetDpiAwarenessContextForProcess(MemorySegment hProcess) {
        var mh$ = GetDpiAwarenessContextForProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiAwarenessContextForProcess", hProcess);
            }
            return (MemorySegment)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDpiHostingBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadDpiHostingBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value)
     * }
     */
    public static FunctionDescriptor SetThreadDpiHostingBehavior$descriptor() {
        return SetThreadDpiHostingBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value)
     * }
     */
    public static MethodHandle SetThreadDpiHostingBehavior$handle() {
        return SetThreadDpiHostingBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value)
     * }
     */
    public static MemorySegment SetThreadDpiHostingBehavior$address() {
        return SetThreadDpiHostingBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value)
     * }
     */
    public static int SetThreadDpiHostingBehavior(int value) {
        var mh$ = SetThreadDpiHostingBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDpiHostingBehavior", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDpiHostingBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadDpiHostingBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior()
     * }
     */
    public static FunctionDescriptor GetThreadDpiHostingBehavior$descriptor() {
        return GetThreadDpiHostingBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior()
     * }
     */
    public static MethodHandle GetThreadDpiHostingBehavior$handle() {
        return GetThreadDpiHostingBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior()
     * }
     */
    public static MemorySegment GetThreadDpiHostingBehavior$address() {
        return GetThreadDpiHostingBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior()
     * }
     */
    public static int GetThreadDpiHostingBehavior() {
        var mh$ = GetThreadDpiHostingBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDpiHostingBehavior");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDpiHostingBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowDpiHostingBehavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetWindowDpiHostingBehavior$descriptor() {
        return GetWindowDpiHostingBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(HWND hwnd)
     * }
     */
    public static MethodHandle GetWindowDpiHostingBehavior$handle() {
        return GetWindowDpiHostingBehavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(HWND hwnd)
     * }
     */
    public static MemorySegment GetWindowDpiHostingBehavior$address() {
        return GetWindowDpiHostingBehavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(HWND hwnd)
     * }
     */
    public static int GetWindowDpiHostingBehavior(MemorySegment hwnd) {
        var mh$ = GetWindowDpiHostingBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDpiHostingBehavior", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowModuleFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowModuleFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static FunctionDescriptor GetWindowModuleFileNameA$descriptor() {
        return GetWindowModuleFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static MethodHandle GetWindowModuleFileNameA$handle() {
        return GetWindowModuleFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static MemorySegment GetWindowModuleFileNameA$address() {
        return GetWindowModuleFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static int GetWindowModuleFileNameA(MemorySegment hwnd, MemorySegment pszFileName, int cchFileNameMax) {
        var mh$ = GetWindowModuleFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowModuleFileNameA", hwnd, pszFileName, cchFileNameMax);
            }
            return (int)mh$.invokeExact(hwnd, pszFileName, cchFileNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowModuleFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowModuleFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static FunctionDescriptor GetWindowModuleFileNameW$descriptor() {
        return GetWindowModuleFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static MethodHandle GetWindowModuleFileNameW$handle() {
        return GetWindowModuleFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static MemorySegment GetWindowModuleFileNameW$address() {
        return GetWindowModuleFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static int GetWindowModuleFileNameW(MemorySegment hwnd, MemorySegment pszFileName, int cchFileNameMax) {
        var mh$ = GetWindowModuleFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowModuleFileNameW", hwnd, pszFileName, cchFileNameMax);
            }
            return (int)mh$.invokeExact(hwnd, pszFileName, cchFileNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCURSORINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HCURSOR hCursor;
     *     POINT ptScreenPos;
     * } *PCURSORINFO
     * }
     */
    public static final AddressLayout PCURSORINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCURSORINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HCURSOR hCursor;
     *     POINT ptScreenPos;
     * } *LPCURSORINFO
     * }
     */
    public static final AddressLayout LPCURSORINFO = freeglut_h.C_POINTER;

    private static class GetCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCursorInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCursorInfo(PCURSORINFO pci)
     * }
     */
    public static FunctionDescriptor GetCursorInfo$descriptor() {
        return GetCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCursorInfo(PCURSORINFO pci)
     * }
     */
    public static MethodHandle GetCursorInfo$handle() {
        return GetCursorInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCursorInfo(PCURSORINFO pci)
     * }
     */
    public static MemorySegment GetCursorInfo$address() {
        return GetCursorInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCursorInfo(PCURSORINFO pci)
     * }
     */
    public static int GetCursorInfo(MemorySegment pci) {
        var mh$ = GetCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCursorInfo", pci);
            }
            return (int)mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWINFO {
     *     DWORD cbSize;
     *     RECT rcWindow;
     *     RECT rcClient;
     *     DWORD dwStyle;
     *     DWORD dwExStyle;
     *     DWORD dwWindowStatus;
     *     UINT cxWindowBorders;
     *     UINT cyWindowBorders;
     *     ATOM atomWindowType;
     *     WORD wCreatorVersion;
     * } *PWINDOWINFO
     * }
     */
    public static final AddressLayout PWINDOWINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWINFO {
     *     DWORD cbSize;
     *     RECT rcWindow;
     *     RECT rcClient;
     *     DWORD dwStyle;
     *     DWORD dwExStyle;
     *     DWORD dwWindowStatus;
     *     UINT cxWindowBorders;
     *     UINT cyWindowBorders;
     *     ATOM atomWindowType;
     *     WORD wCreatorVersion;
     * } *LPWINDOWINFO
     * }
     */
    public static final AddressLayout LPWINDOWINFO = freeglut_h.C_POINTER;

    private static class GetWindowInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
     * }
     */
    public static FunctionDescriptor GetWindowInfo$descriptor() {
        return GetWindowInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
     * }
     */
    public static MethodHandle GetWindowInfo$handle() {
        return GetWindowInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
     * }
     */
    public static MemorySegment GetWindowInfo$address() {
        return GetWindowInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
     * }
     */
    public static int GetWindowInfo(MemorySegment hwnd, MemorySegment pwi) {
        var mh$ = GetWindowInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowInfo", hwnd, pwi);
            }
            return (int)mh$.invokeExact(hwnd, pwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFO {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     * } *PTITLEBARINFO
     * }
     */
    public static final AddressLayout PTITLEBARINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFO {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     * } *LPTITLEBARINFO
     * }
     */
    public static final AddressLayout LPTITLEBARINFO = freeglut_h.C_POINTER;

    private static class GetTitleBarInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTitleBarInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti)
     * }
     */
    public static FunctionDescriptor GetTitleBarInfo$descriptor() {
        return GetTitleBarInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti)
     * }
     */
    public static MethodHandle GetTitleBarInfo$handle() {
        return GetTitleBarInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti)
     * }
     */
    public static MemorySegment GetTitleBarInfo$address() {
        return GetTitleBarInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti)
     * }
     */
    public static int GetTitleBarInfo(MemorySegment hwnd, MemorySegment pti) {
        var mh$ = GetTitleBarInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTitleBarInfo", hwnd, pti);
            }
            return (int)mh$.invokeExact(hwnd, pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFOEX {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     *     RECT rgrect[6];
     * } *PTITLEBARINFOEX
     * }
     */
    public static final AddressLayout PTITLEBARINFOEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFOEX {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     *     RECT rgrect[6];
     * } *LPTITLEBARINFOEX
     * }
     */
    public static final AddressLayout LPTITLEBARINFOEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUBARINFO {
     *     DWORD cbSize;
     *     RECT rcBar;
     *     HMENU hMenu;
     *     HWND hwndMenu;
     *     BOOL fBarFocused : 1;
     *     BOOL fFocused : 1;
     *     BOOL fUnused : 30;
     * } *PMENUBARINFO
     * }
     */
    public static final AddressLayout PMENUBARINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUBARINFO {
     *     DWORD cbSize;
     *     RECT rcBar;
     *     HMENU hMenu;
     *     HWND hwndMenu;
     *     BOOL fBarFocused : 1;
     *     BOOL fFocused : 1;
     *     BOOL fUnused : 30;
     * } *LPMENUBARINFO
     * }
     */
    public static final AddressLayout LPMENUBARINFO = freeglut_h.C_POINTER;

    private static class GetMenuBarInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMenuBarInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi)
     * }
     */
    public static FunctionDescriptor GetMenuBarInfo$descriptor() {
        return GetMenuBarInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi)
     * }
     */
    public static MethodHandle GetMenuBarInfo$handle() {
        return GetMenuBarInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi)
     * }
     */
    public static MemorySegment GetMenuBarInfo$address() {
        return GetMenuBarInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi)
     * }
     */
    public static int GetMenuBarInfo(MemorySegment hwnd, int idObject, int idItem, MemorySegment pmbi) {
        var mh$ = GetMenuBarInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuBarInfo", hwnd, idObject, idItem, pmbi);
            }
            return (int)mh$.invokeExact(hwnd, idObject, idItem, pmbi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagSCROLLBARINFO {
     *     DWORD cbSize;
     *     RECT rcScrollBar;
     *     int dxyLineButton;
     *     int xyThumbTop;
     *     int xyThumbBottom;
     *     int reserved;
     *     DWORD rgstate[6];
     * } *PSCROLLBARINFO
     * }
     */
    public static final AddressLayout PSCROLLBARINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSCROLLBARINFO {
     *     DWORD cbSize;
     *     RECT rcScrollBar;
     *     int dxyLineButton;
     *     int xyThumbTop;
     *     int xyThumbBottom;
     *     int reserved;
     *     DWORD rgstate[6];
     * } *LPSCROLLBARINFO
     * }
     */
    public static final AddressLayout LPSCROLLBARINFO = freeglut_h.C_POINTER;

    private static class GetScrollBarInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetScrollBarInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi)
     * }
     */
    public static FunctionDescriptor GetScrollBarInfo$descriptor() {
        return GetScrollBarInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi)
     * }
     */
    public static MethodHandle GetScrollBarInfo$handle() {
        return GetScrollBarInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi)
     * }
     */
    public static MemorySegment GetScrollBarInfo$address() {
        return GetScrollBarInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi)
     * }
     */
    public static int GetScrollBarInfo(MemorySegment hwnd, int idObject, MemorySegment psbi) {
        var mh$ = GetScrollBarInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollBarInfo", hwnd, idObject, psbi);
            }
            return (int)mh$.invokeExact(hwnd, idObject, psbi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMBOBOXINFO {
     *     DWORD cbSize;
     *     RECT rcItem;
     *     RECT rcButton;
     *     DWORD stateButton;
     *     HWND hwndCombo;
     *     HWND hwndItem;
     *     HWND hwndList;
     * } *PCOMBOBOXINFO
     * }
     */
    public static final AddressLayout PCOMBOBOXINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMBOBOXINFO {
     *     DWORD cbSize;
     *     RECT rcItem;
     *     RECT rcButton;
     *     DWORD stateButton;
     *     HWND hwndCombo;
     *     HWND hwndItem;
     *     HWND hwndList;
     * } *LPCOMBOBOXINFO
     * }
     */
    public static final AddressLayout LPCOMBOBOXINFO = freeglut_h.C_POINTER;

    private static class GetComboBoxInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetComboBoxInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi)
     * }
     */
    public static FunctionDescriptor GetComboBoxInfo$descriptor() {
        return GetComboBoxInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi)
     * }
     */
    public static MethodHandle GetComboBoxInfo$handle() {
        return GetComboBoxInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi)
     * }
     */
    public static MemorySegment GetComboBoxInfo$address() {
        return GetComboBoxInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi)
     * }
     */
    public static int GetComboBoxInfo(MemorySegment hwndCombo, MemorySegment pcbi) {
        var mh$ = GetComboBoxInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComboBoxInfo", hwndCombo, pcbi);
            }
            return (int)mh$.invokeExact(hwndCombo, pcbi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAncestor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAncestor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetAncestor(HWND hwnd, UINT gaFlags)
     * }
     */
    public static FunctionDescriptor GetAncestor$descriptor() {
        return GetAncestor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetAncestor(HWND hwnd, UINT gaFlags)
     * }
     */
    public static MethodHandle GetAncestor$handle() {
        return GetAncestor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetAncestor(HWND hwnd, UINT gaFlags)
     * }
     */
    public static MemorySegment GetAncestor$address() {
        return GetAncestor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetAncestor(HWND hwnd, UINT gaFlags)
     * }
     */
    public static MemorySegment GetAncestor(MemorySegment hwnd, int gaFlags) {
        var mh$ = GetAncestor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAncestor", hwnd, gaFlags);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, gaFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealChildWindowFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            tagPOINT.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RealChildWindowFromPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
     * }
     */
    public static FunctionDescriptor RealChildWindowFromPoint$descriptor() {
        return RealChildWindowFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
     * }
     */
    public static MethodHandle RealChildWindowFromPoint$handle() {
        return RealChildWindowFromPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
     * }
     */
    public static MemorySegment RealChildWindowFromPoint$address() {
        return RealChildWindowFromPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
     * }
     */
    public static MemorySegment RealChildWindowFromPoint(MemorySegment hwndParent, MemorySegment ptParentClientCoords) {
        var mh$ = RealChildWindowFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealChildWindowFromPoint", hwndParent, ptParentClientCoords);
            }
            return (MemorySegment)mh$.invokeExact(hwndParent, ptParentClientCoords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealGetWindowClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RealGetWindowClassA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static FunctionDescriptor RealGetWindowClassA$descriptor() {
        return RealGetWindowClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static MethodHandle RealGetWindowClassA$handle() {
        return RealGetWindowClassA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static MemorySegment RealGetWindowClassA$address() {
        return RealGetWindowClassA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static int RealGetWindowClassA(MemorySegment hwnd, MemorySegment ptszClassName, int cchClassNameMax) {
        var mh$ = RealGetWindowClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealGetWindowClassA", hwnd, ptszClassName, cchClassNameMax);
            }
            return (int)mh$.invokeExact(hwnd, ptszClassName, cchClassNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealGetWindowClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RealGetWindowClassW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static FunctionDescriptor RealGetWindowClassW$descriptor() {
        return RealGetWindowClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static MethodHandle RealGetWindowClassW$handle() {
        return RealGetWindowClassW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static MemorySegment RealGetWindowClassW$address() {
        return RealGetWindowClassW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static int RealGetWindowClassW(MemorySegment hwnd, MemorySegment ptszClassName, int cchClassNameMax) {
        var mh$ = RealGetWindowClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealGetWindowClassW", hwnd, ptszClassName, cchClassNameMax);
            }
            return (int)mh$.invokeExact(hwnd, ptszClassName, cchClassNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagALTTABINFO {
     *     DWORD cbSize;
     *     int cItems;
     *     int cColumns;
     *     int cRows;
     *     int iColFocus;
     *     int iRowFocus;
     *     int cxItem;
     *     int cyItem;
     *     POINT ptStart;
     * } *PALTTABINFO
     * }
     */
    public static final AddressLayout PALTTABINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagALTTABINFO {
     *     DWORD cbSize;
     *     int cItems;
     *     int cColumns;
     *     int cRows;
     *     int iColFocus;
     *     int iRowFocus;
     *     int cxItem;
     *     int cyItem;
     *     POINT ptStart;
     * } *LPALTTABINFO
     * }
     */
    public static final AddressLayout LPALTTABINFO = freeglut_h.C_POINTER;

    private static class GetAltTabInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAltTabInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText)
     * }
     */
    public static FunctionDescriptor GetAltTabInfoA$descriptor() {
        return GetAltTabInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText)
     * }
     */
    public static MethodHandle GetAltTabInfoA$handle() {
        return GetAltTabInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText)
     * }
     */
    public static MemorySegment GetAltTabInfoA$address() {
        return GetAltTabInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText)
     * }
     */
    public static int GetAltTabInfoA(MemorySegment hwnd, int iItem, MemorySegment pati, MemorySegment pszItemText, int cchItemText) {
        var mh$ = GetAltTabInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAltTabInfoA", hwnd, iItem, pati, pszItemText, cchItemText);
            }
            return (int)mh$.invokeExact(hwnd, iItem, pati, pszItemText, cchItemText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAltTabInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAltTabInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText)
     * }
     */
    public static FunctionDescriptor GetAltTabInfoW$descriptor() {
        return GetAltTabInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText)
     * }
     */
    public static MethodHandle GetAltTabInfoW$handle() {
        return GetAltTabInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText)
     * }
     */
    public static MemorySegment GetAltTabInfoW$address() {
        return GetAltTabInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText)
     * }
     */
    public static int GetAltTabInfoW(MemorySegment hwnd, int iItem, MemorySegment pati, MemorySegment pszItemText, int cchItemText) {
        var mh$ = GetAltTabInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAltTabInfoW", hwnd, iItem, pati, pszItemText, cchItemText);
            }
            return (int)mh$.invokeExact(hwnd, iItem, pati, pszItemText, cchItemText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetListBoxInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetListBoxInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetListBoxInfo(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetListBoxInfo$descriptor() {
        return GetListBoxInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetListBoxInfo(HWND hwnd)
     * }
     */
    public static MethodHandle GetListBoxInfo$handle() {
        return GetListBoxInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetListBoxInfo(HWND hwnd)
     * }
     */
    public static MemorySegment GetListBoxInfo$address() {
        return GetListBoxInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetListBoxInfo(HWND hwnd)
     * }
     */
    public static int GetListBoxInfo(MemorySegment hwnd) {
        var mh$ = GetListBoxInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetListBoxInfo", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockWorkStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LockWorkStation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockWorkStation()
     * }
     */
    public static FunctionDescriptor LockWorkStation$descriptor() {
        return LockWorkStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockWorkStation()
     * }
     */
    public static MethodHandle LockWorkStation$handle() {
        return LockWorkStation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockWorkStation()
     * }
     */
    public static MemorySegment LockWorkStation$address() {
        return LockWorkStation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockWorkStation()
     * }
     */
    public static int LockWorkStation() {
        var mh$ = LockWorkStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockWorkStation");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserHandleGrantAccess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UserHandleGrantAccess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant)
     * }
     */
    public static FunctionDescriptor UserHandleGrantAccess$descriptor() {
        return UserHandleGrantAccess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant)
     * }
     */
    public static MethodHandle UserHandleGrantAccess$handle() {
        return UserHandleGrantAccess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant)
     * }
     */
    public static MemorySegment UserHandleGrantAccess$address() {
        return UserHandleGrantAccess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant)
     * }
     */
    public static int UserHandleGrantAccess(MemorySegment hUserHandle, MemorySegment hJob, int bGrant) {
        var mh$ = UserHandleGrantAccess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserHandleGrantAccess", hUserHandle, hJob, bGrant);
            }
            return (int)mh$.invokeExact(hUserHandle, hJob, bGrant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HRAWINPUT__ {
     *     int unused;
     * } *HRAWINPUT
     * }
     */
    public static final AddressLayout HRAWINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTHEADER {
     *     DWORD dwType;
     *     DWORD dwSize;
     *     HANDLE hDevice;
     *     WPARAM wParam;
     * } *PRAWINPUTHEADER
     * }
     */
    public static final AddressLayout PRAWINPUTHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTHEADER {
     *     DWORD dwType;
     *     DWORD dwSize;
     *     HANDLE hDevice;
     *     WPARAM wParam;
     * } *LPRAWINPUTHEADER
     * }
     */
    public static final AddressLayout LPRAWINPUTHEADER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWMOUSE {
     *     USHORT usFlags;
     *     union {
     *         ULONG ulButtons;
     *         struct {
     *             USHORT usButtonFlags;
     *             USHORT usButtonData;
     *         };
     *     };
     *     ULONG ulRawButtons;
     *     LONG lLastX;
     *     LONG lLastY;
     *     ULONG ulExtraInformation;
     * } *PRAWMOUSE
     * }
     */
    public static final AddressLayout PRAWMOUSE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWMOUSE {
     *     USHORT usFlags;
     *     union {
     *         ULONG ulButtons;
     *         struct {
     *             USHORT usButtonFlags;
     *             USHORT usButtonData;
     *         };
     *     };
     *     ULONG ulRawButtons;
     *     LONG lLastX;
     *     LONG lLastY;
     *     ULONG ulExtraInformation;
     * } *LPRAWMOUSE
     * }
     */
    public static final AddressLayout LPRAWMOUSE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWKEYBOARD {
     *     USHORT MakeCode;
     *     USHORT Flags;
     *     USHORT Reserved;
     *     USHORT VKey;
     *     UINT Message;
     *     ULONG ExtraInformation;
     * } *PRAWKEYBOARD
     * }
     */
    public static final AddressLayout PRAWKEYBOARD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWKEYBOARD {
     *     USHORT MakeCode;
     *     USHORT Flags;
     *     USHORT Reserved;
     *     USHORT VKey;
     *     UINT Message;
     *     ULONG ExtraInformation;
     * } *LPRAWKEYBOARD
     * }
     */
    public static final AddressLayout LPRAWKEYBOARD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWHID {
     *     DWORD dwSizeHid;
     *     DWORD dwCount;
     *     BYTE bRawData[1];
     * } *PRAWHID
     * }
     */
    public static final AddressLayout PRAWHID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWHID {
     *     DWORD dwSizeHid;
     *     DWORD dwCount;
     *     BYTE bRawData[1];
     * } *LPRAWHID
     * }
     */
    public static final AddressLayout LPRAWHID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUT {
     *     RAWINPUTHEADER header;
     *     union {
     *         RAWMOUSE mouse;
     *         RAWKEYBOARD keyboard;
     *         RAWHID hid;
     *     } data;
     * } *PRAWINPUT
     * }
     */
    public static final AddressLayout PRAWINPUT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUT {
     *     RAWINPUTHEADER header;
     *     union {
     *         RAWMOUSE mouse;
     *         RAWKEYBOARD keyboard;
     *         RAWHID hid;
     *     } data;
     * } *LPRAWINPUT
     * }
     */
    public static final AddressLayout LPRAWINPUT = freeglut_h.C_POINTER;

    private static class GetRawInputData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRawInputData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static FunctionDescriptor GetRawInputData$descriptor() {
        return GetRawInputData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static MethodHandle GetRawInputData$handle() {
        return GetRawInputData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static MemorySegment GetRawInputData$address() {
        return GetRawInputData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static int GetRawInputData(MemorySegment hRawInput, int uiCommand, MemorySegment pData, MemorySegment pcbSize, int cbSizeHeader) {
        var mh$ = GetRawInputData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputData", hRawInput, uiCommand, pData, pcbSize, cbSizeHeader);
            }
            return (int)mh$.invokeExact(hRawInput, uiCommand, pData, pcbSize, cbSizeHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO_MOUSE {
     *     DWORD dwId;
     *     DWORD dwNumberOfButtons;
     *     DWORD dwSampleRate;
     *     BOOL fHasHorizontalWheel;
     * } *PRID_DEVICE_INFO_MOUSE
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO_MOUSE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO_KEYBOARD {
     *     DWORD dwType;
     *     DWORD dwSubType;
     *     DWORD dwKeyboardMode;
     *     DWORD dwNumberOfFunctionKeys;
     *     DWORD dwNumberOfIndicators;
     *     DWORD dwNumberOfKeysTotal;
     * } *PRID_DEVICE_INFO_KEYBOARD
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO_KEYBOARD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO_HID {
     *     DWORD dwVendorId;
     *     DWORD dwProductId;
     *     DWORD dwVersionNumber;
     *     USHORT usUsagePage;
     *     USHORT usUsage;
     * } *PRID_DEVICE_INFO_HID
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO_HID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO {
     *     DWORD cbSize;
     *     DWORD dwType;
     *     union {
     *         RID_DEVICE_INFO_MOUSE mouse;
     *         RID_DEVICE_INFO_KEYBOARD keyboard;
     *         RID_DEVICE_INFO_HID hid;
     *     };
     * } *PRID_DEVICE_INFO
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO {
     *     DWORD cbSize;
     *     DWORD dwType;
     *     union {
     *         RID_DEVICE_INFO_MOUSE mouse;
     *         RID_DEVICE_INFO_KEYBOARD keyboard;
     *         RID_DEVICE_INFO_HID hid;
     *     };
     * } *LPRID_DEVICE_INFO
     * }
     */
    public static final AddressLayout LPRID_DEVICE_INFO = freeglut_h.C_POINTER;

    private static class GetRawInputDeviceInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRawInputDeviceInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static FunctionDescriptor GetRawInputDeviceInfoA$descriptor() {
        return GetRawInputDeviceInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static MethodHandle GetRawInputDeviceInfoA$handle() {
        return GetRawInputDeviceInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static MemorySegment GetRawInputDeviceInfoA$address() {
        return GetRawInputDeviceInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static int GetRawInputDeviceInfoA(MemorySegment hDevice, int uiCommand, MemorySegment pData, MemorySegment pcbSize) {
        var mh$ = GetRawInputDeviceInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputDeviceInfoA", hDevice, uiCommand, pData, pcbSize);
            }
            return (int)mh$.invokeExact(hDevice, uiCommand, pData, pcbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRawInputDeviceInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRawInputDeviceInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static FunctionDescriptor GetRawInputDeviceInfoW$descriptor() {
        return GetRawInputDeviceInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static MethodHandle GetRawInputDeviceInfoW$handle() {
        return GetRawInputDeviceInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static MemorySegment GetRawInputDeviceInfoW$address() {
        return GetRawInputDeviceInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static int GetRawInputDeviceInfoW(MemorySegment hDevice, int uiCommand, MemorySegment pData, MemorySegment pcbSize) {
        var mh$ = GetRawInputDeviceInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputDeviceInfoW", hDevice, uiCommand, pData, pcbSize);
            }
            return (int)mh$.invokeExact(hDevice, uiCommand, pData, pcbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRawInputBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRawInputBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static FunctionDescriptor GetRawInputBuffer$descriptor() {
        return GetRawInputBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static MethodHandle GetRawInputBuffer$handle() {
        return GetRawInputBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static MemorySegment GetRawInputBuffer$address() {
        return GetRawInputBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static int GetRawInputBuffer(MemorySegment pData, MemorySegment pcbSize, int cbSizeHeader) {
        var mh$ = GetRawInputBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputBuffer", pData, pcbSize, cbSizeHeader);
            }
            return (int)mh$.invokeExact(pData, pcbSize, cbSizeHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTDEVICE {
     *     USHORT usUsagePage;
     *     USHORT usUsage;
     *     DWORD dwFlags;
     *     HWND hwndTarget;
     * } *PRAWINPUTDEVICE
     * }
     */
    public static final AddressLayout PRAWINPUTDEVICE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTDEVICE {
     *     USHORT usUsagePage;
     *     USHORT usUsage;
     *     DWORD dwFlags;
     *     HWND hwndTarget;
     * } *LPRAWINPUTDEVICE
     * }
     */
    public static final AddressLayout LPRAWINPUTDEVICE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RAWINPUTDEVICE *PCRAWINPUTDEVICE
     * }
     */
    public static final AddressLayout PCRAWINPUTDEVICE = freeglut_h.C_POINTER;

    private static class RegisterRawInputDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterRawInputDevices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize)
     * }
     */
    public static FunctionDescriptor RegisterRawInputDevices$descriptor() {
        return RegisterRawInputDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize)
     * }
     */
    public static MethodHandle RegisterRawInputDevices$handle() {
        return RegisterRawInputDevices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize)
     * }
     */
    public static MemorySegment RegisterRawInputDevices$address() {
        return RegisterRawInputDevices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize)
     * }
     */
    public static int RegisterRawInputDevices(MemorySegment pRawInputDevices, int uiNumDevices, int cbSize) {
        var mh$ = RegisterRawInputDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterRawInputDevices", pRawInputDevices, uiNumDevices, cbSize);
            }
            return (int)mh$.invokeExact(pRawInputDevices, uiNumDevices, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRegisteredRawInputDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRegisteredRawInputDevices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static FunctionDescriptor GetRegisteredRawInputDevices$descriptor() {
        return GetRegisteredRawInputDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static MethodHandle GetRegisteredRawInputDevices$handle() {
        return GetRegisteredRawInputDevices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static MemorySegment GetRegisteredRawInputDevices$address() {
        return GetRegisteredRawInputDevices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static int GetRegisteredRawInputDevices(MemorySegment pRawInputDevices, MemorySegment puiNumDevices, int cbSize) {
        var mh$ = GetRegisteredRawInputDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRegisteredRawInputDevices", pRawInputDevices, puiNumDevices, cbSize);
            }
            return (int)mh$.invokeExact(pRawInputDevices, puiNumDevices, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTDEVICELIST {
     *     HANDLE hDevice;
     *     DWORD dwType;
     * } *PRAWINPUTDEVICELIST
     * }
     */
    public static final AddressLayout PRAWINPUTDEVICELIST = freeglut_h.C_POINTER;

    private static class GetRawInputDeviceList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRawInputDeviceList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static FunctionDescriptor GetRawInputDeviceList$descriptor() {
        return GetRawInputDeviceList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static MethodHandle GetRawInputDeviceList$handle() {
        return GetRawInputDeviceList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static MemorySegment GetRawInputDeviceList$address() {
        return GetRawInputDeviceList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static int GetRawInputDeviceList(MemorySegment pRawInputDeviceList, MemorySegment puiNumDevices, int cbSize) {
        var mh$ = GetRawInputDeviceList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputDeviceList", pRawInputDeviceList, puiNumDevices, cbSize);
            }
            return (int)mh$.invokeExact(pRawInputDeviceList, puiNumDevices, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefRawInputProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DefRawInputProc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefRawInputProc(PRAWINPUT *paRawInput, INT nInput, UINT cbSizeHeader)
     * }
     */
    public static FunctionDescriptor DefRawInputProc$descriptor() {
        return DefRawInputProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefRawInputProc(PRAWINPUT *paRawInput, INT nInput, UINT cbSizeHeader)
     * }
     */
    public static MethodHandle DefRawInputProc$handle() {
        return DefRawInputProc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT DefRawInputProc(PRAWINPUT *paRawInput, INT nInput, UINT cbSizeHeader)
     * }
     */
    public static MemorySegment DefRawInputProc$address() {
        return DefRawInputProc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT DefRawInputProc(PRAWINPUT *paRawInput, INT nInput, UINT cbSizeHeader)
     * }
     */
    public static long DefRawInputProc(MemorySegment paRawInput, int nInput, int cbSizeHeader) {
        var mh$ = DefRawInputProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefRawInputProc", paRawInput, nInput, cbSizeHeader);
            }
            return (long)mh$.invokeExact(paRawInput, nInput, cbSizeHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int POINTER_DEVICE_TYPE_INTEGRATED_PEN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_INTEGRATED_PEN = 1
     * }
     */
    public static int POINTER_DEVICE_TYPE_INTEGRATED_PEN() {
        return POINTER_DEVICE_TYPE_INTEGRATED_PEN;
    }
    private static final int POINTER_DEVICE_TYPE_EXTERNAL_PEN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_EXTERNAL_PEN = 2
     * }
     */
    public static int POINTER_DEVICE_TYPE_EXTERNAL_PEN() {
        return POINTER_DEVICE_TYPE_EXTERNAL_PEN;
    }
    private static final int POINTER_DEVICE_TYPE_TOUCH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH = 3
     * }
     */
    public static int POINTER_DEVICE_TYPE_TOUCH() {
        return POINTER_DEVICE_TYPE_TOUCH;
    }
    private static final int POINTER_DEVICE_TYPE_TOUCH_PAD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH_PAD = 4
     * }
     */
    public static int POINTER_DEVICE_TYPE_TOUCH_PAD() {
        return POINTER_DEVICE_TYPE_TOUCH_PAD;
    }
    private static final int POINTER_DEVICE_TYPE_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_MAX = -1
     * }
     */
    public static int POINTER_DEVICE_TYPE_MAX() {
        return POINTER_DEVICE_TYPE_MAX;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_UNKNOWN() {
        return POINTER_DEVICE_CURSOR_TYPE_UNKNOWN;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_TIP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_TIP = 1
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_TIP() {
        return POINTER_DEVICE_CURSOR_TYPE_TIP;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_ERASER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_ERASER = 2
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_ERASER() {
        return POINTER_DEVICE_CURSOR_TYPE_ERASER;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_MAX = -1
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_MAX() {
        return POINTER_DEVICE_CURSOR_TYPE_MAX;
    }

    private static class GetPointerDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerDevices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDevices(UINT32 *deviceCount, POINTER_DEVICE_INFO *pointerDevices)
     * }
     */
    public static FunctionDescriptor GetPointerDevices$descriptor() {
        return GetPointerDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDevices(UINT32 *deviceCount, POINTER_DEVICE_INFO *pointerDevices)
     * }
     */
    public static MethodHandle GetPointerDevices$handle() {
        return GetPointerDevices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerDevices(UINT32 *deviceCount, POINTER_DEVICE_INFO *pointerDevices)
     * }
     */
    public static MemorySegment GetPointerDevices$address() {
        return GetPointerDevices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerDevices(UINT32 *deviceCount, POINTER_DEVICE_INFO *pointerDevices)
     * }
     */
    public static int GetPointerDevices(MemorySegment deviceCount, MemorySegment pointerDevices) {
        var mh$ = GetPointerDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDevices", deviceCount, pointerDevices);
            }
            return (int)mh$.invokeExact(deviceCount, pointerDevices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice)
     * }
     */
    public static FunctionDescriptor GetPointerDevice$descriptor() {
        return GetPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice)
     * }
     */
    public static MethodHandle GetPointerDevice$handle() {
        return GetPointerDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice)
     * }
     */
    public static MemorySegment GetPointerDevice$address() {
        return GetPointerDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice)
     * }
     */
    public static int GetPointerDevice(MemorySegment device, MemorySegment pointerDevice) {
        var mh$ = GetPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDevice", device, pointerDevice);
            }
            return (int)mh$.invokeExact(device, pointerDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDeviceProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerDeviceProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceProperties(HANDLE device, UINT32 *propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties)
     * }
     */
    public static FunctionDescriptor GetPointerDeviceProperties$descriptor() {
        return GetPointerDeviceProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceProperties(HANDLE device, UINT32 *propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties)
     * }
     */
    public static MethodHandle GetPointerDeviceProperties$handle() {
        return GetPointerDeviceProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceProperties(HANDLE device, UINT32 *propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties)
     * }
     */
    public static MemorySegment GetPointerDeviceProperties$address() {
        return GetPointerDeviceProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerDeviceProperties(HANDLE device, UINT32 *propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties)
     * }
     */
    public static int GetPointerDeviceProperties(MemorySegment device, MemorySegment propertyCount, MemorySegment pointerProperties) {
        var mh$ = GetPointerDeviceProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDeviceProperties", device, propertyCount, pointerProperties);
            }
            return (int)mh$.invokeExact(device, propertyCount, pointerProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerDeviceNotifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterPointerDeviceNotifications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange)
     * }
     */
    public static FunctionDescriptor RegisterPointerDeviceNotifications$descriptor() {
        return RegisterPointerDeviceNotifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange)
     * }
     */
    public static MethodHandle RegisterPointerDeviceNotifications$handle() {
        return RegisterPointerDeviceNotifications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange)
     * }
     */
    public static MemorySegment RegisterPointerDeviceNotifications$address() {
        return RegisterPointerDeviceNotifications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange)
     * }
     */
    public static int RegisterPointerDeviceNotifications(MemorySegment window, int notifyRange) {
        var mh$ = RegisterPointerDeviceNotifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerDeviceNotifications", window, notifyRange);
            }
            return (int)mh$.invokeExact(window, notifyRange);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDeviceRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerDeviceRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceRects(HANDLE device, RECT *pointerDeviceRect, RECT *displayRect)
     * }
     */
    public static FunctionDescriptor GetPointerDeviceRects$descriptor() {
        return GetPointerDeviceRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceRects(HANDLE device, RECT *pointerDeviceRect, RECT *displayRect)
     * }
     */
    public static MethodHandle GetPointerDeviceRects$handle() {
        return GetPointerDeviceRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceRects(HANDLE device, RECT *pointerDeviceRect, RECT *displayRect)
     * }
     */
    public static MemorySegment GetPointerDeviceRects$address() {
        return GetPointerDeviceRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerDeviceRects(HANDLE device, RECT *pointerDeviceRect, RECT *displayRect)
     * }
     */
    public static int GetPointerDeviceRects(MemorySegment device, MemorySegment pointerDeviceRect, MemorySegment displayRect) {
        var mh$ = GetPointerDeviceRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDeviceRects", device, pointerDeviceRect, displayRect);
            }
            return (int)mh$.invokeExact(device, pointerDeviceRect, displayRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDeviceCursors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPointerDeviceCursors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceCursors(HANDLE device, UINT32 *cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors)
     * }
     */
    public static FunctionDescriptor GetPointerDeviceCursors$descriptor() {
        return GetPointerDeviceCursors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceCursors(HANDLE device, UINT32 *cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors)
     * }
     */
    public static MethodHandle GetPointerDeviceCursors$handle() {
        return GetPointerDeviceCursors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceCursors(HANDLE device, UINT32 *cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors)
     * }
     */
    public static MemorySegment GetPointerDeviceCursors$address() {
        return GetPointerDeviceCursors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPointerDeviceCursors(HANDLE device, UINT32 *cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors)
     * }
     */
    public static int GetPointerDeviceCursors(MemorySegment device, MemorySegment cursorCount, MemorySegment deviceCursors) {
        var mh$ = GetPointerDeviceCursors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDeviceCursors", device, cursorCount, deviceCursors);
            }
            return (int)mh$.invokeExact(device, cursorCount, deviceCursors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRawPointerDeviceData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetRawPointerDeviceData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY *pProperties, LONG *pValues)
     * }
     */
    public static FunctionDescriptor GetRawPointerDeviceData$descriptor() {
        return GetRawPointerDeviceData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY *pProperties, LONG *pValues)
     * }
     */
    public static MethodHandle GetRawPointerDeviceData$handle() {
        return GetRawPointerDeviceData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY *pProperties, LONG *pValues)
     * }
     */
    public static MemorySegment GetRawPointerDeviceData$address() {
        return GetRawPointerDeviceData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY *pProperties, LONG *pValues)
     * }
     */
    public static int GetRawPointerDeviceData(int pointerId, int historyCount, int propertiesCount, MemorySegment pProperties, MemorySegment pValues) {
        var mh$ = GetRawPointerDeviceData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawPointerDeviceData", pointerId, historyCount, propertiesCount, pProperties, pValues);
            }
            return (int)mh$.invokeExact(pointerId, historyCount, propertiesCount, pProperties, pValues);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeWindowMessageFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeWindowMessageFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilter(UINT message, DWORD dwFlag)
     * }
     */
    public static FunctionDescriptor ChangeWindowMessageFilter$descriptor() {
        return ChangeWindowMessageFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilter(UINT message, DWORD dwFlag)
     * }
     */
    public static MethodHandle ChangeWindowMessageFilter$handle() {
        return ChangeWindowMessageFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilter(UINT message, DWORD dwFlag)
     * }
     */
    public static MemorySegment ChangeWindowMessageFilter$address() {
        return ChangeWindowMessageFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilter(UINT message, DWORD dwFlag)
     * }
     */
    public static int ChangeWindowMessageFilter(int message, int dwFlag) {
        var mh$ = ChangeWindowMessageFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeWindowMessageFilter", message, dwFlag);
            }
            return (int)mh$.invokeExact(message, dwFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCHANGEFILTERSTRUCT {
     *     DWORD cbSize;
     *     DWORD ExtStatus;
     * } *PCHANGEFILTERSTRUCT
     * }
     */
    public static final AddressLayout PCHANGEFILTERSTRUCT = freeglut_h.C_POINTER;

    private static class ChangeWindowMessageFilterEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeWindowMessageFilterEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct)
     * }
     */
    public static FunctionDescriptor ChangeWindowMessageFilterEx$descriptor() {
        return ChangeWindowMessageFilterEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct)
     * }
     */
    public static MethodHandle ChangeWindowMessageFilterEx$handle() {
        return ChangeWindowMessageFilterEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct)
     * }
     */
    public static MemorySegment ChangeWindowMessageFilterEx$address() {
        return ChangeWindowMessageFilterEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct)
     * }
     */
    public static int ChangeWindowMessageFilterEx(MemorySegment hwnd, int message, int action, MemorySegment pChangeFilterStruct) {
        var mh$ = ChangeWindowMessageFilterEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeWindowMessageFilterEx", hwnd, message, action, pChangeFilterStruct);
            }
            return (int)mh$.invokeExact(hwnd, message, action, pChangeFilterStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HGESTUREINFO__ {
     *     int unused;
     * } *HGESTUREINFO
     * }
     */
    public static final AddressLayout HGESTUREINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGESTUREINFO {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD dwID;
     *     HWND hwndTarget;
     *     POINTS ptsLocation;
     *     DWORD dwInstanceID;
     *     DWORD dwSequenceID;
     *     ULONGLONG ullArguments;
     *     UINT cbExtraArgs;
     * } *PGESTUREINFO
     * }
     */
    public static final AddressLayout PGESTUREINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const GESTUREINFO *PCGESTUREINFO
     * }
     */
    public static final AddressLayout PCGESTUREINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGESTURENOTIFYSTRUCT {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     HWND hwndTarget;
     *     POINTS ptsLocation;
     *     DWORD dwInstanceID;
     * } *PGESTURENOTIFYSTRUCT
     * }
     */
    public static final AddressLayout PGESTURENOTIFYSTRUCT = freeglut_h.C_POINTER;

    private static class GetGestureInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGestureInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo)
     * }
     */
    public static FunctionDescriptor GetGestureInfo$descriptor() {
        return GetGestureInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo)
     * }
     */
    public static MethodHandle GetGestureInfo$handle() {
        return GetGestureInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo)
     * }
     */
    public static MemorySegment GetGestureInfo$address() {
        return GetGestureInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo)
     * }
     */
    public static int GetGestureInfo(MemorySegment hGestureInfo, MemorySegment pGestureInfo) {
        var mh$ = GetGestureInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureInfo", hGestureInfo, pGestureInfo);
            }
            return (int)mh$.invokeExact(hGestureInfo, pGestureInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureExtraArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGestureExtraArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs)
     * }
     */
    public static FunctionDescriptor GetGestureExtraArgs$descriptor() {
        return GetGestureExtraArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs)
     * }
     */
    public static MethodHandle GetGestureExtraArgs$handle() {
        return GetGestureExtraArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs)
     * }
     */
    public static MemorySegment GetGestureExtraArgs$address() {
        return GetGestureExtraArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs)
     * }
     */
    public static int GetGestureExtraArgs(MemorySegment hGestureInfo, int cbExtraArgs, MemorySegment pExtraArgs) {
        var mh$ = GetGestureExtraArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureExtraArgs", hGestureInfo, cbExtraArgs, pExtraArgs);
            }
            return (int)mh$.invokeExact(hGestureInfo, cbExtraArgs, pExtraArgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseGestureInfoHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseGestureInfoHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseGestureInfoHandle(HGESTUREINFO hGestureInfo)
     * }
     */
    public static FunctionDescriptor CloseGestureInfoHandle$descriptor() {
        return CloseGestureInfoHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseGestureInfoHandle(HGESTUREINFO hGestureInfo)
     * }
     */
    public static MethodHandle CloseGestureInfoHandle$handle() {
        return CloseGestureInfoHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseGestureInfoHandle(HGESTUREINFO hGestureInfo)
     * }
     */
    public static MemorySegment CloseGestureInfoHandle$address() {
        return CloseGestureInfoHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseGestureInfoHandle(HGESTUREINFO hGestureInfo)
     * }
     */
    public static int CloseGestureInfoHandle(MemorySegment hGestureInfo) {
        var mh$ = CloseGestureInfoHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseGestureInfoHandle", hGestureInfo);
            }
            return (int)mh$.invokeExact(hGestureInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagGESTURECONFIG {
     *     DWORD dwID;
     *     DWORD dwWant;
     *     DWORD dwBlock;
     * } *PGESTURECONFIG
     * }
     */
    public static final AddressLayout PGESTURECONFIG = freeglut_h.C_POINTER;

    private static class SetGestureConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetGestureConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static FunctionDescriptor SetGestureConfig$descriptor() {
        return SetGestureConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static MethodHandle SetGestureConfig$handle() {
        return SetGestureConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static MemorySegment SetGestureConfig$address() {
        return SetGestureConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static int SetGestureConfig(MemorySegment hwnd, int dwReserved, int cIDs, MemorySegment pGestureConfig, int cbSize) {
        var mh$ = SetGestureConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGestureConfig", hwnd, dwReserved, cIDs, pGestureConfig, cbSize);
            }
            return (int)mh$.invokeExact(hwnd, dwReserved, cIDs, pGestureConfig, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGestureConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static FunctionDescriptor GetGestureConfig$descriptor() {
        return GetGestureConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static MethodHandle GetGestureConfig$handle() {
        return GetGestureConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static MemorySegment GetGestureConfig$address() {
        return GetGestureConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static int GetGestureConfig(MemorySegment hwnd, int dwReserved, int dwFlags, MemorySegment pcIDs, MemorySegment pGestureConfig, int cbSize) {
        var mh$ = GetGestureConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureConfig", hwnd, dwReserved, dwFlags, pcIDs, pGestureConfig, cbSize);
            }
            return (int)mh$.invokeExact(hwnd, dwReserved, dwFlags, pcIDs, pGestureConfig, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShutdownBlockReasonCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShutdownBlockReasonCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason)
     * }
     */
    public static FunctionDescriptor ShutdownBlockReasonCreate$descriptor() {
        return ShutdownBlockReasonCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason)
     * }
     */
    public static MethodHandle ShutdownBlockReasonCreate$handle() {
        return ShutdownBlockReasonCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason)
     * }
     */
    public static MemorySegment ShutdownBlockReasonCreate$address() {
        return ShutdownBlockReasonCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason)
     * }
     */
    public static int ShutdownBlockReasonCreate(MemorySegment hWnd, MemorySegment pwszReason) {
        var mh$ = ShutdownBlockReasonCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShutdownBlockReasonCreate", hWnd, pwszReason);
            }
            return (int)mh$.invokeExact(hWnd, pwszReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShutdownBlockReasonQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShutdownBlockReasonQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff)
     * }
     */
    public static FunctionDescriptor ShutdownBlockReasonQuery$descriptor() {
        return ShutdownBlockReasonQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff)
     * }
     */
    public static MethodHandle ShutdownBlockReasonQuery$handle() {
        return ShutdownBlockReasonQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff)
     * }
     */
    public static MemorySegment ShutdownBlockReasonQuery$address() {
        return ShutdownBlockReasonQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff)
     * }
     */
    public static int ShutdownBlockReasonQuery(MemorySegment hWnd, MemorySegment pwszBuff, MemorySegment pcchBuff) {
        var mh$ = ShutdownBlockReasonQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShutdownBlockReasonQuery", hWnd, pwszBuff, pcchBuff);
            }
            return (int)mh$.invokeExact(hWnd, pwszBuff, pcchBuff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShutdownBlockReasonDestroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ShutdownBlockReasonDestroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonDestroy(HWND hWnd)
     * }
     */
    public static FunctionDescriptor ShutdownBlockReasonDestroy$descriptor() {
        return ShutdownBlockReasonDestroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonDestroy(HWND hWnd)
     * }
     */
    public static MethodHandle ShutdownBlockReasonDestroy$handle() {
        return ShutdownBlockReasonDestroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonDestroy(HWND hWnd)
     * }
     */
    public static MemorySegment ShutdownBlockReasonDestroy$address() {
        return ShutdownBlockReasonDestroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonDestroy(HWND hWnd)
     * }
     */
    public static int ShutdownBlockReasonDestroy(MemorySegment hWnd) {
        var mh$ = ShutdownBlockReasonDestroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShutdownBlockReasonDestroy", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int IMDT_UNAVAILABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_UNAVAILABLE = 0
     * }
     */
    public static int IMDT_UNAVAILABLE() {
        return IMDT_UNAVAILABLE;
    }
    private static final int IMDT_KEYBOARD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_KEYBOARD = 1
     * }
     */
    public static int IMDT_KEYBOARD() {
        return IMDT_KEYBOARD;
    }
    private static final int IMDT_MOUSE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_MOUSE = 2
     * }
     */
    public static int IMDT_MOUSE() {
        return IMDT_MOUSE;
    }
    private static final int IMDT_TOUCH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCH = 4
     * }
     */
    public static int IMDT_TOUCH() {
        return IMDT_TOUCH;
    }
    private static final int IMDT_PEN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_PEN = 8
     * }
     */
    public static int IMDT_PEN() {
        return IMDT_PEN;
    }
    private static final int IMDT_TOUCHPAD = (int)16L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCHPAD = 16
     * }
     */
    public static int IMDT_TOUCHPAD() {
        return IMDT_TOUCHPAD;
    }
    private static final int IMO_UNAVAILABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_UNAVAILABLE = 0
     * }
     */
    public static int IMO_UNAVAILABLE() {
        return IMO_UNAVAILABLE;
    }
    private static final int IMO_HARDWARE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_HARDWARE = 1
     * }
     */
    public static int IMO_HARDWARE() {
        return IMO_HARDWARE;
    }
    private static final int IMO_INJECTED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_INJECTED = 2
     * }
     */
    public static int IMO_INJECTED() {
        return IMO_INJECTED;
    }
    private static final int IMO_SYSTEM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_SYSTEM = 4
     * }
     */
    public static int IMO_SYSTEM() {
        return IMO_SYSTEM;
    }

    private static class GetCurrentInputMessageSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentInputMessageSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static FunctionDescriptor GetCurrentInputMessageSource$descriptor() {
        return GetCurrentInputMessageSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static MethodHandle GetCurrentInputMessageSource$handle() {
        return GetCurrentInputMessageSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static MemorySegment GetCurrentInputMessageSource$address() {
        return GetCurrentInputMessageSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static int GetCurrentInputMessageSource(MemorySegment inputMessageSource) {
        var mh$ = GetCurrentInputMessageSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentInputMessageSource", inputMessageSource);
            }
            return (int)mh$.invokeExact(inputMessageSource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCIMSSM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCIMSSM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static FunctionDescriptor GetCIMSSM$descriptor() {
        return GetCIMSSM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static MethodHandle GetCIMSSM$handle() {
        return GetCIMSSM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static MemorySegment GetCIMSSM$address() {
        return GetCIMSSM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static int GetCIMSSM(MemorySegment inputMessageSource) {
        var mh$ = GetCIMSSM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCIMSSM", inputMessageSource);
            }
            return (int)mh$.invokeExact(inputMessageSource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AR_ENABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_ENABLED = 0
     * }
     */
    public static int AR_ENABLED() {
        return AR_ENABLED;
    }
    private static final int AR_DISABLED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_DISABLED = 1
     * }
     */
    public static int AR_DISABLED() {
        return AR_DISABLED;
    }
    private static final int AR_SUPPRESSED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_SUPPRESSED = 2
     * }
     */
    public static int AR_SUPPRESSED() {
        return AR_SUPPRESSED;
    }
    private static final int AR_REMOTESESSION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_REMOTESESSION = 4
     * }
     */
    public static int AR_REMOTESESSION() {
        return AR_REMOTESESSION;
    }
    private static final int AR_MULTIMON = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_MULTIMON = 8
     * }
     */
    public static int AR_MULTIMON() {
        return AR_MULTIMON;
    }
    private static final int AR_NOSENSOR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_NOSENSOR = 16
     * }
     */
    public static int AR_NOSENSOR() {
        return AR_NOSENSOR;
    }
    private static final int AR_NOT_SUPPORTED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_NOT_SUPPORTED = 32
     * }
     */
    public static int AR_NOT_SUPPORTED() {
        return AR_NOT_SUPPORTED;
    }
    private static final int AR_DOCKED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_DOCKED = 64
     * }
     */
    public static int AR_DOCKED() {
        return AR_DOCKED;
    }
    private static final int AR_LAPTOP = (int)128L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_LAPTOP = 128
     * }
     */
    public static int AR_LAPTOP() {
        return AR_LAPTOP;
    }
    /**
     * {@snippet lang=c :
     * typedef enum tagAR_STATE {
     *     AR_ENABLED = 0,
     *     AR_DISABLED = 1,
     *     AR_SUPPRESSED = 2,
     *     AR_REMOTESESSION = 4,
     *     AR_MULTIMON = 8,
     *     AR_NOSENSOR = 16,
     *     AR_NOT_SUPPORTED = 32,
     *     AR_DOCKED = 64,
     *     AR_LAPTOP = 128
     * } *PAR_STATE
     * }
     */
    public static final AddressLayout PAR_STATE = freeglut_h.C_POINTER;
    private static final int ORIENTATION_PREFERENCE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_NONE = 0
     * }
     */
    public static int ORIENTATION_PREFERENCE_NONE() {
        return ORIENTATION_PREFERENCE_NONE;
    }
    private static final int ORIENTATION_PREFERENCE_LANDSCAPE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_LANDSCAPE = 1
     * }
     */
    public static int ORIENTATION_PREFERENCE_LANDSCAPE() {
        return ORIENTATION_PREFERENCE_LANDSCAPE;
    }
    private static final int ORIENTATION_PREFERENCE_PORTRAIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_PORTRAIT = 2
     * }
     */
    public static int ORIENTATION_PREFERENCE_PORTRAIT() {
        return ORIENTATION_PREFERENCE_PORTRAIT;
    }
    private static final int ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 4
     * }
     */
    public static int ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED() {
        return ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED;
    }
    private static final int ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 8
     * }
     */
    public static int ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED() {
        return ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED;
    }

    private static class GetAutoRotationState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAutoRotationState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAutoRotationState(PAR_STATE pState)
     * }
     */
    public static FunctionDescriptor GetAutoRotationState$descriptor() {
        return GetAutoRotationState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAutoRotationState(PAR_STATE pState)
     * }
     */
    public static MethodHandle GetAutoRotationState$handle() {
        return GetAutoRotationState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAutoRotationState(PAR_STATE pState)
     * }
     */
    public static MemorySegment GetAutoRotationState$address() {
        return GetAutoRotationState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAutoRotationState(PAR_STATE pState)
     * }
     */
    public static int GetAutoRotationState(MemorySegment pState) {
        var mh$ = GetAutoRotationState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAutoRotationState", pState);
            }
            return (int)mh$.invokeExact(pState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDisplayAutoRotationPreferences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDisplayAutoRotationPreferences");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation)
     * }
     */
    public static FunctionDescriptor GetDisplayAutoRotationPreferences$descriptor() {
        return GetDisplayAutoRotationPreferences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation)
     * }
     */
    public static MethodHandle GetDisplayAutoRotationPreferences$handle() {
        return GetDisplayAutoRotationPreferences.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation)
     * }
     */
    public static MemorySegment GetDisplayAutoRotationPreferences$address() {
        return GetDisplayAutoRotationPreferences.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation)
     * }
     */
    public static int GetDisplayAutoRotationPreferences(MemorySegment pOrientation) {
        var mh$ = GetDisplayAutoRotationPreferences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDisplayAutoRotationPreferences", pOrientation);
            }
            return (int)mh$.invokeExact(pOrientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDisplayAutoRotationPreferencesByProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDisplayAutoRotationPreferencesByProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen)
     * }
     */
    public static FunctionDescriptor GetDisplayAutoRotationPreferencesByProcessId$descriptor() {
        return GetDisplayAutoRotationPreferencesByProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen)
     * }
     */
    public static MethodHandle GetDisplayAutoRotationPreferencesByProcessId$handle() {
        return GetDisplayAutoRotationPreferencesByProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen)
     * }
     */
    public static MemorySegment GetDisplayAutoRotationPreferencesByProcessId$address() {
        return GetDisplayAutoRotationPreferencesByProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen)
     * }
     */
    public static int GetDisplayAutoRotationPreferencesByProcessId(int dwProcessId, MemorySegment pOrientation, MemorySegment fRotateScreen) {
        var mh$ = GetDisplayAutoRotationPreferencesByProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDisplayAutoRotationPreferencesByProcessId", dwProcessId, pOrientation, fRotateScreen);
            }
            return (int)mh$.invokeExact(dwProcessId, pOrientation, fRotateScreen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDisplayAutoRotationPreferences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDisplayAutoRotationPreferences");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation)
     * }
     */
    public static FunctionDescriptor SetDisplayAutoRotationPreferences$descriptor() {
        return SetDisplayAutoRotationPreferences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation)
     * }
     */
    public static MethodHandle SetDisplayAutoRotationPreferences$handle() {
        return SetDisplayAutoRotationPreferences.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation)
     * }
     */
    public static MemorySegment SetDisplayAutoRotationPreferences$address() {
        return SetDisplayAutoRotationPreferences.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation)
     * }
     */
    public static int SetDisplayAutoRotationPreferences(int orientation) {
        var mh$ = SetDisplayAutoRotationPreferences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDisplayAutoRotationPreferences", orientation);
            }
            return (int)mh$.invokeExact(orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsImmersiveProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsImmersiveProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsImmersiveProcess(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor IsImmersiveProcess$descriptor() {
        return IsImmersiveProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsImmersiveProcess(HANDLE hProcess)
     * }
     */
    public static MethodHandle IsImmersiveProcess$handle() {
        return IsImmersiveProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsImmersiveProcess(HANDLE hProcess)
     * }
     */
    public static MemorySegment IsImmersiveProcess$address() {
        return IsImmersiveProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsImmersiveProcess(HANDLE hProcess)
     * }
     */
    public static int IsImmersiveProcess(MemorySegment hProcess) {
        var mh$ = IsImmersiveProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsImmersiveProcess", hProcess);
            }
            return (int)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessRestrictionExemption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessRestrictionExemption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessRestrictionExemption(BOOL fEnableExemption)
     * }
     */
    public static FunctionDescriptor SetProcessRestrictionExemption$descriptor() {
        return SetProcessRestrictionExemption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessRestrictionExemption(BOOL fEnableExemption)
     * }
     */
    public static MethodHandle SetProcessRestrictionExemption$handle() {
        return SetProcessRestrictionExemption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessRestrictionExemption(BOOL fEnableExemption)
     * }
     */
    public static MemorySegment SetProcessRestrictionExemption$address() {
        return SetProcessRestrictionExemption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessRestrictionExemption(BOOL fEnableExemption)
     * }
     */
    public static int SetProcessRestrictionExemption(int fEnableExemption) {
        var mh$ = SetProcessRestrictionExemption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessRestrictionExemption", fEnableExemption);
            }
            return (int)mh$.invokeExact(fEnableExemption);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDateFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDateFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
     * }
     */
    public static FunctionDescriptor GetDateFormatA$descriptor() {
        return GetDateFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
     * }
     */
    public static MethodHandle GetDateFormatA$handle() {
        return GetDateFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
     * }
     */
    public static MemorySegment GetDateFormatA$address() {
        return GetDateFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
     * }
     */
    public static int GetDateFormatA(int Locale, int dwFlags, MemorySegment lpDate, MemorySegment lpFormat, MemorySegment lpDateStr, int cchDate) {
        var mh$ = GetDateFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDateFormatA", Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDateFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDateFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
     * }
     */
    public static FunctionDescriptor GetDateFormatW$descriptor() {
        return GetDateFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
     * }
     */
    public static MethodHandle GetDateFormatW$handle() {
        return GetDateFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
     * }
     */
    public static MemorySegment GetDateFormatW$address() {
        return GetDateFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
     * }
     */
    public static int GetDateFormatW(int Locale, int dwFlags, MemorySegment lpDate, MemorySegment lpFormat, MemorySegment lpDateStr, int cchDate) {
        var mh$ = GetDateFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDateFormatW", Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTimeFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
     * }
     */
    public static FunctionDescriptor GetTimeFormatA$descriptor() {
        return GetTimeFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
     * }
     */
    public static MethodHandle GetTimeFormatA$handle() {
        return GetTimeFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
     * }
     */
    public static MemorySegment GetTimeFormatA$address() {
        return GetTimeFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
     * }
     */
    public static int GetTimeFormatA(int Locale, int dwFlags, MemorySegment lpTime, MemorySegment lpFormat, MemorySegment lpTimeStr, int cchTime) {
        var mh$ = GetTimeFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeFormatA", Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTimeFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static FunctionDescriptor GetTimeFormatW$descriptor() {
        return GetTimeFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static MethodHandle GetTimeFormatW$handle() {
        return GetTimeFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static MemorySegment GetTimeFormatW$address() {
        return GetTimeFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static int GetTimeFormatW(int Locale, int dwFlags, MemorySegment lpTime, MemorySegment lpFormat, MemorySegment lpTimeStr, int cchTime) {
        var mh$ = GetTimeFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeFormatW", Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTimeFormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static FunctionDescriptor GetTimeFormatEx$descriptor() {
        return GetTimeFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static MethodHandle GetTimeFormatEx$handle() {
        return GetTimeFormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static MemorySegment GetTimeFormatEx$address() {
        return GetTimeFormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static int GetTimeFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpTime, MemorySegment lpFormat, MemorySegment lpTimeStr, int cchTime) {
        var mh$ = GetTimeFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeFormatEx", lpLocaleName, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDateFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDateFormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
     * }
     */
    public static FunctionDescriptor GetDateFormatEx$descriptor() {
        return GetDateFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
     * }
     */
    public static MethodHandle GetDateFormatEx$handle() {
        return GetDateFormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
     * }
     */
    public static MemorySegment GetDateFormatEx$address() {
        return GetDateFormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
     * }
     */
    public static int GetDateFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpDate, MemorySegment lpFormat, MemorySegment lpDateStr, int cchDate, MemorySegment lpCalendar) {
        var mh$ = GetDateFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDateFormatEx", lpLocaleName, dwFlags, lpDate, lpFormat, lpDateStr, cchDate, lpCalendar);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpDate, lpFormat, lpDateStr, cchDate, lpCalendar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDurationFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDurationFormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static FunctionDescriptor GetDurationFormatEx$descriptor() {
        return GetDurationFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MethodHandle GetDurationFormatEx$handle() {
        return GetDurationFormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MemorySegment GetDurationFormatEx$address() {
        return GetDurationFormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static int GetDurationFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpDuration, long ullDuration, MemorySegment lpFormat, MemorySegment lpDurationStr, int cchDuration) {
        var mh$ = GetDurationFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDurationFormatEx", lpLocaleName, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD LGRPID
     * }
     */
    public static final OfInt LGRPID = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD LCTYPE
     * }
     */
    public static final OfInt LCTYPE = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD CALTYPE
     * }
     */
    public static final OfInt CALTYPE = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD CALID
     * }
     */
    public static final OfInt CALID = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _cpinfo {
     *     UINT MaxCharSize;
     *     BYTE DefaultChar[2];
     *     BYTE LeadByte[12];
     * } *LPCPINFO
     * }
     */
    public static final AddressLayout LPCPINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD GEOTYPE
     * }
     */
    public static final OfInt GEOTYPE = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD GEOCLASS
     * }
     */
    public static final OfInt GEOCLASS = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG GEOID
     * }
     */
    public static final OfInt GEOID = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _cpinfoexA {
     *     UINT MaxCharSize;
     *     BYTE DefaultChar[2];
     *     BYTE LeadByte[12];
     *     WCHAR UnicodeDefaultChar;
     *     UINT CodePage;
     *     CHAR CodePageName[260];
     * } *LPCPINFOEXA
     * }
     */
    public static final AddressLayout LPCPINFOEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cpinfoexW {
     *     UINT MaxCharSize;
     *     BYTE DefaultChar[2];
     *     BYTE LeadByte[12];
     *     WCHAR UnicodeDefaultChar;
     *     UINT CodePage;
     *     WCHAR CodePageName[260];
     * } *LPCPINFOEXW
     * }
     */
    public static final AddressLayout LPCPINFOEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCPINFOEXA LPCPINFOEX
     * }
     */
    public static final AddressLayout LPCPINFOEX = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _numberfmtA {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPSTR lpDecimalSep;
     *     LPSTR lpThousandSep;
     *     UINT NegativeOrder;
     * } *LPNUMBERFMTA
     * }
     */
    public static final AddressLayout LPNUMBERFMTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _numberfmtW {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPWSTR lpDecimalSep;
     *     LPWSTR lpThousandSep;
     *     UINT NegativeOrder;
     * } *LPNUMBERFMTW
     * }
     */
    public static final AddressLayout LPNUMBERFMTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNUMBERFMTA LPNUMBERFMT
     * }
     */
    public static final AddressLayout LPNUMBERFMT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _currencyfmtA {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPSTR lpDecimalSep;
     *     LPSTR lpThousandSep;
     *     UINT NegativeOrder;
     *     UINT PositiveOrder;
     *     LPSTR lpCurrencySymbol;
     * } *LPCURRENCYFMTA
     * }
     */
    public static final AddressLayout LPCURRENCYFMTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _currencyfmtW {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPWSTR lpDecimalSep;
     *     LPWSTR lpThousandSep;
     *     UINT NegativeOrder;
     *     UINT PositiveOrder;
     *     LPWSTR lpCurrencySymbol;
     * } *LPCURRENCYFMTW
     * }
     */
    public static final AddressLayout LPCURRENCYFMTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCURRENCYFMTA LPCURRENCYFMT
     * }
     */
    public static final AddressLayout LPCURRENCYFMT = freeglut_h.C_POINTER;
    private static final int COMPARE_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYSNLS_FUNCTION.COMPARE_STRING = 1
     * }
     */
    public static int COMPARE_STRING() {
        return COMPARE_STRING;
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD NLS_FUNCTION
     * }
     */
    public static final OfInt NLS_FUNCTION = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _nlsversioninfo {
     *     DWORD dwNLSVersionInfoSize;
     *     DWORD dwNLSVersion;
     *     DWORD dwDefinedVersion;
     *     DWORD dwEffectiveId;
     *     GUID guidCustomVersion;
     * } *LPNLSVERSIONINFO
     * }
     */
    public static final AddressLayout LPNLSVERSIONINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _nlsversioninfoex {
     *     DWORD dwNLSVersionInfoSize;
     *     DWORD dwNLSVersion;
     *     DWORD dwDefinedVersion;
     *     DWORD dwEffectiveId;
     *     GUID guidCustomVersion;
     * } *LPNLSVERSIONINFOEX
     * }
     */
    public static final AddressLayout LPNLSVERSIONINFOEX = freeglut_h.C_POINTER;
    private static final int GEO_NATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_NATION = 1
     * }
     */
    public static int GEO_NATION() {
        return GEO_NATION;
    }
    private static final int GEO_LATITUDE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LATITUDE = 2
     * }
     */
    public static int GEO_LATITUDE() {
        return GEO_LATITUDE;
    }
    private static final int GEO_LONGITUDE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LONGITUDE = 3
     * }
     */
    public static int GEO_LONGITUDE() {
        return GEO_LONGITUDE;
    }
    private static final int GEO_ISO2 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO2 = 4
     * }
     */
    public static int GEO_ISO2() {
        return GEO_ISO2;
    }
    private static final int GEO_ISO3 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO3 = 5
     * }
     */
    public static int GEO_ISO3() {
        return GEO_ISO3;
    }
    private static final int GEO_RFC1766 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_RFC1766 = 6
     * }
     */
    public static int GEO_RFC1766() {
        return GEO_RFC1766;
    }
    private static final int GEO_LCID = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LCID = 7
     * }
     */
    public static int GEO_LCID() {
        return GEO_LCID;
    }
    private static final int GEO_FRIENDLYNAME = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_FRIENDLYNAME = 8
     * }
     */
    public static int GEO_FRIENDLYNAME() {
        return GEO_FRIENDLYNAME;
    }
    private static final int GEO_OFFICIALNAME = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_OFFICIALNAME = 9
     * }
     */
    public static int GEO_OFFICIALNAME() {
        return GEO_OFFICIALNAME;
    }
    private static final int GEO_TIMEZONES = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_TIMEZONES = 10
     * }
     */
    public static int GEO_TIMEZONES() {
        return GEO_TIMEZONES;
    }
    private static final int GEO_OFFICIALLANGUAGES = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_OFFICIALLANGUAGES = 11
     * }
     */
    public static int GEO_OFFICIALLANGUAGES() {
        return GEO_OFFICIALLANGUAGES;
    }
    private static final int GEO_ISO_UN_NUMBER = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO_UN_NUMBER = 12
     * }
     */
    public static int GEO_ISO_UN_NUMBER() {
        return GEO_ISO_UN_NUMBER;
    }
    private static final int GEO_PARENT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_PARENT = 13
     * }
     */
    public static int GEO_PARENT() {
        return GEO_PARENT;
    }
    private static final int GEO_DIALINGCODE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_DIALINGCODE = 14
     * }
     */
    public static int GEO_DIALINGCODE() {
        return GEO_DIALINGCODE;
    }
    private static final int GEO_CURRENCYCODE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_CURRENCYCODE = 15
     * }
     */
    public static int GEO_CURRENCYCODE() {
        return GEO_CURRENCYCODE;
    }
    private static final int GEO_CURRENCYSYMBOL = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_CURRENCYSYMBOL = 16
     * }
     */
    public static int GEO_CURRENCYSYMBOL() {
        return GEO_CURRENCYSYMBOL;
    }
    private static final int GEO_NAME = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_NAME = 17
     * }
     */
    public static int GEO_NAME() {
        return GEO_NAME;
    }
    private static final int GEO_ID = (int)18L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ID = 18
     * }
     */
    public static int GEO_ID() {
        return GEO_ID;
    }
    private static final int GEOCLASS_NATION = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_NATION = 16
     * }
     */
    public static int GEOCLASS_NATION() {
        return GEOCLASS_NATION;
    }
    private static final int GEOCLASS_REGION = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_REGION = 14
     * }
     */
    public static int GEOCLASS_REGION() {
        return GEOCLASS_REGION;
    }
    private static final int GEOCLASS_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_ALL = 0
     * }
     */
    public static int GEOCLASS_ALL() {
        return GEOCLASS_ALL;
    }
    private static final int NormalizationOther = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationOther = 0
     * }
     */
    public static int NormalizationOther() {
        return NormalizationOther;
    }
    private static final int NormalizationC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationC = 1
     * }
     */
    public static int NormalizationC() {
        return NormalizationC;
    }
    private static final int NormalizationD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationD = 2
     * }
     */
    public static int NormalizationD() {
        return NormalizationD;
    }
    private static final int NormalizationKC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationKC = 5
     * }
     */
    public static int NormalizationKC() {
        return NormalizationKC;
    }
    private static final int NormalizationKD = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationKD = 6
     * }
     */
    public static int NormalizationKD() {
        return NormalizationKD;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILEMUIINFO {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwFileType;
     *     BYTE pChecksum[16];
     *     BYTE pServiceChecksum[16];
     *     DWORD dwLanguageNameOffset;
     *     DWORD dwTypeIDMainSize;
     *     DWORD dwTypeIDMainOffset;
     *     DWORD dwTypeNameMainOffset;
     *     DWORD dwTypeIDMUISize;
     *     DWORD dwTypeIDMUIOffset;
     *     DWORD dwTypeNameMUIOffset;
     *     BYTE abBuffer[8];
     * } *PFILEMUIINFO
     * }
     */
    public static final AddressLayout PFILEMUIINFO = freeglut_h.C_POINTER;

    private static class CompareStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CompareStringEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CompareStringEx$descriptor() {
        return CompareStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static MethodHandle CompareStringEx$handle() {
        return CompareStringEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static MemorySegment CompareStringEx$address() {
        return CompareStringEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static int CompareStringEx(MemorySegment lpLocaleName, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2, MemorySegment lpVersionInformation, MemorySegment lpReserved, long lParam) {
        var mh$ = CompareStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringEx", lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, lpVersionInformation, lpReserved, lParam);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, lpVersionInformation, lpReserved, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CompareStringOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static FunctionDescriptor CompareStringOrdinal$descriptor() {
        return CompareStringOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static MethodHandle CompareStringOrdinal$handle() {
        return CompareStringOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static MemorySegment CompareStringOrdinal$address() {
        return CompareStringOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static int CompareStringOrdinal(MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2, int bIgnoreCase) {
        var mh$ = CompareStringOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringOrdinal", lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase);
            }
            return (int)mh$.invokeExact(lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CompareStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static FunctionDescriptor CompareStringW$descriptor() {
        return CompareStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static MethodHandle CompareStringW$handle() {
        return CompareStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static MemorySegment CompareStringW$address() {
        return CompareStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static int CompareStringW(int Locale, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2) {
        var mh$ = CompareStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringW", Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
            }
            return (int)mh$.invokeExact(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FoldStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FoldStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor FoldStringW$descriptor() {
        return FoldStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle FoldStringW$handle() {
        return FoldStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment FoldStringW$address() {
        return FoldStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static int FoldStringW(int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = FoldStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FoldStringW", dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStringTypeExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeExW$descriptor() {
        return GetStringTypeExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeExW$handle() {
        return GetStringTypeExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeExW$address() {
        return GetStringTypeExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeExW(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeExW", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStringTypeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeW$descriptor() {
        return GetStringTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeW$handle() {
        return GetStringTypeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeW$address() {
        return GetStringTypeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeW(int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeW", dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MultiByteToWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MultiByteToWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static FunctionDescriptor MultiByteToWideChar$descriptor() {
        return MultiByteToWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static MethodHandle MultiByteToWideChar$handle() {
        return MultiByteToWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static MemorySegment MultiByteToWideChar$address() {
        return MultiByteToWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static int MultiByteToWideChar(int CodePage, int dwFlags, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpWideCharStr, int cchWideChar) {
        var mh$ = MultiByteToWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultiByteToWideChar", CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WideCharToMultiByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WideCharToMultiByte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static FunctionDescriptor WideCharToMultiByte$descriptor() {
        return WideCharToMultiByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static MethodHandle WideCharToMultiByte$handle() {
        return WideCharToMultiByte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static MemorySegment WideCharToMultiByte$address() {
        return WideCharToMultiByte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static int WideCharToMultiByte(int CodePage, int dwFlags, MemorySegment lpWideCharStr, int cchWideChar, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpDefaultChar, MemorySegment lpUsedDefaultChar) {
        var mh$ = WideCharToMultiByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WideCharToMultiByte", CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidCodePage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static FunctionDescriptor IsValidCodePage$descriptor() {
        return IsValidCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static MethodHandle IsValidCodePage$handle() {
        return IsValidCodePage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static MemorySegment IsValidCodePage$address() {
        return IsValidCodePage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static int IsValidCodePage(int CodePage) {
        var mh$ = IsValidCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidCodePage", CodePage);
            }
            return (int)mh$.invokeExact(CodePage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetACP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetACP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static FunctionDescriptor GetACP$descriptor() {
        return GetACP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static MethodHandle GetACP$handle() {
        return GetACP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static MemorySegment GetACP$address() {
        return GetACP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static int GetACP() {
        var mh$ = GetACP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetACP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOEMCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOEMCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static FunctionDescriptor GetOEMCP$descriptor() {
        return GetOEMCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static MethodHandle GetOEMCP$handle() {
        return GetOEMCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static MemorySegment GetOEMCP$address() {
        return GetOEMCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static int GetOEMCP() {
        var mh$ = GetOEMCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOEMCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCPInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static FunctionDescriptor GetCPInfo$descriptor() {
        return GetCPInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static MethodHandle GetCPInfo$handle() {
        return GetCPInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static MemorySegment GetCPInfo$address() {
        return GetCPInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static int GetCPInfo(int CodePage, MemorySegment lpCPInfo) {
        var mh$ = GetCPInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfo", CodePage, lpCPInfo);
            }
            return (int)mh$.invokeExact(CodePage, lpCPInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCPInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static FunctionDescriptor GetCPInfoExA$descriptor() {
        return GetCPInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static MethodHandle GetCPInfoExA$handle() {
        return GetCPInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static MemorySegment GetCPInfoExA$address() {
        return GetCPInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static int GetCPInfoExA(int CodePage, int dwFlags, MemorySegment lpCPInfoEx) {
        var mh$ = GetCPInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfoExA", CodePage, dwFlags, lpCPInfoEx);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpCPInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCPInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static FunctionDescriptor GetCPInfoExW$descriptor() {
        return GetCPInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static MethodHandle GetCPInfoExW$handle() {
        return GetCPInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static MemorySegment GetCPInfoExW$address() {
        return GetCPInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static int GetCPInfoExW(int CodePage, int dwFlags, MemorySegment lpCPInfoEx) {
        var mh$ = GetCPInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfoExW", CodePage, dwFlags, lpCPInfoEx);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpCPInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CompareStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static FunctionDescriptor CompareStringA$descriptor() {
        return CompareStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static MethodHandle CompareStringA$handle() {
        return CompareStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static MemorySegment CompareStringA$address() {
        return CompareStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static int CompareStringA(int Locale, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2) {
        var mh$ = CompareStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringA", Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
            }
            return (int)mh$.invokeExact(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNLSString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindNLSString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static FunctionDescriptor FindNLSString$descriptor() {
        return FindNLSString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static MethodHandle FindNLSString$handle() {
        return FindNLSString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static MemorySegment FindNLSString$address() {
        return FindNLSString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static int FindNLSString(int Locale, int dwFindNLSStringFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, MemorySegment pcchFound) {
        var mh$ = FindNLSString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNLSString", Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound);
            }
            return (int)mh$.invokeExact(Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LCMapStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor LCMapStringW$descriptor() {
        return LCMapStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle LCMapStringW$handle() {
        return LCMapStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment LCMapStringW$address() {
        return LCMapStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static int LCMapStringW(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = LCMapStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringW", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LCMapStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor LCMapStringA$descriptor() {
        return LCMapStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle LCMapStringA$handle() {
        return LCMapStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment LCMapStringA$address() {
        return LCMapStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static int LCMapStringA(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = LCMapStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringA", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLocaleInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoW$descriptor() {
        return GetLocaleInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoW$handle() {
        return GetLocaleInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MemorySegment GetLocaleInfoW$address() {
        return GetLocaleInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoW(int Locale, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoW", Locale, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLocaleInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoA$descriptor() {
        return GetLocaleInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoA$handle() {
        return GetLocaleInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static MemorySegment GetLocaleInfoA$address() {
        return GetLocaleInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoA(int Locale, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoA", Locale, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocaleInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetLocaleInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static FunctionDescriptor SetLocaleInfoA$descriptor() {
        return SetLocaleInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static MethodHandle SetLocaleInfoA$handle() {
        return SetLocaleInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static MemorySegment SetLocaleInfoA$address() {
        return SetLocaleInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static int SetLocaleInfoA(int Locale, int LCType, MemorySegment lpLCData) {
        var mh$ = SetLocaleInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocaleInfoA", Locale, LCType, lpLCData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocaleInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetLocaleInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static FunctionDescriptor SetLocaleInfoW$descriptor() {
        return SetLocaleInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static MethodHandle SetLocaleInfoW$handle() {
        return SetLocaleInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static MemorySegment SetLocaleInfoW$address() {
        return SetLocaleInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static int SetLocaleInfoW(int Locale, int LCType, MemorySegment lpLCData) {
        var mh$ = SetLocaleInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocaleInfoW", Locale, LCType, lpLCData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCalendarInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoA$descriptor() {
        return GetCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoA$handle() {
        return GetCalendarInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MemorySegment GetCalendarInfoA$address() {
        return GetCalendarInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoA(int Locale, int Calendar, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoA", Locale, Calendar, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCalendarInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoW$descriptor() {
        return GetCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoW$handle() {
        return GetCalendarInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MemorySegment GetCalendarInfoW$address() {
        return GetCalendarInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoW(int Locale, int Calendar, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoW", Locale, Calendar, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCalendarInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static FunctionDescriptor SetCalendarInfoA$descriptor() {
        return SetCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static MethodHandle SetCalendarInfoA$handle() {
        return SetCalendarInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static MemorySegment SetCalendarInfoA$address() {
        return SetCalendarInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static int SetCalendarInfoA(int Locale, int Calendar, int CalType, MemorySegment lpCalData) {
        var mh$ = SetCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCalendarInfoA", Locale, Calendar, CalType, lpCalData);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCalendarInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static FunctionDescriptor SetCalendarInfoW$descriptor() {
        return SetCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static MethodHandle SetCalendarInfoW$handle() {
        return SetCalendarInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static MemorySegment SetCalendarInfoW$address() {
        return SetCalendarInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static int SetCalendarInfoW(int Locale, int Calendar, int CalType, MemorySegment lpCalData) {
        var mh$ = SetCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCalendarInfoW", Locale, Calendar, CalType, lpCalData);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringByReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadStringByReference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static FunctionDescriptor LoadStringByReference$descriptor() {
        return LoadStringByReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static MethodHandle LoadStringByReference$handle() {
        return LoadStringByReference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static MemorySegment LoadStringByReference$address() {
        return LoadStringByReference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static int LoadStringByReference(int Flags, MemorySegment Language, MemorySegment SourceString, MemorySegment Buffer, int cchBuffer, MemorySegment Directory, MemorySegment pcchBufferOut) {
        var mh$ = LoadStringByReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringByReference", Flags, Language, SourceString, Buffer, cchBuffer, Directory, pcchBufferOut);
            }
            return (int)mh$.invokeExact(Flags, Language, SourceString, Buffer, cchBuffer, Directory, pcchBufferOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDBCSLeadByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsDBCSLeadByte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static FunctionDescriptor IsDBCSLeadByte$descriptor() {
        return IsDBCSLeadByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static MethodHandle IsDBCSLeadByte$handle() {
        return IsDBCSLeadByte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static MemorySegment IsDBCSLeadByte$address() {
        return IsDBCSLeadByte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static int IsDBCSLeadByte(byte TestChar) {
        var mh$ = IsDBCSLeadByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDBCSLeadByte", TestChar);
            }
            return (int)mh$.invokeExact(TestChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDBCSLeadByteEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsDBCSLeadByteEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static FunctionDescriptor IsDBCSLeadByteEx$descriptor() {
        return IsDBCSLeadByteEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static MethodHandle IsDBCSLeadByteEx$handle() {
        return IsDBCSLeadByteEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static MemorySegment IsDBCSLeadByteEx$address() {
        return IsDBCSLeadByteEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static int IsDBCSLeadByteEx(int CodePage, byte TestChar) {
        var mh$ = IsDBCSLeadByteEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDBCSLeadByteEx", CodePage, TestChar);
            }
            return (int)mh$.invokeExact(CodePage, TestChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocaleNameToLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocaleNameToLCID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LocaleNameToLCID$descriptor() {
        return LocaleNameToLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static MethodHandle LocaleNameToLCID$handle() {
        return LocaleNameToLCID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static MemorySegment LocaleNameToLCID$address() {
        return LocaleNameToLCID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static int LocaleNameToLCID(MemorySegment lpName, int dwFlags) {
        var mh$ = LocaleNameToLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocaleNameToLCID", lpName, dwFlags);
            }
            return (int)mh$.invokeExact(lpName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCIDToLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LCIDToLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LCIDToLocaleName$descriptor() {
        return LCIDToLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static MethodHandle LCIDToLocaleName$handle() {
        return LCIDToLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static MemorySegment LCIDToLocaleName$address() {
        return LCIDToLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static int LCIDToLocaleName(int Locale, MemorySegment lpName, int cchName, int dwFlags) {
        var mh$ = LCIDToLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCIDToLocaleName", Locale, lpName, cchName, dwFlags);
            }
            return (int)mh$.invokeExact(Locale, lpName, cchName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDurationFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDurationFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static FunctionDescriptor GetDurationFormat$descriptor() {
        return GetDurationFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MethodHandle GetDurationFormat$handle() {
        return GetDurationFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MemorySegment GetDurationFormat$address() {
        return GetDurationFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static int GetDurationFormat(int Locale, int dwFlags, MemorySegment lpDuration, long ullDuration, MemorySegment lpFormat, MemorySegment lpDurationStr, int cchDuration) {
        var mh$ = GetDurationFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDurationFormat", Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumberFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatA$descriptor() {
        return GetNumberFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatA$handle() {
        return GetNumberFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MemorySegment GetNumberFormatA$address() {
        return GetNumberFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatA(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatA", Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumberFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatW$descriptor() {
        return GetNumberFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatW$handle() {
        return GetNumberFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MemorySegment GetNumberFormatW$address() {
        return GetNumberFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatW(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatW", Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrencyFormatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatA$descriptor() {
        return GetCurrencyFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatA$handle() {
        return GetCurrencyFormatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MemorySegment GetCurrencyFormatA$address() {
        return GetCurrencyFormatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatA(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatA", Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrencyFormatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatW$descriptor() {
        return GetCurrencyFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatW$handle() {
        return GetCurrencyFormatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MemorySegment GetCurrencyFormatW$address() {
        return GetCurrencyFormatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatW(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatW", Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumCalendarInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoA$descriptor() {
        return EnumCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoA$handle() {
        return EnumCalendarInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoA$address() {
        return EnumCalendarInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoA(MemorySegment lpCalInfoEnumProc, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoA", lpCalInfoEnumProc, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProc, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumCalendarInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoW$descriptor() {
        return EnumCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoW$handle() {
        return EnumCalendarInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoW$address() {
        return EnumCalendarInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoW(MemorySegment lpCalInfoEnumProc, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoW", lpCalInfoEnumProc, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProc, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumCalendarInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExA$descriptor() {
        return EnumCalendarInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoExA$handle() {
        return EnumCalendarInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoExA$address() {
        return EnumCalendarInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoExA(MemorySegment lpCalInfoEnumProcEx, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExA", lpCalInfoEnumProcEx, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProcEx, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumCalendarInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExW$descriptor() {
        return EnumCalendarInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoExW$handle() {
        return EnumCalendarInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MemorySegment EnumCalendarInfoExW$address() {
        return EnumCalendarInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoExW(MemorySegment lpCalInfoEnumProcEx, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExW", lpCalInfoEnumProcEx, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProcEx, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumTimeFormatsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsA$descriptor() {
        return EnumTimeFormatsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumTimeFormatsA$handle() {
        return EnumTimeFormatsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumTimeFormatsA$address() {
        return EnumTimeFormatsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumTimeFormatsA(MemorySegment lpTimeFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumTimeFormatsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsA", lpTimeFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumTimeFormatsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsW$descriptor() {
        return EnumTimeFormatsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumTimeFormatsW$handle() {
        return EnumTimeFormatsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumTimeFormatsW$address() {
        return EnumTimeFormatsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumTimeFormatsW(MemorySegment lpTimeFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumTimeFormatsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsW", lpTimeFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDateFormatsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsA$descriptor() {
        return EnumDateFormatsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsA$handle() {
        return EnumDateFormatsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsA$address() {
        return EnumDateFormatsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsA(MemorySegment lpDateFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsA", lpDateFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDateFormatsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsW$descriptor() {
        return EnumDateFormatsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsW$handle() {
        return EnumDateFormatsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsW$address() {
        return EnumDateFormatsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsW(MemorySegment lpDateFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsW", lpDateFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDateFormatsExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExA$descriptor() {
        return EnumDateFormatsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsExA$handle() {
        return EnumDateFormatsExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsExA$address() {
        return EnumDateFormatsExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsExA(MemorySegment lpDateFmtEnumProcEx, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExA", lpDateFmtEnumProcEx, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcEx, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDateFormatsExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExW$descriptor() {
        return EnumDateFormatsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsExW$handle() {
        return EnumDateFormatsExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumDateFormatsExW$address() {
        return EnumDateFormatsExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsExW(MemorySegment lpDateFmtEnumProcEx, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExW", lpDateFmtEnumProcEx, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcEx, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLanguageGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidLanguageGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor IsValidLanguageGroup$descriptor() {
        return IsValidLanguageGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static MethodHandle IsValidLanguageGroup$handle() {
        return IsValidLanguageGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static MemorySegment IsValidLanguageGroup$address() {
        return IsValidLanguageGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static int IsValidLanguageGroup(int LanguageGroup, int dwFlags) {
        var mh$ = IsValidLanguageGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLanguageGroup", LanguageGroup, dwFlags);
            }
            return (int)mh$.invokeExact(LanguageGroup, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNLSVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNLSVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetNLSVersion$descriptor() {
        return GetNLSVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static MethodHandle GetNLSVersion$handle() {
        return GetNLSVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static MemorySegment GetNLSVersion$address() {
        return GetNLSVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static int GetNLSVersion(int Function, int Locale, MemorySegment lpVersionInformation) {
        var mh$ = GetNLSVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNLSVersion", Function, Locale, lpVersionInformation);
            }
            return (int)mh$.invokeExact(Function, Locale, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor IsValidLocale$descriptor() {
        return IsValidLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle IsValidLocale$handle() {
        return IsValidLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static MemorySegment IsValidLocale$address() {
        return IsValidLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static int IsValidLocale(int Locale, int dwFlags) {
        var mh$ = IsValidLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLocale", Locale, dwFlags);
            }
            return (int)mh$.invokeExact(Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGeoInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static FunctionDescriptor GetGeoInfoA$descriptor() {
        return GetGeoInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MethodHandle GetGeoInfoA$handle() {
        return GetGeoInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MemorySegment GetGeoInfoA$address() {
        return GetGeoInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static int GetGeoInfoA(int Location, int GeoType, MemorySegment lpGeoData, int cchData, short LangId) {
        var mh$ = GetGeoInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoA", Location, GeoType, lpGeoData, cchData, LangId);
            }
            return (int)mh$.invokeExact(Location, GeoType, lpGeoData, cchData, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGeoInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static FunctionDescriptor GetGeoInfoW$descriptor() {
        return GetGeoInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MethodHandle GetGeoInfoW$handle() {
        return GetGeoInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MemorySegment GetGeoInfoW$address() {
        return GetGeoInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static int GetGeoInfoW(int Location, int GeoType, MemorySegment lpGeoData, int cchData, short LangId) {
        var mh$ = GetGeoInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoW", Location, GeoType, lpGeoData, cchData, LangId);
            }
            return (int)mh$.invokeExact(Location, GeoType, lpGeoData, cchData, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetGeoInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static FunctionDescriptor GetGeoInfoEx$descriptor() {
        return GetGeoInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static MethodHandle GetGeoInfoEx$handle() {
        return GetGeoInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static MemorySegment GetGeoInfoEx$address() {
        return GetGeoInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static int GetGeoInfoEx(MemorySegment location, int geoType, MemorySegment geoData, int geoDataCount) {
        var mh$ = GetGeoInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoEx", location, geoType, geoData, geoDataCount);
            }
            return (int)mh$.invokeExact(location, geoType, geoData, geoDataCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemGeoID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static FunctionDescriptor EnumSystemGeoID$descriptor() {
        return EnumSystemGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static MethodHandle EnumSystemGeoID$handle() {
        return EnumSystemGeoID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static MemorySegment EnumSystemGeoID$address() {
        return EnumSystemGeoID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static int EnumSystemGeoID(int GeoClass, int ParentGeoId, MemorySegment lpGeoEnumProc) {
        var mh$ = EnumSystemGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemGeoID", GeoClass, ParentGeoId, lpGeoEnumProc);
            }
            return (int)mh$.invokeExact(GeoClass, ParentGeoId, lpGeoEnumProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemGeoNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemGeoNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static FunctionDescriptor EnumSystemGeoNames$descriptor() {
        return EnumSystemGeoNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static MethodHandle EnumSystemGeoNames$handle() {
        return EnumSystemGeoNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static MemorySegment EnumSystemGeoNames$address() {
        return EnumSystemGeoNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static int EnumSystemGeoNames(int geoClass, MemorySegment geoEnumProc, long data) {
        var mh$ = EnumSystemGeoNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemGeoNames", geoClass, geoEnumProc, data);
            }
            return (int)mh$.invokeExact(geoClass, geoEnumProc, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserGeoID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static FunctionDescriptor GetUserGeoID$descriptor() {
        return GetUserGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static MethodHandle GetUserGeoID$handle() {
        return GetUserGeoID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static MemorySegment GetUserGeoID$address() {
        return GetUserGeoID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static int GetUserGeoID(int GeoClass) {
        var mh$ = GetUserGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserGeoID", GeoClass);
            }
            return (int)mh$.invokeExact(GeoClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultGeoName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserDefaultGeoName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static FunctionDescriptor GetUserDefaultGeoName$descriptor() {
        return GetUserDefaultGeoName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static MethodHandle GetUserDefaultGeoName$handle() {
        return GetUserDefaultGeoName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static MemorySegment GetUserDefaultGeoName$address() {
        return GetUserDefaultGeoName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static int GetUserDefaultGeoName(MemorySegment geoName, int geoNameCount) {
        var mh$ = GetUserDefaultGeoName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultGeoName", geoName, geoNameCount);
            }
            return (int)mh$.invokeExact(geoName, geoNameCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetUserGeoID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static FunctionDescriptor SetUserGeoID$descriptor() {
        return SetUserGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static MethodHandle SetUserGeoID$handle() {
        return SetUserGeoID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static MemorySegment SetUserGeoID$address() {
        return SetUserGeoID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static int SetUserGeoID(int GeoId) {
        var mh$ = SetUserGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserGeoID", GeoId);
            }
            return (int)mh$.invokeExact(GeoId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserGeoName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetUserGeoName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static FunctionDescriptor SetUserGeoName$descriptor() {
        return SetUserGeoName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static MethodHandle SetUserGeoName$handle() {
        return SetUserGeoName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static MemorySegment SetUserGeoName$address() {
        return SetUserGeoName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static int SetUserGeoName(MemorySegment geoName) {
        var mh$ = SetUserGeoName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserGeoName", geoName);
            }
            return (int)mh$.invokeExact(geoName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertDefaultLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConvertDefaultLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static FunctionDescriptor ConvertDefaultLocale$descriptor() {
        return ConvertDefaultLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static MethodHandle ConvertDefaultLocale$handle() {
        return ConvertDefaultLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static MemorySegment ConvertDefaultLocale$address() {
        return ConvertDefaultLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static int ConvertDefaultLocale(int Locale) {
        var mh$ = ConvertDefaultLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertDefaultLocale", Locale);
            }
            return (int)mh$.invokeExact(Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDefaultUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultUILanguage$descriptor() {
        return GetSystemDefaultUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static MethodHandle GetSystemDefaultUILanguage$handle() {
        return GetSystemDefaultUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static MemorySegment GetSystemDefaultUILanguage$address() {
        return GetSystemDefaultUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static short GetSystemDefaultUILanguage() {
        var mh$ = GetSystemDefaultUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static FunctionDescriptor GetThreadLocale$descriptor() {
        return GetThreadLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static MethodHandle GetThreadLocale$handle() {
        return GetThreadLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static MemorySegment GetThreadLocale$address() {
        return GetThreadLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static int GetThreadLocale() {
        var mh$ = GetThreadLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadLocale");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static FunctionDescriptor SetThreadLocale$descriptor() {
        return SetThreadLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static MethodHandle SetThreadLocale$handle() {
        return SetThreadLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static MemorySegment SetThreadLocale$address() {
        return SetThreadLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static int SetThreadLocale(int Locale) {
        var mh$ = SetThreadLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadLocale", Locale);
            }
            return (int)mh$.invokeExact(Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserDefaultUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static FunctionDescriptor GetUserDefaultUILanguage$descriptor() {
        return GetUserDefaultUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static MethodHandle GetUserDefaultUILanguage$handle() {
        return GetUserDefaultUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static MemorySegment GetUserDefaultUILanguage$address() {
        return GetUserDefaultUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static short GetUserDefaultUILanguage() {
        var mh$ = GetUserDefaultUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLangID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserDefaultLangID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static FunctionDescriptor GetUserDefaultLangID$descriptor() {
        return GetUserDefaultLangID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static MethodHandle GetUserDefaultLangID$handle() {
        return GetUserDefaultLangID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static MemorySegment GetUserDefaultLangID$address() {
        return GetUserDefaultLangID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static short GetUserDefaultLangID() {
        var mh$ = GetUserDefaultLangID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLangID");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLangID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDefaultLangID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLangID$descriptor() {
        return GetSystemDefaultLangID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static MethodHandle GetSystemDefaultLangID$handle() {
        return GetSystemDefaultLangID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static MemorySegment GetSystemDefaultLangID$address() {
        return GetSystemDefaultLangID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static short GetSystemDefaultLangID() {
        var mh$ = GetSystemDefaultLangID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLangID");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDefaultLCID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLCID$descriptor() {
        return GetSystemDefaultLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static MethodHandle GetSystemDefaultLCID$handle() {
        return GetSystemDefaultLCID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static MemorySegment GetSystemDefaultLCID$address() {
        return GetSystemDefaultLCID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static int GetSystemDefaultLCID() {
        var mh$ = GetSystemDefaultLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLCID");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserDefaultLCID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static FunctionDescriptor GetUserDefaultLCID$descriptor() {
        return GetUserDefaultLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static MethodHandle GetUserDefaultLCID$handle() {
        return GetUserDefaultLCID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static MemorySegment GetUserDefaultLCID$address() {
        return GetUserDefaultLCID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static int GetUserDefaultLCID() {
        var mh$ = GetUserDefaultLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLCID");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static FunctionDescriptor SetThreadUILanguage$descriptor() {
        return SetThreadUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static MethodHandle SetThreadUILanguage$handle() {
        return SetThreadUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static MemorySegment SetThreadUILanguage$address() {
        return SetThreadUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static short SetThreadUILanguage(short LangId) {
        var mh$ = SetThreadUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadUILanguage", LangId);
            }
            return (short)mh$.invokeExact(LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadUILanguage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static FunctionDescriptor GetThreadUILanguage$descriptor() {
        return GetThreadUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static MethodHandle GetThreadUILanguage$handle() {
        return GetThreadUILanguage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static MemorySegment GetThreadUILanguage$address() {
        return GetThreadUILanguage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static short GetThreadUILanguage() {
        var mh$ = GetThreadUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetProcessPreferredUILanguages$descriptor() {
        return GetProcessPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetProcessPreferredUILanguages$handle() {
        return GetProcessPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetProcessPreferredUILanguages$address() {
        return GetProcessPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetProcessPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetProcessPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static FunctionDescriptor SetProcessPreferredUILanguages$descriptor() {
        return SetProcessPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MethodHandle SetProcessPreferredUILanguages$handle() {
        return SetProcessPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MemorySegment SetProcessPreferredUILanguages$address() {
        return SetProcessPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static int SetProcessPreferredUILanguages(int dwFlags, MemorySegment pwszLanguagesBuffer, MemorySegment pulNumLanguages) {
        var mh$ = SetProcessPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessPreferredUILanguages", dwFlags, pwszLanguagesBuffer, pulNumLanguages);
            }
            return (int)mh$.invokeExact(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetUserPreferredUILanguages$descriptor() {
        return GetUserPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetUserPreferredUILanguages$handle() {
        return GetUserPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetUserPreferredUILanguages$address() {
        return GetUserPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetUserPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetUserPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetSystemPreferredUILanguages$descriptor() {
        return GetSystemPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetSystemPreferredUILanguages$handle() {
        return GetSystemPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetSystemPreferredUILanguages$address() {
        return GetSystemPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetSystemPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetSystemPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetThreadPreferredUILanguages$descriptor() {
        return GetThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetThreadPreferredUILanguages$handle() {
        return GetThreadPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MemorySegment GetThreadPreferredUILanguages$address() {
        return GetThreadPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetThreadPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static FunctionDescriptor SetThreadPreferredUILanguages$descriptor() {
        return SetThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MethodHandle SetThreadPreferredUILanguages$handle() {
        return SetThreadPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MemorySegment SetThreadPreferredUILanguages$address() {
        return SetThreadPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static int SetThreadPreferredUILanguages(int dwFlags, MemorySegment pwszLanguagesBuffer, MemorySegment pulNumLanguages) {
        var mh$ = SetThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPreferredUILanguages", dwFlags, pwszLanguagesBuffer, pulNumLanguages);
            }
            return (int)mh$.invokeExact(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileMUIInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileMUIInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static FunctionDescriptor GetFileMUIInfo$descriptor() {
        return GetFileMUIInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static MethodHandle GetFileMUIInfo$handle() {
        return GetFileMUIInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static MemorySegment GetFileMUIInfo$address() {
        return GetFileMUIInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static int GetFileMUIInfo(int dwFlags, MemorySegment pcwszFilePath, MemorySegment pFileMUIInfo, MemorySegment pcbFileMUIInfo) {
        var mh$ = GetFileMUIInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileMUIInfo", dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo);
            }
            return (int)mh$.invokeExact(dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileMUIPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileMUIPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static FunctionDescriptor GetFileMUIPath$descriptor() {
        return GetFileMUIPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static MethodHandle GetFileMUIPath$handle() {
        return GetFileMUIPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static MemorySegment GetFileMUIPath$address() {
        return GetFileMUIPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static int GetFileMUIPath(int dwFlags, MemorySegment pcwszFilePath, MemorySegment pwszLanguage, MemorySegment pcchLanguage, MemorySegment pwszFileMUIPath, MemorySegment pcchFileMUIPath, MemorySegment pululEnumerator) {
        var mh$ = GetFileMUIPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileMUIPath", dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator);
            }
            return (int)mh$.invokeExact(dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUILanguageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUILanguageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static FunctionDescriptor GetUILanguageInfo$descriptor() {
        return GetUILanguageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static MethodHandle GetUILanguageInfo$handle() {
        return GetUILanguageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static MemorySegment GetUILanguageInfo$address() {
        return GetUILanguageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static int GetUILanguageInfo(int dwFlags, MemorySegment pwmszLanguage, MemorySegment pwszFallbackLanguages, MemorySegment pcchFallbackLanguages, MemorySegment pAttributes) {
        var mh$ = GetUILanguageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUILanguageInfo", dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes);
            }
            return (int)mh$.invokeExact(dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HSAVEDUILANGUAGES__ {
     *     int unused;
     * } *HSAVEDUILANGUAGES
     * }
     */
    public static final AddressLayout HSAVEDUILANGUAGES = freeglut_h.C_POINTER;

    private static class SetThreadPreferredUILanguages2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadPreferredUILanguages2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static FunctionDescriptor SetThreadPreferredUILanguages2$descriptor() {
        return SetThreadPreferredUILanguages2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static MethodHandle SetThreadPreferredUILanguages2$handle() {
        return SetThreadPreferredUILanguages2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static MemorySegment SetThreadPreferredUILanguages2$address() {
        return SetThreadPreferredUILanguages2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static int SetThreadPreferredUILanguages2(int flags, MemorySegment languages, MemorySegment numLanguagesSet, MemorySegment snapshot) {
        var mh$ = SetThreadPreferredUILanguages2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPreferredUILanguages2", flags, languages, numLanguagesSet, snapshot);
            }
            return (int)mh$.invokeExact(flags, languages, numLanguagesSet, snapshot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RestoreThreadPreferredUILanguages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static FunctionDescriptor RestoreThreadPreferredUILanguages$descriptor() {
        return RestoreThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static MethodHandle RestoreThreadPreferredUILanguages$handle() {
        return RestoreThreadPreferredUILanguages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static MemorySegment RestoreThreadPreferredUILanguages$address() {
        return RestoreThreadPreferredUILanguages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static void RestoreThreadPreferredUILanguages(MemorySegment snapshot) {
        var mh$ = RestoreThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreThreadPreferredUILanguages", snapshot);
            }
            mh$.invokeExact(snapshot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyUILanguageChange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("NotifyUILanguageChange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static FunctionDescriptor NotifyUILanguageChange$descriptor() {
        return NotifyUILanguageChange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static MethodHandle NotifyUILanguageChange$handle() {
        return NotifyUILanguageChange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static MemorySegment NotifyUILanguageChange$address() {
        return NotifyUILanguageChange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static int NotifyUILanguageChange(int dwFlags, MemorySegment pcwstrNewLanguage, MemorySegment pcwstrPreviousLanguage, int dwReserved, MemorySegment pdwStatusRtrn) {
        var mh$ = NotifyUILanguageChange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyUILanguageChange", dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, dwReserved, pdwStatusRtrn);
            }
            return (int)mh$.invokeExact(dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, dwReserved, pdwStatusRtrn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStringTypeExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeExA$descriptor() {
        return GetStringTypeExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeExA$handle() {
        return GetStringTypeExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeExA$address() {
        return GetStringTypeExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeExA(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeExA", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStringTypeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeA$descriptor() {
        return GetStringTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeA$handle() {
        return GetStringTypeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MemorySegment GetStringTypeA$address() {
        return GetStringTypeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeA(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeA", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FoldStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FoldStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor FoldStringA$descriptor() {
        return FoldStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle FoldStringA$handle() {
        return FoldStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MemorySegment FoldStringA$address() {
        return FoldStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static int FoldStringA(int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = FoldStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FoldStringA", dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemLocalesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesA$descriptor() {
        return EnumSystemLocalesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemLocalesA$handle() {
        return EnumSystemLocalesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemLocalesA$address() {
        return EnumSystemLocalesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemLocalesA(MemorySegment lpLocaleEnumProc, int dwFlags) {
        var mh$ = EnumSystemLocalesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesA", lpLocaleEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemLocalesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesW$descriptor() {
        return EnumSystemLocalesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemLocalesW$handle() {
        return EnumSystemLocalesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemLocalesW$address() {
        return EnumSystemLocalesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemLocalesW(MemorySegment lpLocaleEnumProc, int dwFlags) {
        var mh$ = EnumSystemLocalesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesW", lpLocaleEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLanguageGroupsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemLanguageGroupsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumSystemLanguageGroupsA$descriptor() {
        return EnumSystemLanguageGroupsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumSystemLanguageGroupsA$handle() {
        return EnumSystemLanguageGroupsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumSystemLanguageGroupsA$address() {
        return EnumSystemLanguageGroupsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumSystemLanguageGroupsA(MemorySegment lpLanguageGroupEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumSystemLanguageGroupsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLanguageGroupsA", lpLanguageGroupEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLanguageGroupEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLanguageGroupsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemLanguageGroupsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumSystemLanguageGroupsW$descriptor() {
        return EnumSystemLanguageGroupsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumSystemLanguageGroupsW$handle() {
        return EnumSystemLanguageGroupsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumSystemLanguageGroupsW$address() {
        return EnumSystemLanguageGroupsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumSystemLanguageGroupsW(MemorySegment lpLanguageGroupEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumSystemLanguageGroupsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLanguageGroupsW", lpLanguageGroupEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLanguageGroupEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumLanguageGroupLocalesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumLanguageGroupLocalesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumLanguageGroupLocalesA$descriptor() {
        return EnumLanguageGroupLocalesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumLanguageGroupLocalesA$handle() {
        return EnumLanguageGroupLocalesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumLanguageGroupLocalesA$address() {
        return EnumLanguageGroupLocalesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumLanguageGroupLocalesA(MemorySegment lpLangGroupLocaleEnumProc, int LanguageGroup, int dwFlags, long lParam) {
        var mh$ = EnumLanguageGroupLocalesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumLanguageGroupLocalesA", lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumLanguageGroupLocalesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumLanguageGroupLocalesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumLanguageGroupLocalesW$descriptor() {
        return EnumLanguageGroupLocalesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumLanguageGroupLocalesW$handle() {
        return EnumLanguageGroupLocalesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumLanguageGroupLocalesW$address() {
        return EnumLanguageGroupLocalesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumLanguageGroupLocalesW(MemorySegment lpLangGroupLocaleEnumProc, int LanguageGroup, int dwFlags, long lParam) {
        var mh$ = EnumLanguageGroupLocalesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumLanguageGroupLocalesW", lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumUILanguagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumUILanguagesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumUILanguagesA$descriptor() {
        return EnumUILanguagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumUILanguagesA$handle() {
        return EnumUILanguagesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumUILanguagesA$address() {
        return EnumUILanguagesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumUILanguagesA(MemorySegment lpUILanguageEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumUILanguagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumUILanguagesA", lpUILanguageEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpUILanguageEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumUILanguagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumUILanguagesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumUILanguagesW$descriptor() {
        return EnumUILanguagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumUILanguagesW$handle() {
        return EnumUILanguagesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumUILanguagesW$address() {
        return EnumUILanguagesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumUILanguagesW(MemorySegment lpUILanguageEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumUILanguagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumUILanguagesW", lpUILanguageEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpUILanguageEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemCodePagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemCodePagesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemCodePagesA$descriptor() {
        return EnumSystemCodePagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemCodePagesA$handle() {
        return EnumSystemCodePagesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemCodePagesA$address() {
        return EnumSystemCodePagesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemCodePagesA(MemorySegment lpCodePageEnumProc, int dwFlags) {
        var mh$ = EnumSystemCodePagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemCodePagesA", lpCodePageEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpCodePageEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemCodePagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemCodePagesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemCodePagesW$descriptor() {
        return EnumSystemCodePagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemCodePagesW$handle() {
        return EnumSystemCodePagesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnumSystemCodePagesW$address() {
        return EnumSystemCodePagesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemCodePagesW(MemorySegment lpCodePageEnumProc, int dwFlags) {
        var mh$ = EnumSystemCodePagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemCodePagesW", lpCodePageEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpCodePageEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToAscii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IdnToAscii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static FunctionDescriptor IdnToAscii$descriptor() {
        return IdnToAscii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static MethodHandle IdnToAscii$handle() {
        return IdnToAscii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static MemorySegment IdnToAscii$address() {
        return IdnToAscii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static int IdnToAscii(int dwFlags, MemorySegment lpUnicodeCharStr, int cchUnicodeChar, MemorySegment lpASCIICharStr, int cchASCIIChar) {
        var mh$ = IdnToAscii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToAscii", dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IdnToUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static FunctionDescriptor IdnToUnicode$descriptor() {
        return IdnToUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static MethodHandle IdnToUnicode$handle() {
        return IdnToUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static MemorySegment IdnToUnicode$address() {
        return IdnToUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static int IdnToUnicode(int dwFlags, MemorySegment lpASCIICharStr, int cchASCIIChar, MemorySegment lpUnicodeCharStr, int cchUnicodeChar) {
        var mh$ = IdnToUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToUnicode", dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToNameprepUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IdnToNameprepUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static FunctionDescriptor IdnToNameprepUnicode$descriptor() {
        return IdnToNameprepUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static MethodHandle IdnToNameprepUnicode$handle() {
        return IdnToNameprepUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static MemorySegment IdnToNameprepUnicode$address() {
        return IdnToNameprepUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static int IdnToNameprepUnicode(int dwFlags, MemorySegment lpUnicodeCharStr, int cchUnicodeChar, MemorySegment lpNameprepCharStr, int cchNameprepChar) {
        var mh$ = IdnToNameprepUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToNameprepUnicode", dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NormalizeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("NormalizeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static FunctionDescriptor NormalizeString$descriptor() {
        return NormalizeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static MethodHandle NormalizeString$handle() {
        return NormalizeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static MemorySegment NormalizeString$address() {
        return NormalizeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static int NormalizeString(int NormForm, MemorySegment lpSrcString, int cwSrcLength, MemorySegment lpDstString, int cwDstLength) {
        var mh$ = NormalizeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NormalizeString", NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength);
            }
            return (int)mh$.invokeExact(NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNormalizedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsNormalizedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static FunctionDescriptor IsNormalizedString$descriptor() {
        return IsNormalizedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static MethodHandle IsNormalizedString$handle() {
        return IsNormalizedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static MemorySegment IsNormalizedString$address() {
        return IsNormalizedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static int IsNormalizedString(int NormForm, MemorySegment lpString, int cwLength) {
        var mh$ = IsNormalizedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNormalizedString", NormForm, lpString, cwLength);
            }
            return (int)mh$.invokeExact(NormForm, lpString, cwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyScripts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerifyScripts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static FunctionDescriptor VerifyScripts$descriptor() {
        return VerifyScripts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static MethodHandle VerifyScripts$handle() {
        return VerifyScripts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static MemorySegment VerifyScripts$address() {
        return VerifyScripts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static int VerifyScripts(int dwFlags, MemorySegment lpLocaleScripts, int cchLocaleScripts, MemorySegment lpTestScripts, int cchTestScripts) {
        var mh$ = VerifyScripts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyScripts", dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts);
            }
            return (int)mh$.invokeExact(dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringScripts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStringScripts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static FunctionDescriptor GetStringScripts$descriptor() {
        return GetStringScripts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static MethodHandle GetStringScripts$handle() {
        return GetStringScripts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static MemorySegment GetStringScripts$address() {
        return GetStringScripts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static int GetStringScripts(int dwFlags, MemorySegment lpString, int cchString, MemorySegment lpScripts, int cchScripts) {
        var mh$ = GetStringScripts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringScripts", dwFlags, lpString, cchString, lpScripts, cchScripts);
            }
            return (int)mh$.invokeExact(dwFlags, lpString, cchString, lpScripts, cchScripts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLocaleInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoEx$descriptor() {
        return GetLocaleInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoEx$handle() {
        return GetLocaleInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MemorySegment GetLocaleInfoEx$address() {
        return GetLocaleInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoEx(MemorySegment lpLocaleName, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoEx", lpLocaleName, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(lpLocaleName, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCalendarInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoEx$descriptor() {
        return GetCalendarInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoEx$handle() {
        return GetCalendarInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MemorySegment GetCalendarInfoEx$address() {
        return GetCalendarInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoEx(MemorySegment lpLocaleName, int Calendar, MemorySegment lpReserved, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoEx", lpLocaleName, Calendar, lpReserved, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(lpLocaleName, Calendar, lpReserved, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumberFormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatEx$descriptor() {
        return GetNumberFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatEx$handle() {
        return GetNumberFormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MemorySegment GetNumberFormatEx$address() {
        return GetNumberFormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatEx", lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrencyFormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatEx$descriptor() {
        return GetCurrencyFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatEx$handle() {
        return GetCurrencyFormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MemorySegment GetCurrencyFormatEx$address() {
        return GetCurrencyFormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatEx", lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUserDefaultLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor GetUserDefaultLocaleName$descriptor() {
        return GetUserDefaultLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle GetUserDefaultLocaleName$handle() {
        return GetUserDefaultLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MemorySegment GetUserDefaultLocaleName$address() {
        return GetUserDefaultLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int GetUserDefaultLocaleName(MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = GetUserDefaultLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLocaleName", lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDefaultLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLocaleName$descriptor() {
        return GetSystemDefaultLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle GetSystemDefaultLocaleName$handle() {
        return GetSystemDefaultLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MemorySegment GetSystemDefaultLocaleName$address() {
        return GetSystemDefaultLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int GetSystemDefaultLocaleName(MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = GetSystemDefaultLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLocaleName", lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNLSDefinedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsNLSDefinedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static FunctionDescriptor IsNLSDefinedString$descriptor() {
        return IsNLSDefinedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static MethodHandle IsNLSDefinedString$handle() {
        return IsNLSDefinedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static MemorySegment IsNLSDefinedString$address() {
        return IsNLSDefinedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static int IsNLSDefinedString(int Function, int dwFlags, MemorySegment lpVersionInformation, MemorySegment lpString, int cchStr) {
        var mh$ = IsNLSDefinedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNLSDefinedString", Function, dwFlags, lpVersionInformation, lpString, cchStr);
            }
            return (int)mh$.invokeExact(Function, dwFlags, lpVersionInformation, lpString, cchStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNLSVersionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNLSVersionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetNLSVersionEx$descriptor() {
        return GetNLSVersionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MethodHandle GetNLSVersionEx$handle() {
        return GetNLSVersionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MemorySegment GetNLSVersionEx$address() {
        return GetNLSVersionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static int GetNLSVersionEx(int function, MemorySegment lpLocaleName, MemorySegment lpVersionInformation) {
        var mh$ = GetNLSVersionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNLSVersionEx", function, lpLocaleName, lpVersionInformation);
            }
            return (int)mh$.invokeExact(function, lpLocaleName, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidNLSVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidNLSVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static FunctionDescriptor IsValidNLSVersion$descriptor() {
        return IsValidNLSVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MethodHandle IsValidNLSVersion$handle() {
        return IsValidNLSVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MemorySegment IsValidNLSVersion$address() {
        return IsValidNLSVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static int IsValidNLSVersion(int function, MemorySegment lpLocaleName, MemorySegment lpVersionInformation) {
        var mh$ = IsValidNLSVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidNLSVersion", function, lpLocaleName, lpVersionInformation);
            }
            return (int)mh$.invokeExact(function, lpLocaleName, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNLSStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindNLSStringEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static FunctionDescriptor FindNLSStringEx$descriptor() {
        return FindNLSStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MethodHandle FindNLSStringEx$handle() {
        return FindNLSStringEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MemorySegment FindNLSStringEx$address() {
        return FindNLSStringEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static int FindNLSStringEx(MemorySegment lpLocaleName, int dwFindNLSStringFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, MemorySegment pcchFound, MemorySegment lpVersionInformation, MemorySegment lpReserved, long sortHandle) {
        var mh$ = FindNLSStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNLSStringEx", lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, lpReserved, sortHandle);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, lpReserved, sortHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LCMapStringEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static FunctionDescriptor LCMapStringEx$descriptor() {
        return LCMapStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MethodHandle LCMapStringEx$handle() {
        return LCMapStringEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MemorySegment LCMapStringEx$address() {
        return LCMapStringEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static int LCMapStringEx(MemorySegment lpLocaleName, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest, MemorySegment lpVersionInformation, MemorySegment lpReserved, long sortHandle) {
        var mh$ = LCMapStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringEx", lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, lpReserved, sortHandle);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, lpReserved, sortHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static FunctionDescriptor IsValidLocaleName$descriptor() {
        return IsValidLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static MethodHandle IsValidLocaleName$handle() {
        return IsValidLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static MemorySegment IsValidLocaleName$address() {
        return IsValidLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static int IsValidLocaleName(MemorySegment lpLocaleName) {
        var mh$ = IsValidLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLocaleName", lpLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumCalendarInfoExEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExEx$descriptor() {
        return EnumCalendarInfoExEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumCalendarInfoExEx$handle() {
        return EnumCalendarInfoExEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumCalendarInfoExEx$address() {
        return EnumCalendarInfoExEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static int EnumCalendarInfoExEx(MemorySegment pCalInfoEnumProcExEx, MemorySegment lpLocaleName, int Calendar, MemorySegment lpReserved, int CalType, long lParam) {
        var mh$ = EnumCalendarInfoExEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExEx", pCalInfoEnumProcExEx, lpLocaleName, Calendar, lpReserved, CalType, lParam);
            }
            return (int)mh$.invokeExact(pCalInfoEnumProcExEx, lpLocaleName, Calendar, lpReserved, CalType, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDateFormatsExEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExEx$descriptor() {
        return EnumDateFormatsExEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDateFormatsExEx$handle() {
        return EnumDateFormatsExEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumDateFormatsExEx$address() {
        return EnumDateFormatsExEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static int EnumDateFormatsExEx(MemorySegment lpDateFmtEnumProcExEx, MemorySegment lpLocaleName, int dwFlags, long lParam) {
        var mh$ = EnumDateFormatsExEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExEx", lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumTimeFormatsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsEx$descriptor() {
        return EnumTimeFormatsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumTimeFormatsEx$handle() {
        return EnumTimeFormatsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MemorySegment EnumTimeFormatsEx$address() {
        return EnumTimeFormatsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static int EnumTimeFormatsEx(MemorySegment lpTimeFmtEnumProcEx, MemorySegment lpLocaleName, int dwFlags, long lParam) {
        var mh$ = EnumTimeFormatsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsEx", lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemLocalesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesEx$descriptor() {
        return EnumSystemLocalesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static MethodHandle EnumSystemLocalesEx$handle() {
        return EnumSystemLocalesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static MemorySegment EnumSystemLocalesEx$address() {
        return EnumSystemLocalesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static int EnumSystemLocalesEx(MemorySegment lpLocaleEnumProcEx, int dwFlags, long lParam, MemorySegment lpReserved) {
        var mh$ = EnumSystemLocalesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesEx", lpLocaleEnumProcEx, dwFlags, lParam, lpReserved);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProcEx, dwFlags, lParam, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResolveLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResolveLocaleName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor ResolveLocaleName$descriptor() {
        return ResolveLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle ResolveLocaleName$handle() {
        return ResolveLocaleName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MemorySegment ResolveLocaleName$address() {
        return ResolveLocaleName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int ResolveLocaleName(MemorySegment lpNameToResolve, MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = ResolveLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResolveLocaleName", lpNameToResolve, lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpNameToResolve, lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _COORD {
     *     SHORT X;
     *     SHORT Y;
     * } *PCOORD
     * }
     */
    public static final AddressLayout PCOORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SMALL_RECT {
     *     SHORT Left;
     *     SHORT Top;
     *     SHORT Right;
     *     SHORT Bottom;
     * } *PSMALL_RECT
     * }
     */
    public static final AddressLayout PSMALL_RECT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KEY_EVENT_RECORD {
     *     BOOL bKeyDown;
     *     WORD wRepeatCount;
     *     WORD wVirtualKeyCode;
     *     WORD wVirtualScanCode;
     *     union {
     *         WCHAR UnicodeChar;
     *         CHAR AsciiChar;
     *     } uChar;
     *     DWORD dwControlKeyState;
     * } *PKEY_EVENT_RECORD
     * }
     */
    public static final AddressLayout PKEY_EVENT_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MOUSE_EVENT_RECORD {
     *     COORD dwMousePosition;
     *     DWORD dwButtonState;
     *     DWORD dwControlKeyState;
     *     DWORD dwEventFlags;
     * } *PMOUSE_EVENT_RECORD
     * }
     */
    public static final AddressLayout PMOUSE_EVENT_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WINDOW_BUFFER_SIZE_RECORD {
     *     COORD dwSize;
     * } *PWINDOW_BUFFER_SIZE_RECORD
     * }
     */
    public static final AddressLayout PWINDOW_BUFFER_SIZE_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MENU_EVENT_RECORD {
     *     UINT dwCommandId;
     * } *PMENU_EVENT_RECORD
     * }
     */
    public static final AddressLayout PMENU_EVENT_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FOCUS_EVENT_RECORD {
     *     BOOL bSetFocus;
     * } *PFOCUS_EVENT_RECORD
     * }
     */
    public static final AddressLayout PFOCUS_EVENT_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _INPUT_RECORD {
     *     WORD EventType;
     *     union {
     *         KEY_EVENT_RECORD KeyEvent;
     *         MOUSE_EVENT_RECORD MouseEvent;
     *         WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
     *         MENU_EVENT_RECORD MenuEvent;
     *         FOCUS_EVENT_RECORD FocusEvent;
     *     } Event;
     * } *PINPUT_RECORD
     * }
     */
    public static final AddressLayout PINPUT_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CHAR_INFO {
     *     union {
     *         WCHAR UnicodeChar;
     *         CHAR AsciiChar;
     *     } Char;
     *     WORD Attributes;
     * } *PCHAR_INFO
     * }
     */
    public static final AddressLayout PCHAR_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_FONT_INFO {
     *     DWORD nFont;
     *     COORD dwFontSize;
     * } *PCONSOLE_FONT_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_FONT_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HPCON
     * }
     */
    public static final AddressLayout HPCON = freeglut_h.C_POINTER;

    private static class AllocConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AllocConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static FunctionDescriptor AllocConsole$descriptor() {
        return AllocConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static MethodHandle AllocConsole$handle() {
        return AllocConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static MemorySegment AllocConsole$address() {
        return AllocConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static int AllocConsole() {
        var mh$ = AllocConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocConsole");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static FunctionDescriptor FreeConsole$descriptor() {
        return FreeConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static MethodHandle FreeConsole$handle() {
        return FreeConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static MemorySegment FreeConsole$address() {
        return FreeConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static int FreeConsole() {
        var mh$ = FreeConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeConsole");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AttachConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor AttachConsole$descriptor() {
        return AttachConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static MethodHandle AttachConsole$handle() {
        return AttachConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static MemorySegment AttachConsole$address() {
        return AttachConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static int AttachConsole(int dwProcessId) {
        var mh$ = AttachConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachConsole", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static FunctionDescriptor GetConsoleCP$descriptor() {
        return GetConsoleCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static MethodHandle GetConsoleCP$handle() {
        return GetConsoleCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static MemorySegment GetConsoleCP$address() {
        return GetConsoleCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static int GetConsoleCP() {
        var mh$ = GetConsoleCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOutputCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleOutputCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static FunctionDescriptor GetConsoleOutputCP$descriptor() {
        return GetConsoleOutputCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static MethodHandle GetConsoleOutputCP$handle() {
        return GetConsoleOutputCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static MemorySegment GetConsoleOutputCP$address() {
        return GetConsoleOutputCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static int GetConsoleOutputCP() {
        var mh$ = GetConsoleOutputCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOutputCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static FunctionDescriptor GetConsoleMode$descriptor() {
        return GetConsoleMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static MethodHandle GetConsoleMode$handle() {
        return GetConsoleMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static MemorySegment GetConsoleMode$address() {
        return GetConsoleMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static int GetConsoleMode(MemorySegment hConsoleHandle, MemorySegment lpMode) {
        var mh$ = GetConsoleMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleMode", hConsoleHandle, lpMode);
            }
            return (int)mh$.invokeExact(hConsoleHandle, lpMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static FunctionDescriptor SetConsoleMode$descriptor() {
        return SetConsoleMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static MethodHandle SetConsoleMode$handle() {
        return SetConsoleMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static MemorySegment SetConsoleMode$address() {
        return SetConsoleMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static int SetConsoleMode(MemorySegment hConsoleHandle, int dwMode) {
        var mh$ = SetConsoleMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleMode", hConsoleHandle, dwMode);
            }
            return (int)mh$.invokeExact(hConsoleHandle, dwMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfConsoleInputEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumberOfConsoleInputEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static FunctionDescriptor GetNumberOfConsoleInputEvents$descriptor() {
        return GetNumberOfConsoleInputEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static MethodHandle GetNumberOfConsoleInputEvents$handle() {
        return GetNumberOfConsoleInputEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static MemorySegment GetNumberOfConsoleInputEvents$address() {
        return GetNumberOfConsoleInputEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static int GetNumberOfConsoleInputEvents(MemorySegment hConsoleInput, MemorySegment lpNumberOfEvents) {
        var mh$ = GetNumberOfConsoleInputEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfConsoleInputEvents", hConsoleInput, lpNumberOfEvents);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpNumberOfEvents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleInputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleInputA$descriptor() {
        return ReadConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle ReadConsoleInputA$handle() {
        return ReadConsoleInputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment ReadConsoleInputA$address() {
        return ReadConsoleInputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int ReadConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = ReadConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleInputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleInputW$descriptor() {
        return ReadConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle ReadConsoleInputW$handle() {
        return ReadConsoleInputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment ReadConsoleInputW$address() {
        return ReadConsoleInputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int ReadConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = ReadConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PeekConsoleInputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor PeekConsoleInputA$descriptor() {
        return PeekConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle PeekConsoleInputA$handle() {
        return PeekConsoleInputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment PeekConsoleInputA$address() {
        return PeekConsoleInputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int PeekConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = PeekConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PeekConsoleInputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor PeekConsoleInputW$descriptor() {
        return PeekConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle PeekConsoleInputW$handle() {
        return PeekConsoleInputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MemorySegment PeekConsoleInputW$address() {
        return PeekConsoleInputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int PeekConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = PeekConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_READCONSOLE_CONTROL {
     *     ULONG nLength;
     *     ULONG nInitialChars;
     *     ULONG dwCtrlWakeupMask;
     *     ULONG dwControlKeyState;
     * } *PCONSOLE_READCONSOLE_CONTROL
     * }
     */
    public static final AddressLayout PCONSOLE_READCONSOLE_CONTROL = freeglut_h.C_POINTER;

    private static class ReadConsoleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static FunctionDescriptor ReadConsoleA$descriptor() {
        return ReadConsoleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MethodHandle ReadConsoleA$handle() {
        return ReadConsoleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MemorySegment ReadConsoleA$address() {
        return ReadConsoleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static int ReadConsoleA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nNumberOfCharsToRead, MemorySegment lpNumberOfCharsRead, MemorySegment pInputControl) {
        var mh$ = ReadConsoleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleA", hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static FunctionDescriptor ReadConsoleW$descriptor() {
        return ReadConsoleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MethodHandle ReadConsoleW$handle() {
        return ReadConsoleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MemorySegment ReadConsoleW$address() {
        return ReadConsoleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static int ReadConsoleW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nNumberOfCharsToRead, MemorySegment lpNumberOfCharsRead, MemorySegment pInputControl) {
        var mh$ = ReadConsoleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleW", hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor WriteConsoleA$descriptor() {
        return WriteConsoleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MethodHandle WriteConsoleA$handle() {
        return WriteConsoleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MemorySegment WriteConsoleA$address() {
        return WriteConsoleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static int WriteConsoleA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
        var mh$ = WriteConsoleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleA", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor WriteConsoleW$descriptor() {
        return WriteConsoleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MethodHandle WriteConsoleW$handle() {
        return WriteConsoleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MemorySegment WriteConsoleW$address() {
        return WriteConsoleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static int WriteConsoleW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
        var mh$ = WriteConsoleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleW", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCtrlHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleCtrlHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static FunctionDescriptor SetConsoleCtrlHandler$descriptor() {
        return SetConsoleCtrlHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static MethodHandle SetConsoleCtrlHandler$handle() {
        return SetConsoleCtrlHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static MemorySegment SetConsoleCtrlHandler$address() {
        return SetConsoleCtrlHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static int SetConsoleCtrlHandler(MemorySegment HandlerRoutine, int Add) {
        var mh$ = SetConsoleCtrlHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCtrlHandler", HandlerRoutine, Add);
            }
            return (int)mh$.invokeExact(HandlerRoutine, Add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePseudoConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static FunctionDescriptor CreatePseudoConsole$descriptor() {
        return CreatePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static MethodHandle CreatePseudoConsole$handle() {
        return CreatePseudoConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static MemorySegment CreatePseudoConsole$address() {
        return CreatePseudoConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static int CreatePseudoConsole(MemorySegment size, MemorySegment hInput, MemorySegment hOutput, int dwFlags, MemorySegment phPC) {
        var mh$ = CreatePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePseudoConsole", size, hInput, hOutput, dwFlags, phPC);
            }
            return (int)mh$.invokeExact(size, hInput, hOutput, dwFlags, phPC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            _COORD.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResizePseudoConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static FunctionDescriptor ResizePseudoConsole$descriptor() {
        return ResizePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static MethodHandle ResizePseudoConsole$handle() {
        return ResizePseudoConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static MemorySegment ResizePseudoConsole$address() {
        return ResizePseudoConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static int ResizePseudoConsole(MemorySegment hPC, MemorySegment size) {
        var mh$ = ResizePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizePseudoConsole", hPC, size);
            }
            return (int)mh$.invokeExact(hPC, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClosePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClosePseudoConsole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static FunctionDescriptor ClosePseudoConsole$descriptor() {
        return ClosePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static MethodHandle ClosePseudoConsole$handle() {
        return ClosePseudoConsole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static MemorySegment ClosePseudoConsole$address() {
        return ClosePseudoConsole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static void ClosePseudoConsole(MemorySegment hPC) {
        var mh$ = ClosePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClosePseudoConsole", hPC);
            }
            mh$.invokeExact(hPC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FillConsoleOutputCharacterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputCharacterA$descriptor() {
        return FillConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputCharacterA$handle() {
        return FillConsoleOutputCharacterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment FillConsoleOutputCharacterA$address() {
        return FillConsoleOutputCharacterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int FillConsoleOutputCharacterA(MemorySegment hConsoleOutput, byte cCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = FillConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputCharacterA", hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FillConsoleOutputCharacterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputCharacterW$descriptor() {
        return FillConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputCharacterW$handle() {
        return FillConsoleOutputCharacterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment FillConsoleOutputCharacterW$address() {
        return FillConsoleOutputCharacterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int FillConsoleOutputCharacterW(MemorySegment hConsoleOutput, short cCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = FillConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputCharacterW", hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FillConsoleOutputAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputAttribute$descriptor() {
        return FillConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputAttribute$handle() {
        return FillConsoleOutputAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MemorySegment FillConsoleOutputAttribute$address() {
        return FillConsoleOutputAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static int FillConsoleOutputAttribute(MemorySegment hConsoleOutput, short wAttribute, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfAttrsWritten) {
        var mh$ = FillConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputAttribute", hConsoleOutput, wAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, wAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenerateConsoleCtrlEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GenerateConsoleCtrlEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static FunctionDescriptor GenerateConsoleCtrlEvent$descriptor() {
        return GenerateConsoleCtrlEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static MethodHandle GenerateConsoleCtrlEvent$handle() {
        return GenerateConsoleCtrlEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static MemorySegment GenerateConsoleCtrlEvent$address() {
        return GenerateConsoleCtrlEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static int GenerateConsoleCtrlEvent(int dwCtrlEvent, int dwProcessGroupId) {
        var mh$ = GenerateConsoleCtrlEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenerateConsoleCtrlEvent", dwCtrlEvent, dwProcessGroupId);
            }
            return (int)mh$.invokeExact(dwCtrlEvent, dwProcessGroupId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateConsoleScreenBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateConsoleScreenBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static FunctionDescriptor CreateConsoleScreenBuffer$descriptor() {
        return CreateConsoleScreenBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MethodHandle CreateConsoleScreenBuffer$handle() {
        return CreateConsoleScreenBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MemorySegment CreateConsoleScreenBuffer$address() {
        return CreateConsoleScreenBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MemorySegment CreateConsoleScreenBuffer(int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwFlags, MemorySegment lpScreenBufferData) {
        var mh$ = CreateConsoleScreenBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateConsoleScreenBuffer", dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags, lpScreenBufferData);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags, lpScreenBufferData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleActiveScreenBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleActiveScreenBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static FunctionDescriptor SetConsoleActiveScreenBuffer$descriptor() {
        return SetConsoleActiveScreenBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static MethodHandle SetConsoleActiveScreenBuffer$handle() {
        return SetConsoleActiveScreenBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static MemorySegment SetConsoleActiveScreenBuffer$address() {
        return SetConsoleActiveScreenBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static int SetConsoleActiveScreenBuffer(MemorySegment hConsoleOutput) {
        var mh$ = SetConsoleActiveScreenBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleActiveScreenBuffer", hConsoleOutput);
            }
            return (int)mh$.invokeExact(hConsoleOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushConsoleInputBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlushConsoleInputBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static FunctionDescriptor FlushConsoleInputBuffer$descriptor() {
        return FlushConsoleInputBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static MethodHandle FlushConsoleInputBuffer$handle() {
        return FlushConsoleInputBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static MemorySegment FlushConsoleInputBuffer$address() {
        return FlushConsoleInputBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static int FlushConsoleInputBuffer(MemorySegment hConsoleInput) {
        var mh$ = FlushConsoleInputBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushConsoleInputBuffer", hConsoleInput);
            }
            return (int)mh$.invokeExact(hConsoleInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static FunctionDescriptor SetConsoleCP$descriptor() {
        return SetConsoleCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static MethodHandle SetConsoleCP$handle() {
        return SetConsoleCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static MemorySegment SetConsoleCP$address() {
        return SetConsoleCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static int SetConsoleCP(int wCodePageID) {
        var mh$ = SetConsoleCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCP", wCodePageID);
            }
            return (int)mh$.invokeExact(wCodePageID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleOutputCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleOutputCP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static FunctionDescriptor SetConsoleOutputCP$descriptor() {
        return SetConsoleOutputCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static MethodHandle SetConsoleOutputCP$handle() {
        return SetConsoleOutputCP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static MemorySegment SetConsoleOutputCP$address() {
        return SetConsoleOutputCP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static int SetConsoleOutputCP(int wCodePageID) {
        var mh$ = SetConsoleOutputCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleOutputCP", wCodePageID);
            }
            return (int)mh$.invokeExact(wCodePageID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_CURSOR_INFO {
     *     DWORD dwSize;
     *     BOOL bVisible;
     * } *PCONSOLE_CURSOR_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_CURSOR_INFO = freeglut_h.C_POINTER;

    private static class GetConsoleCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleCursorInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleCursorInfo$descriptor() {
        return GetConsoleCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static MethodHandle GetConsoleCursorInfo$handle() {
        return GetConsoleCursorInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static MemorySegment GetConsoleCursorInfo$address() {
        return GetConsoleCursorInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static int GetConsoleCursorInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleCursorInfo) {
        var mh$ = GetConsoleCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCursorInfo", hConsoleOutput, lpConsoleCursorInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleCursorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleCursorInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static FunctionDescriptor SetConsoleCursorInfo$descriptor() {
        return SetConsoleCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static MethodHandle SetConsoleCursorInfo$handle() {
        return SetConsoleCursorInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static MemorySegment SetConsoleCursorInfo$address() {
        return SetConsoleCursorInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static int SetConsoleCursorInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleCursorInfo) {
        var mh$ = SetConsoleCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCursorInfo", hConsoleOutput, lpConsoleCursorInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleCursorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
     *     COORD dwSize;
     *     COORD dwCursorPosition;
     *     WORD wAttributes;
     *     SMALL_RECT srWindow;
     *     COORD dwMaximumWindowSize;
     * } *PCONSOLE_SCREEN_BUFFER_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_SCREEN_BUFFER_INFO = freeglut_h.C_POINTER;

    private static class GetConsoleScreenBufferInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleScreenBufferInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleScreenBufferInfo$descriptor() {
        return GetConsoleScreenBufferInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static MethodHandle GetConsoleScreenBufferInfo$handle() {
        return GetConsoleScreenBufferInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static MemorySegment GetConsoleScreenBufferInfo$address() {
        return GetConsoleScreenBufferInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static int GetConsoleScreenBufferInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfo) {
        var mh$ = GetConsoleScreenBufferInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleScreenBufferInfo", hConsoleOutput, lpConsoleScreenBufferInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
     *     ULONG cbSize;
     *     COORD dwSize;
     *     COORD dwCursorPosition;
     *     WORD wAttributes;
     *     SMALL_RECT srWindow;
     *     COORD dwMaximumWindowSize;
     *     WORD wPopupAttributes;
     *     BOOL bFullscreenSupported;
     *     COLORREF ColorTable[16];
     * } *PCONSOLE_SCREEN_BUFFER_INFOEX
     * }
     */
    public static final AddressLayout PCONSOLE_SCREEN_BUFFER_INFOEX = freeglut_h.C_POINTER;

    private static class GetConsoleScreenBufferInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleScreenBufferInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static FunctionDescriptor GetConsoleScreenBufferInfoEx$descriptor() {
        return GetConsoleScreenBufferInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MethodHandle GetConsoleScreenBufferInfoEx$handle() {
        return GetConsoleScreenBufferInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MemorySegment GetConsoleScreenBufferInfoEx$address() {
        return GetConsoleScreenBufferInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static int GetConsoleScreenBufferInfoEx(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfoEx) {
        var mh$ = GetConsoleScreenBufferInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleScreenBufferInfoEx", hConsoleOutput, lpConsoleScreenBufferInfoEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleScreenBufferInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleScreenBufferInfoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static FunctionDescriptor SetConsoleScreenBufferInfoEx$descriptor() {
        return SetConsoleScreenBufferInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MethodHandle SetConsoleScreenBufferInfoEx$handle() {
        return SetConsoleScreenBufferInfoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MemorySegment SetConsoleScreenBufferInfoEx$address() {
        return SetConsoleScreenBufferInfoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static int SetConsoleScreenBufferInfoEx(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfoEx) {
        var mh$ = SetConsoleScreenBufferInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleScreenBufferInfoEx", hConsoleOutput, lpConsoleScreenBufferInfoEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleScreenBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            _COORD.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleScreenBufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static FunctionDescriptor SetConsoleScreenBufferSize$descriptor() {
        return SetConsoleScreenBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static MethodHandle SetConsoleScreenBufferSize$handle() {
        return SetConsoleScreenBufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static MemorySegment SetConsoleScreenBufferSize$address() {
        return SetConsoleScreenBufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static int SetConsoleScreenBufferSize(MemorySegment hConsoleOutput, MemorySegment dwSize) {
        var mh$ = SetConsoleScreenBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleScreenBufferSize", hConsoleOutput, dwSize);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCursorPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            _COORD.layout()
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleCursorPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static FunctionDescriptor SetConsoleCursorPosition$descriptor() {
        return SetConsoleCursorPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static MethodHandle SetConsoleCursorPosition$handle() {
        return SetConsoleCursorPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static MemorySegment SetConsoleCursorPosition$address() {
        return SetConsoleCursorPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static int SetConsoleCursorPosition(MemorySegment hConsoleOutput, MemorySegment dwCursorPosition) {
        var mh$ = SetConsoleCursorPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCursorPosition", hConsoleOutput, dwCursorPosition);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwCursorPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLargestConsoleWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLargestConsoleWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static FunctionDescriptor GetLargestConsoleWindowSize$descriptor() {
        return GetLargestConsoleWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MethodHandle GetLargestConsoleWindowSize$handle() {
        return GetLargestConsoleWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MemorySegment GetLargestConsoleWindowSize$address() {
        return GetLargestConsoleWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MemorySegment GetLargestConsoleWindowSize(SegmentAllocator allocator, MemorySegment hConsoleOutput) {
        var mh$ = GetLargestConsoleWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLargestConsoleWindowSize", allocator, hConsoleOutput);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hConsoleOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTextAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleTextAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static FunctionDescriptor SetConsoleTextAttribute$descriptor() {
        return SetConsoleTextAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static MethodHandle SetConsoleTextAttribute$handle() {
        return SetConsoleTextAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static MemorySegment SetConsoleTextAttribute$address() {
        return SetConsoleTextAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static int SetConsoleTextAttribute(MemorySegment hConsoleOutput, short wAttributes) {
        var mh$ = SetConsoleTextAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTextAttribute", hConsoleOutput, wAttributes);
            }
            return (int)mh$.invokeExact(hConsoleOutput, wAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleWindowInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleWindowInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static FunctionDescriptor SetConsoleWindowInfo$descriptor() {
        return SetConsoleWindowInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static MethodHandle SetConsoleWindowInfo$handle() {
        return SetConsoleWindowInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static MemorySegment SetConsoleWindowInfo$address() {
        return SetConsoleWindowInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static int SetConsoleWindowInfo(MemorySegment hConsoleOutput, int bAbsolute, MemorySegment lpConsoleWindow) {
        var mh$ = SetConsoleWindowInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleWindowInfo", hConsoleOutput, bAbsolute, lpConsoleWindow);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bAbsolute, lpConsoleWindow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleOutputCharacterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputCharacterA$descriptor() {
        return WriteConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputCharacterA$handle() {
        return WriteConsoleOutputCharacterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment WriteConsoleOutputCharacterA$address() {
        return WriteConsoleOutputCharacterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int WriteConsoleOutputCharacterA(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = WriteConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputCharacterA", hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleOutputCharacterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputCharacterW$descriptor() {
        return WriteConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputCharacterW$handle() {
        return WriteConsoleOutputCharacterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MemorySegment WriteConsoleOutputCharacterW$address() {
        return WriteConsoleOutputCharacterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int WriteConsoleOutputCharacterW(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = WriteConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputCharacterW", hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleOutputAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputAttribute$descriptor() {
        return WriteConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputAttribute$handle() {
        return WriteConsoleOutputAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MemorySegment WriteConsoleOutputAttribute$address() {
        return WriteConsoleOutputAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static int WriteConsoleOutputAttribute(MemorySegment hConsoleOutput, MemorySegment lpAttribute, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfAttrsWritten) {
        var mh$ = WriteConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputAttribute", hConsoleOutput, lpAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleOutputCharacterA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputCharacterA$descriptor() {
        return ReadConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputCharacterA$handle() {
        return ReadConsoleOutputCharacterA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MemorySegment ReadConsoleOutputCharacterA$address() {
        return ReadConsoleOutputCharacterA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static int ReadConsoleOutputCharacterA(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfCharsRead) {
        var mh$ = ReadConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputCharacterA", hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleOutputCharacterW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputCharacterW$descriptor() {
        return ReadConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputCharacterW$handle() {
        return ReadConsoleOutputCharacterW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MemorySegment ReadConsoleOutputCharacterW$address() {
        return ReadConsoleOutputCharacterW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static int ReadConsoleOutputCharacterW(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfCharsRead) {
        var mh$ = ReadConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputCharacterW", hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleOutputAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputAttribute$descriptor() {
        return ReadConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputAttribute$handle() {
        return ReadConsoleOutputAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static MemorySegment ReadConsoleOutputAttribute$address() {
        return ReadConsoleOutputAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static int ReadConsoleOutputAttribute(MemorySegment hConsoleOutput, MemorySegment lpAttribute, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfAttrsRead) {
        var mh$ = ReadConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputAttribute", hConsoleOutput, lpAttribute, nLength, dwReadCoord, lpNumberOfAttrsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpAttribute, nLength, dwReadCoord, lpNumberOfAttrsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleInputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleInputA$descriptor() {
        return WriteConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MethodHandle WriteConsoleInputA$handle() {
        return WriteConsoleInputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MemorySegment WriteConsoleInputA$address() {
        return WriteConsoleInputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static int WriteConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsWritten) {
        var mh$ = WriteConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleInputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleInputW$descriptor() {
        return WriteConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MethodHandle WriteConsoleInputW$handle() {
        return WriteConsoleInputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MemorySegment WriteConsoleInputW$address() {
        return WriteConsoleInputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static int WriteConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsWritten) {
        var mh$ = WriteConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollConsoleScreenBufferA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScrollConsoleScreenBufferA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static FunctionDescriptor ScrollConsoleScreenBufferA$descriptor() {
        return ScrollConsoleScreenBufferA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MethodHandle ScrollConsoleScreenBufferA$handle() {
        return ScrollConsoleScreenBufferA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MemorySegment ScrollConsoleScreenBufferA$address() {
        return ScrollConsoleScreenBufferA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static int ScrollConsoleScreenBufferA(MemorySegment hConsoleOutput, MemorySegment lpScrollRectangle, MemorySegment lpClipRectangle, MemorySegment dwDestinationOrigin, MemorySegment lpFill) {
        var mh$ = ScrollConsoleScreenBufferA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollConsoleScreenBufferA", hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollConsoleScreenBufferW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ScrollConsoleScreenBufferW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static FunctionDescriptor ScrollConsoleScreenBufferW$descriptor() {
        return ScrollConsoleScreenBufferW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MethodHandle ScrollConsoleScreenBufferW$handle() {
        return ScrollConsoleScreenBufferW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MemorySegment ScrollConsoleScreenBufferW$address() {
        return ScrollConsoleScreenBufferW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static int ScrollConsoleScreenBufferW(MemorySegment hConsoleOutput, MemorySegment lpScrollRectangle, MemorySegment lpClipRectangle, MemorySegment dwDestinationOrigin, MemorySegment lpFill) {
        var mh$ = ScrollConsoleScreenBufferW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollConsoleScreenBufferW", hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleOutputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputA$descriptor() {
        return WriteConsoleOutputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MethodHandle WriteConsoleOutputA$handle() {
        return WriteConsoleOutputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MemorySegment WriteConsoleOutputA$address() {
        return WriteConsoleOutputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static int WriteConsoleOutputA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpWriteRegion) {
        var mh$ = WriteConsoleOutputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputA", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteConsoleOutputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputW$descriptor() {
        return WriteConsoleOutputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MethodHandle WriteConsoleOutputW$handle() {
        return WriteConsoleOutputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MemorySegment WriteConsoleOutputW$address() {
        return WriteConsoleOutputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static int WriteConsoleOutputW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpWriteRegion) {
        var mh$ = WriteConsoleOutputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputW", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleOutputA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputA$descriptor() {
        return ReadConsoleOutputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MethodHandle ReadConsoleOutputA$handle() {
        return ReadConsoleOutputA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MemorySegment ReadConsoleOutputA$address() {
        return ReadConsoleOutputA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static int ReadConsoleOutputA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpReadRegion) {
        var mh$ = ReadConsoleOutputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputA", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadConsoleOutputW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputW$descriptor() {
        return ReadConsoleOutputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MethodHandle ReadConsoleOutputW$handle() {
        return ReadConsoleOutputW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MemorySegment ReadConsoleOutputW$address() {
        return ReadConsoleOutputW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static int ReadConsoleOutputW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpReadRegion) {
        var mh$ = ReadConsoleOutputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputW", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleTitleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleTitleA$descriptor() {
        return GetConsoleTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleTitleA$handle() {
        return GetConsoleTitleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleTitleA$address() {
        return GetConsoleTitleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleTitleA(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleTitleA", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleTitleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleTitleW$descriptor() {
        return GetConsoleTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleTitleW$handle() {
        return GetConsoleTitleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleTitleW$address() {
        return GetConsoleTitleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleTitleW(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleTitleW", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOriginalTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleOriginalTitleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleOriginalTitleA$descriptor() {
        return GetConsoleOriginalTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleOriginalTitleA$handle() {
        return GetConsoleOriginalTitleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleOriginalTitleA$address() {
        return GetConsoleOriginalTitleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleOriginalTitleA(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleOriginalTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOriginalTitleA", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOriginalTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleOriginalTitleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleOriginalTitleW$descriptor() {
        return GetConsoleOriginalTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleOriginalTitleW$handle() {
        return GetConsoleOriginalTitleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MemorySegment GetConsoleOriginalTitleW$address() {
        return GetConsoleOriginalTitleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleOriginalTitleW(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleOriginalTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOriginalTitleW", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleTitleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static FunctionDescriptor SetConsoleTitleA$descriptor() {
        return SetConsoleTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static MethodHandle SetConsoleTitleA$handle() {
        return SetConsoleTitleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static MemorySegment SetConsoleTitleA$address() {
        return SetConsoleTitleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static int SetConsoleTitleA(MemorySegment lpConsoleTitle) {
        var mh$ = SetConsoleTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTitleA", lpConsoleTitle);
            }
            return (int)mh$.invokeExact(lpConsoleTitle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleTitleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static FunctionDescriptor SetConsoleTitleW$descriptor() {
        return SetConsoleTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static MethodHandle SetConsoleTitleW$handle() {
        return SetConsoleTitleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static MemorySegment SetConsoleTitleW$address() {
        return SetConsoleTitleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static int SetConsoleTitleW(MemorySegment lpConsoleTitle) {
        var mh$ = SetConsoleTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTitleW", lpConsoleTitle);
            }
            return (int)mh$.invokeExact(lpConsoleTitle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfConsoleMouseButtons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumberOfConsoleMouseButtons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static FunctionDescriptor GetNumberOfConsoleMouseButtons$descriptor() {
        return GetNumberOfConsoleMouseButtons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static MethodHandle GetNumberOfConsoleMouseButtons$handle() {
        return GetNumberOfConsoleMouseButtons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static MemorySegment GetNumberOfConsoleMouseButtons$address() {
        return GetNumberOfConsoleMouseButtons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static int GetNumberOfConsoleMouseButtons(MemorySegment lpNumberOfMouseButtons) {
        var mh$ = GetNumberOfConsoleMouseButtons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfConsoleMouseButtons", lpNumberOfMouseButtons);
            }
            return (int)mh$.invokeExact(lpNumberOfMouseButtons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleFontSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _COORD.layout(),
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleFontSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static FunctionDescriptor GetConsoleFontSize$descriptor() {
        return GetConsoleFontSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MethodHandle GetConsoleFontSize$handle() {
        return GetConsoleFontSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MemorySegment GetConsoleFontSize$address() {
        return GetConsoleFontSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MemorySegment GetConsoleFontSize(SegmentAllocator allocator, MemorySegment hConsoleOutput, int nFont) {
        var mh$ = GetConsoleFontSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleFontSize", allocator, hConsoleOutput, nFont);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hConsoleOutput, nFont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentConsoleFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentConsoleFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static FunctionDescriptor GetCurrentConsoleFont$descriptor() {
        return GetCurrentConsoleFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static MethodHandle GetCurrentConsoleFont$handle() {
        return GetCurrentConsoleFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static MemorySegment GetCurrentConsoleFont$address() {
        return GetCurrentConsoleFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static int GetCurrentConsoleFont(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFont) {
        var mh$ = GetCurrentConsoleFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentConsoleFont", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFont);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_FONT_INFOEX {
     *     ULONG cbSize;
     *     DWORD nFont;
     *     COORD dwFontSize;
     *     UINT FontFamily;
     *     UINT FontWeight;
     *     WCHAR FaceName[32];
     * } *PCONSOLE_FONT_INFOEX
     * }
     */
    public static final AddressLayout PCONSOLE_FONT_INFOEX = freeglut_h.C_POINTER;

    private static class GetCurrentConsoleFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentConsoleFontEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static FunctionDescriptor GetCurrentConsoleFontEx$descriptor() {
        return GetCurrentConsoleFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MethodHandle GetCurrentConsoleFontEx$handle() {
        return GetCurrentConsoleFontEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MemorySegment GetCurrentConsoleFontEx$address() {
        return GetCurrentConsoleFontEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static int GetCurrentConsoleFontEx(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFontEx) {
        var mh$ = GetCurrentConsoleFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentConsoleFontEx", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentConsoleFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCurrentConsoleFontEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static FunctionDescriptor SetCurrentConsoleFontEx$descriptor() {
        return SetCurrentConsoleFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MethodHandle SetCurrentConsoleFontEx$handle() {
        return SetCurrentConsoleFontEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MemorySegment SetCurrentConsoleFontEx$address() {
        return SetCurrentConsoleFontEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static int SetCurrentConsoleFontEx(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFontEx) {
        var mh$ = SetCurrentConsoleFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentConsoleFontEx", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SELECTION_INFO {
     *     DWORD dwFlags;
     *     COORD dwSelectionAnchor;
     *     SMALL_RECT srSelection;
     * } *PCONSOLE_SELECTION_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_SELECTION_INFO = freeglut_h.C_POINTER;

    private static class GetConsoleSelectionInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleSelectionInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleSelectionInfo$descriptor() {
        return GetConsoleSelectionInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static MethodHandle GetConsoleSelectionInfo$handle() {
        return GetConsoleSelectionInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static MemorySegment GetConsoleSelectionInfo$address() {
        return GetConsoleSelectionInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static int GetConsoleSelectionInfo(MemorySegment lpConsoleSelectionInfo) {
        var mh$ = GetConsoleSelectionInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleSelectionInfo", lpConsoleSelectionInfo);
            }
            return (int)mh$.invokeExact(lpConsoleSelectionInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_HISTORY_INFO {
     *     UINT cbSize;
     *     UINT HistoryBufferSize;
     *     UINT NumberOfHistoryBuffers;
     *     DWORD dwFlags;
     * } *PCONSOLE_HISTORY_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_HISTORY_INFO = freeglut_h.C_POINTER;

    private static class GetConsoleHistoryInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleHistoryInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleHistoryInfo$descriptor() {
        return GetConsoleHistoryInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MethodHandle GetConsoleHistoryInfo$handle() {
        return GetConsoleHistoryInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MemorySegment GetConsoleHistoryInfo$address() {
        return GetConsoleHistoryInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static int GetConsoleHistoryInfo(MemorySegment lpConsoleHistoryInfo) {
        var mh$ = GetConsoleHistoryInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleHistoryInfo", lpConsoleHistoryInfo);
            }
            return (int)mh$.invokeExact(lpConsoleHistoryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleHistoryInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleHistoryInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static FunctionDescriptor SetConsoleHistoryInfo$descriptor() {
        return SetConsoleHistoryInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MethodHandle SetConsoleHistoryInfo$handle() {
        return SetConsoleHistoryInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MemorySegment SetConsoleHistoryInfo$address() {
        return SetConsoleHistoryInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static int SetConsoleHistoryInfo(MemorySegment lpConsoleHistoryInfo) {
        var mh$ = SetConsoleHistoryInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleHistoryInfo", lpConsoleHistoryInfo);
            }
            return (int)mh$.invokeExact(lpConsoleHistoryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleDisplayMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static FunctionDescriptor GetConsoleDisplayMode$descriptor() {
        return GetConsoleDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static MethodHandle GetConsoleDisplayMode$handle() {
        return GetConsoleDisplayMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static MemorySegment GetConsoleDisplayMode$address() {
        return GetConsoleDisplayMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static int GetConsoleDisplayMode(MemorySegment lpModeFlags) {
        var mh$ = GetConsoleDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleDisplayMode", lpModeFlags);
            }
            return (int)mh$.invokeExact(lpModeFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleDisplayMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static FunctionDescriptor SetConsoleDisplayMode$descriptor() {
        return SetConsoleDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static MethodHandle SetConsoleDisplayMode$handle() {
        return SetConsoleDisplayMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static MemorySegment SetConsoleDisplayMode$address() {
        return SetConsoleDisplayMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static int SetConsoleDisplayMode(MemorySegment hConsoleOutput, int dwFlags, MemorySegment lpNewScreenBufferDimensions) {
        var mh$ = SetConsoleDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleDisplayMode", hConsoleOutput, dwFlags, lpNewScreenBufferDimensions);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwFlags, lpNewScreenBufferDimensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static FunctionDescriptor GetConsoleWindow$descriptor() {
        return GetConsoleWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MethodHandle GetConsoleWindow$handle() {
        return GetConsoleWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MemorySegment GetConsoleWindow$address() {
        return GetConsoleWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MemorySegment GetConsoleWindow() {
        var mh$ = GetConsoleWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConsoleAliasA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddConsoleAliasA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor AddConsoleAliasA$descriptor() {
        return AddConsoleAliasA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static MethodHandle AddConsoleAliasA$handle() {
        return AddConsoleAliasA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static MemorySegment AddConsoleAliasA$address() {
        return AddConsoleAliasA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static int AddConsoleAliasA(MemorySegment Source, MemorySegment Target, MemorySegment ExeName) {
        var mh$ = AddConsoleAliasA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConsoleAliasA", Source, Target, ExeName);
            }
            return (int)mh$.invokeExact(Source, Target, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConsoleAliasW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddConsoleAliasW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor AddConsoleAliasW$descriptor() {
        return AddConsoleAliasW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static MethodHandle AddConsoleAliasW$handle() {
        return AddConsoleAliasW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static MemorySegment AddConsoleAliasW$address() {
        return AddConsoleAliasW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static int AddConsoleAliasW(MemorySegment Source, MemorySegment Target, MemorySegment ExeName) {
        var mh$ = AddConsoleAliasW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConsoleAliasW", Source, Target, ExeName);
            }
            return (int)mh$.invokeExact(Source, Target, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasA$descriptor() {
        return GetConsoleAliasA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasA$handle() {
        return GetConsoleAliasA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasA$address() {
        return GetConsoleAliasA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasA(MemorySegment Source, MemorySegment TargetBuffer, int TargetBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasA", Source, TargetBuffer, TargetBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Source, TargetBuffer, TargetBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasW$descriptor() {
        return GetConsoleAliasW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasW$handle() {
        return GetConsoleAliasW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasW$address() {
        return GetConsoleAliasW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasW(MemorySegment Source, MemorySegment TargetBuffer, int TargetBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasW", Source, TargetBuffer, TargetBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Source, TargetBuffer, TargetBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasesLengthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesLengthA$descriptor() {
        return GetConsoleAliasesLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesLengthA$handle() {
        return GetConsoleAliasesLengthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesLengthA$address() {
        return GetConsoleAliasesLengthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesLengthA(MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesLengthA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasesLengthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesLengthW$descriptor() {
        return GetConsoleAliasesLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesLengthW$handle() {
        return GetConsoleAliasesLengthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesLengthW$address() {
        return GetConsoleAliasesLengthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesLengthW(MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesLengthW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasExesLengthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesLengthA$descriptor() {
        return GetConsoleAliasExesLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static MethodHandle GetConsoleAliasExesLengthA$handle() {
        return GetConsoleAliasExesLengthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static MemorySegment GetConsoleAliasExesLengthA$address() {
        return GetConsoleAliasExesLengthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static int GetConsoleAliasExesLengthA() {
        var mh$ = GetConsoleAliasExesLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesLengthA");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasExesLengthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesLengthW$descriptor() {
        return GetConsoleAliasExesLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static MethodHandle GetConsoleAliasExesLengthW$handle() {
        return GetConsoleAliasExesLengthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static MemorySegment GetConsoleAliasExesLengthW$address() {
        return GetConsoleAliasExesLengthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static int GetConsoleAliasExesLengthW() {
        var mh$ = GetConsoleAliasExesLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesLengthW");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesA$descriptor() {
        return GetConsoleAliasesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesA$handle() {
        return GetConsoleAliasesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesA$address() {
        return GetConsoleAliasesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesA(MemorySegment AliasBuffer, int AliasBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesA", AliasBuffer, AliasBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(AliasBuffer, AliasBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesW$descriptor() {
        return GetConsoleAliasesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesW$handle() {
        return GetConsoleAliasesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleAliasesW$address() {
        return GetConsoleAliasesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesW(MemorySegment AliasBuffer, int AliasBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesW", AliasBuffer, AliasBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(AliasBuffer, AliasBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasExesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesA$descriptor() {
        return GetConsoleAliasExesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MethodHandle GetConsoleAliasExesA$handle() {
        return GetConsoleAliasExesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MemorySegment GetConsoleAliasExesA$address() {
        return GetConsoleAliasExesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static int GetConsoleAliasExesA(MemorySegment ExeNameBuffer, int ExeNameBufferLength) {
        var mh$ = GetConsoleAliasExesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesA", ExeNameBuffer, ExeNameBufferLength);
            }
            return (int)mh$.invokeExact(ExeNameBuffer, ExeNameBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleAliasExesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesW$descriptor() {
        return GetConsoleAliasExesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MethodHandle GetConsoleAliasExesW$handle() {
        return GetConsoleAliasExesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MemorySegment GetConsoleAliasExesW$address() {
        return GetConsoleAliasExesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static int GetConsoleAliasExesW(MemorySegment ExeNameBuffer, int ExeNameBufferLength) {
        var mh$ = GetConsoleAliasExesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesW", ExeNameBuffer, ExeNameBufferLength);
            }
            return (int)mh$.invokeExact(ExeNameBuffer, ExeNameBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpungeConsoleCommandHistoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExpungeConsoleCommandHistoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor ExpungeConsoleCommandHistoryA$descriptor() {
        return ExpungeConsoleCommandHistoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static MethodHandle ExpungeConsoleCommandHistoryA$handle() {
        return ExpungeConsoleCommandHistoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static MemorySegment ExpungeConsoleCommandHistoryA$address() {
        return ExpungeConsoleCommandHistoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static void ExpungeConsoleCommandHistoryA(MemorySegment ExeName) {
        var mh$ = ExpungeConsoleCommandHistoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpungeConsoleCommandHistoryA", ExeName);
            }
            mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpungeConsoleCommandHistoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExpungeConsoleCommandHistoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor ExpungeConsoleCommandHistoryW$descriptor() {
        return ExpungeConsoleCommandHistoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle ExpungeConsoleCommandHistoryW$handle() {
        return ExpungeConsoleCommandHistoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static MemorySegment ExpungeConsoleCommandHistoryW$address() {
        return ExpungeConsoleCommandHistoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static void ExpungeConsoleCommandHistoryW(MemorySegment ExeName) {
        var mh$ = ExpungeConsoleCommandHistoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpungeConsoleCommandHistoryW", ExeName);
            }
            mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleNumberOfCommandsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleNumberOfCommandsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor SetConsoleNumberOfCommandsA$descriptor() {
        return SetConsoleNumberOfCommandsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static MethodHandle SetConsoleNumberOfCommandsA$handle() {
        return SetConsoleNumberOfCommandsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static MemorySegment SetConsoleNumberOfCommandsA$address() {
        return SetConsoleNumberOfCommandsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static int SetConsoleNumberOfCommandsA(int Number, MemorySegment ExeName) {
        var mh$ = SetConsoleNumberOfCommandsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleNumberOfCommandsA", Number, ExeName);
            }
            return (int)mh$.invokeExact(Number, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleNumberOfCommandsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetConsoleNumberOfCommandsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor SetConsoleNumberOfCommandsW$descriptor() {
        return SetConsoleNumberOfCommandsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static MethodHandle SetConsoleNumberOfCommandsW$handle() {
        return SetConsoleNumberOfCommandsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static MemorySegment SetConsoleNumberOfCommandsW$address() {
        return SetConsoleNumberOfCommandsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static int SetConsoleNumberOfCommandsW(int Number, MemorySegment ExeName) {
        var mh$ = SetConsoleNumberOfCommandsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleNumberOfCommandsW", Number, ExeName);
            }
            return (int)mh$.invokeExact(Number, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleCommandHistoryLengthA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryLengthA$descriptor() {
        return GetConsoleCommandHistoryLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryLengthA$handle() {
        return GetConsoleCommandHistoryLengthA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryLengthA$address() {
        return GetConsoleCommandHistoryLengthA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryLengthA(MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryLengthA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleCommandHistoryLengthW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryLengthW$descriptor() {
        return GetConsoleCommandHistoryLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryLengthW$handle() {
        return GetConsoleCommandHistoryLengthW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryLengthW$address() {
        return GetConsoleCommandHistoryLengthW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryLengthW(MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryLengthW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleCommandHistoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryA$descriptor() {
        return GetConsoleCommandHistoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryA$handle() {
        return GetConsoleCommandHistoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryA$address() {
        return GetConsoleCommandHistoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryA(MemorySegment Commands, int CommandBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryA", Commands, CommandBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Commands, CommandBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleCommandHistoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryW$descriptor() {
        return GetConsoleCommandHistoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryW$handle() {
        return GetConsoleCommandHistoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static MemorySegment GetConsoleCommandHistoryW$address() {
        return GetConsoleCommandHistoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryW(MemorySegment Commands, int CommandBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryW", Commands, CommandBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Commands, CommandBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleProcessList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetConsoleProcessList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static FunctionDescriptor GetConsoleProcessList$descriptor() {
        return GetConsoleProcessList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static MethodHandle GetConsoleProcessList$handle() {
        return GetConsoleProcessList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static MemorySegment GetConsoleProcessList$address() {
        return GetConsoleProcessList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static int GetConsoleProcessList(MemorySegment lpdwProcessList, int dwProcessCount) {
        var mh$ = GetConsoleProcessList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleProcessList", lpdwProcessList, dwProcessCount);
            }
            return (int)mh$.invokeExact(lpdwProcessList, dwProcessCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerFindFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerFindFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static FunctionDescriptor VerFindFileA$descriptor() {
        return VerFindFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MethodHandle VerFindFileA$handle() {
        return VerFindFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MemorySegment VerFindFileA$address() {
        return VerFindFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static int VerFindFileA(int uFlags, MemorySegment szFileName, MemorySegment szWinDir, MemorySegment szAppDir, MemorySegment szCurDir, MemorySegment puCurDirLen, MemorySegment szDestDir, MemorySegment puDestDirLen) {
        var mh$ = VerFindFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerFindFileA", uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
            }
            return (int)mh$.invokeExact(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerFindFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerFindFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static FunctionDescriptor VerFindFileW$descriptor() {
        return VerFindFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MethodHandle VerFindFileW$handle() {
        return VerFindFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MemorySegment VerFindFileW$address() {
        return VerFindFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static int VerFindFileW(int uFlags, MemorySegment szFileName, MemorySegment szWinDir, MemorySegment szAppDir, MemorySegment szCurDir, MemorySegment puCurDirLen, MemorySegment szDestDir, MemorySegment puDestDirLen) {
        var mh$ = VerFindFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerFindFileW", uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
            }
            return (int)mh$.invokeExact(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerInstallFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerInstallFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static FunctionDescriptor VerInstallFileA$descriptor() {
        return VerInstallFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MethodHandle VerInstallFileA$handle() {
        return VerInstallFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MemorySegment VerInstallFileA$address() {
        return VerInstallFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static int VerInstallFileA(int uFlags, MemorySegment szSrcFileName, MemorySegment szDestFileName, MemorySegment szSrcDir, MemorySegment szDestDir, MemorySegment szCurDir, MemorySegment szTmpFile, MemorySegment puTmpFileLen) {
        var mh$ = VerInstallFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerInstallFileA", uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
            }
            return (int)mh$.invokeExact(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerInstallFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerInstallFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static FunctionDescriptor VerInstallFileW$descriptor() {
        return VerInstallFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MethodHandle VerInstallFileW$handle() {
        return VerInstallFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MemorySegment VerInstallFileW$address() {
        return VerInstallFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static int VerInstallFileW(int uFlags, MemorySegment szSrcFileName, MemorySegment szDestFileName, MemorySegment szSrcDir, MemorySegment szDestDir, MemorySegment szCurDir, MemorySegment szTmpFile, MemorySegment puTmpFileLen) {
        var mh$ = VerInstallFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerInstallFileW", uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
            }
            return (int)mh$.invokeExact(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoSizeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeA$descriptor() {
        return GetFileVersionInfoSizeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeA$handle() {
        return GetFileVersionInfoSizeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeA$address() {
        return GetFileVersionInfoSizeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeA(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeA", lptstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(lptstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoSizeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeW$descriptor() {
        return GetFileVersionInfoSizeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeW$handle() {
        return GetFileVersionInfoSizeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeW$address() {
        return GetFileVersionInfoSizeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeW(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeW", lptstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(lptstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoA$descriptor() {
        return GetFileVersionInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoA$handle() {
        return GetFileVersionInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoA$address() {
        return GetFileVersionInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoA(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoA", lptstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoW$descriptor() {
        return GetFileVersionInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoW$handle() {
        return GetFileVersionInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoW$address() {
        return GetFileVersionInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoW(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoW", lptstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoSizeExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeExA$descriptor() {
        return GetFileVersionInfoSizeExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeExA$handle() {
        return GetFileVersionInfoSizeExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeExA$address() {
        return GetFileVersionInfoSizeExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeExA(int dwFlags, MemorySegment lpwstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeExA", dwFlags, lpwstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoSizeExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeExW$descriptor() {
        return GetFileVersionInfoSizeExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeExW$handle() {
        return GetFileVersionInfoSizeExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MemorySegment GetFileVersionInfoSizeExW$address() {
        return GetFileVersionInfoSizeExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeExW(int dwFlags, MemorySegment lpwstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeExW", dwFlags, lpwstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoExA$descriptor() {
        return GetFileVersionInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoExA$handle() {
        return GetFileVersionInfoExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoExA$address() {
        return GetFileVersionInfoExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoExA(int dwFlags, MemorySegment lpwstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoExA", dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileVersionInfoExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoExW$descriptor() {
        return GetFileVersionInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoExW$handle() {
        return GetFileVersionInfoExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MemorySegment GetFileVersionInfoExW$address() {
        return GetFileVersionInfoExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoExW(int dwFlags, MemorySegment lpwstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoExW", dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerLanguageNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerLanguageNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static FunctionDescriptor VerLanguageNameA$descriptor() {
        return VerLanguageNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static MethodHandle VerLanguageNameA$handle() {
        return VerLanguageNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static MemorySegment VerLanguageNameA$address() {
        return VerLanguageNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static int VerLanguageNameA(int wLang, MemorySegment szLang, int cchLang) {
        var mh$ = VerLanguageNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerLanguageNameA", wLang, szLang, cchLang);
            }
            return (int)mh$.invokeExact(wLang, szLang, cchLang);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerLanguageNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerLanguageNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static FunctionDescriptor VerLanguageNameW$descriptor() {
        return VerLanguageNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static MethodHandle VerLanguageNameW$handle() {
        return VerLanguageNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static MemorySegment VerLanguageNameW$address() {
        return VerLanguageNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static int VerLanguageNameW(int wLang, MemorySegment szLang, int cchLang) {
        var mh$ = VerLanguageNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerLanguageNameW", wLang, szLang, cchLang);
            }
            return (int)mh$.invokeExact(wLang, szLang, cchLang);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerQueryValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerQueryValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static FunctionDescriptor VerQueryValueA$descriptor() {
        return VerQueryValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MethodHandle VerQueryValueA$handle() {
        return VerQueryValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MemorySegment VerQueryValueA$address() {
        return VerQueryValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static int VerQueryValueA(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
        var mh$ = VerQueryValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerQueryValueA", pBlock, lpSubBlock, lplpBuffer, puLen);
            }
            return (int)mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerQueryValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VerQueryValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static FunctionDescriptor VerQueryValueW$descriptor() {
        return VerQueryValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MethodHandle VerQueryValueW$handle() {
        return VerQueryValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MemorySegment VerQueryValueW$address() {
        return VerQueryValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static int VerQueryValueW(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
        var mh$ = VerQueryValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerQueryValueW", pBlock, lpSubBlock, lplpBuffer, puLen);
            }
            return (int)mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LONG LSTATUS
     * }
     */
    public static final OfInt LSTATUS = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ACCESS_MASK REGSAM
     * }
     */
    public static final OfInt REGSAM = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct val_context {
     *     int valuelen;
     *     LPVOID value_context;
     *     LPVOID val_buff_ptr;
     * } *PVALCONTEXT
     * }
     */
    public static final AddressLayout PVALCONTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pvalueA {
     *     LPSTR pv_valuename;
     *     int pv_valuelen;
     *     LPVOID pv_value_context;
     *     DWORD pv_type;
     * } *PPVALUEA
     * }
     */
    public static final AddressLayout PPVALUEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pvalueW {
     *     LPWSTR pv_valuename;
     *     int pv_valuelen;
     *     LPVOID pv_value_context;
     *     DWORD pv_type;
     * } *PPVALUEW
     * }
     */
    public static final AddressLayout PPVALUEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PPVALUEA PPVALUE
     * }
     */
    public static final AddressLayout PPVALUE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct provider_info {
     *     PQUERYHANDLER pi_R0_1val;
     *     PQUERYHANDLER pi_R0_allvals;
     *     PQUERYHANDLER pi_R3_1val;
     *     PQUERYHANDLER pi_R3_allvals;
     *     DWORD pi_flags;
     *     LPVOID pi_key_context;
     * } *PPROVIDER
     * }
     */
    public static final AddressLayout PPROVIDER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct value_entA {
     *     LPSTR ve_valuename;
     *     DWORD ve_valuelen;
     *     DWORD_PTR ve_valueptr;
     *     DWORD ve_type;
     * } *PVALENTA
     * }
     */
    public static final AddressLayout PVALENTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct value_entW {
     *     LPWSTR ve_valuename;
     *     DWORD ve_valuelen;
     *     DWORD_PTR ve_valueptr;
     *     DWORD ve_type;
     * } *PVALENTW
     * }
     */
    public static final AddressLayout PVALENTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVALENTA PVALENT
     * }
     */
    public static final AddressLayout PVALENT = freeglut_h.C_POINTER;

    private static class RegCloseKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCloseKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegCloseKey$descriptor() {
        return RegCloseKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegCloseKey$handle() {
        return RegCloseKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MemorySegment RegCloseKey$address() {
        return RegCloseKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static int RegCloseKey(MemorySegment hKey) {
        var mh$ = RegCloseKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCloseKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOverridePredefKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOverridePredefKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static FunctionDescriptor RegOverridePredefKey$descriptor() {
        return RegOverridePredefKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static MethodHandle RegOverridePredefKey$handle() {
        return RegOverridePredefKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static MemorySegment RegOverridePredefKey$address() {
        return RegOverridePredefKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static int RegOverridePredefKey(MemorySegment hKey, MemorySegment hNewHKey) {
        var mh$ = RegOverridePredefKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOverridePredefKey", hKey, hNewHKey);
            }
            return (int)mh$.invokeExact(hKey, hNewHKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenUserClassesRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenUserClassesRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenUserClassesRoot$descriptor() {
        return RegOpenUserClassesRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenUserClassesRoot$handle() {
        return RegOpenUserClassesRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenUserClassesRoot$address() {
        return RegOpenUserClassesRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenUserClassesRoot(MemorySegment hToken, int dwOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenUserClassesRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenUserClassesRoot", hToken, dwOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hToken, dwOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenCurrentUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenCurrentUser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenCurrentUser$descriptor() {
        return RegOpenCurrentUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenCurrentUser$handle() {
        return RegOpenCurrentUser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenCurrentUser$address() {
        return RegOpenCurrentUser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenCurrentUser(int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenCurrentUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenCurrentUser", samDesired, phkResult);
            }
            return (int)mh$.invokeExact(samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisablePredefinedCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDisablePredefinedCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static FunctionDescriptor RegDisablePredefinedCache$descriptor() {
        return RegDisablePredefinedCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static MethodHandle RegDisablePredefinedCache$handle() {
        return RegDisablePredefinedCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static MemorySegment RegDisablePredefinedCache$address() {
        return RegDisablePredefinedCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static int RegDisablePredefinedCache() {
        var mh$ = RegDisablePredefinedCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisablePredefinedCache");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisablePredefinedCacheEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDisablePredefinedCacheEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static FunctionDescriptor RegDisablePredefinedCacheEx$descriptor() {
        return RegDisablePredefinedCacheEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static MethodHandle RegDisablePredefinedCacheEx$handle() {
        return RegDisablePredefinedCacheEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static MemorySegment RegDisablePredefinedCacheEx$address() {
        return RegDisablePredefinedCacheEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static int RegDisablePredefinedCacheEx() {
        var mh$ = RegDisablePredefinedCacheEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisablePredefinedCacheEx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegConnectRegistryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryA$descriptor() {
        return RegConnectRegistryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryA$handle() {
        return RegConnectRegistryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryA$address() {
        return RegConnectRegistryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryA(MemorySegment lpMachineName, MemorySegment hKey, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryA", lpMachineName, hKey, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegConnectRegistryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryW$descriptor() {
        return RegConnectRegistryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryW$handle() {
        return RegConnectRegistryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryW$address() {
        return RegConnectRegistryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryW(MemorySegment lpMachineName, MemorySegment hKey, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryW", lpMachineName, hKey, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegConnectRegistryExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryExA$descriptor() {
        return RegConnectRegistryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryExA$handle() {
        return RegConnectRegistryExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryExA$address() {
        return RegConnectRegistryExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryExA(MemorySegment lpMachineName, MemorySegment hKey, int Flags, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryExA", lpMachineName, hKey, Flags, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, Flags, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegConnectRegistryExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryExW$descriptor() {
        return RegConnectRegistryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryExW$handle() {
        return RegConnectRegistryExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegConnectRegistryExW$address() {
        return RegConnectRegistryExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryExW(MemorySegment lpMachineName, MemorySegment hKey, int Flags, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryExW", lpMachineName, hKey, Flags, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, Flags, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCreateKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegCreateKeyA$descriptor() {
        return RegCreateKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegCreateKeyA$handle() {
        return RegCreateKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegCreateKeyA$address() {
        return RegCreateKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegCreateKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegCreateKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyA", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCreateKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegCreateKeyW$descriptor() {
        return RegCreateKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegCreateKeyW$handle() {
        return RegCreateKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegCreateKeyW$address() {
        return RegCreateKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegCreateKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegCreateKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyW", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCreateKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static FunctionDescriptor RegCreateKeyExA$descriptor() {
        return RegCreateKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MethodHandle RegCreateKeyExA$handle() {
        return RegCreateKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MemorySegment RegCreateKeyExA$address() {
        return RegCreateKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static int RegCreateKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition) {
        var mh$ = RegCreateKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyExA", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCreateKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static FunctionDescriptor RegCreateKeyExW$descriptor() {
        return RegCreateKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MethodHandle RegCreateKeyExW$handle() {
        return RegCreateKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MemorySegment RegCreateKeyExW$address() {
        return RegCreateKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static int RegCreateKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition) {
        var mh$ = RegCreateKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyExW", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCreateKeyTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegCreateKeyTransactedA$descriptor() {
        return RegCreateKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegCreateKeyTransactedA$handle() {
        return RegCreateKeyTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegCreateKeyTransactedA$address() {
        return RegCreateKeyTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegCreateKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegCreateKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyTransactedA", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCreateKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegCreateKeyTransactedW$descriptor() {
        return RegCreateKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegCreateKeyTransactedW$handle() {
        return RegCreateKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegCreateKeyTransactedW$address() {
        return RegCreateKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegCreateKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegCreateKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyTransactedW", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyA$descriptor() {
        return RegDeleteKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteKeyA$handle() {
        return RegDeleteKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteKeyA$address() {
        return RegDeleteKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegDeleteKeyA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyW$descriptor() {
        return RegDeleteKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteKeyW$handle() {
        return RegDeleteKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteKeyW$address() {
        return RegDeleteKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegDeleteKeyW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyExA$descriptor() {
        return RegDeleteKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MethodHandle RegDeleteKeyExA$handle() {
        return RegDeleteKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MemorySegment RegDeleteKeyExA$address() {
        return RegDeleteKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static int RegDeleteKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved) {
        var mh$ = RegDeleteKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyExA", hKey, lpSubKey, samDesired, Reserved);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyExW$descriptor() {
        return RegDeleteKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MethodHandle RegDeleteKeyExW$handle() {
        return RegDeleteKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MemorySegment RegDeleteKeyExW$address() {
        return RegDeleteKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static int RegDeleteKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved) {
        var mh$ = RegDeleteKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyExW", hKey, lpSubKey, samDesired, Reserved);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyTransactedA$descriptor() {
        return RegDeleteKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MethodHandle RegDeleteKeyTransactedA$handle() {
        return RegDeleteKeyTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MemorySegment RegDeleteKeyTransactedA$address() {
        return RegDeleteKeyTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static int RegDeleteKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved, MemorySegment hTransaction, MemorySegment pExtendedParameter) {
        var mh$ = RegDeleteKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyTransactedA", hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyTransactedW$descriptor() {
        return RegDeleteKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MethodHandle RegDeleteKeyTransactedW$handle() {
        return RegDeleteKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MemorySegment RegDeleteKeyTransactedW$address() {
        return RegDeleteKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static int RegDeleteKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved, MemorySegment hTransaction, MemorySegment pExtendedParameter) {
        var mh$ = RegDeleteKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyTransactedW", hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisableReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDisableReflectionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static FunctionDescriptor RegDisableReflectionKey$descriptor() {
        return RegDisableReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static MethodHandle RegDisableReflectionKey$handle() {
        return RegDisableReflectionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static MemorySegment RegDisableReflectionKey$address() {
        return RegDisableReflectionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static int RegDisableReflectionKey(MemorySegment hBase) {
        var mh$ = RegDisableReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisableReflectionKey", hBase);
            }
            return (int)mh$.invokeExact(hBase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnableReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegEnableReflectionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static FunctionDescriptor RegEnableReflectionKey$descriptor() {
        return RegEnableReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static MethodHandle RegEnableReflectionKey$handle() {
        return RegEnableReflectionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static MemorySegment RegEnableReflectionKey$address() {
        return RegEnableReflectionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static int RegEnableReflectionKey(MemorySegment hBase) {
        var mh$ = RegEnableReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnableReflectionKey", hBase);
            }
            return (int)mh$.invokeExact(hBase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryReflectionKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static FunctionDescriptor RegQueryReflectionKey$descriptor() {
        return RegQueryReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static MethodHandle RegQueryReflectionKey$handle() {
        return RegQueryReflectionKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static MemorySegment RegQueryReflectionKey$address() {
        return RegQueryReflectionKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static int RegQueryReflectionKey(MemorySegment hBase, MemorySegment bIsReflectionDisabled) {
        var mh$ = RegQueryReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryReflectionKey", hBase, bIsReflectionDisabled);
            }
            return (int)mh$.invokeExact(hBase, bIsReflectionDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteValueA$descriptor() {
        return RegDeleteValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteValueA$handle() {
        return RegDeleteValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteValueA$address() {
        return RegDeleteValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static int RegDeleteValueA(MemorySegment hKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteValueA", hKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteValueW$descriptor() {
        return RegDeleteValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteValueW$handle() {
        return RegDeleteValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteValueW$address() {
        return RegDeleteValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static int RegDeleteValueW(MemorySegment hKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteValueW", hKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegEnumKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static FunctionDescriptor RegEnumKeyA$descriptor() {
        return RegEnumKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static MethodHandle RegEnumKeyA$handle() {
        return RegEnumKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static MemorySegment RegEnumKeyA$address() {
        return RegEnumKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static int RegEnumKeyA(MemorySegment hKey, int dwIndex, MemorySegment lpName, int cchName) {
        var mh$ = RegEnumKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyA", hKey, dwIndex, lpName, cchName);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegEnumKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static FunctionDescriptor RegEnumKeyW$descriptor() {
        return RegEnumKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static MethodHandle RegEnumKeyW$handle() {
        return RegEnumKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static MemorySegment RegEnumKeyW$address() {
        return RegEnumKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static int RegEnumKeyW(MemorySegment hKey, int dwIndex, MemorySegment lpName, int cchName) {
        var mh$ = RegEnumKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyW", hKey, dwIndex, lpName, cchName);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegEnumKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegEnumKeyExA$descriptor() {
        return RegEnumKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegEnumKeyExA$handle() {
        return RegEnumKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegEnumKeyExA$address() {
        return RegEnumKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegEnumKeyExA(MemorySegment hKey, int dwIndex, MemorySegment lpName, MemorySegment lpcchName, MemorySegment lpReserved, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpftLastWriteTime) {
        var mh$ = RegEnumKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyExA", hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegEnumKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegEnumKeyExW$descriptor() {
        return RegEnumKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegEnumKeyExW$handle() {
        return RegEnumKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegEnumKeyExW$address() {
        return RegEnumKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegEnumKeyExW(MemorySegment hKey, int dwIndex, MemorySegment lpName, MemorySegment lpcchName, MemorySegment lpReserved, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpftLastWriteTime) {
        var mh$ = RegEnumKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyExW", hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegEnumValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegEnumValueA$descriptor() {
        return RegEnumValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegEnumValueA$handle() {
        return RegEnumValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegEnumValueA$address() {
        return RegEnumValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueA(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueA", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegEnumValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegEnumValueW$descriptor() {
        return RegEnumValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegEnumValueW$handle() {
        return RegEnumValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegEnumValueW$address() {
        return RegEnumValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueW(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueW", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegFlushKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegFlushKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegFlushKey$descriptor() {
        return RegFlushKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegFlushKey$handle() {
        return RegFlushKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static MemorySegment RegFlushKey$address() {
        return RegFlushKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static int RegFlushKey(MemorySegment hKey) {
        var mh$ = RegFlushKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegFlushKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetKeySecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegGetKeySecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor RegGetKeySecurity$descriptor() {
        return RegGetKeySecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static MethodHandle RegGetKeySecurity$handle() {
        return RegGetKeySecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static MemorySegment RegGetKeySecurity$address() {
        return RegGetKeySecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static int RegGetKeySecurity(MemorySegment hKey, int SecurityInformation, MemorySegment pSecurityDescriptor, MemorySegment lpcbSecurityDescriptor) {
        var mh$ = RegGetKeySecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetKeySecurity", hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegLoadKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static FunctionDescriptor RegLoadKeyA$descriptor() {
        return RegLoadKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static MethodHandle RegLoadKeyA$handle() {
        return RegLoadKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static MemorySegment RegLoadKeyA$address() {
        return RegLoadKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static int RegLoadKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpFile) {
        var mh$ = RegLoadKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadKeyA", hKey, lpSubKey, lpFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegLoadKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static FunctionDescriptor RegLoadKeyW$descriptor() {
        return RegLoadKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static MethodHandle RegLoadKeyW$handle() {
        return RegLoadKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static MemorySegment RegLoadKeyW$address() {
        return RegLoadKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static int RegLoadKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpFile) {
        var mh$ = RegLoadKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadKeyW", hKey, lpSubKey, lpFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegNotifyChangeKeyValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegNotifyChangeKeyValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static FunctionDescriptor RegNotifyChangeKeyValue$descriptor() {
        return RegNotifyChangeKeyValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static MethodHandle RegNotifyChangeKeyValue$handle() {
        return RegNotifyChangeKeyValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static MemorySegment RegNotifyChangeKeyValue$address() {
        return RegNotifyChangeKeyValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static int RegNotifyChangeKeyValue(MemorySegment hKey, int bWatchSubtree, int dwNotifyFilter, MemorySegment hEvent, int fAsynchronous) {
        var mh$ = RegNotifyChangeKeyValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegNotifyChangeKeyValue", hKey, bWatchSubtree, dwNotifyFilter, hEvent, fAsynchronous);
            }
            return (int)mh$.invokeExact(hKey, bWatchSubtree, dwNotifyFilter, hEvent, fAsynchronous);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyA$descriptor() {
        return RegOpenKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyA$handle() {
        return RegOpenKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyA$address() {
        return RegOpenKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegOpenKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyA", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyW$descriptor() {
        return RegOpenKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyW$handle() {
        return RegOpenKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyW$address() {
        return RegOpenKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegOpenKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyW", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyExA$descriptor() {
        return RegOpenKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyExA$handle() {
        return RegOpenKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyExA$address() {
        return RegOpenKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExA", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyExW$descriptor() {
        return RegOpenKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyExW$handle() {
        return RegOpenKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MemorySegment RegOpenKeyExW$address() {
        return RegOpenKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExW", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenKeyTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegOpenKeyTransactedA$descriptor() {
        return RegOpenKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegOpenKeyTransactedA$handle() {
        return RegOpenKeyTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegOpenKeyTransactedA$address() {
        return RegOpenKeyTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegOpenKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegOpenKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyTransactedA", hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegOpenKeyTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegOpenKeyTransactedW$descriptor() {
        return RegOpenKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegOpenKeyTransactedW$handle() {
        return RegOpenKeyTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MemorySegment RegOpenKeyTransactedW$address() {
        return RegOpenKeyTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegOpenKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegOpenKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyTransactedW", hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryInfoKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryInfoKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegQueryInfoKeyA$descriptor() {
        return RegQueryInfoKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegQueryInfoKeyA$handle() {
        return RegQueryInfoKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegQueryInfoKeyA$address() {
        return RegQueryInfoKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegQueryInfoKeyA(MemorySegment hKey, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpReserved, MemorySegment lpcSubKeys, MemorySegment lpcbMaxSubKeyLen, MemorySegment lpcbMaxClassLen, MemorySegment lpcValues, MemorySegment lpcbMaxValueNameLen, MemorySegment lpcbMaxValueLen, MemorySegment lpcbSecurityDescriptor, MemorySegment lpftLastWriteTime) {
        var mh$ = RegQueryInfoKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryInfoKeyA", hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryInfoKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryInfoKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegQueryInfoKeyW$descriptor() {
        return RegQueryInfoKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegQueryInfoKeyW$handle() {
        return RegQueryInfoKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MemorySegment RegQueryInfoKeyW$address() {
        return RegQueryInfoKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegQueryInfoKeyW(MemorySegment hKey, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpReserved, MemorySegment lpcSubKeys, MemorySegment lpcbMaxSubKeyLen, MemorySegment lpcbMaxClassLen, MemorySegment lpcValues, MemorySegment lpcbMaxValueNameLen, MemorySegment lpcbMaxValueLen, MemorySegment lpcbSecurityDescriptor, MemorySegment lpftLastWriteTime) {
        var mh$ = RegQueryInfoKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryInfoKeyW", hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueA$descriptor() {
        return RegQueryValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueA$handle() {
        return RegQueryValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueA$address() {
        return RegQueryValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static int RegQueryValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueA", hKey, lpSubKey, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueW$descriptor() {
        return RegQueryValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueW$handle() {
        return RegQueryValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueW$address() {
        return RegQueryValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static int RegQueryValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueW", hKey, lpSubKey, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryMultipleValuesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryMultipleValuesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static FunctionDescriptor RegQueryMultipleValuesA$descriptor() {
        return RegQueryMultipleValuesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MethodHandle RegQueryMultipleValuesA$handle() {
        return RegQueryMultipleValuesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MemorySegment RegQueryMultipleValuesA$address() {
        return RegQueryMultipleValuesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static int RegQueryMultipleValuesA(MemorySegment hKey, MemorySegment val_list, int num_vals, MemorySegment lpValueBuf, MemorySegment ldwTotsize) {
        var mh$ = RegQueryMultipleValuesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryMultipleValuesA", hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
            }
            return (int)mh$.invokeExact(hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryMultipleValuesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryMultipleValuesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static FunctionDescriptor RegQueryMultipleValuesW$descriptor() {
        return RegQueryMultipleValuesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MethodHandle RegQueryMultipleValuesW$handle() {
        return RegQueryMultipleValuesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MemorySegment RegQueryMultipleValuesW$address() {
        return RegQueryMultipleValuesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static int RegQueryMultipleValuesW(MemorySegment hKey, MemorySegment val_list, int num_vals, MemorySegment lpValueBuf, MemorySegment ldwTotsize) {
        var mh$ = RegQueryMultipleValuesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryMultipleValuesW", hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
            }
            return (int)mh$.invokeExact(hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryValueExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueExA$descriptor() {
        return RegQueryValueExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueExA$handle() {
        return RegQueryValueExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueExA$address() {
        return RegQueryValueExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegQueryValueExA(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueExA", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegQueryValueExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueExW$descriptor() {
        return RegQueryValueExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueExW$handle() {
        return RegQueryValueExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MemorySegment RegQueryValueExW$address() {
        return RegQueryValueExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegQueryValueExW(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueExW", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegReplaceKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegReplaceKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static FunctionDescriptor RegReplaceKeyA$descriptor() {
        return RegReplaceKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static MethodHandle RegReplaceKeyA$handle() {
        return RegReplaceKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static MemorySegment RegReplaceKeyA$address() {
        return RegReplaceKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static int RegReplaceKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpNewFile, MemorySegment lpOldFile) {
        var mh$ = RegReplaceKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegReplaceKeyA", hKey, lpSubKey, lpNewFile, lpOldFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpNewFile, lpOldFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegReplaceKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegReplaceKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static FunctionDescriptor RegReplaceKeyW$descriptor() {
        return RegReplaceKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static MethodHandle RegReplaceKeyW$handle() {
        return RegReplaceKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static MemorySegment RegReplaceKeyW$address() {
        return RegReplaceKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static int RegReplaceKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpNewFile, MemorySegment lpOldFile) {
        var mh$ = RegReplaceKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegReplaceKeyW", hKey, lpSubKey, lpNewFile, lpOldFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpNewFile, lpOldFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRestoreKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegRestoreKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegRestoreKeyA$descriptor() {
        return RegRestoreKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegRestoreKeyA$handle() {
        return RegRestoreKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegRestoreKeyA$address() {
        return RegRestoreKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static int RegRestoreKeyA(MemorySegment hKey, MemorySegment lpFile, int dwFlags) {
        var mh$ = RegRestoreKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRestoreKeyA", hKey, lpFile, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRestoreKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegRestoreKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegRestoreKeyW$descriptor() {
        return RegRestoreKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegRestoreKeyW$handle() {
        return RegRestoreKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment RegRestoreKeyW$address() {
        return RegRestoreKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static int RegRestoreKeyW(MemorySegment hKey, MemorySegment lpFile, int dwFlags) {
        var mh$ = RegRestoreKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRestoreKeyW", hKey, lpFile, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRenameKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegRenameKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static FunctionDescriptor RegRenameKey$descriptor() {
        return RegRenameKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static MethodHandle RegRenameKey$handle() {
        return RegRenameKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static MemorySegment RegRenameKey$address() {
        return RegRenameKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static int RegRenameKey(MemorySegment hKey, MemorySegment lpSubKeyName, MemorySegment lpNewKeyName) {
        var mh$ = RegRenameKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRenameKey", hKey, lpSubKeyName, lpNewKeyName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKeyName, lpNewKeyName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSaveKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor RegSaveKeyA$descriptor() {
        return RegSaveKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle RegSaveKeyA$handle() {
        return RegSaveKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment RegSaveKeyA$address() {
        return RegSaveKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int RegSaveKeyA(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes) {
        var mh$ = RegSaveKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyA", hKey, lpFile, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSaveKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor RegSaveKeyW$descriptor() {
        return RegSaveKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle RegSaveKeyW$handle() {
        return RegSaveKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment RegSaveKeyW$address() {
        return RegSaveKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int RegSaveKeyW(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes) {
        var mh$ = RegSaveKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyW", hKey, lpFile, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeySecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSetKeySecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor RegSetKeySecurity$descriptor() {
        return RegSetKeySecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle RegSetKeySecurity$handle() {
        return RegSetKeySecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment RegSetKeySecurity$address() {
        return RegSetKeySecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int RegSetKeySecurity(MemorySegment hKey, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = RegSetKeySecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeySecurity", hKey, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hKey, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSetValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueA$descriptor() {
        return RegSetValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueA$handle() {
        return RegSetValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueA$address() {
        return RegSetValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueA(MemorySegment hKey, MemorySegment lpSubKey, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueA", hKey, lpSubKey, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSetValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueW$descriptor() {
        return RegSetValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueW$handle() {
        return RegSetValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueW$address() {
        return RegSetValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueW(MemorySegment hKey, MemorySegment lpSubKey, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueW", hKey, lpSubKey, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSetValueExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueExA$descriptor() {
        return RegSetValueExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueExA$handle() {
        return RegSetValueExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueExA$address() {
        return RegSetValueExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueExA(MemorySegment hKey, MemorySegment lpValueName, int Reserved, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueExA", hKey, lpValueName, Reserved, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSetValueExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueExW$descriptor() {
        return RegSetValueExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueExW$handle() {
        return RegSetValueExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetValueExW$address() {
        return RegSetValueExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueExW(MemorySegment hKey, MemorySegment lpValueName, int Reserved, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueExW", hKey, lpValueName, Reserved, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegUnLoadKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegUnLoadKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegUnLoadKeyA$descriptor() {
        return RegUnLoadKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegUnLoadKeyA$handle() {
        return RegUnLoadKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MemorySegment RegUnLoadKeyA$address() {
        return RegUnLoadKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegUnLoadKeyA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegUnLoadKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegUnLoadKeyA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegUnLoadKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegUnLoadKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegUnLoadKeyW$descriptor() {
        return RegUnLoadKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegUnLoadKeyW$handle() {
        return RegUnLoadKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MemorySegment RegUnLoadKeyW$address() {
        return RegUnLoadKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegUnLoadKeyW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegUnLoadKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegUnLoadKeyW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyValueA$descriptor() {
        return RegDeleteKeyValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteKeyValueA$handle() {
        return RegDeleteKeyValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteKeyValueA$address() {
        return RegDeleteKeyValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static int RegDeleteKeyValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteKeyValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyValueA", hKey, lpSubKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteKeyValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyValueW$descriptor() {
        return RegDeleteKeyValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteKeyValueW$handle() {
        return RegDeleteKeyValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static MemorySegment RegDeleteKeyValueW$address() {
        return RegDeleteKeyValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static int RegDeleteKeyValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteKeyValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyValueW", hKey, lpSubKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeyValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSetKeyValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetKeyValueA$descriptor() {
        return RegSetKeyValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetKeyValueA$handle() {
        return RegSetKeyValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetKeyValueA$address() {
        return RegSetKeyValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static int RegSetKeyValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetKeyValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeyValueA", hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeyValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSetKeyValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetKeyValueW$descriptor() {
        return RegSetKeyValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetKeyValueW$handle() {
        return RegSetKeyValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MemorySegment RegSetKeyValueW$address() {
        return RegSetKeyValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static int RegSetKeyValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetKeyValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeyValueW", hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteTreeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteTreeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteTreeA$descriptor() {
        return RegDeleteTreeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteTreeA$handle() {
        return RegDeleteTreeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteTreeA$address() {
        return RegDeleteTreeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegDeleteTreeA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteTreeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteTreeA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteTreeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegDeleteTreeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteTreeW$descriptor() {
        return RegDeleteTreeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteTreeW$handle() {
        return RegDeleteTreeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MemorySegment RegDeleteTreeW$address() {
        return RegDeleteTreeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegDeleteTreeW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteTreeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteTreeW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCopyTreeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCopyTreeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static FunctionDescriptor RegCopyTreeA$descriptor() {
        return RegCopyTreeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MethodHandle RegCopyTreeA$handle() {
        return RegCopyTreeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MemorySegment RegCopyTreeA$address() {
        return RegCopyTreeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static int RegCopyTreeA(MemorySegment hKeySrc, MemorySegment lpSubKey, MemorySegment hKeyDest) {
        var mh$ = RegCopyTreeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCopyTreeA", hKeySrc, lpSubKey, hKeyDest);
            }
            return (int)mh$.invokeExact(hKeySrc, lpSubKey, hKeyDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegGetValueA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static FunctionDescriptor RegGetValueA$descriptor() {
        return RegGetValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MethodHandle RegGetValueA$handle() {
        return RegGetValueA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MemorySegment RegGetValueA$address() {
        return RegGetValueA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static int RegGetValueA(MemorySegment hkey, MemorySegment lpSubKey, MemorySegment lpValue, int dwFlags, MemorySegment pdwType, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = RegGetValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetValueA", hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegGetValueW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static FunctionDescriptor RegGetValueW$descriptor() {
        return RegGetValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MethodHandle RegGetValueW$handle() {
        return RegGetValueW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static MemorySegment RegGetValueW$address() {
        return RegGetValueW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData)
     * }
     */
    public static int RegGetValueW(MemorySegment hkey, MemorySegment lpSubKey, MemorySegment lpValue, int dwFlags, MemorySegment pdwType, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = RegGetValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetValueW", hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hkey, lpSubKey, lpValue, dwFlags, pdwType, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCopyTreeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegCopyTreeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static FunctionDescriptor RegCopyTreeW$descriptor() {
        return RegCopyTreeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MethodHandle RegCopyTreeW$handle() {
        return RegCopyTreeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static MemorySegment RegCopyTreeW$address() {
        return RegCopyTreeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest)
     * }
     */
    public static int RegCopyTreeW(MemorySegment hKeySrc, MemorySegment lpSubKey, MemorySegment hKeyDest) {
        var mh$ = RegCopyTreeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCopyTreeW", hKeySrc, lpSubKey, hKeyDest);
            }
            return (int)mh$.invokeExact(hKeySrc, lpSubKey, hKeyDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadMUIStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegLoadMUIStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static FunctionDescriptor RegLoadMUIStringA$descriptor() {
        return RegLoadMUIStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static MethodHandle RegLoadMUIStringA$handle() {
        return RegLoadMUIStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static MemorySegment RegLoadMUIStringA$address() {
        return RegLoadMUIStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
     * }
     */
    public static int RegLoadMUIStringA(MemorySegment hKey, MemorySegment pszValue, MemorySegment pszOutBuf, int cbOutBuf, MemorySegment pcbData, int Flags, MemorySegment pszDirectory) {
        var mh$ = RegLoadMUIStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadMUIStringA", hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
            }
            return (int)mh$.invokeExact(hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadMUIStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegLoadMUIStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static FunctionDescriptor RegLoadMUIStringW$descriptor() {
        return RegLoadMUIStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static MethodHandle RegLoadMUIStringW$handle() {
        return RegLoadMUIStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static MemorySegment RegLoadMUIStringW$address() {
        return RegLoadMUIStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory)
     * }
     */
    public static int RegLoadMUIStringW(MemorySegment hKey, MemorySegment pszValue, MemorySegment pszOutBuf, int cbOutBuf, MemorySegment pcbData, int Flags, MemorySegment pszDirectory) {
        var mh$ = RegLoadMUIStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadMUIStringW", hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
            }
            return (int)mh$.invokeExact(hKey, pszValue, pszOutBuf, cbOutBuf, pcbData, Flags, pszDirectory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadAppKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegLoadAppKeyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegLoadAppKeyA$descriptor() {
        return RegLoadAppKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MethodHandle RegLoadAppKeyA$handle() {
        return RegLoadAppKeyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MemorySegment RegLoadAppKeyA$address() {
        return RegLoadAppKeyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static int RegLoadAppKeyA(MemorySegment lpFile, MemorySegment phkResult, int samDesired, int dwOptions, int Reserved) {
        var mh$ = RegLoadAppKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadAppKeyA", lpFile, phkResult, samDesired, dwOptions, Reserved);
            }
            return (int)mh$.invokeExact(lpFile, phkResult, samDesired, dwOptions, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadAppKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegLoadAppKeyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegLoadAppKeyW$descriptor() {
        return RegLoadAppKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MethodHandle RegLoadAppKeyW$handle() {
        return RegLoadAppKeyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static MemorySegment RegLoadAppKeyW$address() {
        return RegLoadAppKeyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved)
     * }
     */
    public static int RegLoadAppKeyW(MemorySegment lpFile, MemorySegment phkResult, int samDesired, int dwOptions, int Reserved) {
        var mh$ = RegLoadAppKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadAppKeyW", lpFile, phkResult, samDesired, dwOptions, Reserved);
            }
            return (int)mh$.invokeExact(lpFile, phkResult, samDesired, dwOptions, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitiateSystemShutdownA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownA$descriptor() {
        return InitiateSystemShutdownA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MethodHandle InitiateSystemShutdownA$handle() {
        return InitiateSystemShutdownA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MemorySegment InitiateSystemShutdownA$address() {
        return InitiateSystemShutdownA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static int InitiateSystemShutdownA(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown) {
        var mh$ = InitiateSystemShutdownA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownA", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitiateSystemShutdownW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownW$descriptor() {
        return InitiateSystemShutdownW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MethodHandle InitiateSystemShutdownW$handle() {
        return InitiateSystemShutdownW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static MemorySegment InitiateSystemShutdownW$address() {
        return InitiateSystemShutdownW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown)
     * }
     */
    public static int InitiateSystemShutdownW(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown) {
        var mh$ = InitiateSystemShutdownW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownW", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortSystemShutdownA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AbortSystemShutdownA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static FunctionDescriptor AbortSystemShutdownA$descriptor() {
        return AbortSystemShutdownA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static MethodHandle AbortSystemShutdownA$handle() {
        return AbortSystemShutdownA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static MemorySegment AbortSystemShutdownA$address() {
        return AbortSystemShutdownA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownA(LPSTR lpMachineName)
     * }
     */
    public static int AbortSystemShutdownA(MemorySegment lpMachineName) {
        var mh$ = AbortSystemShutdownA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortSystemShutdownA", lpMachineName);
            }
            return (int)mh$.invokeExact(lpMachineName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortSystemShutdownW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AbortSystemShutdownW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static FunctionDescriptor AbortSystemShutdownW$descriptor() {
        return AbortSystemShutdownW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static MethodHandle AbortSystemShutdownW$handle() {
        return AbortSystemShutdownW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static MemorySegment AbortSystemShutdownW$address() {
        return AbortSystemShutdownW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AbortSystemShutdownW(LPWSTR lpMachineName)
     * }
     */
    public static int AbortSystemShutdownW(MemorySegment lpMachineName) {
        var mh$ = AbortSystemShutdownW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortSystemShutdownW", lpMachineName);
            }
            return (int)mh$.invokeExact(lpMachineName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitiateSystemShutdownExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownExA$descriptor() {
        return InitiateSystemShutdownExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateSystemShutdownExA$handle() {
        return InitiateSystemShutdownExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateSystemShutdownExA$address() {
        return InitiateSystemShutdownExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static int InitiateSystemShutdownExA(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown, int dwReason) {
        var mh$ = InitiateSystemShutdownExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownExA", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateSystemShutdownExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitiateSystemShutdownExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateSystemShutdownExW$descriptor() {
        return InitiateSystemShutdownExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateSystemShutdownExW$handle() {
        return InitiateSystemShutdownExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateSystemShutdownExW$address() {
        return InitiateSystemShutdownExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason)
     * }
     */
    public static int InitiateSystemShutdownExW(MemorySegment lpMachineName, MemorySegment lpMessage, int dwTimeout, int bForceAppsClosed, int bRebootAfterShutdown, int dwReason) {
        var mh$ = InitiateSystemShutdownExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateSystemShutdownExW", lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwTimeout, bForceAppsClosed, bRebootAfterShutdown, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateShutdownA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitiateShutdownA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateShutdownA$descriptor() {
        return InitiateShutdownA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateShutdownA$handle() {
        return InitiateShutdownA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateShutdownA$address() {
        return InitiateShutdownA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static int InitiateShutdownA(MemorySegment lpMachineName, MemorySegment lpMessage, int dwGracePeriod, int dwShutdownFlags, int dwReason) {
        var mh$ = InitiateShutdownA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateShutdownA", lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitiateShutdownW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitiateShutdownW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor InitiateShutdownW$descriptor() {
        return InitiateShutdownW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MethodHandle InitiateShutdownW$handle() {
        return InitiateShutdownW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static MemorySegment InitiateShutdownW$address() {
        return InitiateShutdownW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason)
     * }
     */
    public static int InitiateShutdownW(MemorySegment lpMachineName, MemorySegment lpMessage, int dwGracePeriod, int dwShutdownFlags, int dwReason) {
        var mh$ = InitiateShutdownW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitiateShutdownW", lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
            }
            return (int)mh$.invokeExact(lpMachineName, lpMessage, dwGracePeriod, dwShutdownFlags, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckForHiberboot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckForHiberboot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static FunctionDescriptor CheckForHiberboot$descriptor() {
        return CheckForHiberboot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static MethodHandle CheckForHiberboot$handle() {
        return CheckForHiberboot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static MemorySegment CheckForHiberboot$address() {
        return CheckForHiberboot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag)
     * }
     */
    public static int CheckForHiberboot(MemorySegment pHiberboot, byte bClearFlag) {
        var mh$ = CheckForHiberboot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckForHiberboot", pHiberboot, bClearFlag);
            }
            return (int)mh$.invokeExact(pHiberboot, bClearFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSaveKeyExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegSaveKeyExA$descriptor() {
        return RegSaveKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MethodHandle RegSaveKeyExA$handle() {
        return RegSaveKeyExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MemorySegment RegSaveKeyExA$address() {
        return RegSaveKeyExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static int RegSaveKeyExA(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes, int Flags) {
        var mh$ = RegSaveKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyExA", hKey, lpFile, lpSecurityAttributes, Flags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegSaveKeyExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegSaveKeyExW$descriptor() {
        return RegSaveKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MethodHandle RegSaveKeyExW$handle() {
        return RegSaveKeyExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static MemorySegment RegSaveKeyExW$address() {
        return RegSaveKeyExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
     * }
     */
    public static int RegSaveKeyExW(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes, int Flags) {
        var mh$ = RegSaveKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyExW", hKey, lpFile, lpSecurityAttributes, Flags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NETRESOURCEA {
     *     DWORD dwScope;
     *     DWORD dwType;
     *     DWORD dwDisplayType;
     *     DWORD dwUsage;
     *     LPSTR lpLocalName;
     *     LPSTR lpRemoteName;
     *     LPSTR lpComment;
     *     LPSTR lpProvider;
     * } *LPNETRESOURCEA
     * }
     */
    public static final AddressLayout LPNETRESOURCEA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NETRESOURCEW {
     *     DWORD dwScope;
     *     DWORD dwType;
     *     DWORD dwDisplayType;
     *     DWORD dwUsage;
     *     LPWSTR lpLocalName;
     *     LPWSTR lpRemoteName;
     *     LPWSTR lpComment;
     *     LPWSTR lpProvider;
     * } *LPNETRESOURCEW
     * }
     */
    public static final AddressLayout LPNETRESOURCEW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNETRESOURCEA LPNETRESOURCE
     * }
     */
    public static final AddressLayout LPNETRESOURCE = freeglut_h.C_POINTER;

    private static class WNetAddConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static FunctionDescriptor WNetAddConnectionA$descriptor() {
        return WNetAddConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static MethodHandle WNetAddConnectionA$handle() {
        return WNetAddConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static MemorySegment WNetAddConnectionA$address() {
        return WNetAddConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName)
     * }
     */
    public static int WNetAddConnectionA(MemorySegment lpRemoteName, MemorySegment lpPassword, MemorySegment lpLocalName) {
        var mh$ = WNetAddConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnectionA", lpRemoteName, lpPassword, lpLocalName);
            }
            return (int)mh$.invokeExact(lpRemoteName, lpPassword, lpLocalName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static FunctionDescriptor WNetAddConnectionW$descriptor() {
        return WNetAddConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static MethodHandle WNetAddConnectionW$handle() {
        return WNetAddConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static MemorySegment WNetAddConnectionW$address() {
        return WNetAddConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName)
     * }
     */
    public static int WNetAddConnectionW(MemorySegment lpRemoteName, MemorySegment lpPassword, MemorySegment lpLocalName) {
        var mh$ = WNetAddConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnectionW", lpRemoteName, lpPassword, lpLocalName);
            }
            return (int)mh$.invokeExact(lpRemoteName, lpPassword, lpLocalName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnection2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection2A$descriptor() {
        return WNetAddConnection2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection2A$handle() {
        return WNetAddConnection2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection2A$address() {
        return WNetAddConnection2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection2A(MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection2A", lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnection2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection2W$descriptor() {
        return WNetAddConnection2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection2W$handle() {
        return WNetAddConnection2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection2W$address() {
        return WNetAddConnection2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection2W(MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection2W", lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection3A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnection3A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection3A$descriptor() {
        return WNetAddConnection3A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection3A$handle() {
        return WNetAddConnection3A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection3A$address() {
        return WNetAddConnection3A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection3A(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection3A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection3A", hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection3W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnection3W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WNetAddConnection3W$descriptor() {
        return WNetAddConnection3W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MethodHandle WNetAddConnection3W$handle() {
        return WNetAddConnection3W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static MemorySegment WNetAddConnection3W$address() {
        return WNetAddConnection3W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags)
     * }
     */
    public static int WNetAddConnection3W(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserName, int dwFlags) {
        var mh$ = WNetAddConnection3W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection3W", hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection4A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnection4A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static FunctionDescriptor WNetAddConnection4A$descriptor() {
        return WNetAddConnection4A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MethodHandle WNetAddConnection4A$handle() {
        return WNetAddConnection4A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MemorySegment WNetAddConnection4A$address() {
        return WNetAddConnection4A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static int WNetAddConnection4A(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions) {
        var mh$ = WNetAddConnection4A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection4A", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetAddConnection4W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetAddConnection4W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static FunctionDescriptor WNetAddConnection4W$descriptor() {
        return WNetAddConnection4W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MethodHandle WNetAddConnection4W$handle() {
        return WNetAddConnection4W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static MemorySegment WNetAddConnection4W$address() {
        return WNetAddConnection4W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetAddConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions)
     * }
     */
    public static int WNetAddConnection4W(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions) {
        var mh$ = WNetAddConnection4W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetAddConnection4W", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetCancelConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnectionA$descriptor() {
        return WNetCancelConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnectionA$handle() {
        return WNetCancelConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnectionA$address() {
        return WNetCancelConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionA(LPCSTR lpName, BOOL fForce)
     * }
     */
    public static int WNetCancelConnectionA(MemorySegment lpName, int fForce) {
        var mh$ = WNetCancelConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnectionA", lpName, fForce);
            }
            return (int)mh$.invokeExact(lpName, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetCancelConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnectionW$descriptor() {
        return WNetCancelConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnectionW$handle() {
        return WNetCancelConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnectionW$address() {
        return WNetCancelConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce)
     * }
     */
    public static int WNetCancelConnectionW(MemorySegment lpName, int fForce) {
        var mh$ = WNetCancelConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnectionW", lpName, fForce);
            }
            return (int)mh$.invokeExact(lpName, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnection2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetCancelConnection2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnection2A$descriptor() {
        return WNetCancelConnection2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnection2A$handle() {
        return WNetCancelConnection2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnection2A$address() {
        return WNetCancelConnection2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static int WNetCancelConnection2A(MemorySegment lpName, int dwFlags, int fForce) {
        var mh$ = WNetCancelConnection2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnection2A", lpName, dwFlags, fForce);
            }
            return (int)mh$.invokeExact(lpName, dwFlags, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCancelConnection2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetCancelConnection2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static FunctionDescriptor WNetCancelConnection2W$descriptor() {
        return WNetCancelConnection2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MethodHandle WNetCancelConnection2W$handle() {
        return WNetCancelConnection2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static MemorySegment WNetCancelConnection2W$address() {
        return WNetCancelConnection2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce)
     * }
     */
    public static int WNetCancelConnection2W(MemorySegment lpName, int dwFlags, int fForce) {
        var mh$ = WNetCancelConnection2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCancelConnection2W", lpName, dwFlags, fForce);
            }
            return (int)mh$.invokeExact(lpName, dwFlags, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetConnectionA$descriptor() {
        return WNetGetConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetConnectionA$handle() {
        return WNetGetConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetConnectionA$address() {
        return WNetGetConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetConnectionA(MemorySegment lpLocalName, MemorySegment lpRemoteName, MemorySegment lpnLength) {
        var mh$ = WNetGetConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetConnectionA", lpLocalName, lpRemoteName, lpnLength);
            }
            return (int)mh$.invokeExact(lpLocalName, lpRemoteName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetConnectionW$descriptor() {
        return WNetGetConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetConnectionW$handle() {
        return WNetGetConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetConnectionW$address() {
        return WNetGetConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetConnectionW(MemorySegment lpLocalName, MemorySegment lpRemoteName, MemorySegment lpnLength) {
        var mh$ = WNetGetConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetConnectionW", lpLocalName, lpRemoteName, lpnLength);
            }
            return (int)mh$.invokeExact(lpLocalName, lpRemoteName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetRestoreSingleConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetRestoreSingleConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static FunctionDescriptor WNetRestoreSingleConnectionW$descriptor() {
        return WNetRestoreSingleConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static MethodHandle WNetRestoreSingleConnectionW$handle() {
        return WNetRestoreSingleConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static MemorySegment WNetRestoreSingleConnectionW$address() {
        return WNetRestoreSingleConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI)
     * }
     */
    public static int WNetRestoreSingleConnectionW(MemorySegment hwndParent, MemorySegment lpDevice, int fUseUI) {
        var mh$ = WNetRestoreSingleConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetRestoreSingleConnectionW", hwndParent, lpDevice, fUseUI);
            }
            return (int)mh$.invokeExact(hwndParent, lpDevice, fUseUI);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetUseConnectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnectionA$descriptor() {
        return WNetUseConnectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnectionA$handle() {
        return WNetUseConnectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnectionA$address() {
        return WNetUseConnectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnectionA(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserId, DWORD dwFlags, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnectionA(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserId, int dwFlags, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnectionA", hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetUseConnectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnectionW$descriptor() {
        return WNetUseConnectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnectionW$handle() {
        return WNetUseConnectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnectionW$address() {
        return WNetUseConnectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnectionW(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserId, DWORD dwFlags, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnectionW(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment lpPassword, MemorySegment lpUserId, int dwFlags, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnectionW", hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, lpPassword, lpUserId, dwFlags, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnection4A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetUseConnection4A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnection4A$descriptor() {
        return WNetUseConnection4A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnection4A$handle() {
        return WNetUseConnection4A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnection4A$address() {
        return WNetUseConnection4A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnection4A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnection4A(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnection4A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnection4A", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetUseConnection4W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetUseConnection4W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static FunctionDescriptor WNetUseConnection4W$descriptor() {
        return WNetUseConnection4W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MethodHandle WNetUseConnection4W$handle() {
        return WNetUseConnection4W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static MemorySegment WNetUseConnection4W$address() {
        return WNetUseConnection4W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetUseConnection4W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, PVOID pAuthBuffer, DWORD cbAuthBuffer, DWORD dwFlags, PBYTE lpUseOptions, DWORD cbUseOptions, LPWSTR lpAccessName, LPDWORD lpBufferSize, LPDWORD lpResult)
     * }
     */
    public static int WNetUseConnection4W(MemorySegment hwndOwner, MemorySegment lpNetResource, MemorySegment pAuthBuffer, int cbAuthBuffer, int dwFlags, MemorySegment lpUseOptions, int cbUseOptions, MemorySegment lpAccessName, MemorySegment lpBufferSize, MemorySegment lpResult) {
        var mh$ = WNetUseConnection4W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetUseConnection4W", hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
            }
            return (int)mh$.invokeExact(hwndOwner, lpNetResource, pAuthBuffer, cbAuthBuffer, dwFlags, lpUseOptions, cbUseOptions, lpAccessName, lpBufferSize, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetConnectionDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetConnectionDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static FunctionDescriptor WNetConnectionDialog$descriptor() {
        return WNetConnectionDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MethodHandle WNetConnectionDialog$handle() {
        return WNetConnectionDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MemorySegment WNetConnectionDialog$address() {
        return WNetConnectionDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static int WNetConnectionDialog(MemorySegment hwnd, int dwType) {
        var mh$ = WNetConnectionDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetConnectionDialog", hwnd, dwType);
            }
            return (int)mh$.invokeExact(hwnd, dwType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetDisconnectDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetDisconnectDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static FunctionDescriptor WNetDisconnectDialog$descriptor() {
        return WNetDisconnectDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MethodHandle WNetDisconnectDialog$handle() {
        return WNetDisconnectDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static MemorySegment WNetDisconnectDialog$address() {
        return WNetDisconnectDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog(HWND hwnd, DWORD dwType)
     * }
     */
    public static int WNetDisconnectDialog(MemorySegment hwnd, int dwType) {
        var mh$ = WNetDisconnectDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetDisconnectDialog", hwnd, dwType);
            }
            return (int)mh$.invokeExact(hwnd, dwType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONNECTDLGSTRUCTA {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPNETRESOURCEA lpConnRes;
     *     DWORD dwFlags;
     *     DWORD dwDevNum;
     * } *LPCONNECTDLGSTRUCTA
     * }
     */
    public static final AddressLayout LPCONNECTDLGSTRUCTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CONNECTDLGSTRUCTW {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPNETRESOURCEW lpConnRes;
     *     DWORD dwFlags;
     *     DWORD dwDevNum;
     * } *LPCONNECTDLGSTRUCTW
     * }
     */
    public static final AddressLayout LPCONNECTDLGSTRUCTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT
     * }
     */
    public static final AddressLayout LPCONNECTDLGSTRUCT = freeglut_h.C_POINTER;

    private static class WNetConnectionDialog1A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetConnectionDialog1A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetConnectionDialog1A$descriptor() {
        return WNetConnectionDialog1A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetConnectionDialog1A$handle() {
        return WNetConnectionDialog1A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetConnectionDialog1A$address() {
        return WNetConnectionDialog1A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static int WNetConnectionDialog1A(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetConnectionDialog1A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetConnectionDialog1A", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetConnectionDialog1W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetConnectionDialog1W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetConnectionDialog1W$descriptor() {
        return WNetConnectionDialog1W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetConnectionDialog1W$handle() {
        return WNetConnectionDialog1W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetConnectionDialog1W$address() {
        return WNetConnectionDialog1W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static int WNetConnectionDialog1W(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetConnectionDialog1W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetConnectionDialog1W", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DISCDLGSTRUCTA {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPSTR lpLocalName;
     *     LPSTR lpRemoteName;
     *     DWORD dwFlags;
     * } *LPDISCDLGSTRUCTA
     * }
     */
    public static final AddressLayout LPDISCDLGSTRUCTA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISCDLGSTRUCTW {
     *     DWORD cbStructure;
     *     HWND hwndOwner;
     *     LPWSTR lpLocalName;
     *     LPWSTR lpRemoteName;
     *     DWORD dwFlags;
     * } *LPDISCDLGSTRUCTW
     * }
     */
    public static final AddressLayout LPDISCDLGSTRUCTW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT
     * }
     */
    public static final AddressLayout LPDISCDLGSTRUCT = freeglut_h.C_POINTER;

    private static class WNetDisconnectDialog1A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetDisconnectDialog1A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetDisconnectDialog1A$descriptor() {
        return WNetDisconnectDialog1A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetDisconnectDialog1A$handle() {
        return WNetDisconnectDialog1A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetDisconnectDialog1A$address() {
        return WNetDisconnectDialog1A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct)
     * }
     */
    public static int WNetDisconnectDialog1A(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetDisconnectDialog1A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetDisconnectDialog1A", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetDisconnectDialog1W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetDisconnectDialog1W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static FunctionDescriptor WNetDisconnectDialog1W$descriptor() {
        return WNetDisconnectDialog1W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MethodHandle WNetDisconnectDialog1W$handle() {
        return WNetDisconnectDialog1W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static MemorySegment WNetDisconnectDialog1W$address() {
        return WNetDisconnectDialog1W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct)
     * }
     */
    public static int WNetDisconnectDialog1W(MemorySegment lpConnDlgStruct) {
        var mh$ = WNetDisconnectDialog1W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetDisconnectDialog1W", lpConnDlgStruct);
            }
            return (int)mh$.invokeExact(lpConnDlgStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetOpenEnumA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetOpenEnumA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static FunctionDescriptor WNetOpenEnumA$descriptor() {
        return WNetOpenEnumA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MethodHandle WNetOpenEnumA$handle() {
        return WNetOpenEnumA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MemorySegment WNetOpenEnumA$address() {
        return WNetOpenEnumA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static int WNetOpenEnumA(int dwScope, int dwType, int dwUsage, MemorySegment lpNetResource, MemorySegment lphEnum) {
        var mh$ = WNetOpenEnumA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetOpenEnumA", dwScope, dwType, dwUsage, lpNetResource, lphEnum);
            }
            return (int)mh$.invokeExact(dwScope, dwType, dwUsage, lpNetResource, lphEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetOpenEnumW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetOpenEnumW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static FunctionDescriptor WNetOpenEnumW$descriptor() {
        return WNetOpenEnumW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MethodHandle WNetOpenEnumW$handle() {
        return WNetOpenEnumW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static MemorySegment WNetOpenEnumW$address() {
        return WNetOpenEnumW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
     * }
     */
    public static int WNetOpenEnumW(int dwScope, int dwType, int dwUsage, MemorySegment lpNetResource, MemorySegment lphEnum) {
        var mh$ = WNetOpenEnumW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetOpenEnumW", dwScope, dwType, dwUsage, lpNetResource, lphEnum);
            }
            return (int)mh$.invokeExact(dwScope, dwType, dwUsage, lpNetResource, lphEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetEnumResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetEnumResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetEnumResourceA$descriptor() {
        return WNetEnumResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetEnumResourceA$handle() {
        return WNetEnumResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetEnumResourceA$address() {
        return WNetEnumResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetEnumResourceA(MemorySegment hEnum, MemorySegment lpcCount, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetEnumResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetEnumResourceA", hEnum, lpcCount, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(hEnum, lpcCount, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetEnumResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetEnumResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetEnumResourceW$descriptor() {
        return WNetEnumResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetEnumResourceW$handle() {
        return WNetEnumResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetEnumResourceW$address() {
        return WNetEnumResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetEnumResourceW(MemorySegment hEnum, MemorySegment lpcCount, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetEnumResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetEnumResourceW", hEnum, lpcCount, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(hEnum, lpcCount, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetCloseEnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetCloseEnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static FunctionDescriptor WNetCloseEnum$descriptor() {
        return WNetCloseEnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static MethodHandle WNetCloseEnum$handle() {
        return WNetCloseEnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static MemorySegment WNetCloseEnum$address() {
        return WNetCloseEnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetCloseEnum(HANDLE hEnum)
     * }
     */
    public static int WNetCloseEnum(MemorySegment hEnum) {
        var mh$ = WNetCloseEnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetCloseEnum", hEnum);
            }
            return (int)mh$.invokeExact(hEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceParentA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetResourceParentA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static FunctionDescriptor WNetGetResourceParentA$descriptor() {
        return WNetGetResourceParentA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MethodHandle WNetGetResourceParentA$handle() {
        return WNetGetResourceParentA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MemorySegment WNetGetResourceParentA$address() {
        return WNetGetResourceParentA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static int WNetGetResourceParentA(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer) {
        var mh$ = WNetGetResourceParentA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceParentA", lpNetResource, lpBuffer, lpcbBuffer);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceParentW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetResourceParentW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static FunctionDescriptor WNetGetResourceParentW$descriptor() {
        return WNetGetResourceParentW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MethodHandle WNetGetResourceParentW$handle() {
        return WNetGetResourceParentW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static MemorySegment WNetGetResourceParentW$address() {
        return WNetGetResourceParentW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer)
     * }
     */
    public static int WNetGetResourceParentW(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer) {
        var mh$ = WNetGetResourceParentW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceParentW", lpNetResource, lpBuffer, lpcbBuffer);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetResourceInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static FunctionDescriptor WNetGetResourceInformationA$descriptor() {
        return WNetGetResourceInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static MethodHandle WNetGetResourceInformationA$handle() {
        return WNetGetResourceInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static MemorySegment WNetGetResourceInformationA$address() {
        return WNetGetResourceInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR *lplpSystem)
     * }
     */
    public static int WNetGetResourceInformationA(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer, MemorySegment lplpSystem) {
        var mh$ = WNetGetResourceInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceInformationA", lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetResourceInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetResourceInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static FunctionDescriptor WNetGetResourceInformationW$descriptor() {
        return WNetGetResourceInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static MethodHandle WNetGetResourceInformationW$handle() {
        return WNetGetResourceInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static MemorySegment WNetGetResourceInformationW$address() {
        return WNetGetResourceInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR *lplpSystem)
     * }
     */
    public static int WNetGetResourceInformationW(MemorySegment lpNetResource, MemorySegment lpBuffer, MemorySegment lpcbBuffer, MemorySegment lplpSystem) {
        var mh$ = WNetGetResourceInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetResourceInformationW", lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
            }
            return (int)mh$.invokeExact(lpNetResource, lpBuffer, lpcbBuffer, lplpSystem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _UNIVERSAL_NAME_INFOA {
     *     LPSTR lpUniversalName;
     * } *LPUNIVERSAL_NAME_INFOA
     * }
     */
    public static final AddressLayout LPUNIVERSAL_NAME_INFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNIVERSAL_NAME_INFOW {
     *     LPWSTR lpUniversalName;
     * } *LPUNIVERSAL_NAME_INFOW
     * }
     */
    public static final AddressLayout LPUNIVERSAL_NAME_INFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO
     * }
     */
    public static final AddressLayout LPUNIVERSAL_NAME_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REMOTE_NAME_INFOA {
     *     LPSTR lpUniversalName;
     *     LPSTR lpConnectionName;
     *     LPSTR lpRemainingPath;
     * } *LPREMOTE_NAME_INFOA
     * }
     */
    public static final AddressLayout LPREMOTE_NAME_INFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REMOTE_NAME_INFOW {
     *     LPWSTR lpUniversalName;
     *     LPWSTR lpConnectionName;
     *     LPWSTR lpRemainingPath;
     * } *LPREMOTE_NAME_INFOW
     * }
     */
    public static final AddressLayout LPREMOTE_NAME_INFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO
     * }
     */
    public static final AddressLayout LPREMOTE_NAME_INFO = freeglut_h.C_POINTER;

    private static class WNetGetUniversalNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetUniversalNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetUniversalNameA$descriptor() {
        return WNetGetUniversalNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetUniversalNameA$handle() {
        return WNetGetUniversalNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetUniversalNameA$address() {
        return WNetGetUniversalNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetUniversalNameA(MemorySegment lpLocalPath, int dwInfoLevel, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetGetUniversalNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUniversalNameA", lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetUniversalNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetUniversalNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetUniversalNameW$descriptor() {
        return WNetGetUniversalNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetUniversalNameW$handle() {
        return WNetGetUniversalNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetUniversalNameW$address() {
        return WNetGetUniversalNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetUniversalNameW(MemorySegment lpLocalPath, int dwInfoLevel, MemorySegment lpBuffer, MemorySegment lpBufferSize) {
        var mh$ = WNetGetUniversalNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUniversalNameW", lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
            }
            return (int)mh$.invokeExact(lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetUserA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetUserA$descriptor() {
        return WNetGetUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetUserA$handle() {
        return WNetGetUserA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetUserA$address() {
        return WNetGetUserA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetUserA(MemorySegment lpName, MemorySegment lpUserName, MemorySegment lpnLength) {
        var mh$ = WNetGetUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUserA", lpName, lpUserName, lpnLength);
            }
            return (int)mh$.invokeExact(lpName, lpUserName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetUserW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static FunctionDescriptor WNetGetUserW$descriptor() {
        return WNetGetUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MethodHandle WNetGetUserW$handle() {
        return WNetGetUserW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static MemorySegment WNetGetUserW$address() {
        return WNetGetUserW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
     * }
     */
    public static int WNetGetUserW(MemorySegment lpName, MemorySegment lpUserName, MemorySegment lpnLength) {
        var mh$ = WNetGetUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetUserW", lpName, lpUserName, lpnLength);
            }
            return (int)mh$.invokeExact(lpName, lpUserName, lpnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetProviderNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetProviderNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetProviderNameA$descriptor() {
        return WNetGetProviderNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetProviderNameA$handle() {
        return WNetGetProviderNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetProviderNameA$address() {
        return WNetGetProviderNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetProviderNameA(int dwNetType, MemorySegment lpProviderName, MemorySegment lpBufferSize) {
        var mh$ = WNetGetProviderNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetProviderNameA", dwNetType, lpProviderName, lpBufferSize);
            }
            return (int)mh$.invokeExact(dwNetType, lpProviderName, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetProviderNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetProviderNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static FunctionDescriptor WNetGetProviderNameW$descriptor() {
        return WNetGetProviderNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MethodHandle WNetGetProviderNameW$handle() {
        return WNetGetProviderNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static MemorySegment WNetGetProviderNameW$address() {
        return WNetGetProviderNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize)
     * }
     */
    public static int WNetGetProviderNameW(int dwNetType, MemorySegment lpProviderName, MemorySegment lpBufferSize) {
        var mh$ = WNetGetProviderNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetProviderNameW", dwNetType, lpProviderName, lpBufferSize);
            }
            return (int)mh$.invokeExact(dwNetType, lpProviderName, lpBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NETINFOSTRUCT {
     *     DWORD cbStructure;
     *     DWORD dwProviderVersion;
     *     DWORD dwStatus;
     *     DWORD dwCharacteristics;
     *     ULONG_PTR dwHandle;
     *     WORD wNetType;
     *     DWORD dwPrinters;
     *     DWORD dwDrives;
     * } *LPNETINFOSTRUCT
     * }
     */
    public static final AddressLayout LPNETINFOSTRUCT = freeglut_h.C_POINTER;

    private static class WNetGetNetworkInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetNetworkInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static FunctionDescriptor WNetGetNetworkInformationA$descriptor() {
        return WNetGetNetworkInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MethodHandle WNetGetNetworkInformationA$handle() {
        return WNetGetNetworkInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MemorySegment WNetGetNetworkInformationA$address() {
        return WNetGetNetworkInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static int WNetGetNetworkInformationA(MemorySegment lpProvider, MemorySegment lpNetInfoStruct) {
        var mh$ = WNetGetNetworkInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetNetworkInformationA", lpProvider, lpNetInfoStruct);
            }
            return (int)mh$.invokeExact(lpProvider, lpNetInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetNetworkInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetNetworkInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static FunctionDescriptor WNetGetNetworkInformationW$descriptor() {
        return WNetGetNetworkInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MethodHandle WNetGetNetworkInformationW$handle() {
        return WNetGetNetworkInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static MemorySegment WNetGetNetworkInformationW$address() {
        return WNetGetNetworkInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct)
     * }
     */
    public static int WNetGetNetworkInformationW(MemorySegment lpProvider, MemorySegment lpNetInfoStruct) {
        var mh$ = WNetGetNetworkInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetNetworkInformationW", lpProvider, lpNetInfoStruct);
            }
            return (int)mh$.invokeExact(lpProvider, lpNetInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetLastErrorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetLastErrorA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static FunctionDescriptor WNetGetLastErrorA$descriptor() {
        return WNetGetLastErrorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MethodHandle WNetGetLastErrorA$handle() {
        return WNetGetLastErrorA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MemorySegment WNetGetLastErrorA$address() {
        return WNetGetLastErrorA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static int WNetGetLastErrorA(MemorySegment lpError, MemorySegment lpErrorBuf, int nErrorBufSize, MemorySegment lpNameBuf, int nNameBufSize) {
        var mh$ = WNetGetLastErrorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetLastErrorA", lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
            }
            return (int)mh$.invokeExact(lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WNetGetLastErrorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WNetGetLastErrorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static FunctionDescriptor WNetGetLastErrorW$descriptor() {
        return WNetGetLastErrorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MethodHandle WNetGetLastErrorW$handle() {
        return WNetGetLastErrorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static MemorySegment WNetGetLastErrorW$address() {
        return WNetGetLastErrorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize)
     * }
     */
    public static int WNetGetLastErrorW(MemorySegment lpError, MemorySegment lpErrorBuf, int nErrorBufSize, MemorySegment lpNameBuf, int nNameBufSize) {
        var mh$ = WNetGetLastErrorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WNetGetLastErrorW", lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
            }
            return (int)mh$.invokeExact(lpError, lpErrorBuf, nErrorBufSize, lpNameBuf, nNameBufSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NETCONNECTINFOSTRUCT {
     *     DWORD cbStructure;
     *     DWORD dwFlags;
     *     DWORD dwSpeed;
     *     DWORD dwDelay;
     *     DWORD dwOptDataSize;
     * } *LPNETCONNECTINFOSTRUCT
     * }
     */
    public static final AddressLayout LPNETCONNECTINFOSTRUCT = freeglut_h.C_POINTER;

    private static class MultinetGetConnectionPerformanceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MultinetGetConnectionPerformanceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static FunctionDescriptor MultinetGetConnectionPerformanceA$descriptor() {
        return MultinetGetConnectionPerformanceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MethodHandle MultinetGetConnectionPerformanceA$handle() {
        return MultinetGetConnectionPerformanceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MemorySegment MultinetGetConnectionPerformanceA$address() {
        return MultinetGetConnectionPerformanceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static int MultinetGetConnectionPerformanceA(MemorySegment lpNetResource, MemorySegment lpNetConnectInfoStruct) {
        var mh$ = MultinetGetConnectionPerformanceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultinetGetConnectionPerformanceA", lpNetResource, lpNetConnectInfoStruct);
            }
            return (int)mh$.invokeExact(lpNetResource, lpNetConnectInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MultinetGetConnectionPerformanceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MultinetGetConnectionPerformanceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static FunctionDescriptor MultinetGetConnectionPerformanceW$descriptor() {
        return MultinetGetConnectionPerformanceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MethodHandle MultinetGetConnectionPerformanceW$handle() {
        return MultinetGetConnectionPerformanceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static MemorySegment MultinetGetConnectionPerformanceW$address() {
        return MultinetGetConnectionPerformanceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct)
     * }
     */
    public static int MultinetGetConnectionPerformanceW(MemorySegment lpNetResource, MemorySegment lpNetConnectInfoStruct) {
        var mh$ = MultinetGetConnectionPerformanceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultinetGetConnectionPerformanceW", lpNetResource, lpNetConnectInfoStruct);
            }
            return (int)mh$.invokeExact(lpNetResource, lpNetConnectInfoStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_CharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_CharUpperW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static FunctionDescriptor uaw_CharUpperW$descriptor() {
        return uaw_CharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static MethodHandle uaw_CharUpperW$handle() {
        return uaw_CharUpperW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static MemorySegment uaw_CharUpperW$address() {
        return uaw_CharUpperW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPUWSTR uaw_CharUpperW(LPUWSTR String)
     * }
     */
    public static MemorySegment uaw_CharUpperW(MemorySegment String_) {
        var mh$ = uaw_CharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_CharUpperW", String_);
            }
            return (MemorySegment)mh$.invokeExact(String_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_lstrcmpW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_lstrcmpW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static FunctionDescriptor uaw_lstrcmpW$descriptor() {
        return uaw_lstrcmpW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MethodHandle uaw_lstrcmpW$handle() {
        return uaw_lstrcmpW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MemorySegment uaw_lstrcmpW$address() {
        return uaw_lstrcmpW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static int uaw_lstrcmpW(MemorySegment String1, MemorySegment String2) {
        var mh$ = uaw_lstrcmpW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_lstrcmpW", String1, String2);
            }
            return (int)mh$.invokeExact(String1, String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_lstrcmpiW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_lstrcmpiW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static FunctionDescriptor uaw_lstrcmpiW$descriptor() {
        return uaw_lstrcmpiW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MethodHandle uaw_lstrcmpiW$handle() {
        return uaw_lstrcmpiW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MemorySegment uaw_lstrcmpiW$address() {
        return uaw_lstrcmpiW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static int uaw_lstrcmpiW(MemorySegment String1, MemorySegment String2) {
        var mh$ = uaw_lstrcmpiW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_lstrcmpiW", String1, String2);
            }
            return (int)mh$.invokeExact(String1, String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_lstrlenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_lstrlenW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static FunctionDescriptor uaw_lstrlenW$descriptor() {
        return uaw_lstrlenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static MethodHandle uaw_lstrlenW$handle() {
        return uaw_lstrlenW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static MemorySegment uaw_lstrlenW$address() {
        return uaw_lstrlenW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_lstrlenW(LPCUWSTR String)
     * }
     */
    public static int uaw_lstrlenW(MemorySegment String_) {
        var mh$ = uaw_lstrlenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_lstrlenW", String_);
            }
            return (int)mh$.invokeExact(String_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static FunctionDescriptor uaw_wcschr$descriptor() {
        return uaw_wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MethodHandle uaw_wcschr$handle() {
        return uaw_wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcschr$address() {
        return uaw_wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUWSTR uaw_wcschr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcschr(MemorySegment String_, short Character) {
        var mh$ = uaw_wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcschr", String_, Character);
            }
            return (MemorySegment)mh$.invokeExact(String_, Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static FunctionDescriptor uaw_wcscpy$descriptor() {
        return uaw_wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static MethodHandle uaw_wcscpy$handle() {
        return uaw_wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static MemorySegment uaw_wcscpy$address() {
        return uaw_wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUWSTR uaw_wcscpy(PUWSTR Destination, PCUWSTR Source)
     * }
     */
    public static MemorySegment uaw_wcscpy(MemorySegment Destination, MemorySegment Source) {
        var mh$ = uaw_wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcscpy", Destination, Source);
            }
            return (MemorySegment)mh$.invokeExact(Destination, Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static FunctionDescriptor uaw_wcsicmp$descriptor() {
        return uaw_wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MethodHandle uaw_wcsicmp$handle() {
        return uaw_wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static MemorySegment uaw_wcsicmp$address() {
        return uaw_wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2)
     * }
     */
    public static int uaw_wcsicmp(MemorySegment String1, MemorySegment String2) {
        var mh$ = uaw_wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcsicmp", String1, String2);
            }
            return (int)mh$.invokeExact(String1, String2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static FunctionDescriptor uaw_wcslen$descriptor() {
        return uaw_wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static MethodHandle uaw_wcslen$handle() {
        return uaw_wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static MemorySegment uaw_wcslen$address() {
        return uaw_wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t uaw_wcslen(PCUWSTR String)
     * }
     */
    public static long uaw_wcslen(MemorySegment String_) {
        var mh$ = uaw_wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcslen", String_);
            }
            return (long)mh$.invokeExact(String_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uaw_wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("uaw_wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static FunctionDescriptor uaw_wcsrchr$descriptor() {
        return uaw_wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MethodHandle uaw_wcsrchr$handle() {
        return uaw_wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcsrchr$address() {
        return uaw_wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUWSTR uaw_wcsrchr(PCUWSTR String, WCHAR Character)
     * }
     */
    public static MemorySegment uaw_wcsrchr(MemorySegment String_, short Character) {
        var mh$ = uaw_wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uaw_wcsrchr", String_, Character);
            }
            return (MemorySegment)mh$.invokeExact(String_, Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __unaligned WCHAR *PUWSTR_C
     * }
     */
    public static final AddressLayout PUWSTR_C = freeglut_h.C_POINTER;

    private static class NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID
     * }
     */
    public static GroupLayout NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$layout() {
        return NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID
     * }
     */
    public static MemorySegment NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID() {
        return NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID
     * }
     */
    public static void NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.SEGMENT, 0L, NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID$constants.LAYOUT.byteSize());
    }

    private static class NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
     * }
     */
    public static GroupLayout NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$layout() {
        return NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
     * }
     */
    public static MemorySegment NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID() {
        return NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
     * }
     */
    public static void NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.SEGMENT, 0L, NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID$constants.LAYOUT.byteSize());
    }

    private static class DOMAIN_JOIN_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("DOMAIN_JOIN_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_JOIN_GUID
     * }
     */
    public static GroupLayout DOMAIN_JOIN_GUID$layout() {
        return DOMAIN_JOIN_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_JOIN_GUID
     * }
     */
    public static MemorySegment DOMAIN_JOIN_GUID() {
        return DOMAIN_JOIN_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_JOIN_GUID
     * }
     */
    public static void DOMAIN_JOIN_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, DOMAIN_JOIN_GUID$constants.SEGMENT, 0L, DOMAIN_JOIN_GUID$constants.LAYOUT.byteSize());
    }

    private static class DOMAIN_LEAVE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("DOMAIN_LEAVE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_LEAVE_GUID
     * }
     */
    public static GroupLayout DOMAIN_LEAVE_GUID$layout() {
        return DOMAIN_LEAVE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_LEAVE_GUID
     * }
     */
    public static MemorySegment DOMAIN_LEAVE_GUID() {
        return DOMAIN_LEAVE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID DOMAIN_LEAVE_GUID
     * }
     */
    public static void DOMAIN_LEAVE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, DOMAIN_LEAVE_GUID$constants.SEGMENT, 0L, DOMAIN_LEAVE_GUID$constants.LAYOUT.byteSize());
    }

    private static class FIREWALL_PORT_OPEN_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("FIREWALL_PORT_OPEN_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_OPEN_GUID
     * }
     */
    public static GroupLayout FIREWALL_PORT_OPEN_GUID$layout() {
        return FIREWALL_PORT_OPEN_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_OPEN_GUID
     * }
     */
    public static MemorySegment FIREWALL_PORT_OPEN_GUID() {
        return FIREWALL_PORT_OPEN_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_OPEN_GUID
     * }
     */
    public static void FIREWALL_PORT_OPEN_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, FIREWALL_PORT_OPEN_GUID$constants.SEGMENT, 0L, FIREWALL_PORT_OPEN_GUID$constants.LAYOUT.byteSize());
    }

    private static class FIREWALL_PORT_CLOSE_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("FIREWALL_PORT_CLOSE_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_CLOSE_GUID
     * }
     */
    public static GroupLayout FIREWALL_PORT_CLOSE_GUID$layout() {
        return FIREWALL_PORT_CLOSE_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_CLOSE_GUID
     * }
     */
    public static MemorySegment FIREWALL_PORT_CLOSE_GUID() {
        return FIREWALL_PORT_CLOSE_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID FIREWALL_PORT_CLOSE_GUID
     * }
     */
    public static void FIREWALL_PORT_CLOSE_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, FIREWALL_PORT_CLOSE_GUID$constants.SEGMENT, 0L, FIREWALL_PORT_CLOSE_GUID$constants.LAYOUT.byteSize());
    }

    private static class MACHINE_POLICY_PRESENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("MACHINE_POLICY_PRESENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID MACHINE_POLICY_PRESENT_GUID
     * }
     */
    public static GroupLayout MACHINE_POLICY_PRESENT_GUID$layout() {
        return MACHINE_POLICY_PRESENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID MACHINE_POLICY_PRESENT_GUID
     * }
     */
    public static MemorySegment MACHINE_POLICY_PRESENT_GUID() {
        return MACHINE_POLICY_PRESENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID MACHINE_POLICY_PRESENT_GUID
     * }
     */
    public static void MACHINE_POLICY_PRESENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, MACHINE_POLICY_PRESENT_GUID$constants.SEGMENT, 0L, MACHINE_POLICY_PRESENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class USER_POLICY_PRESENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("USER_POLICY_PRESENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID USER_POLICY_PRESENT_GUID
     * }
     */
    public static GroupLayout USER_POLICY_PRESENT_GUID$layout() {
        return USER_POLICY_PRESENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID USER_POLICY_PRESENT_GUID
     * }
     */
    public static MemorySegment USER_POLICY_PRESENT_GUID() {
        return USER_POLICY_PRESENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID USER_POLICY_PRESENT_GUID
     * }
     */
    public static void USER_POLICY_PRESENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, USER_POLICY_PRESENT_GUID$constants.SEGMENT, 0L, USER_POLICY_PRESENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class RPC_INTERFACE_EVENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("RPC_INTERFACE_EVENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID RPC_INTERFACE_EVENT_GUID
     * }
     */
    public static GroupLayout RPC_INTERFACE_EVENT_GUID$layout() {
        return RPC_INTERFACE_EVENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID RPC_INTERFACE_EVENT_GUID
     * }
     */
    public static MemorySegment RPC_INTERFACE_EVENT_GUID() {
        return RPC_INTERFACE_EVENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID RPC_INTERFACE_EVENT_GUID
     * }
     */
    public static void RPC_INTERFACE_EVENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, RPC_INTERFACE_EVENT_GUID$constants.SEGMENT, 0L, RPC_INTERFACE_EVENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class NAMED_PIPE_EVENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("NAMED_PIPE_EVENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID NAMED_PIPE_EVENT_GUID
     * }
     */
    public static GroupLayout NAMED_PIPE_EVENT_GUID$layout() {
        return NAMED_PIPE_EVENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID NAMED_PIPE_EVENT_GUID
     * }
     */
    public static MemorySegment NAMED_PIPE_EVENT_GUID() {
        return NAMED_PIPE_EVENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID NAMED_PIPE_EVENT_GUID
     * }
     */
    public static void NAMED_PIPE_EVENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, NAMED_PIPE_EVENT_GUID$constants.SEGMENT, 0L, NAMED_PIPE_EVENT_GUID$constants.LAYOUT.byteSize());
    }

    private static class CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants {
        public static final GroupLayout LAYOUT = _GUID.layout();
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID
     * }
     */
    public static GroupLayout CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$layout() {
        return CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID
     * }
     */
    public static MemorySegment CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID() {
        return CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID
     * }
     */
    public static void CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.SEGMENT, 0L, CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
     *     union {
     *         SERVICE_TRIGGER_CUSTOM_STATE_ID CustomStateId;
     *         struct {
     *             DWORD DataOffset;
     *             BYTE Data[1];
     *         } s;
     *     } u;
     * } *LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM
     * }
     */
    public static final AddressLayout LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_DESCRIPTIONA {
     *     LPSTR lpDescription;
     * } *LPSERVICE_DESCRIPTIONA
     * }
     */
    public static final AddressLayout LPSERVICE_DESCRIPTIONA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_DESCRIPTIONW {
     *     LPWSTR lpDescription;
     * } *LPSERVICE_DESCRIPTIONW
     * }
     */
    public static final AddressLayout LPSERVICE_DESCRIPTIONW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION
     * }
     */
    public static final AddressLayout LPSERVICE_DESCRIPTION = freeglut_h.C_POINTER;
    private static final int SC_ACTION_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_NONE = 0
     * }
     */
    public static int SC_ACTION_NONE() {
        return SC_ACTION_NONE;
    }
    private static final int SC_ACTION_RESTART = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_RESTART = 1
     * }
     */
    public static int SC_ACTION_RESTART() {
        return SC_ACTION_RESTART;
    }
    private static final int SC_ACTION_REBOOT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_REBOOT = 2
     * }
     */
    public static int SC_ACTION_REBOOT() {
        return SC_ACTION_REBOOT;
    }
    private static final int SC_ACTION_RUN_COMMAND = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_RUN_COMMAND = 3
     * }
     */
    public static int SC_ACTION_RUN_COMMAND() {
        return SC_ACTION_RUN_COMMAND;
    }
    private static final int SC_ACTION_OWN_RESTART = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _SC_ACTION_TYPE.SC_ACTION_OWN_RESTART = 4
     * }
     */
    public static int SC_ACTION_OWN_RESTART() {
        return SC_ACTION_OWN_RESTART;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SC_ACTION {
     *     SC_ACTION_TYPE Type;
     *     DWORD Delay;
     * } *LPSC_ACTION
     * }
     */
    public static final AddressLayout LPSC_ACTION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_FAILURE_ACTIONSA {
     *     DWORD dwResetPeriod;
     *     LPSTR lpRebootMsg;
     *     LPSTR lpCommand;
     *     DWORD cActions;
     *     SC_ACTION *lpsaActions;
     * } *LPSERVICE_FAILURE_ACTIONSA
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_FAILURE_ACTIONSW {
     *     DWORD dwResetPeriod;
     *     LPWSTR lpRebootMsg;
     *     LPWSTR lpCommand;
     *     DWORD cActions;
     *     SC_ACTION *lpsaActions;
     * } *LPSERVICE_FAILURE_ACTIONSW
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
     *     BOOL fDelayedAutostart;
     * } *LPSERVICE_DELAYED_AUTO_START_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_DELAYED_AUTO_START_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
     *     BOOL fFailureActionsOnNonCrashFailures;
     * } *LPSERVICE_FAILURE_ACTIONS_FLAG
     * }
     */
    public static final AddressLayout LPSERVICE_FAILURE_ACTIONS_FLAG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_SID_INFO {
     *     DWORD dwServiceSidType;
     * } *LPSERVICE_SID_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_SID_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
     *     LPSTR pmszRequiredPrivileges;
     * } *LPSERVICE_REQUIRED_PRIVILEGES_INFOA
     * }
     */
    public static final AddressLayout LPSERVICE_REQUIRED_PRIVILEGES_INFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
     *     LPWSTR pmszRequiredPrivileges;
     * } *LPSERVICE_REQUIRED_PRIVILEGES_INFOW
     * }
     */
    public static final AddressLayout LPSERVICE_REQUIRED_PRIVILEGES_INFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_REQUIRED_PRIVILEGES_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_PRESHUTDOWN_INFO {
     *     DWORD dwPreshutdownTimeout;
     * } *LPSERVICE_PRESHUTDOWN_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_PRESHUTDOWN_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
     *     DWORD dwDataType;
     *     DWORD cbData;
     *     PBYTE pData;
     * } *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM
     * }
     */
    public static final AddressLayout PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TRIGGER {
     *     DWORD dwTriggerType;
     *     DWORD dwAction;
     *     GUID *pTriggerSubtype;
     *     DWORD cDataItems;
     *     PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM pDataItems;
     * } *PSERVICE_TRIGGER
     * }
     */
    public static final AddressLayout PSERVICE_TRIGGER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TRIGGER_INFO {
     *     DWORD cTriggers;
     *     PSERVICE_TRIGGER pTriggers;
     *     PBYTE pReserved;
     * } *PSERVICE_TRIGGER_INFO
     * }
     */
    public static final AddressLayout PSERVICE_TRIGGER_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_PREFERRED_NODE_INFO {
     *     USHORT usPreferredNode;
     *     BOOLEAN fDelete;
     * } *LPSERVICE_PREFERRED_NODE_INFO
     * }
     */
    public static final AddressLayout LPSERVICE_PREFERRED_NODE_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TIMECHANGE_INFO {
     *     LARGE_INTEGER liNewTime;
     *     LARGE_INTEGER liOldTime;
     * } *PSERVICE_TIMECHANGE_INFO
     * }
     */
    public static final AddressLayout PSERVICE_TIMECHANGE_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_LAUNCH_PROTECTED_INFO {
     *     DWORD dwLaunchProtected;
     * } *PSERVICE_LAUNCH_PROTECTED_INFO
     * }
     */
    public static final AddressLayout PSERVICE_LAUNCH_PROTECTED_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct SC_HANDLE__ {
     *     int unused;
     * } *SC_HANDLE
     * }
     */
    public static final AddressLayout SC_HANDLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SC_HANDLE *LPSC_HANDLE
     * }
     */
    public static final AddressLayout LPSC_HANDLE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct SERVICE_STATUS_HANDLE__ {
     *     int unused;
     * } *SERVICE_STATUS_HANDLE
     * }
     */
    public static final AddressLayout SERVICE_STATUS_HANDLE = freeglut_h.C_POINTER;
    private static final int SC_STATUS_PROCESS_INFO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_STATUS_TYPE.SC_STATUS_PROCESS_INFO = 0
     * }
     */
    public static int SC_STATUS_PROCESS_INFO() {
        return SC_STATUS_PROCESS_INFO;
    }
    private static final int SC_ENUM_PROCESS_INFO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_ENUM_TYPE.SC_ENUM_PROCESS_INFO = 0
     * }
     */
    public static int SC_ENUM_PROCESS_INFO() {
        return SC_ENUM_PROCESS_INFO;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_STATUS {
     *     DWORD dwServiceType;
     *     DWORD dwCurrentState;
     *     DWORD dwControlsAccepted;
     *     DWORD dwWin32ExitCode;
     *     DWORD dwServiceSpecificExitCode;
     *     DWORD dwCheckPoint;
     *     DWORD dwWaitHint;
     * } *LPSERVICE_STATUS
     * }
     */
    public static final AddressLayout LPSERVICE_STATUS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_STATUS_PROCESS {
     *     DWORD dwServiceType;
     *     DWORD dwCurrentState;
     *     DWORD dwControlsAccepted;
     *     DWORD dwWin32ExitCode;
     *     DWORD dwServiceSpecificExitCode;
     *     DWORD dwCheckPoint;
     *     DWORD dwWaitHint;
     *     DWORD dwProcessId;
     *     DWORD dwServiceFlags;
     * } *LPSERVICE_STATUS_PROCESS
     * }
     */
    public static final AddressLayout LPSERVICE_STATUS_PROCESS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUSA {
     *     LPSTR lpServiceName;
     *     LPSTR lpDisplayName;
     *     SERVICE_STATUS ServiceStatus;
     * } *LPENUM_SERVICE_STATUSA
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUSW {
     *     LPWSTR lpServiceName;
     *     LPWSTR lpDisplayName;
     *     SERVICE_STATUS ServiceStatus;
     * } *LPENUM_SERVICE_STATUSW
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
     *     LPSTR lpServiceName;
     *     LPSTR lpDisplayName;
     *     SERVICE_STATUS_PROCESS ServiceStatusProcess;
     * } *LPENUM_SERVICE_STATUS_PROCESSA
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS_PROCESSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
     *     LPWSTR lpServiceName;
     *     LPWSTR lpDisplayName;
     *     SERVICE_STATUS_PROCESS ServiceStatusProcess;
     * } *LPENUM_SERVICE_STATUS_PROCESSW
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS_PROCESSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS
     * }
     */
    public static final AddressLayout LPENUM_SERVICE_STATUS_PROCESS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPVOID SC_LOCK
     * }
     */
    public static final AddressLayout SC_LOCK = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_LOCK_STATUSA {
     *     DWORD fIsLocked;
     *     LPSTR lpLockOwner;
     *     DWORD dwLockDuration;
     * } *LPQUERY_SERVICE_LOCK_STATUSA
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_LOCK_STATUSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_LOCK_STATUSW {
     *     DWORD fIsLocked;
     *     LPWSTR lpLockOwner;
     *     DWORD dwLockDuration;
     * } *LPQUERY_SERVICE_LOCK_STATUSW
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_LOCK_STATUSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_LOCK_STATUS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_CONFIGA {
     *     DWORD dwServiceType;
     *     DWORD dwStartType;
     *     DWORD dwErrorControl;
     *     LPSTR lpBinaryPathName;
     *     LPSTR lpLoadOrderGroup;
     *     DWORD dwTagId;
     *     LPSTR lpDependencies;
     *     LPSTR lpServiceStartName;
     *     LPSTR lpDisplayName;
     * } *LPQUERY_SERVICE_CONFIGA
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_CONFIGA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _QUERY_SERVICE_CONFIGW {
     *     DWORD dwServiceType;
     *     DWORD dwStartType;
     *     DWORD dwErrorControl;
     *     LPWSTR lpBinaryPathName;
     *     LPWSTR lpLoadOrderGroup;
     *     DWORD dwTagId;
     *     LPWSTR lpDependencies;
     *     LPWSTR lpServiceStartName;
     *     LPWSTR lpDisplayName;
     * } *LPQUERY_SERVICE_CONFIGW
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_CONFIGW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG
     * }
     */
    public static final AddressLayout LPQUERY_SERVICE_CONFIG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TABLE_ENTRYA {
     *     LPSTR lpServiceName;
     *     LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
     * } *LPSERVICE_TABLE_ENTRYA
     * }
     */
    public static final AddressLayout LPSERVICE_TABLE_ENTRYA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_TABLE_ENTRYW {
     *     LPWSTR lpServiceName;
     *     LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
     * } *LPSERVICE_TABLE_ENTRYW
     * }
     */
    public static final AddressLayout LPSERVICE_TABLE_ENTRYW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY
     * }
     */
    public static final AddressLayout LPSERVICE_TABLE_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_NOTIFY_1 {
     *     DWORD dwVersion;
     *     PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
     *     PVOID pContext;
     *     DWORD dwNotificationStatus;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     * } *PSERVICE_NOTIFY_1
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_1 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_NOTIFY_2A {
     *     DWORD dwVersion;
     *     PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
     *     PVOID pContext;
     *     DWORD dwNotificationStatus;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     *     DWORD dwNotificationTriggered;
     *     LPSTR pszServiceNames;
     * } *PSERVICE_NOTIFY_2A
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_2A = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_NOTIFY_2W {
     *     DWORD dwVersion;
     *     PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
     *     PVOID pContext;
     *     DWORD dwNotificationStatus;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     *     DWORD dwNotificationTriggered;
     *     LPWSTR pszServiceNames;
     * } *PSERVICE_NOTIFY_2W
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_2W = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY_2 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SERVICE_NOTIFY_2A *PSERVICE_NOTIFYA
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFYA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SERVICE_NOTIFY_2W *PSERVICE_NOTIFYW
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFYW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY
     * }
     */
    public static final AddressLayout PSERVICE_NOTIFY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
     *     DWORD dwReason;
     *     LPSTR pszComment;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     * } *PSERVICE_CONTROL_STATUS_REASON_PARAMSA
     * }
     */
    public static final AddressLayout PSERVICE_CONTROL_STATUS_REASON_PARAMSA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
     *     DWORD dwReason;
     *     LPWSTR pszComment;
     *     SERVICE_STATUS_PROCESS ServiceStatus;
     * } *PSERVICE_CONTROL_STATUS_REASON_PARAMSW
     * }
     */
    public static final AddressLayout PSERVICE_CONTROL_STATUS_REASON_PARAMSW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS
     * }
     */
    public static final AddressLayout PSERVICE_CONTROL_STATUS_REASON_PARAMS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SERVICE_START_REASON {
     *     DWORD dwReason;
     * } *PSERVICE_START_REASON
     * }
     */
    public static final AddressLayout PSERVICE_START_REASON = freeglut_h.C_POINTER;

    private static class ChangeServiceConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeServiceConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfigA$descriptor() {
        return ChangeServiceConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static MethodHandle ChangeServiceConfigA$handle() {
        return ChangeServiceConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static MemorySegment ChangeServiceConfigA$address() {
        return ChangeServiceConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName)
     * }
     */
    public static int ChangeServiceConfigA(MemorySegment hService, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword, MemorySegment lpDisplayName) {
        var mh$ = ChangeServiceConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfigA", hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
            }
            return (int)mh$.invokeExact(hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeServiceConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeServiceConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfigW$descriptor() {
        return ChangeServiceConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static MethodHandle ChangeServiceConfigW$handle() {
        return ChangeServiceConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static MemorySegment ChangeServiceConfigW$address() {
        return ChangeServiceConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName)
     * }
     */
    public static int ChangeServiceConfigW(MemorySegment hService, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword, MemorySegment lpDisplayName) {
        var mh$ = ChangeServiceConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfigW", hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
            }
            return (int)mh$.invokeExact(hService, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeServiceConfig2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeServiceConfig2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfig2A$descriptor() {
        return ChangeServiceConfig2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MethodHandle ChangeServiceConfig2A$handle() {
        return ChangeServiceConfig2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MemorySegment ChangeServiceConfig2A$address() {
        return ChangeServiceConfig2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static int ChangeServiceConfig2A(MemorySegment hService, int dwInfoLevel, MemorySegment lpInfo) {
        var mh$ = ChangeServiceConfig2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfig2A", hService, dwInfoLevel, lpInfo);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeServiceConfig2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeServiceConfig2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static FunctionDescriptor ChangeServiceConfig2W$descriptor() {
        return ChangeServiceConfig2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MethodHandle ChangeServiceConfig2W$handle() {
        return ChangeServiceConfig2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static MemorySegment ChangeServiceConfig2W$address() {
        return ChangeServiceConfig2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo)
     * }
     */
    public static int ChangeServiceConfig2W(MemorySegment hService, int dwInfoLevel, MemorySegment lpInfo) {
        var mh$ = ChangeServiceConfig2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeServiceConfig2W", hService, dwInfoLevel, lpInfo);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseServiceHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseServiceHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static FunctionDescriptor CloseServiceHandle$descriptor() {
        return CloseServiceHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static MethodHandle CloseServiceHandle$handle() {
        return CloseServiceHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static MemorySegment CloseServiceHandle$address() {
        return CloseServiceHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseServiceHandle(SC_HANDLE hSCObject)
     * }
     */
    public static int CloseServiceHandle(MemorySegment hSCObject) {
        var mh$ = CloseServiceHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseServiceHandle", hSCObject);
            }
            return (int)mh$.invokeExact(hSCObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ControlService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ControlService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static FunctionDescriptor ControlService$descriptor() {
        return ControlService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MethodHandle ControlService$handle() {
        return ControlService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MemorySegment ControlService$address() {
        return ControlService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static int ControlService(MemorySegment hService, int dwControl, MemorySegment lpServiceStatus) {
        var mh$ = ControlService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ControlService", hService, dwControl, lpServiceStatus);
            }
            return (int)mh$.invokeExact(hService, dwControl, lpServiceStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateServiceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateServiceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static FunctionDescriptor CreateServiceA$descriptor() {
        return CreateServiceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static MethodHandle CreateServiceA$handle() {
        return CreateServiceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceA$address() {
        return CreateServiceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceA(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, int dwDesiredAccess, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword) {
        var mh$ = CreateServiceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateServiceA", hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateServiceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateServiceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static FunctionDescriptor CreateServiceW$descriptor() {
        return CreateServiceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static MethodHandle CreateServiceW$handle() {
        return CreateServiceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceW$address() {
        return CreateServiceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)
     * }
     */
    public static MemorySegment CreateServiceW(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, int dwDesiredAccess, int dwServiceType, int dwStartType, int dwErrorControl, MemorySegment lpBinaryPathName, MemorySegment lpLoadOrderGroup, MemorySegment lpdwTagId, MemorySegment lpDependencies, MemorySegment lpServiceStartName, MemorySegment lpPassword) {
        var mh$ = CreateServiceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateServiceW", hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static FunctionDescriptor DeleteService$descriptor() {
        return DeleteService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static MethodHandle DeleteService$handle() {
        return DeleteService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static MemorySegment DeleteService$address() {
        return DeleteService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteService(SC_HANDLE hService)
     * }
     */
    public static int DeleteService(MemorySegment hService) {
        var mh$ = DeleteService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteService", hService);
            }
            return (int)mh$.invokeExact(hService);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDependentServicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDependentServicesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static FunctionDescriptor EnumDependentServicesA$descriptor() {
        return EnumDependentServicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MethodHandle EnumDependentServicesA$handle() {
        return EnumDependentServicesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MemorySegment EnumDependentServicesA$address() {
        return EnumDependentServicesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static int EnumDependentServicesA(MemorySegment hService, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned) {
        var mh$ = EnumDependentServicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDependentServicesA", hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
            }
            return (int)mh$.invokeExact(hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDependentServicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumDependentServicesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static FunctionDescriptor EnumDependentServicesW$descriptor() {
        return EnumDependentServicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MethodHandle EnumDependentServicesW$handle() {
        return EnumDependentServicesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static MemorySegment EnumDependentServicesW$address() {
        return EnumDependentServicesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned)
     * }
     */
    public static int EnumDependentServicesW(MemorySegment hService, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned) {
        var mh$ = EnumDependentServicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDependentServicesW", hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
            }
            return (int)mh$.invokeExact(hService, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumServicesStatusA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusA$descriptor() {
        return EnumServicesStatusA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MethodHandle EnumServicesStatusA$handle() {
        return EnumServicesStatusA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MemorySegment EnumServicesStatusA$address() {
        return EnumServicesStatusA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static int EnumServicesStatusA(MemorySegment hSCManager, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle) {
        var mh$ = EnumServicesStatusA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusA", hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
            }
            return (int)mh$.invokeExact(hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumServicesStatusW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusW$descriptor() {
        return EnumServicesStatusW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MethodHandle EnumServicesStatusW$handle() {
        return EnumServicesStatusW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static MemorySegment EnumServicesStatusW$address() {
        return EnumServicesStatusW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle)
     * }
     */
    public static int EnumServicesStatusW(MemorySegment hSCManager, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle) {
        var mh$ = EnumServicesStatusW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusW", hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
            }
            return (int)mh$.invokeExact(hSCManager, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumServicesStatusExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusExA$descriptor() {
        return EnumServicesStatusExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static MethodHandle EnumServicesStatusExA$handle() {
        return EnumServicesStatusExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static MemorySegment EnumServicesStatusExA$address() {
        return EnumServicesStatusExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
     * }
     */
    public static int EnumServicesStatusExA(MemorySegment hSCManager, int InfoLevel, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle, MemorySegment pszGroupName) {
        var mh$ = EnumServicesStatusExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusExA", hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
            }
            return (int)mh$.invokeExact(hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumServicesStatusExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumServicesStatusExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static FunctionDescriptor EnumServicesStatusExW$descriptor() {
        return EnumServicesStatusExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static MethodHandle EnumServicesStatusExW$handle() {
        return EnumServicesStatusExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static MemorySegment EnumServicesStatusExW$address() {
        return EnumServicesStatusExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName)
     * }
     */
    public static int EnumServicesStatusExW(MemorySegment hSCManager, int InfoLevel, int dwServiceType, int dwServiceState, MemorySegment lpServices, int cbBufSize, MemorySegment pcbBytesNeeded, MemorySegment lpServicesReturned, MemorySegment lpResumeHandle, MemorySegment pszGroupName) {
        var mh$ = EnumServicesStatusExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumServicesStatusExW", hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
            }
            return (int)mh$.invokeExact(hSCManager, InfoLevel, dwServiceType, dwServiceState, lpServices, cbBufSize, pcbBytesNeeded, lpServicesReturned, lpResumeHandle, pszGroupName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceKeyNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetServiceKeyNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceKeyNameA$descriptor() {
        return GetServiceKeyNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceKeyNameA$handle() {
        return GetServiceKeyNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceKeyNameA$address() {
        return GetServiceKeyNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceKeyNameA(MemorySegment hSCManager, MemorySegment lpDisplayName, MemorySegment lpServiceName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceKeyNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceKeyNameA", hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceKeyNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetServiceKeyNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceKeyNameW$descriptor() {
        return GetServiceKeyNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceKeyNameW$handle() {
        return GetServiceKeyNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceKeyNameW$address() {
        return GetServiceKeyNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceKeyNameW(MemorySegment hSCManager, MemorySegment lpDisplayName, MemorySegment lpServiceName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceKeyNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceKeyNameW", hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpDisplayName, lpServiceName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceDisplayNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetServiceDisplayNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceDisplayNameA$descriptor() {
        return GetServiceDisplayNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceDisplayNameA$handle() {
        return GetServiceDisplayNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceDisplayNameA$address() {
        return GetServiceDisplayNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceDisplayNameA(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceDisplayNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceDisplayNameA", hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetServiceDisplayNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetServiceDisplayNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static FunctionDescriptor GetServiceDisplayNameW$descriptor() {
        return GetServiceDisplayNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MethodHandle GetServiceDisplayNameW$handle() {
        return GetServiceDisplayNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static MemorySegment GetServiceDisplayNameW$address() {
        return GetServiceDisplayNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer)
     * }
     */
    public static int GetServiceDisplayNameW(MemorySegment hSCManager, MemorySegment lpServiceName, MemorySegment lpDisplayName, MemorySegment lpcchBuffer) {
        var mh$ = GetServiceDisplayNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceDisplayNameW", hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
            }
            return (int)mh$.invokeExact(hSCManager, lpServiceName, lpDisplayName, lpcchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockServiceDatabase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LockServiceDatabase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static FunctionDescriptor LockServiceDatabase$descriptor() {
        return LockServiceDatabase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static MethodHandle LockServiceDatabase$handle() {
        return LockServiceDatabase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static MemorySegment LockServiceDatabase$address() {
        return LockServiceDatabase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager)
     * }
     */
    public static MemorySegment LockServiceDatabase(MemorySegment hSCManager) {
        var mh$ = LockServiceDatabase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockServiceDatabase", hSCManager);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyBootConfigStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("NotifyBootConfigStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static FunctionDescriptor NotifyBootConfigStatus$descriptor() {
        return NotifyBootConfigStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static MethodHandle NotifyBootConfigStatus$handle() {
        return NotifyBootConfigStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static MemorySegment NotifyBootConfigStatus$address() {
        return NotifyBootConfigStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL NotifyBootConfigStatus(BOOL BootAcceptable)
     * }
     */
    public static int NotifyBootConfigStatus(int BootAcceptable) {
        var mh$ = NotifyBootConfigStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyBootConfigStatus", BootAcceptable);
            }
            return (int)mh$.invokeExact(BootAcceptable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSCManagerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenSCManagerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenSCManagerA$descriptor() {
        return OpenSCManagerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenSCManagerA$handle() {
        return OpenSCManagerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerA$address() {
        return OpenSCManagerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerA(MemorySegment lpMachineName, MemorySegment lpDatabaseName, int dwDesiredAccess) {
        var mh$ = OpenSCManagerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSCManagerA", lpMachineName, lpDatabaseName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMachineName, lpDatabaseName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSCManagerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenSCManagerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenSCManagerW$descriptor() {
        return OpenSCManagerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenSCManagerW$handle() {
        return OpenSCManagerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerW$address() {
        return OpenSCManagerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenSCManagerW(MemorySegment lpMachineName, MemorySegment lpDatabaseName, int dwDesiredAccess) {
        var mh$ = OpenSCManagerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSCManagerW", lpMachineName, lpDatabaseName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMachineName, lpDatabaseName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenServiceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenServiceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenServiceA$descriptor() {
        return OpenServiceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenServiceA$handle() {
        return OpenServiceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceA$address() {
        return OpenServiceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceA(MemorySegment hSCManager, MemorySegment lpServiceName, int dwDesiredAccess) {
        var mh$ = OpenServiceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenServiceA", hSCManager, lpServiceName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenServiceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenServiceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenServiceW$descriptor() {
        return OpenServiceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenServiceW$handle() {
        return OpenServiceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceW$address() {
        return OpenServiceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SC_HANDLE OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenServiceW(MemorySegment hSCManager, MemorySegment lpServiceName, int dwDesiredAccess) {
        var mh$ = OpenServiceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenServiceW", hSCManager, lpServiceName, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(hSCManager, lpServiceName, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceConfigA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfigA$descriptor() {
        return QueryServiceConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfigA$handle() {
        return QueryServiceConfigA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfigA$address() {
        return QueryServiceConfigA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfigA(MemorySegment hService, MemorySegment lpServiceConfig, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfigA", hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceConfigW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfigW$descriptor() {
        return QueryServiceConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfigW$handle() {
        return QueryServiceConfigW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfigW$address() {
        return QueryServiceConfigW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfigW(MemorySegment hService, MemorySegment lpServiceConfig, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfigW", hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfig2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceConfig2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfig2A$descriptor() {
        return QueryServiceConfig2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfig2A$handle() {
        return QueryServiceConfig2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfig2A$address() {
        return QueryServiceConfig2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfig2A(MemorySegment hService, int dwInfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfig2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfig2A", hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceConfig2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceConfig2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceConfig2W$descriptor() {
        return QueryServiceConfig2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceConfig2W$handle() {
        return QueryServiceConfig2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceConfig2W$address() {
        return QueryServiceConfig2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceConfig2W(MemorySegment hService, int dwInfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceConfig2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceConfig2W", hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceLockStatusA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceLockStatusA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceLockStatusA$descriptor() {
        return QueryServiceLockStatusA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceLockStatusA$handle() {
        return QueryServiceLockStatusA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceLockStatusA$address() {
        return QueryServiceLockStatusA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceLockStatusA(MemorySegment hSCManager, MemorySegment lpLockStatus, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceLockStatusA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceLockStatusA", hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceLockStatusW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceLockStatusW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceLockStatusW$descriptor() {
        return QueryServiceLockStatusW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceLockStatusW$handle() {
        return QueryServiceLockStatusW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceLockStatusW$address() {
        return QueryServiceLockStatusW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceLockStatusW(MemorySegment hSCManager, MemorySegment lpLockStatus, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceLockStatusW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceLockStatusW", hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hSCManager, lpLockStatus, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceObjectSecurity$descriptor() {
        return QueryServiceObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceObjectSecurity$handle() {
        return QueryServiceObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceObjectSecurity$address() {
        return QueryServiceObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceObjectSecurity(MemorySegment hService, int dwSecurityInformation, MemorySegment lpSecurityDescriptor, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceObjectSecurity", hService, dwSecurityInformation, lpSecurityDescriptor, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, dwSecurityInformation, lpSecurityDescriptor, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static FunctionDescriptor QueryServiceStatus$descriptor() {
        return QueryServiceStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MethodHandle QueryServiceStatus$handle() {
        return QueryServiceStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MemorySegment QueryServiceStatus$address() {
        return QueryServiceStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static int QueryServiceStatus(MemorySegment hService, MemorySegment lpServiceStatus) {
        var mh$ = QueryServiceStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceStatus", hService, lpServiceStatus);
            }
            return (int)mh$.invokeExact(hService, lpServiceStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor QueryServiceStatusEx$descriptor() {
        return QueryServiceStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle QueryServiceStatusEx$handle() {
        return QueryServiceStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MemorySegment QueryServiceStatusEx$address() {
        return QueryServiceStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int QueryServiceStatusEx(MemorySegment hService, int InfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = QueryServiceStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceStatusEx", hService, InfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hService, InfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterServiceCtrlHandlerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerA$descriptor() {
        return RegisterServiceCtrlHandlerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerA$handle() {
        return RegisterServiceCtrlHandlerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerA$address() {
        return RegisterServiceCtrlHandlerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerA(MemorySegment lpServiceName, MemorySegment lpHandlerProc) {
        var mh$ = RegisterServiceCtrlHandlerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerA", lpServiceName, lpHandlerProc);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterServiceCtrlHandlerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerW$descriptor() {
        return RegisterServiceCtrlHandlerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerW$handle() {
        return RegisterServiceCtrlHandlerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerW$address() {
        return RegisterServiceCtrlHandlerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerW(MemorySegment lpServiceName, MemorySegment lpHandlerProc) {
        var mh$ = RegisterServiceCtrlHandlerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerW", lpServiceName, lpHandlerProc);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterServiceCtrlHandlerExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerExA$descriptor() {
        return RegisterServiceCtrlHandlerExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerExA$handle() {
        return RegisterServiceCtrlHandlerExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExA$address() {
        return RegisterServiceCtrlHandlerExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExA(MemorySegment lpServiceName, MemorySegment lpHandlerProc, MemorySegment lpContext) {
        var mh$ = RegisterServiceCtrlHandlerExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerExA", lpServiceName, lpHandlerProc, lpContext);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterServiceCtrlHandlerExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterServiceCtrlHandlerExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor RegisterServiceCtrlHandlerExW$descriptor() {
        return RegisterServiceCtrlHandlerExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MethodHandle RegisterServiceCtrlHandlerExW$handle() {
        return RegisterServiceCtrlHandlerExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExW$address() {
        return RegisterServiceCtrlHandlerExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)
     * }
     */
    public static MemorySegment RegisterServiceCtrlHandlerExW(MemorySegment lpServiceName, MemorySegment lpHandlerProc, MemorySegment lpContext) {
        var mh$ = RegisterServiceCtrlHandlerExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterServiceCtrlHandlerExW", lpServiceName, lpHandlerProc, lpContext);
            }
            return (MemorySegment)mh$.invokeExact(lpServiceName, lpHandlerProc, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetServiceObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetServiceObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetServiceObjectSecurity$descriptor() {
        return SetServiceObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static MethodHandle SetServiceObjectSecurity$handle() {
        return SetServiceObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static MemorySegment SetServiceObjectSecurity$address() {
        return SetServiceObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor)
     * }
     */
    public static int SetServiceObjectSecurity(MemorySegment hService, int dwSecurityInformation, MemorySegment lpSecurityDescriptor) {
        var mh$ = SetServiceObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetServiceObjectSecurity", hService, dwSecurityInformation, lpSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hService, dwSecurityInformation, lpSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetServiceStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetServiceStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static FunctionDescriptor SetServiceStatus$descriptor() {
        return SetServiceStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MethodHandle SetServiceStatus$handle() {
        return SetServiceStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static MemorySegment SetServiceStatus$address() {
        return SetServiceStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus)
     * }
     */
    public static int SetServiceStatus(MemorySegment hServiceStatus, MemorySegment lpServiceStatus) {
        var mh$ = SetServiceStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetServiceStatus", hServiceStatus, lpServiceStatus);
            }
            return (int)mh$.invokeExact(hServiceStatus, lpServiceStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceCtrlDispatcherA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartServiceCtrlDispatcherA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static FunctionDescriptor StartServiceCtrlDispatcherA$descriptor() {
        return StartServiceCtrlDispatcherA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static MethodHandle StartServiceCtrlDispatcherA$handle() {
        return StartServiceCtrlDispatcherA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static MemorySegment StartServiceCtrlDispatcherA$address() {
        return StartServiceCtrlDispatcherA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA *lpServiceStartTable)
     * }
     */
    public static int StartServiceCtrlDispatcherA(MemorySegment lpServiceStartTable) {
        var mh$ = StartServiceCtrlDispatcherA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceCtrlDispatcherA", lpServiceStartTable);
            }
            return (int)mh$.invokeExact(lpServiceStartTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceCtrlDispatcherW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartServiceCtrlDispatcherW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static FunctionDescriptor StartServiceCtrlDispatcherW$descriptor() {
        return StartServiceCtrlDispatcherW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static MethodHandle StartServiceCtrlDispatcherW$handle() {
        return StartServiceCtrlDispatcherW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static MemorySegment StartServiceCtrlDispatcherW$address() {
        return StartServiceCtrlDispatcherW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW *lpServiceStartTable)
     * }
     */
    public static int StartServiceCtrlDispatcherW(MemorySegment lpServiceStartTable) {
        var mh$ = StartServiceCtrlDispatcherW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceCtrlDispatcherW", lpServiceStartTable);
            }
            return (int)mh$.invokeExact(lpServiceStartTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartServiceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static FunctionDescriptor StartServiceA$descriptor() {
        return StartServiceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static MethodHandle StartServiceA$handle() {
        return StartServiceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static MemorySegment StartServiceA$address() {
        return StartServiceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
     * }
     */
    public static int StartServiceA(MemorySegment hService, int dwNumServiceArgs, MemorySegment lpServiceArgVectors) {
        var mh$ = StartServiceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceA", hService, dwNumServiceArgs, lpServiceArgVectors);
            }
            return (int)mh$.invokeExact(hService, dwNumServiceArgs, lpServiceArgVectors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartServiceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartServiceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static FunctionDescriptor StartServiceW$descriptor() {
        return StartServiceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static MethodHandle StartServiceW$handle() {
        return StartServiceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static MemorySegment StartServiceW$address() {
        return StartServiceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors)
     * }
     */
    public static int StartServiceW(MemorySegment hService, int dwNumServiceArgs, MemorySegment lpServiceArgVectors) {
        var mh$ = StartServiceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartServiceW", hService, dwNumServiceArgs, lpServiceArgVectors);
            }
            return (int)mh$.invokeExact(hService, dwNumServiceArgs, lpServiceArgVectors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockServiceDatabase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnlockServiceDatabase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static FunctionDescriptor UnlockServiceDatabase$descriptor() {
        return UnlockServiceDatabase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static MethodHandle UnlockServiceDatabase$handle() {
        return UnlockServiceDatabase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static MemorySegment UnlockServiceDatabase$address() {
        return UnlockServiceDatabase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockServiceDatabase(SC_LOCK ScLock)
     * }
     */
    public static int UnlockServiceDatabase(MemorySegment ScLock) {
        var mh$ = UnlockServiceDatabase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockServiceDatabase", ScLock);
            }
            return (int)mh$.invokeExact(ScLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyServiceStatusChangeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("NotifyServiceStatusChangeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static FunctionDescriptor NotifyServiceStatusChangeA$descriptor() {
        return NotifyServiceStatusChangeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static MethodHandle NotifyServiceStatusChangeA$handle() {
        return NotifyServiceStatusChangeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static MemorySegment NotifyServiceStatusChangeA$address() {
        return NotifyServiceStatusChangeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer)
     * }
     */
    public static int NotifyServiceStatusChangeA(MemorySegment hService, int dwNotifyMask, MemorySegment pNotifyBuffer) {
        var mh$ = NotifyServiceStatusChangeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyServiceStatusChangeA", hService, dwNotifyMask, pNotifyBuffer);
            }
            return (int)mh$.invokeExact(hService, dwNotifyMask, pNotifyBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyServiceStatusChangeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("NotifyServiceStatusChangeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static FunctionDescriptor NotifyServiceStatusChangeW$descriptor() {
        return NotifyServiceStatusChangeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static MethodHandle NotifyServiceStatusChangeW$handle() {
        return NotifyServiceStatusChangeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static MemorySegment NotifyServiceStatusChangeW$address() {
        return NotifyServiceStatusChangeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer)
     * }
     */
    public static int NotifyServiceStatusChangeW(MemorySegment hService, int dwNotifyMask, MemorySegment pNotifyBuffer) {
        var mh$ = NotifyServiceStatusChangeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyServiceStatusChangeW", hService, dwNotifyMask, pNotifyBuffer);
            }
            return (int)mh$.invokeExact(hService, dwNotifyMask, pNotifyBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ControlServiceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ControlServiceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static FunctionDescriptor ControlServiceExA$descriptor() {
        return ControlServiceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MethodHandle ControlServiceExA$handle() {
        return ControlServiceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MemorySegment ControlServiceExA$address() {
        return ControlServiceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static int ControlServiceExA(MemorySegment hService, int dwControl, int dwInfoLevel, MemorySegment pControlParams) {
        var mh$ = ControlServiceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ControlServiceExA", hService, dwControl, dwInfoLevel, pControlParams);
            }
            return (int)mh$.invokeExact(hService, dwControl, dwInfoLevel, pControlParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ControlServiceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ControlServiceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static FunctionDescriptor ControlServiceExW$descriptor() {
        return ControlServiceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MethodHandle ControlServiceExW$handle() {
        return ControlServiceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static MemorySegment ControlServiceExW$address() {
        return ControlServiceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams)
     * }
     */
    public static int ControlServiceExW(MemorySegment hService, int dwControl, int dwInfoLevel, MemorySegment pControlParams) {
        var mh$ = ControlServiceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ControlServiceExW", hService, dwControl, dwInfoLevel, pControlParams);
            }
            return (int)mh$.invokeExact(hService, dwControl, dwInfoLevel, pControlParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryServiceDynamicInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryServiceDynamicInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static FunctionDescriptor QueryServiceDynamicInformation$descriptor() {
        return QueryServiceDynamicInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static MethodHandle QueryServiceDynamicInformation$handle() {
        return QueryServiceDynamicInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static MemorySegment QueryServiceDynamicInformation$address() {
        return QueryServiceDynamicInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo)
     * }
     */
    public static int QueryServiceDynamicInformation(MemorySegment hServiceStatus, int dwInfoLevel, MemorySegment ppDynamicInfo) {
        var mh$ = QueryServiceDynamicInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryServiceDynamicInformation", hServiceStatus, dwInfoLevel, ppDynamicInfo);
            }
            return (int)mh$.invokeExact(hServiceStatus, dwInfoLevel, ppDynamicInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SC_EVENT_DATABASE_CHANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _SC_EVENT_TYPE.SC_EVENT_DATABASE_CHANGE = 0
     * }
     */
    public static int SC_EVENT_DATABASE_CHANGE() {
        return SC_EVENT_DATABASE_CHANGE;
    }
    private static final int SC_EVENT_PROPERTY_CHANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _SC_EVENT_TYPE.SC_EVENT_PROPERTY_CHANGE = 1
     * }
     */
    public static int SC_EVENT_PROPERTY_CHANGE() {
        return SC_EVENT_PROPERTY_CHANGE;
    }
    private static final int SC_EVENT_STATUS_CHANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _SC_EVENT_TYPE.SC_EVENT_STATUS_CHANGE = 2
     * }
     */
    public static int SC_EVENT_STATUS_CHANGE() {
        return SC_EVENT_STATUS_CHANGE;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _SC_EVENT_TYPE {
     *     SC_EVENT_DATABASE_CHANGE,
     *     SC_EVENT_PROPERTY_CHANGE,
     *     SC_EVENT_STATUS_CHANGE
     * } *PSC_EVENT_TYPE
     * }
     */
    public static final AddressLayout PSC_EVENT_TYPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SC_NOTIFICATION_REGISTRATION *PSC_NOTIFICATION_REGISTRATION
     * }
     */
    public static final AddressLayout PSC_NOTIFICATION_REGISTRATION = freeglut_h.C_POINTER;

    private static class SubscribeServiceChangeNotifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SubscribeServiceChangeNotifications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static FunctionDescriptor SubscribeServiceChangeNotifications$descriptor() {
        return SubscribeServiceChangeNotifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static MethodHandle SubscribeServiceChangeNotifications$handle() {
        return SubscribeServiceChangeNotifications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static MemorySegment SubscribeServiceChangeNotifications$address() {
        return SubscribeServiceChangeNotifications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SubscribeServiceChangeNotifications(SC_HANDLE hService, SC_EVENT_TYPE eEventType, PSC_NOTIFICATION_CALLBACK pCallback, PVOID pCallbackContext, PSC_NOTIFICATION_REGISTRATION *pSubscription)
     * }
     */
    public static int SubscribeServiceChangeNotifications(MemorySegment hService, int eEventType, MemorySegment pCallback, MemorySegment pCallbackContext, MemorySegment pSubscription) {
        var mh$ = SubscribeServiceChangeNotifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubscribeServiceChangeNotifications", hService, eEventType, pCallback, pCallbackContext, pSubscription);
            }
            return (int)mh$.invokeExact(hService, eEventType, pCallback, pCallbackContext, pSubscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnsubscribeServiceChangeNotifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnsubscribeServiceChangeNotifications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static FunctionDescriptor UnsubscribeServiceChangeNotifications$descriptor() {
        return UnsubscribeServiceChangeNotifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static MethodHandle UnsubscribeServiceChangeNotifications$handle() {
        return UnsubscribeServiceChangeNotifications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static MemorySegment UnsubscribeServiceChangeNotifications$address() {
        return UnsubscribeServiceChangeNotifications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription)
     * }
     */
    public static void UnsubscribeServiceChangeNotifications(MemorySegment pSubscription) {
        var mh$ = UnsubscribeServiceChangeNotifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnsubscribeServiceChangeNotifications", pSubscription);
            }
            mh$.invokeExact(pSubscription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitServiceState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitServiceState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static FunctionDescriptor WaitServiceState$descriptor() {
        return WaitServiceState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static MethodHandle WaitServiceState$handle() {
        return WaitServiceState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static MemorySegment WaitServiceState$address() {
        return WaitServiceState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent)
     * }
     */
    public static int WaitServiceState(MemorySegment hService, int dwNotify, int dwTimeout, MemorySegment hCancelEvent) {
        var mh$ = WaitServiceState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitServiceState", hService, dwNotify, dwTimeout, hCancelEvent);
            }
            return (int)mh$.invokeExact(hService, dwNotify, dwTimeout, hCancelEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ServiceRegistryStateParameters = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStateParameters = 0
     * }
     */
    public static int ServiceRegistryStateParameters() {
        return ServiceRegistryStateParameters;
    }
    private static final int ServiceRegistryStatePersistent = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStatePersistent = 1
     * }
     */
    public static int ServiceRegistryStatePersistent() {
        return ServiceRegistryStatePersistent;
    }
    private static final int MaxServiceRegistryStateType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_REGISTRY_STATE_TYPE.MaxServiceRegistryStateType = 2
     * }
     */
    public static int MaxServiceRegistryStateType() {
        return MaxServiceRegistryStateType;
    }

    private static class GetServiceRegistryStateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetServiceRegistryStateKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static FunctionDescriptor GetServiceRegistryStateKey$descriptor() {
        return GetServiceRegistryStateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static MethodHandle GetServiceRegistryStateKey$handle() {
        return GetServiceRegistryStateKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static MemorySegment GetServiceRegistryStateKey$address() {
        return GetServiceRegistryStateKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle, SERVICE_REGISTRY_STATE_TYPE StateType, DWORD AccessMask, HKEY *ServiceStateKey)
     * }
     */
    public static int GetServiceRegistryStateKey(MemorySegment ServiceStatusHandle, int StateType, int AccessMask, MemorySegment ServiceStateKey) {
        var mh$ = GetServiceRegistryStateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceRegistryStateKey", ServiceStatusHandle, StateType, AccessMask, ServiceStateKey);
            }
            return (int)mh$.invokeExact(ServiceStatusHandle, StateType, AccessMask, ServiceStateKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ServiceDirectoryPersistentState = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_DIRECTORY_TYPE.ServiceDirectoryPersistentState = 0
     * }
     */
    public static int ServiceDirectoryPersistentState() {
        return ServiceDirectoryPersistentState;
    }
    private static final int ServiceDirectoryTypeMax = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SERVICE_DIRECTORY_TYPE.ServiceDirectoryTypeMax = 1
     * }
     */
    public static int ServiceDirectoryTypeMax() {
        return ServiceDirectoryTypeMax;
    }

    private static class GetServiceDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetServiceDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static FunctionDescriptor GetServiceDirectory$descriptor() {
        return GetServiceDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static MethodHandle GetServiceDirectory$handle() {
        return GetServiceDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static MemorySegment GetServiceDirectory$address() {
        return GetServiceDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus, SERVICE_DIRECTORY_TYPE eDirectoryType, PWCHAR lpPathBuffer, DWORD cchPathBufferLength, DWORD *lpcchRequiredBufferLength)
     * }
     */
    public static int GetServiceDirectory(MemorySegment hServiceStatus, int eDirectoryType, MemorySegment lpPathBuffer, int cchPathBufferLength, MemorySegment lpcchRequiredBufferLength) {
        var mh$ = GetServiceDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetServiceDirectory", hServiceStatus, eDirectoryType, lpPathBuffer, cchPathBufferLength, lpcchRequiredBufferLength);
            }
            return (int)mh$.invokeExact(hServiceStatus, eDirectoryType, lpPathBuffer, cchPathBufferLength, lpcchRequiredBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMDEVCAPS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwModemProviderVersion;
     *     DWORD dwModemManufacturerOffset;
     *     DWORD dwModemManufacturerSize;
     *     DWORD dwModemModelOffset;
     *     DWORD dwModemModelSize;
     *     DWORD dwModemVersionOffset;
     *     DWORD dwModemVersionSize;
     *     DWORD dwDialOptions;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwModemOptions;
     *     DWORD dwMaxDTERate;
     *     DWORD dwMaxDCERate;
     *     BYTE abVariablePortion[1];
     * } *PMODEMDEVCAPS
     * }
     */
    public static final AddressLayout PMODEMDEVCAPS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMDEVCAPS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwModemProviderVersion;
     *     DWORD dwModemManufacturerOffset;
     *     DWORD dwModemManufacturerSize;
     *     DWORD dwModemModelOffset;
     *     DWORD dwModemModelSize;
     *     DWORD dwModemVersionOffset;
     *     DWORD dwModemVersionSize;
     *     DWORD dwDialOptions;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwModemOptions;
     *     DWORD dwMaxDTERate;
     *     DWORD dwMaxDCERate;
     *     BYTE abVariablePortion[1];
     * } *LPMODEMDEVCAPS
     * }
     */
    public static final AddressLayout LPMODEMDEVCAPS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMSETTINGS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwPreferredModemOptions;
     *     DWORD dwNegotiatedModemOptions;
     *     DWORD dwNegotiatedDCERate;
     *     BYTE abVariablePortion[1];
     * } *PMODEMSETTINGS
     * }
     */
    public static final AddressLayout PMODEMSETTINGS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MODEMSETTINGS {
     *     DWORD dwActualSize;
     *     DWORD dwRequiredSize;
     *     DWORD dwDevSpecificOffset;
     *     DWORD dwDevSpecificSize;
     *     DWORD dwCallSetupFailTimer;
     *     DWORD dwInactivityTimeout;
     *     DWORD dwSpeakerVolume;
     *     DWORD dwSpeakerMode;
     *     DWORD dwPreferredModemOptions;
     *     DWORD dwNegotiatedModemOptions;
     *     DWORD dwNegotiatedDCERate;
     *     BYTE abVariablePortion[1];
     * } *LPMODEMSETTINGS
     * }
     */
    public static final AddressLayout LPMODEMSETTINGS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HIMC__ {
     *     int unused;
     * } *HIMC
     * }
     */
    public static final AddressLayout HIMC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HIMCC__ {
     *     int unused;
     * } *HIMCC
     * }
     */
    public static final AddressLayout HIMCC = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HKL *LPHKL
     * }
     */
    public static final AddressLayout LPHKL = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef UINT *LPUINT
     * }
     */
    public static final AddressLayout LPUINT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPOSITIONFORM {
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *PCOMPOSITIONFORM
     * }
     */
    public static final AddressLayout PCOMPOSITIONFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPOSITIONFORM {
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *NPCOMPOSITIONFORM
     * }
     */
    public static final AddressLayout NPCOMPOSITIONFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPOSITIONFORM {
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *LPCOMPOSITIONFORM
     * }
     */
    public static final AddressLayout LPCOMPOSITIONFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATEFORM {
     *     DWORD dwIndex;
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *PCANDIDATEFORM
     * }
     */
    public static final AddressLayout PCANDIDATEFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATEFORM {
     *     DWORD dwIndex;
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *NPCANDIDATEFORM
     * }
     */
    public static final AddressLayout NPCANDIDATEFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATEFORM {
     *     DWORD dwIndex;
     *     DWORD dwStyle;
     *     POINT ptCurrentPos;
     *     RECT rcArea;
     * } *LPCANDIDATEFORM
     * }
     */
    public static final AddressLayout LPCANDIDATEFORM = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATELIST {
     *     DWORD dwSize;
     *     DWORD dwStyle;
     *     DWORD dwCount;
     *     DWORD dwSelection;
     *     DWORD dwPageStart;
     *     DWORD dwPageSize;
     *     DWORD dwOffset[1];
     * } *PCANDIDATELIST
     * }
     */
    public static final AddressLayout PCANDIDATELIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATELIST {
     *     DWORD dwSize;
     *     DWORD dwStyle;
     *     DWORD dwCount;
     *     DWORD dwSelection;
     *     DWORD dwPageStart;
     *     DWORD dwPageSize;
     *     DWORD dwOffset[1];
     * } *NPCANDIDATELIST
     * }
     */
    public static final AddressLayout NPCANDIDATELIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCANDIDATELIST {
     *     DWORD dwSize;
     *     DWORD dwStyle;
     *     DWORD dwCount;
     *     DWORD dwSelection;
     *     DWORD dwPageStart;
     *     DWORD dwPageSize;
     *     DWORD dwOffset[1];
     * } *LPCANDIDATELIST
     * }
     */
    public static final AddressLayout LPCANDIDATELIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDA {
     *     LPSTR lpReading;
     *     LPSTR lpWord;
     * } *PREGISTERWORDA
     * }
     */
    public static final AddressLayout PREGISTERWORDA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDA {
     *     LPSTR lpReading;
     *     LPSTR lpWord;
     * } *NPREGISTERWORDA
     * }
     */
    public static final AddressLayout NPREGISTERWORDA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDA {
     *     LPSTR lpReading;
     *     LPSTR lpWord;
     * } *LPREGISTERWORDA
     * }
     */
    public static final AddressLayout LPREGISTERWORDA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDW {
     *     LPWSTR lpReading;
     *     LPWSTR lpWord;
     * } *PREGISTERWORDW
     * }
     */
    public static final AddressLayout PREGISTERWORDW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDW {
     *     LPWSTR lpReading;
     *     LPWSTR lpWord;
     * } *NPREGISTERWORDW
     * }
     */
    public static final AddressLayout NPREGISTERWORDW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagREGISTERWORDW {
     *     LPWSTR lpReading;
     *     LPWSTR lpWord;
     * } *LPREGISTERWORDW
     * }
     */
    public static final AddressLayout LPREGISTERWORDW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PREGISTERWORDA PREGISTERWORD
     * }
     */
    public static final AddressLayout PREGISTERWORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPREGISTERWORDA NPREGISTERWORD
     * }
     */
    public static final AddressLayout NPREGISTERWORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPREGISTERWORDA LPREGISTERWORD
     * }
     */
    public static final AddressLayout LPREGISTERWORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECONVERTSTRING {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwStrLen;
     *     DWORD dwStrOffset;
     *     DWORD dwCompStrLen;
     *     DWORD dwCompStrOffset;
     *     DWORD dwTargetStrLen;
     *     DWORD dwTargetStrOffset;
     * } *PRECONVERTSTRING
     * }
     */
    public static final AddressLayout PRECONVERTSTRING = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECONVERTSTRING {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwStrLen;
     *     DWORD dwStrOffset;
     *     DWORD dwCompStrLen;
     *     DWORD dwCompStrOffset;
     *     DWORD dwTargetStrLen;
     *     DWORD dwTargetStrOffset;
     * } *NPRECONVERTSTRING
     * }
     */
    public static final AddressLayout NPRECONVERTSTRING = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECONVERTSTRING {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwStrLen;
     *     DWORD dwStrOffset;
     *     DWORD dwCompStrLen;
     *     DWORD dwCompStrOffset;
     *     DWORD dwTargetStrLen;
     *     DWORD dwTargetStrOffset;
     * } *LPRECONVERTSTRING
     * }
     */
    public static final AddressLayout LPRECONVERTSTRING = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFA {
     *     DWORD dwStyle;
     *     CHAR szDescription[32];
     * } *PSTYLEBUFA
     * }
     */
    public static final AddressLayout PSTYLEBUFA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFA {
     *     DWORD dwStyle;
     *     CHAR szDescription[32];
     * } *NPSTYLEBUFA
     * }
     */
    public static final AddressLayout NPSTYLEBUFA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFA {
     *     DWORD dwStyle;
     *     CHAR szDescription[32];
     * } *LPSTYLEBUFA
     * }
     */
    public static final AddressLayout LPSTYLEBUFA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFW {
     *     DWORD dwStyle;
     *     WCHAR szDescription[32];
     * } *PSTYLEBUFW
     * }
     */
    public static final AddressLayout PSTYLEBUFW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFW {
     *     DWORD dwStyle;
     *     WCHAR szDescription[32];
     * } *NPSTYLEBUFW
     * }
     */
    public static final AddressLayout NPSTYLEBUFW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLEBUFW {
     *     DWORD dwStyle;
     *     WCHAR szDescription[32];
     * } *LPSTYLEBUFW
     * }
     */
    public static final AddressLayout LPSTYLEBUFW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PSTYLEBUFA PSTYLEBUF
     * }
     */
    public static final AddressLayout PSTYLEBUF = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPSTYLEBUFA NPSTYLEBUF
     * }
     */
    public static final AddressLayout NPSTYLEBUF = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTYLEBUFA LPSTYLEBUF
     * }
     */
    public static final AddressLayout LPSTYLEBUF = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     CHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *PIMEMENUITEMINFOA
     * }
     */
    public static final AddressLayout PIMEMENUITEMINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     CHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *NPIMEMENUITEMINFOA
     * }
     */
    public static final AddressLayout NPIMEMENUITEMINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     CHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *LPIMEMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPIMEMENUITEMINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     WCHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *PIMEMENUITEMINFOW
     * }
     */
    public static final AddressLayout PIMEMENUITEMINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     WCHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *NPIMEMENUITEMINFOW
     * }
     */
    public static final AddressLayout NPIMEMENUITEMINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMEMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     DWORD dwItemData;
     *     WCHAR szString[80];
     *     HBITMAP hbmpItem;
     * } *LPIMEMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPIMEMENUITEMINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO
     * }
     */
    public static final AddressLayout PIMEMENUITEMINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO
     * }
     */
    public static final AddressLayout NPIMEMENUITEMINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO
     * }
     */
    public static final AddressLayout LPIMEMENUITEMINFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMECHARPOSITION {
     *     DWORD dwSize;
     *     DWORD dwCharPos;
     *     POINT pt;
     *     UINT cLineHeight;
     *     RECT rcDocument;
     * } *PIMECHARPOSITION
     * }
     */
    public static final AddressLayout PIMECHARPOSITION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMECHARPOSITION {
     *     DWORD dwSize;
     *     DWORD dwCharPos;
     *     POINT pt;
     *     UINT cLineHeight;
     *     RECT rcDocument;
     * } *NPIMECHARPOSITION
     * }
     */
    public static final AddressLayout NPIMECHARPOSITION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagIMECHARPOSITION {
     *     DWORD dwSize;
     *     DWORD dwCharPos;
     *     POINT pt;
     *     UINT cLineHeight;
     *     RECT rcDocument;
     * } *LPIMECHARPOSITION
     * }
     */
    public static final AddressLayout LPIMECHARPOSITION = freeglut_h.C_POINTER;

    private static class ImmInstallIMEA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmInstallIMEA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static FunctionDescriptor ImmInstallIMEA$descriptor() {
        return ImmInstallIMEA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static MethodHandle ImmInstallIMEA$handle() {
        return ImmInstallIMEA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEA$address() {
        return ImmInstallIMEA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEA(MemorySegment lpszIMEFileName, MemorySegment lpszLayoutText) {
        var mh$ = ImmInstallIMEA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmInstallIMEA", lpszIMEFileName, lpszLayoutText);
            }
            return (MemorySegment)mh$.invokeExact(lpszIMEFileName, lpszLayoutText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmInstallIMEW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmInstallIMEW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static FunctionDescriptor ImmInstallIMEW$descriptor() {
        return ImmInstallIMEW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static MethodHandle ImmInstallIMEW$handle() {
        return ImmInstallIMEW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEW$address() {
        return ImmInstallIMEW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HKL ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
     * }
     */
    public static MemorySegment ImmInstallIMEW(MemorySegment lpszIMEFileName, MemorySegment lpszLayoutText) {
        var mh$ = ImmInstallIMEW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmInstallIMEW", lpszIMEFileName, lpszLayoutText);
            }
            return (MemorySegment)mh$.invokeExact(lpszIMEFileName, lpszLayoutText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetDefaultIMEWnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetDefaultIMEWnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static FunctionDescriptor ImmGetDefaultIMEWnd$descriptor() {
        return ImmGetDefaultIMEWnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static MethodHandle ImmGetDefaultIMEWnd$handle() {
        return ImmGetDefaultIMEWnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static MemorySegment ImmGetDefaultIMEWnd$address() {
        return ImmGetDefaultIMEWnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HWND ImmGetDefaultIMEWnd(HWND)
     * }
     */
    public static MemorySegment ImmGetDefaultIMEWnd(MemorySegment x0) {
        var mh$ = ImmGetDefaultIMEWnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetDefaultIMEWnd", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetDescriptionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetDescriptionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetDescriptionA$descriptor() {
        return ImmGetDescriptionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetDescriptionA$handle() {
        return ImmGetDescriptionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetDescriptionA$address() {
        return ImmGetDescriptionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static int ImmGetDescriptionA(MemorySegment x0, MemorySegment lpszDescription, int uBufLen) {
        var mh$ = ImmGetDescriptionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetDescriptionA", x0, lpszDescription, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszDescription, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetDescriptionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetDescriptionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetDescriptionW$descriptor() {
        return ImmGetDescriptionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetDescriptionW$handle() {
        return ImmGetDescriptionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetDescriptionW$address() {
        return ImmGetDescriptionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen)
     * }
     */
    public static int ImmGetDescriptionW(MemorySegment x0, MemorySegment lpszDescription, int uBufLen) {
        var mh$ = ImmGetDescriptionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetDescriptionW", x0, lpszDescription, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszDescription, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetIMEFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetIMEFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetIMEFileNameA$descriptor() {
        return ImmGetIMEFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetIMEFileNameA$handle() {
        return ImmGetIMEFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetIMEFileNameA$address() {
        return ImmGetIMEFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static int ImmGetIMEFileNameA(MemorySegment x0, MemorySegment lpszFileName, int uBufLen) {
        var mh$ = ImmGetIMEFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetIMEFileNameA", x0, lpszFileName, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszFileName, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetIMEFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetIMEFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetIMEFileNameW$descriptor() {
        return ImmGetIMEFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MethodHandle ImmGetIMEFileNameW$handle() {
        return ImmGetIMEFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static MemorySegment ImmGetIMEFileNameW$address() {
        return ImmGetIMEFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen)
     * }
     */
    public static int ImmGetIMEFileNameW(MemorySegment x0, MemorySegment lpszFileName, int uBufLen) {
        var mh$ = ImmGetIMEFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetIMEFileNameW", x0, lpszFileName, uBufLen);
            }
            return (int)mh$.invokeExact(x0, lpszFileName, uBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static FunctionDescriptor ImmGetProperty$descriptor() {
        return ImmGetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static MethodHandle ImmGetProperty$handle() {
        return ImmGetProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static MemorySegment ImmGetProperty$address() {
        return ImmGetProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetProperty(HKL, DWORD)
     * }
     */
    public static int ImmGetProperty(MemorySegment x0, int x1) {
        var mh$ = ImmGetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetProperty", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmIsIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmIsIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static FunctionDescriptor ImmIsIME$descriptor() {
        return ImmIsIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static MethodHandle ImmIsIME$handle() {
        return ImmIsIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static MemorySegment ImmIsIME$address() {
        return ImmIsIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmIsIME(HKL)
     * }
     */
    public static int ImmIsIME(MemorySegment x0) {
        var mh$ = ImmIsIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmIsIME", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSimulateHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSimulateHotKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static FunctionDescriptor ImmSimulateHotKey$descriptor() {
        return ImmSimulateHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static MethodHandle ImmSimulateHotKey$handle() {
        return ImmSimulateHotKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static MemorySegment ImmSimulateHotKey$address() {
        return ImmSimulateHotKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSimulateHotKey(HWND, DWORD)
     * }
     */
    public static int ImmSimulateHotKey(MemorySegment x0, int x1) {
        var mh$ = ImmSimulateHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSimulateHotKey", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static FunctionDescriptor ImmCreateContext$descriptor() {
        return ImmCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static MethodHandle ImmCreateContext$handle() {
        return ImmCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static MemorySegment ImmCreateContext$address() {
        return ImmCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HIMC ImmCreateContext()
     * }
     */
    public static MemorySegment ImmCreateContext() {
        var mh$ = ImmCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmCreateContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDestroyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmDestroyContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static FunctionDescriptor ImmDestroyContext$descriptor() {
        return ImmDestroyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static MethodHandle ImmDestroyContext$handle() {
        return ImmDestroyContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static MemorySegment ImmDestroyContext$address() {
        return ImmDestroyContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDestroyContext(HIMC)
     * }
     */
    public static int ImmDestroyContext(MemorySegment x0) {
        var mh$ = ImmDestroyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDestroyContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static FunctionDescriptor ImmGetContext$descriptor() {
        return ImmGetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static MethodHandle ImmGetContext$handle() {
        return ImmGetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static MemorySegment ImmGetContext$address() {
        return ImmGetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HIMC ImmGetContext(HWND)
     * }
     */
    public static MemorySegment ImmGetContext(MemorySegment x0) {
        var mh$ = ImmGetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmReleaseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmReleaseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static FunctionDescriptor ImmReleaseContext$descriptor() {
        return ImmReleaseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static MethodHandle ImmReleaseContext$handle() {
        return ImmReleaseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static MemorySegment ImmReleaseContext$address() {
        return ImmReleaseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmReleaseContext(HWND, HIMC)
     * }
     */
    public static int ImmReleaseContext(MemorySegment x0, MemorySegment x1) {
        var mh$ = ImmReleaseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmReleaseContext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmAssociateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmAssociateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static FunctionDescriptor ImmAssociateContext$descriptor() {
        return ImmAssociateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static MethodHandle ImmAssociateContext$handle() {
        return ImmAssociateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static MemorySegment ImmAssociateContext$address() {
        return ImmAssociateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HIMC ImmAssociateContext(HWND, HIMC)
     * }
     */
    public static MemorySegment ImmAssociateContext(MemorySegment x0, MemorySegment x1) {
        var mh$ = ImmAssociateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmAssociateContext", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmAssociateContextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmAssociateContextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static FunctionDescriptor ImmAssociateContextEx$descriptor() {
        return ImmAssociateContextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static MethodHandle ImmAssociateContextEx$handle() {
        return ImmAssociateContextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static MemorySegment ImmAssociateContextEx$address() {
        return ImmAssociateContextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmAssociateContextEx(HWND, HIMC, DWORD)
     * }
     */
    public static int ImmAssociateContextEx(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ImmAssociateContextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmAssociateContextEx", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCompositionStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionStringA$descriptor() {
        return ImmGetCompositionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCompositionStringA$handle() {
        return ImmGetCompositionStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCompositionStringA$address() {
        return ImmGetCompositionStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCompositionStringA(MemorySegment x0, int x1, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetCompositionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionStringA", x0, x1, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, x1, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCompositionStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionStringW$descriptor() {
        return ImmGetCompositionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCompositionStringW$handle() {
        return ImmGetCompositionStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCompositionStringW$address() {
        return ImmGetCompositionStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCompositionStringW(MemorySegment x0, int x1, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetCompositionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionStringW", x0, x1, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, x1, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetCompositionStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionStringA$descriptor() {
        return ImmSetCompositionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MethodHandle ImmSetCompositionStringA$handle() {
        return ImmSetCompositionStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MemorySegment ImmSetCompositionStringA$address() {
        return ImmSetCompositionStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static int ImmSetCompositionStringA(MemorySegment x0, int dwIndex, MemorySegment lpComp, int dwCompLen, MemorySegment lpRead, int dwReadLen) {
        var mh$ = ImmSetCompositionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionStringA", x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetCompositionStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionStringW$descriptor() {
        return ImmSetCompositionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MethodHandle ImmSetCompositionStringW$handle() {
        return ImmSetCompositionStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static MemorySegment ImmSetCompositionStringW$address() {
        return ImmSetCompositionStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
     * }
     */
    public static int ImmSetCompositionStringW(MemorySegment x0, int dwIndex, MemorySegment lpComp, int dwCompLen, MemorySegment lpRead, int dwReadLen) {
        var mh$ = ImmSetCompositionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionStringW", x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListCountA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCandidateListCountA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListCountA$descriptor() {
        return ImmGetCandidateListCountA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MethodHandle ImmGetCandidateListCountA$handle() {
        return ImmGetCandidateListCountA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MemorySegment ImmGetCandidateListCountA$address() {
        return ImmGetCandidateListCountA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static int ImmGetCandidateListCountA(MemorySegment x0, MemorySegment lpdwListCount) {
        var mh$ = ImmGetCandidateListCountA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListCountA", x0, lpdwListCount);
            }
            return (int)mh$.invokeExact(x0, lpdwListCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListCountW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCandidateListCountW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListCountW$descriptor() {
        return ImmGetCandidateListCountW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MethodHandle ImmGetCandidateListCountW$handle() {
        return ImmGetCandidateListCountW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static MemorySegment ImmGetCandidateListCountW$address() {
        return ImmGetCandidateListCountW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
     * }
     */
    public static int ImmGetCandidateListCountW(MemorySegment x0, MemorySegment lpdwListCount) {
        var mh$ = ImmGetCandidateListCountW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListCountW", x0, lpdwListCount);
            }
            return (int)mh$.invokeExact(x0, lpdwListCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCandidateListA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListA$descriptor() {
        return ImmGetCandidateListA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCandidateListA$handle() {
        return ImmGetCandidateListA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCandidateListA$address() {
        return ImmGetCandidateListA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCandidateListA(MemorySegment x0, int deIndex, MemorySegment lpCandList, int dwBufLen) {
        var mh$ = ImmGetCandidateListA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListA", x0, deIndex, lpCandList, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, deIndex, lpCandList, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateListW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCandidateListW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateListW$descriptor() {
        return ImmGetCandidateListW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetCandidateListW$handle() {
        return ImmGetCandidateListW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetCandidateListW$address() {
        return ImmGetCandidateListW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
     * }
     */
    public static int ImmGetCandidateListW(MemorySegment x0, int deIndex, MemorySegment lpCandList, int dwBufLen) {
        var mh$ = ImmGetCandidateListW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateListW", x0, deIndex, lpCandList, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, deIndex, lpCandList, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetGuideLineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetGuideLineA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetGuideLineA$descriptor() {
        return ImmGetGuideLineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetGuideLineA$handle() {
        return ImmGetGuideLineA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetGuideLineA$address() {
        return ImmGetGuideLineA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetGuideLineA(MemorySegment x0, int dwIndex, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetGuideLineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetGuideLineA", x0, dwIndex, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetGuideLineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetGuideLineW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor ImmGetGuideLineW$descriptor() {
        return ImmGetGuideLineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MethodHandle ImmGetGuideLineW$handle() {
        return ImmGetGuideLineW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static MemorySegment ImmGetGuideLineW$address() {
        return ImmGetGuideLineW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen)
     * }
     */
    public static int ImmGetGuideLineW(MemorySegment x0, int dwIndex, MemorySegment lpBuf, int dwBufLen) {
        var mh$ = ImmGetGuideLineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetGuideLineW", x0, dwIndex, lpBuf, dwBufLen);
            }
            return (int)mh$.invokeExact(x0, dwIndex, lpBuf, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetConversionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetConversionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static FunctionDescriptor ImmGetConversionStatus$descriptor() {
        return ImmGetConversionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static MethodHandle ImmGetConversionStatus$handle() {
        return ImmGetConversionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static MemorySegment ImmGetConversionStatus$address() {
        return ImmGetConversionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
     * }
     */
    public static int ImmGetConversionStatus(MemorySegment x0, MemorySegment lpfdwConversion, MemorySegment lpfdwSentence) {
        var mh$ = ImmGetConversionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetConversionStatus", x0, lpfdwConversion, lpfdwSentence);
            }
            return (int)mh$.invokeExact(x0, lpfdwConversion, lpfdwSentence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetConversionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetConversionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor ImmSetConversionStatus$descriptor() {
        return ImmSetConversionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static MethodHandle ImmSetConversionStatus$handle() {
        return ImmSetConversionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static MemorySegment ImmSetConversionStatus$address() {
        return ImmSetConversionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD)
     * }
     */
    public static int ImmSetConversionStatus(MemorySegment x0, int x1, int x2) {
        var mh$ = ImmSetConversionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetConversionStatus", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetOpenStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetOpenStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static FunctionDescriptor ImmGetOpenStatus$descriptor() {
        return ImmGetOpenStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static MethodHandle ImmGetOpenStatus$handle() {
        return ImmGetOpenStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static MemorySegment ImmGetOpenStatus$address() {
        return ImmGetOpenStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetOpenStatus(HIMC)
     * }
     */
    public static int ImmGetOpenStatus(MemorySegment x0) {
        var mh$ = ImmGetOpenStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetOpenStatus", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetOpenStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetOpenStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static FunctionDescriptor ImmSetOpenStatus$descriptor() {
        return ImmSetOpenStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static MethodHandle ImmSetOpenStatus$handle() {
        return ImmSetOpenStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static MemorySegment ImmSetOpenStatus$address() {
        return ImmSetOpenStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetOpenStatus(HIMC, BOOL)
     * }
     */
    public static int ImmSetOpenStatus(MemorySegment x0, int x1) {
        var mh$ = ImmSetOpenStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetOpenStatus", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCompositionFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionFontA$descriptor() {
        return ImmGetCompositionFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MethodHandle ImmGetCompositionFontA$handle() {
        return ImmGetCompositionFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MemorySegment ImmGetCompositionFontA$address() {
        return ImmGetCompositionFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static int ImmGetCompositionFontA(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmGetCompositionFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionFontA", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCompositionFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionFontW$descriptor() {
        return ImmGetCompositionFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MethodHandle ImmGetCompositionFontW$handle() {
        return ImmGetCompositionFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MemorySegment ImmGetCompositionFontW$address() {
        return ImmGetCompositionFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static int ImmGetCompositionFontW(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmGetCompositionFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionFontW", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetCompositionFontA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionFontA$descriptor() {
        return ImmSetCompositionFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MethodHandle ImmSetCompositionFontA$handle() {
        return ImmSetCompositionFontA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static MemorySegment ImmSetCompositionFontA$address() {
        return ImmSetCompositionFontA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf)
     * }
     */
    public static int ImmSetCompositionFontA(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmSetCompositionFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionFontA", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetCompositionFontW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionFontW$descriptor() {
        return ImmSetCompositionFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MethodHandle ImmSetCompositionFontW$handle() {
        return ImmSetCompositionFontW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static MemorySegment ImmSetCompositionFontW$address() {
        return ImmSetCompositionFontW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf)
     * }
     */
    public static int ImmSetCompositionFontW(MemorySegment x0, MemorySegment lplf) {
        var mh$ = ImmSetCompositionFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionFontW", x0, lplf);
            }
            return (int)mh$.invokeExact(x0, lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmConfigureIMEA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmConfigureIMEA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmConfigureIMEA$descriptor() {
        return ImmConfigureIMEA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MethodHandle ImmConfigureIMEA$handle() {
        return ImmConfigureIMEA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MemorySegment ImmConfigureIMEA$address() {
        return ImmConfigureIMEA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static int ImmConfigureIMEA(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmConfigureIMEA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmConfigureIMEA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmConfigureIMEW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmConfigureIMEW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmConfigureIMEW$descriptor() {
        return ImmConfigureIMEW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MethodHandle ImmConfigureIMEW$handle() {
        return ImmConfigureIMEW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static MemorySegment ImmConfigureIMEW$address() {
        return ImmConfigureIMEW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
     * }
     */
    public static int ImmConfigureIMEW(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmConfigureIMEW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmConfigureIMEW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEscapeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmEscapeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEscapeA$descriptor() {
        return ImmEscapeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MethodHandle ImmEscapeA$handle() {
        return ImmEscapeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MemorySegment ImmEscapeA$address() {
        return ImmEscapeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT ImmEscapeA(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static long ImmEscapeA(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmEscapeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEscapeA", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEscapeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmEscapeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEscapeW$descriptor() {
        return ImmEscapeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MethodHandle ImmEscapeW$handle() {
        return ImmEscapeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static MemorySegment ImmEscapeW$address() {
        return ImmEscapeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LRESULT ImmEscapeW(HKL, HIMC, UINT, LPVOID)
     * }
     */
    public static long ImmEscapeW(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = ImmEscapeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEscapeW", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetConversionListA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetConversionListA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static FunctionDescriptor ImmGetConversionListA$descriptor() {
        return ImmGetConversionListA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MethodHandle ImmGetConversionListA$handle() {
        return ImmGetConversionListA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MemorySegment ImmGetConversionListA$address() {
        return ImmGetConversionListA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static int ImmGetConversionListA(MemorySegment x0, MemorySegment x1, MemorySegment lpSrc, MemorySegment lpDst, int dwBufLen, int uFlag) {
        var mh$ = ImmGetConversionListA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetConversionListA", x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
            }
            return (int)mh$.invokeExact(x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetConversionListW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetConversionListW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static FunctionDescriptor ImmGetConversionListW$descriptor() {
        return ImmGetConversionListW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MethodHandle ImmGetConversionListW$handle() {
        return ImmGetConversionListW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static MemorySegment ImmGetConversionListW$address() {
        return ImmGetConversionListW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag)
     * }
     */
    public static int ImmGetConversionListW(MemorySegment x0, MemorySegment x1, MemorySegment lpSrc, MemorySegment lpDst, int dwBufLen, int uFlag) {
        var mh$ = ImmGetConversionListW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetConversionListW", x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
            }
            return (int)mh$.invokeExact(x0, x1, lpSrc, lpDst, dwBufLen, uFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmNotifyIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmNotifyIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static FunctionDescriptor ImmNotifyIME$descriptor() {
        return ImmNotifyIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static MethodHandle ImmNotifyIME$handle() {
        return ImmNotifyIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static MemorySegment ImmNotifyIME$address() {
        return ImmNotifyIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
     * }
     */
    public static int ImmNotifyIME(MemorySegment x0, int dwAction, int dwIndex, int dwValue) {
        var mh$ = ImmNotifyIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmNotifyIME", x0, dwAction, dwIndex, dwValue);
            }
            return (int)mh$.invokeExact(x0, dwAction, dwIndex, dwValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetStatusWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetStatusWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static FunctionDescriptor ImmGetStatusWindowPos$descriptor() {
        return ImmGetStatusWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MethodHandle ImmGetStatusWindowPos$handle() {
        return ImmGetStatusWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MemorySegment ImmGetStatusWindowPos$address() {
        return ImmGetStatusWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static int ImmGetStatusWindowPos(MemorySegment x0, MemorySegment lpptPos) {
        var mh$ = ImmGetStatusWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetStatusWindowPos", x0, lpptPos);
            }
            return (int)mh$.invokeExact(x0, lpptPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetStatusWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetStatusWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static FunctionDescriptor ImmSetStatusWindowPos$descriptor() {
        return ImmSetStatusWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MethodHandle ImmSetStatusWindowPos$handle() {
        return ImmSetStatusWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static MemorySegment ImmSetStatusWindowPos$address() {
        return ImmSetStatusWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos)
     * }
     */
    public static int ImmSetStatusWindowPos(MemorySegment x0, MemorySegment lpptPos) {
        var mh$ = ImmSetStatusWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetStatusWindowPos", x0, lpptPos);
            }
            return (int)mh$.invokeExact(x0, lpptPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCompositionWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCompositionWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static FunctionDescriptor ImmGetCompositionWindow$descriptor() {
        return ImmGetCompositionWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MethodHandle ImmGetCompositionWindow$handle() {
        return ImmGetCompositionWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MemorySegment ImmGetCompositionWindow$address() {
        return ImmGetCompositionWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static int ImmGetCompositionWindow(MemorySegment x0, MemorySegment lpCompForm) {
        var mh$ = ImmGetCompositionWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCompositionWindow", x0, lpCompForm);
            }
            return (int)mh$.invokeExact(x0, lpCompForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCompositionWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetCompositionWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static FunctionDescriptor ImmSetCompositionWindow$descriptor() {
        return ImmSetCompositionWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MethodHandle ImmSetCompositionWindow$handle() {
        return ImmSetCompositionWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static MemorySegment ImmSetCompositionWindow$address() {
        return ImmSetCompositionWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm)
     * }
     */
    public static int ImmSetCompositionWindow(MemorySegment x0, MemorySegment lpCompForm) {
        var mh$ = ImmSetCompositionWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCompositionWindow", x0, lpCompForm);
            }
            return (int)mh$.invokeExact(x0, lpCompForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetCandidateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetCandidateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static FunctionDescriptor ImmGetCandidateWindow$descriptor() {
        return ImmGetCandidateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MethodHandle ImmGetCandidateWindow$handle() {
        return ImmGetCandidateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MemorySegment ImmGetCandidateWindow$address() {
        return ImmGetCandidateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static int ImmGetCandidateWindow(MemorySegment x0, int x1, MemorySegment lpCandidate) {
        var mh$ = ImmGetCandidateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetCandidateWindow", x0, x1, lpCandidate);
            }
            return (int)mh$.invokeExact(x0, x1, lpCandidate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmSetCandidateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmSetCandidateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static FunctionDescriptor ImmSetCandidateWindow$descriptor() {
        return ImmSetCandidateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MethodHandle ImmSetCandidateWindow$handle() {
        return ImmSetCandidateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static MemorySegment ImmSetCandidateWindow$address() {
        return ImmSetCandidateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate)
     * }
     */
    public static int ImmSetCandidateWindow(MemorySegment x0, MemorySegment lpCandidate) {
        var mh$ = ImmSetCandidateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmSetCandidateWindow", x0, lpCandidate);
            }
            return (int)mh$.invokeExact(x0, lpCandidate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmIsUIMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmIsUIMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static FunctionDescriptor ImmIsUIMessageA$descriptor() {
        return ImmIsUIMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MethodHandle ImmIsUIMessageA$handle() {
        return ImmIsUIMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MemorySegment ImmIsUIMessageA$address() {
        return ImmIsUIMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static int ImmIsUIMessageA(MemorySegment x0, int x1, long x2, long x3) {
        var mh$ = ImmIsUIMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmIsUIMessageA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmIsUIMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmIsUIMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static FunctionDescriptor ImmIsUIMessageW$descriptor() {
        return ImmIsUIMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MethodHandle ImmIsUIMessageW$handle() {
        return ImmIsUIMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static MemorySegment ImmIsUIMessageW$address() {
        return ImmIsUIMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
     * }
     */
    public static int ImmIsUIMessageW(MemorySegment x0, int x1, long x2, long x3) {
        var mh$ = ImmIsUIMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmIsUIMessageW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetVirtualKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetVirtualKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static FunctionDescriptor ImmGetVirtualKey$descriptor() {
        return ImmGetVirtualKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static MethodHandle ImmGetVirtualKey$handle() {
        return ImmGetVirtualKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static MemorySegment ImmGetVirtualKey$address() {
        return ImmGetVirtualKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetVirtualKey(HWND)
     * }
     */
    public static int ImmGetVirtualKey(MemorySegment x0) {
        var mh$ = ImmGetVirtualKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetVirtualKey", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmRegisterWordA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmRegisterWordA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static FunctionDescriptor ImmRegisterWordA$descriptor() {
        return ImmRegisterWordA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static MethodHandle ImmRegisterWordA$handle() {
        return ImmRegisterWordA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static MemorySegment ImmRegisterWordA$address() {
        return ImmRegisterWordA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister)
     * }
     */
    public static int ImmRegisterWordA(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszRegister) {
        var mh$ = ImmRegisterWordA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmRegisterWordA", x0, lpszReading, x2, lpszRegister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszRegister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmRegisterWordW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmRegisterWordW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static FunctionDescriptor ImmRegisterWordW$descriptor() {
        return ImmRegisterWordW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static MethodHandle ImmRegisterWordW$handle() {
        return ImmRegisterWordW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static MemorySegment ImmRegisterWordW$address() {
        return ImmRegisterWordW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
     * }
     */
    public static int ImmRegisterWordW(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszRegister) {
        var mh$ = ImmRegisterWordW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmRegisterWordW", x0, lpszReading, x2, lpszRegister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszRegister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmUnregisterWordA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmUnregisterWordA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static FunctionDescriptor ImmUnregisterWordA$descriptor() {
        return ImmUnregisterWordA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static MethodHandle ImmUnregisterWordA$handle() {
        return ImmUnregisterWordA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static MemorySegment ImmUnregisterWordA$address() {
        return ImmUnregisterWordA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister)
     * }
     */
    public static int ImmUnregisterWordA(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszUnregister) {
        var mh$ = ImmUnregisterWordA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmUnregisterWordA", x0, lpszReading, x2, lpszUnregister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszUnregister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmUnregisterWordW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmUnregisterWordW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static FunctionDescriptor ImmUnregisterWordW$descriptor() {
        return ImmUnregisterWordW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static MethodHandle ImmUnregisterWordW$handle() {
        return ImmUnregisterWordW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static MemorySegment ImmUnregisterWordW$address() {
        return ImmUnregisterWordW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
     * }
     */
    public static int ImmUnregisterWordW(MemorySegment x0, MemorySegment lpszReading, int x2, MemorySegment lpszUnregister) {
        var mh$ = ImmUnregisterWordW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmUnregisterWordW", x0, lpszReading, x2, lpszUnregister);
            }
            return (int)mh$.invokeExact(x0, lpszReading, x2, lpszUnregister);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetRegisterWordStyleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetRegisterWordStyleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static FunctionDescriptor ImmGetRegisterWordStyleA$descriptor() {
        return ImmGetRegisterWordStyleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static MethodHandle ImmGetRegisterWordStyleA$handle() {
        return ImmGetRegisterWordStyleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static MemorySegment ImmGetRegisterWordStyleA$address() {
        return ImmGetRegisterWordStyleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf)
     * }
     */
    public static int ImmGetRegisterWordStyleA(MemorySegment x0, int nItem, MemorySegment lpStyleBuf) {
        var mh$ = ImmGetRegisterWordStyleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetRegisterWordStyleA", x0, nItem, lpStyleBuf);
            }
            return (int)mh$.invokeExact(x0, nItem, lpStyleBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetRegisterWordStyleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetRegisterWordStyleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static FunctionDescriptor ImmGetRegisterWordStyleW$descriptor() {
        return ImmGetRegisterWordStyleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static MethodHandle ImmGetRegisterWordStyleW$handle() {
        return ImmGetRegisterWordStyleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static MemorySegment ImmGetRegisterWordStyleW$address() {
        return ImmGetRegisterWordStyleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf)
     * }
     */
    public static int ImmGetRegisterWordStyleW(MemorySegment x0, int nItem, MemorySegment lpStyleBuf) {
        var mh$ = ImmGetRegisterWordStyleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetRegisterWordStyleW", x0, nItem, lpStyleBuf);
            }
            return (int)mh$.invokeExact(x0, nItem, lpStyleBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEnumRegisterWordA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmEnumRegisterWordA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEnumRegisterWordA$descriptor() {
        return ImmEnumRegisterWordA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static MethodHandle ImmEnumRegisterWordA$handle() {
        return ImmEnumRegisterWordA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static MemorySegment ImmEnumRegisterWordA$address() {
        return ImmEnumRegisterWordA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID)
     * }
     */
    public static int ImmEnumRegisterWordA(MemorySegment x0, MemorySegment x1, MemorySegment lpszReading, int x3, MemorySegment lpszRegister, MemorySegment x5) {
        var mh$ = ImmEnumRegisterWordA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEnumRegisterWordA", x0, x1, lpszReading, x3, lpszRegister, x5);
            }
            return (int)mh$.invokeExact(x0, x1, lpszReading, x3, lpszRegister, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEnumRegisterWordW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmEnumRegisterWordW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static FunctionDescriptor ImmEnumRegisterWordW$descriptor() {
        return ImmEnumRegisterWordW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static MethodHandle ImmEnumRegisterWordW$handle() {
        return ImmEnumRegisterWordW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static MemorySegment ImmEnumRegisterWordW$address() {
        return ImmEnumRegisterWordW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
     * }
     */
    public static int ImmEnumRegisterWordW(MemorySegment x0, MemorySegment x1, MemorySegment lpszReading, int x3, MemorySegment lpszRegister, MemorySegment x5) {
        var mh$ = ImmEnumRegisterWordW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEnumRegisterWordW", x0, x1, lpszReading, x3, lpszRegister, x5);
            }
            return (int)mh$.invokeExact(x0, x1, lpszReading, x3, lpszRegister, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDisableIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmDisableIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static FunctionDescriptor ImmDisableIME$descriptor() {
        return ImmDisableIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static MethodHandle ImmDisableIME$handle() {
        return ImmDisableIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static MemorySegment ImmDisableIME$address() {
        return ImmDisableIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDisableIME(DWORD)
     * }
     */
    public static int ImmDisableIME(int x0) {
        var mh$ = ImmDisableIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDisableIME", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmEnumInputContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmEnumInputContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor ImmEnumInputContext$descriptor() {
        return ImmEnumInputContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle ImmEnumInputContext$handle() {
        return ImmEnumInputContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MemorySegment ImmEnumInputContext$address() {
        return ImmEnumInputContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int ImmEnumInputContext(int idThread, MemorySegment lpfn, long lParam) {
        var mh$ = ImmEnumInputContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmEnumInputContext", idThread, lpfn, lParam);
            }
            return (int)mh$.invokeExact(idThread, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetImeMenuItemsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetImeMenuItemsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor ImmGetImeMenuItemsA$descriptor() {
        return ImmGetImeMenuItemsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static MethodHandle ImmGetImeMenuItemsA$handle() {
        return ImmGetImeMenuItemsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static MemorySegment ImmGetImeMenuItemsA$address() {
        return ImmGetImeMenuItemsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize)
     * }
     */
    public static int ImmGetImeMenuItemsA(MemorySegment x0, int x1, int x2, MemorySegment lpImeParentMenu, MemorySegment lpImeMenu, int dwSize) {
        var mh$ = ImmGetImeMenuItemsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetImeMenuItemsA", x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
            }
            return (int)mh$.invokeExact(x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmGetImeMenuItemsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmGetImeMenuItemsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor ImmGetImeMenuItemsW$descriptor() {
        return ImmGetImeMenuItemsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static MethodHandle ImmGetImeMenuItemsW$handle() {
        return ImmGetImeMenuItemsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static MemorySegment ImmGetImeMenuItemsW$address() {
        return ImmGetImeMenuItemsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize)
     * }
     */
    public static int ImmGetImeMenuItemsW(MemorySegment x0, int x1, int x2, MemorySegment lpImeParentMenu, MemorySegment lpImeMenu, int dwSize) {
        var mh$ = ImmGetImeMenuItemsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmGetImeMenuItemsW", x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
            }
            return (int)mh$.invokeExact(x0, x1, x2, lpImeParentMenu, lpImeMenu, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDisableTextFrameService {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmDisableTextFrameService");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static FunctionDescriptor ImmDisableTextFrameService$descriptor() {
        return ImmDisableTextFrameService.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static MethodHandle ImmDisableTextFrameService$handle() {
        return ImmDisableTextFrameService.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static MemorySegment ImmDisableTextFrameService$address() {
        return ImmDisableTextFrameService.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDisableTextFrameService(DWORD idThread)
     * }
     */
    public static int ImmDisableTextFrameService(int idThread) {
        var mh$ = ImmDisableTextFrameService.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDisableTextFrameService", idThread);
            }
            return (int)mh$.invokeExact(idThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImmDisableLegacyIME {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImmDisableLegacyIME");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static FunctionDescriptor ImmDisableLegacyIME$descriptor() {
        return ImmDisableLegacyIME.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static MethodHandle ImmDisableLegacyIME$handle() {
        return ImmDisableLegacyIME.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static MemorySegment ImmDisableLegacyIME$address() {
        return ImmDisableLegacyIME.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImmDisableLegacyIME()
     * }
     */
    public static int ImmDisableLegacyIME() {
        var mh$ = ImmDisableLegacyIME.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImmDisableLegacyIME");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLenum
     * }
     */
    public static final OfInt GLenum = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLboolean
     * }
     */
    public static final OfByte GLboolean = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLbitfield
     * }
     */
    public static final OfInt GLbitfield = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char GLbyte
     * }
     */
    public static final OfByte GLbyte = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short GLshort
     * }
     */
    public static final OfShort GLshort = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int GLint
     * }
     */
    public static final OfInt GLint = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int GLsizei
     * }
     */
    public static final OfInt GLsizei = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLubyte
     * }
     */
    public static final OfByte GLubyte = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short GLushort
     * }
     */
    public static final OfShort GLushort = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLuint
     * }
     */
    public static final OfInt GLuint = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float GLfloat
     * }
     */
    public static final OfFloat GLfloat = freeglut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef float GLclampf
     * }
     */
    public static final OfFloat GLclampf = freeglut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double GLdouble
     * }
     */
    public static final OfDouble GLdouble = freeglut_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double GLclampd
     * }
     */
    public static final OfDouble GLclampd = freeglut_h.C_DOUBLE;

    private static class glAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static FunctionDescriptor glAccum$descriptor() {
        return glAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MethodHandle glAccum$handle() {
        return glAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MemorySegment glAccum$address() {
        return glAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static void glAccum(int op, float value) {
        var mh$ = glAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAccum", op, value);
            }
            mh$.invokeExact(op, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAlphaFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAlphaFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static FunctionDescriptor glAlphaFunc$descriptor() {
        return glAlphaFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MethodHandle glAlphaFunc$handle() {
        return glAlphaFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MemorySegment glAlphaFunc$address() {
        return glAlphaFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static void glAlphaFunc(int func, float ref) {
        var mh$ = glAlphaFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAlphaFunc", func, ref);
            }
            mh$.invokeExact(func, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAreTexturesResident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAreTexturesResident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static FunctionDescriptor glAreTexturesResident$descriptor() {
        return glAreTexturesResident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MethodHandle glAreTexturesResident$handle() {
        return glAreTexturesResident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MemorySegment glAreTexturesResident$address() {
        return glAreTexturesResident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static byte glAreTexturesResident(int n, MemorySegment textures, MemorySegment residences) {
        var mh$ = glAreTexturesResident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAreTexturesResident", n, textures, residences);
            }
            return (byte)mh$.invokeExact(n, textures, residences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glArrayElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glArrayElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static FunctionDescriptor glArrayElement$descriptor() {
        return glArrayElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MethodHandle glArrayElement$handle() {
        return glArrayElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MemorySegment glArrayElement$address() {
        return glArrayElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static void glArrayElement(int i) {
        var mh$ = glArrayElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glArrayElement", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBegin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBegin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBegin$descriptor() {
        return glBegin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MethodHandle glBegin$handle() {
        return glBegin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MemorySegment glBegin$address() {
        return glBegin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static void glBegin(int mode) {
        var mh$ = glBegin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBegin", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static FunctionDescriptor glBindTexture$descriptor() {
        return glBindTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MethodHandle glBindTexture$handle() {
        return glBindTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MemorySegment glBindTexture$address() {
        return glBindTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static void glBindTexture(int target, int texture) {
        var mh$ = glBindTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindTexture", target, texture);
            }
            mh$.invokeExact(target, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static FunctionDescriptor glBitmap$descriptor() {
        return glBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MethodHandle glBitmap$handle() {
        return glBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MemorySegment glBitmap$address() {
        return glBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, MemorySegment bitmap) {
        var mh$ = glBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBitmap", width, height, xorig, yorig, xmove, ymove, bitmap);
            }
            mh$.invokeExact(width, height, xorig, yorig, xmove, ymove, bitmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static FunctionDescriptor glBlendFunc$descriptor() {
        return glBlendFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MethodHandle glBlendFunc$handle() {
        return glBlendFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MemorySegment glBlendFunc$address() {
        return glBlendFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static void glBlendFunc(int sfactor, int dfactor) {
        var mh$ = glBlendFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendFunc", sfactor, dfactor);
            }
            mh$.invokeExact(sfactor, dfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCallList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static FunctionDescriptor glCallList$descriptor() {
        return glCallList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MethodHandle glCallList$handle() {
        return glCallList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MemorySegment glCallList$address() {
        return glCallList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static void glCallList(int list) {
        var mh$ = glCallList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallList", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCallLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static FunctionDescriptor glCallLists$descriptor() {
        return glCallLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MethodHandle glCallLists$handle() {
        return glCallLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MemorySegment glCallLists$address() {
        return glCallLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static void glCallLists(int n, int type, MemorySegment lists) {
        var mh$ = glCallLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallLists", n, type, lists);
            }
            mh$.invokeExact(n, type, lists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glClear$descriptor() {
        return glClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MethodHandle glClear$handle() {
        return glClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MemorySegment glClear$address() {
        return glClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static void glClear(int mask) {
        var mh$ = glClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClear", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glClearAccum$descriptor() {
        return glClearAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glClearAccum$handle() {
        return glClearAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glClearAccum$address() {
        return glClearAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glClearAccum(float red, float green, float blue, float alpha) {
        var mh$ = glClearAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearAccum", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glClearColor$descriptor() {
        return glClearColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glClearColor$handle() {
        return glClearColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glClearColor$address() {
        return glClearColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glClearColor(float red, float green, float blue, float alpha) {
        var mh$ = glClearColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static FunctionDescriptor glClearDepth$descriptor() {
        return glClearDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MethodHandle glClearDepth$handle() {
        return glClearDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MemorySegment glClearDepth$address() {
        return glClearDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static void glClearDepth(double depth) {
        var mh$ = glClearDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearDepth", depth);
            }
            mh$.invokeExact(depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static FunctionDescriptor glClearIndex$descriptor() {
        return glClearIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MethodHandle glClearIndex$handle() {
        return glClearIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MemorySegment glClearIndex$address() {
        return glClearIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static void glClearIndex(float c) {
        var mh$ = glClearIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearIndex", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearStencil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearStencil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static FunctionDescriptor glClearStencil$descriptor() {
        return glClearStencil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MethodHandle glClearStencil$handle() {
        return glClearStencil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MemorySegment glClearStencil$address() {
        return glClearStencil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static void glClearStencil(int s) {
        var mh$ = glClearStencil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearStencil", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glClipPlane$descriptor() {
        return glClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MethodHandle glClipPlane$handle() {
        return glClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MemorySegment glClipPlane$address() {
        return glClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static void glClipPlane(int plane, MemorySegment equation) {
        var mh$ = glClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glColor3b$descriptor() {
        return glColor3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glColor3b$handle() {
        return glColor3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glColor3b$address() {
        return glColor3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glColor3b(byte red, byte green, byte blue) {
        var mh$ = glColor3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3b", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor3bv$descriptor() {
        return glColor3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor3bv$handle() {
        return glColor3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor3bv$address() {
        return glColor3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static void glColor3bv(MemorySegment v) {
        var mh$ = glColor3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glColor3d$descriptor() {
        return glColor3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glColor3d$handle() {
        return glColor3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glColor3d$address() {
        return glColor3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glColor3d(double red, double green, double blue) {
        var mh$ = glColor3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3d", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor3dv$descriptor() {
        return glColor3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor3dv$handle() {
        return glColor3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor3dv$address() {
        return glColor3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static void glColor3dv(MemorySegment v) {
        var mh$ = glColor3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glColor3f$descriptor() {
        return glColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glColor3f$handle() {
        return glColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glColor3f$address() {
        return glColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glColor3f(float red, float green, float blue) {
        var mh$ = glColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3f", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor3fv$descriptor() {
        return glColor3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor3fv$handle() {
        return glColor3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor3fv$address() {
        return glColor3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static void glColor3fv(MemorySegment v) {
        var mh$ = glColor3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glColor3i$descriptor() {
        return glColor3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glColor3i$handle() {
        return glColor3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glColor3i$address() {
        return glColor3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glColor3i(int red, int green, int blue) {
        var mh$ = glColor3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3i", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor3iv$descriptor() {
        return glColor3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor3iv$handle() {
        return glColor3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor3iv$address() {
        return glColor3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static void glColor3iv(MemorySegment v) {
        var mh$ = glColor3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glColor3s$descriptor() {
        return glColor3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glColor3s$handle() {
        return glColor3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glColor3s$address() {
        return glColor3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glColor3s(short red, short green, short blue) {
        var mh$ = glColor3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3s", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor3sv$descriptor() {
        return glColor3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor3sv$handle() {
        return glColor3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor3sv$address() {
        return glColor3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static void glColor3sv(MemorySegment v) {
        var mh$ = glColor3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glColor3ub$descriptor() {
        return glColor3ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glColor3ub$handle() {
        return glColor3ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glColor3ub$address() {
        return glColor3ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glColor3ub(byte red, byte green, byte blue) {
        var mh$ = glColor3ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ub", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor3ubv$descriptor() {
        return glColor3ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor3ubv$handle() {
        return glColor3ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor3ubv$address() {
        return glColor3ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static void glColor3ubv(MemorySegment v) {
        var mh$ = glColor3ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glColor3ui$descriptor() {
        return glColor3ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glColor3ui$handle() {
        return glColor3ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glColor3ui$address() {
        return glColor3ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glColor3ui(int red, int green, int blue) {
        var mh$ = glColor3ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ui", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor3uiv$descriptor() {
        return glColor3uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor3uiv$handle() {
        return glColor3uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor3uiv$address() {
        return glColor3uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static void glColor3uiv(MemorySegment v) {
        var mh$ = glColor3uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glColor3us$descriptor() {
        return glColor3us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glColor3us$handle() {
        return glColor3us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glColor3us$address() {
        return glColor3us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glColor3us(short red, short green, short blue) {
        var mh$ = glColor3us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3us", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor3usv$descriptor() {
        return glColor3usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor3usv$handle() {
        return glColor3usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor3usv$address() {
        return glColor3usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static void glColor3usv(MemorySegment v) {
        var mh$ = glColor3usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4b$descriptor() {
        return glColor4b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MethodHandle glColor4b$handle() {
        return glColor4b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MemorySegment glColor4b$address() {
        return glColor4b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static void glColor4b(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4b", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor4bv$descriptor() {
        return glColor4bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor4bv$handle() {
        return glColor4bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor4bv$address() {
        return glColor4bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static void glColor4bv(MemorySegment v) {
        var mh$ = glColor4bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static FunctionDescriptor glColor4d$descriptor() {
        return glColor4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MethodHandle glColor4d$handle() {
        return glColor4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MemorySegment glColor4d$address() {
        return glColor4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static void glColor4d(double red, double green, double blue, double alpha) {
        var mh$ = glColor4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4d", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor4dv$descriptor() {
        return glColor4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor4dv$handle() {
        return glColor4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor4dv$address() {
        return glColor4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static void glColor4dv(MemorySegment v) {
        var mh$ = glColor4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glColor4f$descriptor() {
        return glColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glColor4f$handle() {
        return glColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glColor4f$address() {
        return glColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glColor4f(float red, float green, float blue, float alpha) {
        var mh$ = glColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4f", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor4fv$descriptor() {
        return glColor4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor4fv$handle() {
        return glColor4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor4fv$address() {
        return glColor4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static void glColor4fv(MemorySegment v) {
        var mh$ = glColor4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static FunctionDescriptor glColor4i$descriptor() {
        return glColor4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MethodHandle glColor4i$handle() {
        return glColor4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MemorySegment glColor4i$address() {
        return glColor4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static void glColor4i(int red, int green, int blue, int alpha) {
        var mh$ = glColor4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4i", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor4iv$descriptor() {
        return glColor4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor4iv$handle() {
        return glColor4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor4iv$address() {
        return glColor4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static void glColor4iv(MemorySegment v) {
        var mh$ = glColor4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static FunctionDescriptor glColor4s$descriptor() {
        return glColor4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MethodHandle glColor4s$handle() {
        return glColor4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MemorySegment glColor4s$address() {
        return glColor4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static void glColor4s(short red, short green, short blue, short alpha) {
        var mh$ = glColor4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4s", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor4sv$descriptor() {
        return glColor4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor4sv$handle() {
        return glColor4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor4sv$address() {
        return glColor4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static void glColor4sv(MemorySegment v) {
        var mh$ = glColor4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4ub$descriptor() {
        return glColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MethodHandle glColor4ub$handle() {
        return glColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MemorySegment glColor4ub$address() {
        return glColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ub", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor4ubv$descriptor() {
        return glColor4ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor4ubv$handle() {
        return glColor4ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor4ubv$address() {
        return glColor4ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static void glColor4ubv(MemorySegment v) {
        var mh$ = glColor4ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static FunctionDescriptor glColor4ui$descriptor() {
        return glColor4ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MethodHandle glColor4ui$handle() {
        return glColor4ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MemorySegment glColor4ui$address() {
        return glColor4ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static void glColor4ui(int red, int green, int blue, int alpha) {
        var mh$ = glColor4ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ui", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor4uiv$descriptor() {
        return glColor4uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor4uiv$handle() {
        return glColor4uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor4uiv$address() {
        return glColor4uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static void glColor4uiv(MemorySegment v) {
        var mh$ = glColor4uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static FunctionDescriptor glColor4us$descriptor() {
        return glColor4us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MethodHandle glColor4us$handle() {
        return glColor4us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MemorySegment glColor4us$address() {
        return glColor4us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static void glColor4us(short red, short green, short blue, short alpha) {
        var mh$ = glColor4us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4us", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor4usv$descriptor() {
        return glColor4usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor4usv$handle() {
        return glColor4usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor4usv$address() {
        return glColor4usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static void glColor4usv(MemorySegment v) {
        var mh$ = glColor4usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static FunctionDescriptor glColorMask$descriptor() {
        return glColorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MethodHandle glColorMask$handle() {
        return glColorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MemorySegment glColorMask$address() {
        return glColorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static void glColorMask(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMask", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glColorMaterial$descriptor() {
        return glColorMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glColorMaterial$handle() {
        return glColorMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glColorMaterial$address() {
        return glColorMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static void glColorMaterial(int face, int mode) {
        var mh$ = glColorMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMaterial", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glColorPointer$descriptor() {
        return glColorPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glColorPointer$handle() {
        return glColorPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glColorPointer$address() {
        return glColorPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glColorPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glColorPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static FunctionDescriptor glCopyPixels$descriptor() {
        return glCopyPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MethodHandle glCopyPixels$handle() {
        return glCopyPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MemorySegment glCopyPixels$address() {
        return glCopyPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static void glCopyPixels(int x, int y, int width, int height, int type) {
        var mh$ = glCopyPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyPixels", x, y, width, height, type);
            }
            mh$.invokeExact(x, y, width, height, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage1D$descriptor() {
        return glCopyTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage1D$handle() {
        return glCopyTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage1D$address() {
        return glCopyTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static void glCopyTexImage1D(int target, int level, int internalFormat, int x, int y, int width, int border) {
        var mh$ = glCopyTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage1D", target, level, internalFormat, x, y, width, border);
            }
            mh$.invokeExact(target, level, internalFormat, x, y, width, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage2D$descriptor() {
        return glCopyTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage2D$handle() {
        return glCopyTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage2D$address() {
        return glCopyTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static void glCopyTexImage2D(int target, int level, int internalFormat, int x, int y, int width, int height, int border) {
        var mh$ = glCopyTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage2D", target, level, internalFormat, x, y, width, height, border);
            }
            mh$.invokeExact(target, level, internalFormat, x, y, width, height, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage1D$descriptor() {
        return glCopyTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyTexSubImage1D$handle() {
        return glCopyTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyTexSubImage1D$address() {
        return glCopyTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width) {
        var mh$ = glCopyTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage1D", target, level, xoffset, x, y, width);
            }
            mh$.invokeExact(target, level, xoffset, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage2D$descriptor() {
        return glCopyTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage2D$handle() {
        return glCopyTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage2D$address() {
        return glCopyTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage2D", target, level, xoffset, yoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCullFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCullFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glCullFace$descriptor() {
        return glCullFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MethodHandle glCullFace$handle() {
        return glCullFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MemorySegment glCullFace$address() {
        return glCullFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static void glCullFace(int mode) {
        var mh$ = glCullFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCullFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static FunctionDescriptor glDeleteLists$descriptor() {
        return glDeleteLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MethodHandle glDeleteLists$handle() {
        return glDeleteLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MemorySegment glDeleteLists$address() {
        return glDeleteLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static void glDeleteLists(int list, int range) {
        var mh$ = glDeleteLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteLists", list, range);
            }
            mh$.invokeExact(list, range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static FunctionDescriptor glDeleteTextures$descriptor() {
        return glDeleteTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MethodHandle glDeleteTextures$handle() {
        return glDeleteTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MemorySegment glDeleteTextures$address() {
        return glDeleteTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static void glDeleteTextures(int n, MemorySegment textures) {
        var mh$ = glDeleteTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDepthFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static FunctionDescriptor glDepthFunc$descriptor() {
        return glDepthFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MethodHandle glDepthFunc$handle() {
        return glDepthFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MemorySegment glDepthFunc$address() {
        return glDepthFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static void glDepthFunc(int func) {
        var mh$ = glDepthFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glDepthMask$descriptor() {
        return glDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MethodHandle glDepthMask$handle() {
        return glDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MemorySegment glDepthMask$address() {
        return glDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static void glDepthMask(byte flag) {
        var mh$ = glDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthMask", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDepthRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static FunctionDescriptor glDepthRange$descriptor() {
        return glDepthRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static MethodHandle glDepthRange$handle() {
        return glDepthRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static MemorySegment glDepthRange$address() {
        return glDepthRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static void glDepthRange(double zNear, double zFar) {
        var mh$ = glDepthRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthRange", zNear, zFar);
            }
            mh$.invokeExact(zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glDisable$descriptor() {
        return glDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MethodHandle glDisable$handle() {
        return glDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MemorySegment glDisable$address() {
        return glDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static void glDisable(int cap) {
        var mh$ = glDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static FunctionDescriptor glDisableClientState$descriptor() {
        return glDisableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static MethodHandle glDisableClientState$handle() {
        return glDisableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static MemorySegment glDisableClientState$address() {
        return glDisableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisableClientState(GLenum array)
     * }
     */
    public static void glDisableClientState(int array) {
        var mh$ = glDisableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableClientState", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawArrays$descriptor() {
        return glDrawArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawArrays$handle() {
        return glDrawArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawArrays$address() {
        return glDrawArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static void glDrawArrays(int mode, int first, int count) {
        var mh$ = glDrawArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawArrays", mode, first, count);
            }
            mh$.invokeExact(mode, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glDrawBuffer$descriptor() {
        return glDrawBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glDrawBuffer$handle() {
        return glDrawBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glDrawBuffer$address() {
        return glDrawBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static void glDrawBuffer(int mode) {
        var mh$ = glDrawBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawElements$descriptor() {
        return glDrawElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawElements$handle() {
        return glDrawElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawElements$address() {
        return glDrawElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawElements(int mode, int count, int type, MemorySegment indices) {
        var mh$ = glDrawElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElements", mode, count, type, indices);
            }
            mh$.invokeExact(mode, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glDrawPixels$descriptor() {
        return glDrawPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glDrawPixels$handle() {
        return glDrawPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glDrawPixels$address() {
        return glDrawPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glDrawPixels(int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glDrawPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawPixels", width, height, format, type, pixels);
            }
            mh$.invokeExact(width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEdgeFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlag$descriptor() {
        return glEdgeFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MethodHandle glEdgeFlag$handle() {
        return glEdgeFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MemorySegment glEdgeFlag$address() {
        return glEdgeFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static void glEdgeFlag(byte flag) {
        var mh$ = glEdgeFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlag", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEdgeFlagPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glEdgeFlagPointer$descriptor() {
        return glEdgeFlagPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glEdgeFlagPointer$handle() {
        return glEdgeFlagPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glEdgeFlagPointer$address() {
        return glEdgeFlagPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glEdgeFlagPointer(int stride, MemorySegment pointer) {
        var mh$ = glEdgeFlagPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagPointer", stride, pointer);
            }
            mh$.invokeExact(stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEdgeFlagv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlagv$descriptor() {
        return glEdgeFlagv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MethodHandle glEdgeFlagv$handle() {
        return glEdgeFlagv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MemorySegment glEdgeFlagv$address() {
        return glEdgeFlagv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static void glEdgeFlagv(MemorySegment flag) {
        var mh$ = glEdgeFlagv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagv", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glEnable$descriptor() {
        return glEnable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MethodHandle glEnable$handle() {
        return glEnable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MemorySegment glEnable$address() {
        return glEnable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static void glEnable(int cap) {
        var mh$ = glEnable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static FunctionDescriptor glEnableClientState$descriptor() {
        return glEnableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static MethodHandle glEnableClientState$handle() {
        return glEnableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static MemorySegment glEnableClientState$address() {
        return glEnableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnableClientState(GLenum array)
     * }
     */
    public static void glEnableClientState(int array) {
        var mh$ = glEnableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableClientState", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static FunctionDescriptor glEnd$descriptor() {
        return glEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MethodHandle glEnd$handle() {
        return glEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MemorySegment glEnd$address() {
        return glEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static void glEnd() {
        var mh$ = glEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnd");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEndList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static FunctionDescriptor glEndList$descriptor() {
        return glEndList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MethodHandle glEndList$handle() {
        return glEndList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MemorySegment glEndList$address() {
        return glEndList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static void glEndList() {
        var mh$ = glEndList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndList");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1d$descriptor() {
        return glEvalCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MethodHandle glEvalCoord1d$handle() {
        return glEvalCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MemorySegment glEvalCoord1d$address() {
        return glEvalCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static void glEvalCoord1d(double u) {
        var mh$ = glEvalCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1d", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1dv$descriptor() {
        return glEvalCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord1dv$handle() {
        return glEvalCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord1dv$address() {
        return glEvalCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord1dv(MemorySegment u) {
        var mh$ = glEvalCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1f$descriptor() {
        return glEvalCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MethodHandle glEvalCoord1f$handle() {
        return glEvalCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MemorySegment glEvalCoord1f$address() {
        return glEvalCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static void glEvalCoord1f(float u) {
        var mh$ = glEvalCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1f", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1fv$descriptor() {
        return glEvalCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord1fv$handle() {
        return glEvalCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord1fv$address() {
        return glEvalCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord1fv(MemorySegment u) {
        var mh$ = glEvalCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2d$descriptor() {
        return glEvalCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MethodHandle glEvalCoord2d$handle() {
        return glEvalCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MemorySegment glEvalCoord2d$address() {
        return glEvalCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static void glEvalCoord2d(double u, double v) {
        var mh$ = glEvalCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2d", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2dv$descriptor() {
        return glEvalCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord2dv$handle() {
        return glEvalCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord2dv$address() {
        return glEvalCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord2dv(MemorySegment u) {
        var mh$ = glEvalCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2f$descriptor() {
        return glEvalCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MethodHandle glEvalCoord2f$handle() {
        return glEvalCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MemorySegment glEvalCoord2f$address() {
        return glEvalCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static void glEvalCoord2f(float u, float v) {
        var mh$ = glEvalCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2f", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2fv$descriptor() {
        return glEvalCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord2fv$handle() {
        return glEvalCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord2fv$address() {
        return glEvalCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord2fv(MemorySegment u) {
        var mh$ = glEvalCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalMesh1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static FunctionDescriptor glEvalMesh1$descriptor() {
        return glEvalMesh1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MethodHandle glEvalMesh1$handle() {
        return glEvalMesh1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MemorySegment glEvalMesh1$address() {
        return glEvalMesh1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static void glEvalMesh1(int mode, int i1, int i2) {
        var mh$ = glEvalMesh1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh1", mode, i1, i2);
            }
            mh$.invokeExact(mode, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalMesh2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static FunctionDescriptor glEvalMesh2$descriptor() {
        return glEvalMesh2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MethodHandle glEvalMesh2$handle() {
        return glEvalMesh2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MemorySegment glEvalMesh2$address() {
        return glEvalMesh2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static void glEvalMesh2(int mode, int i1, int i2, int j1, int j2) {
        var mh$ = glEvalMesh2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh2", mode, i1, i2, j1, j2);
            }
            mh$.invokeExact(mode, i1, i2, j1, j2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalPoint1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static FunctionDescriptor glEvalPoint1$descriptor() {
        return glEvalPoint1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MethodHandle glEvalPoint1$handle() {
        return glEvalPoint1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MemorySegment glEvalPoint1$address() {
        return glEvalPoint1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static void glEvalPoint1(int i) {
        var mh$ = glEvalPoint1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint1", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalPoint2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static FunctionDescriptor glEvalPoint2$descriptor() {
        return glEvalPoint2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MethodHandle glEvalPoint2$handle() {
        return glEvalPoint2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MemorySegment glEvalPoint2$address() {
        return glEvalPoint2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static void glEvalPoint2(int i, int j) {
        var mh$ = glEvalPoint2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint2", i, j);
            }
            mh$.invokeExact(i, j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFeedbackBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFeedbackBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static FunctionDescriptor glFeedbackBuffer$descriptor() {
        return glFeedbackBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MethodHandle glFeedbackBuffer$handle() {
        return glFeedbackBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MemorySegment glFeedbackBuffer$address() {
        return glFeedbackBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static void glFeedbackBuffer(int size, int type, MemorySegment buffer) {
        var mh$ = glFeedbackBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFeedbackBuffer", size, type, buffer);
            }
            mh$.invokeExact(size, type, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static FunctionDescriptor glFinish$descriptor() {
        return glFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MethodHandle glFinish$handle() {
        return glFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MemorySegment glFinish$address() {
        return glFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static void glFinish() {
        var mh$ = glFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinish");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static FunctionDescriptor glFlush$descriptor() {
        return glFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MethodHandle glFlush$handle() {
        return glFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MemorySegment glFlush$address() {
        return glFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static void glFlush() {
        var mh$ = glFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlush");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

