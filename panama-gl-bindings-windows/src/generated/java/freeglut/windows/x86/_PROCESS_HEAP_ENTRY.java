// Generated by jextract

package freeglut.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct _PROCESS_HEAP_ENTRY {
 *     PVOID lpData;
 *     DWORD cbData;
 *     BYTE cbOverhead;
 *     BYTE iRegionIndex;
 *     WORD wFlags;
 *     union {
 *         struct {
 *             HANDLE hMem;
 *             DWORD dwReserved[3];
 *         } Block;
 *         struct {
 *             DWORD dwCommittedSize;
 *             DWORD dwUnCommittedSize;
 *             LPVOID lpFirstBlock;
 *             LPVOID lpLastBlock;
 *         } Region;
 *     };
 * }
 * }
 */
public class _PROCESS_HEAP_ENTRY {

    _PROCESS_HEAP_ENTRY() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        freeglut_h.C_POINTER.withName("lpData"),
        freeglut_h.C_LONG.withName("cbData"),
        freeglut_h.C_CHAR.withName("cbOverhead"),
        freeglut_h.C_CHAR.withName("iRegionIndex"),
        freeglut_h.C_SHORT.withName("wFlags"),
        MemoryLayout.unionLayout(
            _PROCESS_HEAP_ENTRY.Block.layout().withName("Block"),
            _PROCESS_HEAP_ENTRY.Region.layout().withName("Region")
        ).withName("$anon$244:5")
    ).withName("_PROCESS_HEAP_ENTRY");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout lpData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lpData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * PVOID lpData
     * }
     */
    public static final AddressLayout lpData$layout() {
        return lpData$LAYOUT;
    }

    private static final long lpData$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * PVOID lpData
     * }
     */
    public static final long lpData$offset() {
        return lpData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * PVOID lpData
     * }
     */
    public static MemorySegment lpData(MemorySegment struct) {
        return struct.get(lpData$LAYOUT, lpData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * PVOID lpData
     * }
     */
    public static void lpData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(lpData$LAYOUT, lpData$OFFSET, fieldValue);
    }

    private static final OfInt cbData$LAYOUT = (OfInt)$LAYOUT.select(groupElement("cbData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * DWORD cbData
     * }
     */
    public static final OfInt cbData$layout() {
        return cbData$LAYOUT;
    }

    private static final long cbData$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * DWORD cbData
     * }
     */
    public static final long cbData$offset() {
        return cbData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * DWORD cbData
     * }
     */
    public static int cbData(MemorySegment struct) {
        return struct.get(cbData$LAYOUT, cbData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * DWORD cbData
     * }
     */
    public static void cbData(MemorySegment struct, int fieldValue) {
        struct.set(cbData$LAYOUT, cbData$OFFSET, fieldValue);
    }

    private static final OfByte cbOverhead$LAYOUT = (OfByte)$LAYOUT.select(groupElement("cbOverhead"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * BYTE cbOverhead
     * }
     */
    public static final OfByte cbOverhead$layout() {
        return cbOverhead$LAYOUT;
    }

    private static final long cbOverhead$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * BYTE cbOverhead
     * }
     */
    public static final long cbOverhead$offset() {
        return cbOverhead$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * BYTE cbOverhead
     * }
     */
    public static byte cbOverhead(MemorySegment struct) {
        return struct.get(cbOverhead$LAYOUT, cbOverhead$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * BYTE cbOverhead
     * }
     */
    public static void cbOverhead(MemorySegment struct, byte fieldValue) {
        struct.set(cbOverhead$LAYOUT, cbOverhead$OFFSET, fieldValue);
    }

    private static final OfByte iRegionIndex$LAYOUT = (OfByte)$LAYOUT.select(groupElement("iRegionIndex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * BYTE iRegionIndex
     * }
     */
    public static final OfByte iRegionIndex$layout() {
        return iRegionIndex$LAYOUT;
    }

    private static final long iRegionIndex$OFFSET = 13;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * BYTE iRegionIndex
     * }
     */
    public static final long iRegionIndex$offset() {
        return iRegionIndex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * BYTE iRegionIndex
     * }
     */
    public static byte iRegionIndex(MemorySegment struct) {
        return struct.get(iRegionIndex$LAYOUT, iRegionIndex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * BYTE iRegionIndex
     * }
     */
    public static void iRegionIndex(MemorySegment struct, byte fieldValue) {
        struct.set(iRegionIndex$LAYOUT, iRegionIndex$OFFSET, fieldValue);
    }

    private static final OfShort wFlags$LAYOUT = (OfShort)$LAYOUT.select(groupElement("wFlags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * WORD wFlags
     * }
     */
    public static final OfShort wFlags$layout() {
        return wFlags$LAYOUT;
    }

    private static final long wFlags$OFFSET = 14;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * WORD wFlags
     * }
     */
    public static final long wFlags$offset() {
        return wFlags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * WORD wFlags
     * }
     */
    public static short wFlags(MemorySegment struct) {
        return struct.get(wFlags$LAYOUT, wFlags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * WORD wFlags
     * }
     */
    public static void wFlags(MemorySegment struct, short fieldValue) {
        struct.set(wFlags$LAYOUT, wFlags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     HANDLE hMem;
     *     DWORD dwReserved[3];
     * }
     * }
     */
    public static class Block {

        Block() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            freeglut_h.C_POINTER.withName("hMem"),
            MemoryLayout.sequenceLayout(3, freeglut_h.C_LONG).withName("dwReserved"),
            MemoryLayout.paddingLayout(4)
        ).withName("$anon$245:9");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout hMem$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hMem"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * HANDLE hMem
         * }
         */
        public static final AddressLayout hMem$layout() {
            return hMem$LAYOUT;
        }

        private static final long hMem$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * HANDLE hMem
         * }
         */
        public static final long hMem$offset() {
            return hMem$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * HANDLE hMem
         * }
         */
        public static MemorySegment hMem(MemorySegment struct) {
            return struct.get(hMem$LAYOUT, hMem$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * HANDLE hMem
         * }
         */
        public static void hMem(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(hMem$LAYOUT, hMem$OFFSET, fieldValue);
        }

        private static final SequenceLayout dwReserved$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("dwReserved"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD dwReserved[3]
         * }
         */
        public static final SequenceLayout dwReserved$layout() {
            return dwReserved$LAYOUT;
        }

        private static final long dwReserved$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD dwReserved[3]
         * }
         */
        public static final long dwReserved$offset() {
            return dwReserved$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD dwReserved[3]
         * }
         */
        public static MemorySegment dwReserved(MemorySegment struct) {
            return struct.asSlice(dwReserved$OFFSET, dwReserved$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD dwReserved[3]
         * }
         */
        public static void dwReserved(MemorySegment struct, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, struct, dwReserved$OFFSET, dwReserved$LAYOUT.byteSize());
        }

        private static long[] dwReserved$DIMS = { 3 };

        /**
         * Dimensions for array field:
         * {@snippet lang=c :
         * DWORD dwReserved[3]
         * }
         */
        public static long[] dwReserved$dimensions() {
            return dwReserved$DIMS;
        }
        private static final VarHandle dwReserved$ELEM_HANDLE = dwReserved$LAYOUT.varHandle(sequenceElement());

        /**
         * Indexed getter for field:
         * {@snippet lang=c :
         * DWORD dwReserved[3]
         * }
         */
        public static int dwReserved(MemorySegment struct, long index0) {
            return (int)dwReserved$ELEM_HANDLE.get(struct, 0L, index0);
        }

        /**
         * Indexed setter for field:
         * {@snippet lang=c :
         * DWORD dwReserved[3]
         * }
         */
        public static void dwReserved(MemorySegment struct, long index0, int fieldValue) {
            dwReserved$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout Block$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$244:5"), groupElement("Block"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     HANDLE hMem;
     *     DWORD dwReserved[3];
     * } Block
     * }
     */
    public static final GroupLayout Block$layout() {
        return Block$LAYOUT;
    }

    private static final long Block$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     HANDLE hMem;
     *     DWORD dwReserved[3];
     * } Block
     * }
     */
    public static final long Block$offset() {
        return Block$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     HANDLE hMem;
     *     DWORD dwReserved[3];
     * } Block
     * }
     */
    public static MemorySegment Block(MemorySegment struct) {
        return struct.asSlice(Block$OFFSET, Block$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     HANDLE hMem;
     *     DWORD dwReserved[3];
     * } Block
     * }
     */
    public static void Block(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Block$OFFSET, Block$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     DWORD dwCommittedSize;
     *     DWORD dwUnCommittedSize;
     *     LPVOID lpFirstBlock;
     *     LPVOID lpLastBlock;
     * }
     * }
     */
    public static class Region {

        Region() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            freeglut_h.C_LONG.withName("dwCommittedSize"),
            freeglut_h.C_LONG.withName("dwUnCommittedSize"),
            freeglut_h.C_POINTER.withName("lpFirstBlock"),
            freeglut_h.C_POINTER.withName("lpLastBlock")
        ).withName("$anon$249:9");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt dwCommittedSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dwCommittedSize"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD dwCommittedSize
         * }
         */
        public static final OfInt dwCommittedSize$layout() {
            return dwCommittedSize$LAYOUT;
        }

        private static final long dwCommittedSize$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD dwCommittedSize
         * }
         */
        public static final long dwCommittedSize$offset() {
            return dwCommittedSize$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD dwCommittedSize
         * }
         */
        public static int dwCommittedSize(MemorySegment struct) {
            return struct.get(dwCommittedSize$LAYOUT, dwCommittedSize$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD dwCommittedSize
         * }
         */
        public static void dwCommittedSize(MemorySegment struct, int fieldValue) {
            struct.set(dwCommittedSize$LAYOUT, dwCommittedSize$OFFSET, fieldValue);
        }

        private static final OfInt dwUnCommittedSize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dwUnCommittedSize"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * DWORD dwUnCommittedSize
         * }
         */
        public static final OfInt dwUnCommittedSize$layout() {
            return dwUnCommittedSize$LAYOUT;
        }

        private static final long dwUnCommittedSize$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * DWORD dwUnCommittedSize
         * }
         */
        public static final long dwUnCommittedSize$offset() {
            return dwUnCommittedSize$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * DWORD dwUnCommittedSize
         * }
         */
        public static int dwUnCommittedSize(MemorySegment struct) {
            return struct.get(dwUnCommittedSize$LAYOUT, dwUnCommittedSize$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * DWORD dwUnCommittedSize
         * }
         */
        public static void dwUnCommittedSize(MemorySegment struct, int fieldValue) {
            struct.set(dwUnCommittedSize$LAYOUT, dwUnCommittedSize$OFFSET, fieldValue);
        }

        private static final AddressLayout lpFirstBlock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lpFirstBlock"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * LPVOID lpFirstBlock
         * }
         */
        public static final AddressLayout lpFirstBlock$layout() {
            return lpFirstBlock$LAYOUT;
        }

        private static final long lpFirstBlock$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * LPVOID lpFirstBlock
         * }
         */
        public static final long lpFirstBlock$offset() {
            return lpFirstBlock$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * LPVOID lpFirstBlock
         * }
         */
        public static MemorySegment lpFirstBlock(MemorySegment struct) {
            return struct.get(lpFirstBlock$LAYOUT, lpFirstBlock$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * LPVOID lpFirstBlock
         * }
         */
        public static void lpFirstBlock(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(lpFirstBlock$LAYOUT, lpFirstBlock$OFFSET, fieldValue);
        }

        private static final AddressLayout lpLastBlock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lpLastBlock"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * LPVOID lpLastBlock
         * }
         */
        public static final AddressLayout lpLastBlock$layout() {
            return lpLastBlock$LAYOUT;
        }

        private static final long lpLastBlock$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * LPVOID lpLastBlock
         * }
         */
        public static final long lpLastBlock$offset() {
            return lpLastBlock$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * LPVOID lpLastBlock
         * }
         */
        public static MemorySegment lpLastBlock(MemorySegment struct) {
            return struct.get(lpLastBlock$LAYOUT, lpLastBlock$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * LPVOID lpLastBlock
         * }
         */
        public static void lpLastBlock(MemorySegment struct, MemorySegment fieldValue) {
            struct.set(lpLastBlock$LAYOUT, lpLastBlock$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout Region$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$244:5"), groupElement("Region"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD dwCommittedSize;
     *     DWORD dwUnCommittedSize;
     *     LPVOID lpFirstBlock;
     *     LPVOID lpLastBlock;
     * } Region
     * }
     */
    public static final GroupLayout Region$layout() {
        return Region$LAYOUT;
    }

    private static final long Region$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD dwCommittedSize;
     *     DWORD dwUnCommittedSize;
     *     LPVOID lpFirstBlock;
     *     LPVOID lpLastBlock;
     * } Region
     * }
     */
    public static final long Region$offset() {
        return Region$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD dwCommittedSize;
     *     DWORD dwUnCommittedSize;
     *     LPVOID lpFirstBlock;
     *     LPVOID lpLastBlock;
     * } Region
     * }
     */
    public static MemorySegment Region(MemorySegment struct) {
        return struct.asSlice(Region$OFFSET, Region$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     DWORD dwCommittedSize;
     *     DWORD dwUnCommittedSize;
     *     LPVOID lpFirstBlock;
     *     LPVOID lpLastBlock;
     * } Region
     * }
     */
    public static void Region(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, Region$OFFSET, Region$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

