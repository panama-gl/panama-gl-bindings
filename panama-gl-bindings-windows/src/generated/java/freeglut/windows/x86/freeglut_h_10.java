// Generated by jextract

package freeglut.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h_10 extends freeglut_h_11 {

    freeglut_h_10() {
        // Should not be called directly
    }

    private static class glFogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glFogf$descriptor() {
        return glFogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glFogf$handle() {
        return glFogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glFogf$address() {
        return glFogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static void glFogf(int pname, float param) {
        var mh$ = glFogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glFogfv$descriptor() {
        return glFogfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glFogfv$handle() {
        return glFogfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glFogfv$address() {
        return glFogfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glFogfv(int pname, MemorySegment params) {
        var mh$ = glFogfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glFogi$descriptor() {
        return glFogi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glFogi$handle() {
        return glFogi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glFogi$address() {
        return glFogi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static void glFogi(int pname, int param) {
        var mh$ = glFogi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glFogiv$descriptor() {
        return glFogiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glFogiv$handle() {
        return glFogiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glFogiv$address() {
        return glFogiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static void glFogiv(int pname, MemorySegment params) {
        var mh$ = glFogiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogiv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrontFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFrontFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glFrontFace$descriptor() {
        return glFrontFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MethodHandle glFrontFace$handle() {
        return glFrontFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MemorySegment glFrontFace$address() {
        return glFrontFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static void glFrontFace(int mode) {
        var mh$ = glFrontFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrontFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor glFrustum$descriptor() {
        return glFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle glFrustum$handle() {
        return glFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment glFrustum$address() {
        return glFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void glFrustum(double left, double right, double bottom, double top, double zNear, double zFar) {
        var mh$ = glFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrustum", left, right, bottom, top, zNear, zFar);
            }
            mh$.invokeExact(left, right, bottom, top, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static FunctionDescriptor glGenLists$descriptor() {
        return glGenLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MethodHandle glGenLists$handle() {
        return glGenLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MemorySegment glGenLists$address() {
        return glGenLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static int glGenLists(int range) {
        var mh$ = glGenLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenLists", range);
            }
            return (int)mh$.invokeExact(range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static FunctionDescriptor glGenTextures$descriptor() {
        return glGenTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MethodHandle glGenTextures$handle() {
        return glGenTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MemorySegment glGenTextures$address() {
        return glGenTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static void glGenTextures(int n, MemorySegment textures) {
        var mh$ = glGenTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBooleanv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBooleanv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static FunctionDescriptor glGetBooleanv$descriptor() {
        return glGetBooleanv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MethodHandle glGetBooleanv$handle() {
        return glGetBooleanv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MemorySegment glGetBooleanv$address() {
        return glGetBooleanv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static void glGetBooleanv(int pname, MemorySegment params) {
        var mh$ = glGetBooleanv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBooleanv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glGetClipPlane$descriptor() {
        return glGetClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MethodHandle glGetClipPlane$handle() {
        return glGetClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MemorySegment glGetClipPlane$address() {
        return glGetClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static void glGetClipPlane(int plane, MemorySegment equation) {
        var mh$ = glGetClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetDoublev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetDoublev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetDoublev$descriptor() {
        return glGetDoublev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetDoublev$handle() {
        return glGetDoublev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetDoublev$address() {
        return glGetDoublev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetDoublev(int pname, MemorySegment params) {
        var mh$ = glGetDoublev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetDoublev", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static FunctionDescriptor glGetError$descriptor() {
        return glGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MethodHandle glGetError$handle() {
        return glGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MemorySegment glGetError$address() {
        return glGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static int glGetError() {
        var mh$ = glGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFloatv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetFloatv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetFloatv$descriptor() {
        return glGetFloatv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetFloatv$handle() {
        return glGetFloatv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetFloatv$address() {
        return glGetFloatv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetFloatv(int pname, MemorySegment params) {
        var mh$ = glGetFloatv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFloatv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetIntegerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetIntegerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetIntegerv$descriptor() {
        return glGetIntegerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetIntegerv$handle() {
        return glGetIntegerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetIntegerv$address() {
        return glGetIntegerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static void glGetIntegerv(int pname, MemorySegment params) {
        var mh$ = glGetIntegerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetIntegerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetLightfv$descriptor() {
        return glGetLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetLightfv$handle() {
        return glGetLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetLightfv$address() {
        return glGetLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetLightiv$descriptor() {
        return glGetLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetLightiv$handle() {
        return glGetLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetLightiv$address() {
        return glGetLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static void glGetLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMapdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static FunctionDescriptor glGetMapdv$descriptor() {
        return glGetMapdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MethodHandle glGetMapdv$handle() {
        return glGetMapdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MemorySegment glGetMapdv$address() {
        return glGetMapdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static void glGetMapdv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapdv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static FunctionDescriptor glGetMapfv$descriptor() {
        return glGetMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MethodHandle glGetMapfv$handle() {
        return glGetMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MemorySegment glGetMapfv$address() {
        return glGetMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static void glGetMapfv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapfv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMapiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static FunctionDescriptor glGetMapiv$descriptor() {
        return glGetMapiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MethodHandle glGetMapiv$handle() {
        return glGetMapiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MemorySegment glGetMapiv$address() {
        return glGetMapiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static void glGetMapiv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapiv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialfv$descriptor() {
        return glGetMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMaterialfv$handle() {
        return glGetMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMaterialfv$address() {
        return glGetMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialiv$descriptor() {
        return glGetMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMaterialiv$handle() {
        return glGetMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMaterialiv$address() {
        return glGetMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapfv$descriptor() {
        return glGetPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MethodHandle glGetPixelMapfv$handle() {
        return glGetPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MemorySegment glGetPixelMapfv$address() {
        return glGetPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static void glGetPixelMapfv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapfv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapuiv$descriptor() {
        return glGetPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MethodHandle glGetPixelMapuiv$handle() {
        return glGetPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MemorySegment glGetPixelMapuiv$address() {
        return glGetPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static void glGetPixelMapuiv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapuiv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapusv$descriptor() {
        return glGetPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MethodHandle glGetPixelMapusv$handle() {
        return glGetPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MemorySegment glGetPixelMapusv$address() {
        return glGetPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static void glGetPixelMapusv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapusv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetPointerv$descriptor() {
        return glGetPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetPointerv$handle() {
        return glGetPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetPointerv$address() {
        return glGetPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetPointerv(int pname, MemorySegment params) {
        var mh$ = glGetPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPointerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glGetPolygonStipple$descriptor() {
        return glGetPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MethodHandle glGetPolygonStipple$handle() {
        return glGetPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MemorySegment glGetPolygonStipple$address() {
        return glGetPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static void glGetPolygonStipple(MemorySegment mask) {
        var mh$ = glGetPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor glGetString$descriptor() {
        return glGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MethodHandle glGetString$handle() {
        return glGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString$address() {
        return glGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString(int name) {
        var mh$ = glGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnvfv$descriptor() {
        return glGetTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexEnvfv$handle() {
        return glGetTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexEnvfv$address() {
        return glGetTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnviv$descriptor() {
        return glGetTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexEnviv$handle() {
        return glGetTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexEnviv$address() {
        return glGetTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetTexGendv$descriptor() {
        return glGetTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetTexGendv$handle() {
        return glGetTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetTexGendv$address() {
        return glGetTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexGenfv$descriptor() {
        return glGetTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexGenfv$handle() {
        return glGetTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexGenfv$address() {
        return glGetTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexGeniv$descriptor() {
        return glGetTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexGeniv$handle() {
        return glGetTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexGeniv$address() {
        return glGetTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glGetTexImage$descriptor() {
        return glGetTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glGetTexImage$handle() {
        return glGetTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glGetTexImage$address() {
        return glGetTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glGetTexImage(int target, int level, int format, int type, MemorySegment pixels) {
        var mh$ = glGetTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexImage", target, level, format, type, pixels);
            }
            mh$.invokeExact(target, level, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexLevelParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameterfv$descriptor() {
        return glGetTexLevelParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameterfv$handle() {
        return glGetTexLevelParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameterfv$address() {
        return glGetTexLevelParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexLevelParameterfv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameterfv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexLevelParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameteriv$descriptor() {
        return glGetTexLevelParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameteriv$handle() {
        return glGetTexLevelParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameteriv$address() {
        return glGetTexLevelParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexLevelParameteriv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameteriv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterfv$descriptor() {
        return glGetTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexParameterfv$handle() {
        return glGetTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexParameterfv$address() {
        return glGetTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameteriv$descriptor() {
        return glGetTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexParameteriv$handle() {
        return glGetTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexParameteriv$address() {
        return glGetTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static FunctionDescriptor glHint$descriptor() {
        return glHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MethodHandle glHint$handle() {
        return glHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MemorySegment glHint$address() {
        return glHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static void glHint(int target, int mode) {
        var mh$ = glHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHint", target, mode);
            }
            mh$.invokeExact(target, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glIndexMask$descriptor() {
        return glIndexMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MethodHandle glIndexMask$handle() {
        return glIndexMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MemorySegment glIndexMask$address() {
        return glIndexMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static void glIndexMask(int mask) {
        var mh$ = glIndexMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glIndexPointer$descriptor() {
        return glIndexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glIndexPointer$handle() {
        return glIndexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glIndexPointer$address() {
        return glIndexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glIndexPointer(int type, int stride, MemorySegment pointer) {
        var mh$ = glIndexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexPointer", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static FunctionDescriptor glIndexd$descriptor() {
        return glIndexd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MethodHandle glIndexd$handle() {
        return glIndexd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MemorySegment glIndexd$address() {
        return glIndexd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static void glIndexd(double c) {
        var mh$ = glIndexd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexd", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static FunctionDescriptor glIndexdv$descriptor() {
        return glIndexdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MethodHandle glIndexdv$handle() {
        return glIndexdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MemorySegment glIndexdv$address() {
        return glIndexdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static void glIndexdv(MemorySegment c) {
        var mh$ = glIndexdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexdv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static FunctionDescriptor glIndexf$descriptor() {
        return glIndexf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MethodHandle glIndexf$handle() {
        return glIndexf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MemorySegment glIndexf$address() {
        return glIndexf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static void glIndexf(float c) {
        var mh$ = glIndexf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexf", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static FunctionDescriptor glIndexfv$descriptor() {
        return glIndexfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MethodHandle glIndexfv$handle() {
        return glIndexfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MemorySegment glIndexfv$address() {
        return glIndexfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static void glIndexfv(MemorySegment c) {
        var mh$ = glIndexfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexfv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static FunctionDescriptor glIndexi$descriptor() {
        return glIndexi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MethodHandle glIndexi$handle() {
        return glIndexi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MemorySegment glIndexi$address() {
        return glIndexi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static void glIndexi(int c) {
        var mh$ = glIndexi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexi", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static FunctionDescriptor glIndexiv$descriptor() {
        return glIndexiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MethodHandle glIndexiv$handle() {
        return glIndexiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MemorySegment glIndexiv$address() {
        return glIndexiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static void glIndexiv(MemorySegment c) {
        var mh$ = glIndexiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexiv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static FunctionDescriptor glIndexs$descriptor() {
        return glIndexs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MethodHandle glIndexs$handle() {
        return glIndexs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MemorySegment glIndexs$address() {
        return glIndexs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static void glIndexs(short c) {
        var mh$ = glIndexs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexs", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static FunctionDescriptor glIndexsv$descriptor() {
        return glIndexsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MethodHandle glIndexsv$handle() {
        return glIndexsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MemorySegment glIndexsv$address() {
        return glIndexsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static void glIndexsv(MemorySegment c) {
        var mh$ = glIndexsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexsv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static FunctionDescriptor glIndexub$descriptor() {
        return glIndexub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MethodHandle glIndexub$handle() {
        return glIndexub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MemorySegment glIndexub$address() {
        return glIndexub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static void glIndexub(byte c) {
        var mh$ = glIndexub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexub", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static FunctionDescriptor glIndexubv$descriptor() {
        return glIndexubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MethodHandle glIndexubv$handle() {
        return glIndexubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MemorySegment glIndexubv$address() {
        return glIndexubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static void glIndexubv(MemorySegment c) {
        var mh$ = glIndexubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexubv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInitNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glInitNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static FunctionDescriptor glInitNames$descriptor() {
        return glInitNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MethodHandle glInitNames$handle() {
        return glInitNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MemorySegment glInitNames$address() {
        return glInitNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static void glInitNames() {
        var mh$ = glInitNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInitNames");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInterleavedArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glInterleavedArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glInterleavedArrays$descriptor() {
        return glInterleavedArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glInterleavedArrays$handle() {
        return glInterleavedArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glInterleavedArrays$address() {
        return glInterleavedArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glInterleavedArrays(int format, int stride, MemorySegment pointer) {
        var mh$ = glInterleavedArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInterleavedArrays", format, stride, pointer);
            }
            mh$.invokeExact(format, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static FunctionDescriptor glIsEnabled$descriptor() {
        return glIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MethodHandle glIsEnabled$handle() {
        return glIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MemorySegment glIsEnabled$address() {
        return glIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static byte glIsEnabled(int cap) {
        var mh$ = glIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsEnabled", cap);
            }
            return (byte)mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static FunctionDescriptor glIsList$descriptor() {
        return glIsList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MethodHandle glIsList$handle() {
        return glIsList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MemorySegment glIsList$address() {
        return glIsList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static byte glIsList(int list) {
        var mh$ = glIsList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsList", list);
            }
            return (byte)mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static FunctionDescriptor glIsTexture$descriptor() {
        return glIsTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MethodHandle glIsTexture$handle() {
        return glIsTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MemorySegment glIsTexture$address() {
        return glIsTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static byte glIsTexture(int texture) {
        var mh$ = glIsTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsTexture", texture);
            }
            return (byte)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightModelf$descriptor() {
        return glLightModelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightModelf$handle() {
        return glLightModelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightModelf$address() {
        return glLightModelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static void glLightModelf(int pname, float param) {
        var mh$ = glLightModelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModelfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightModelfv$descriptor() {
        return glLightModelfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightModelfv$handle() {
        return glLightModelfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightModelfv$address() {
        return glLightModelfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightModelfv(int pname, MemorySegment params) {
        var mh$ = glLightModelfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeli {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModeli");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLightModeli$descriptor() {
        return glLightModeli.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLightModeli$handle() {
        return glLightModeli.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLightModeli$address() {
        return glLightModeli.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static void glLightModeli(int pname, int param) {
        var mh$ = glLightModeli.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeli", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeliv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModeliv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightModeliv$descriptor() {
        return glLightModeliv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightModeliv$handle() {
        return glLightModeliv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightModeliv$address() {
        return glLightModeliv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static void glLightModeliv(int pname, MemorySegment params) {
        var mh$ = glLightModeliv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeliv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightf$descriptor() {
        return glLightf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightf$handle() {
        return glLightf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightf$address() {
        return glLightf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static void glLightf(int light, int pname, float param) {
        var mh$ = glLightf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightf", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightfv$descriptor() {
        return glLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightfv$handle() {
        return glLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightfv$address() {
        return glLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLighti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLighti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLighti$descriptor() {
        return glLighti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLighti$handle() {
        return glLighti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLighti$address() {
        return glLighti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static void glLighti(int light, int pname, int param) {
        var mh$ = glLighti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLighti", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightiv$descriptor() {
        return glLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightiv$handle() {
        return glLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightiv$address() {
        return glLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static void glLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLineStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static FunctionDescriptor glLineStipple$descriptor() {
        return glLineStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MethodHandle glLineStipple$handle() {
        return glLineStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MemorySegment glLineStipple$address() {
        return glLineStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static void glLineStipple(int factor, short pattern) {
        var mh$ = glLineStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineStipple", factor, pattern);
            }
            mh$.invokeExact(factor, pattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static FunctionDescriptor glLineWidth$descriptor() {
        return glLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MethodHandle glLineWidth$handle() {
        return glLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MemorySegment glLineWidth$address() {
        return glLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static void glLineWidth(float width) {
        var mh$ = glLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glListBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glListBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static FunctionDescriptor glListBase$descriptor() {
        return glListBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MethodHandle glListBase$handle() {
        return glListBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MemorySegment glListBase$address() {
        return glListBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static void glListBase(int base) {
        var mh$ = glListBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glListBase", base);
            }
            mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static FunctionDescriptor glLoadIdentity$descriptor() {
        return glLoadIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MethodHandle glLoadIdentity$handle() {
        return glLoadIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MemorySegment glLoadIdentity$address() {
        return glLoadIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static void glLoadIdentity() {
        var mh$ = glLoadIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadIdentity");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixd$descriptor() {
        return glLoadMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glLoadMatrixd$handle() {
        return glLoadMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glLoadMatrixd$address() {
        return glLoadMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static void glLoadMatrixd(MemorySegment m) {
        var mh$ = glLoadMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixf$descriptor() {
        return glLoadMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glLoadMatrixf$handle() {
        return glLoadMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glLoadMatrixf$address() {
        return glLoadMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static void glLoadMatrixf(MemorySegment m) {
        var mh$ = glLoadMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static FunctionDescriptor glLoadName$descriptor() {
        return glLoadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MethodHandle glLoadName$handle() {
        return glLoadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MemorySegment glLoadName$address() {
        return glLoadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static void glLoadName(int name) {
        var mh$ = glLoadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLogicOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLogicOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static FunctionDescriptor glLogicOp$descriptor() {
        return glLogicOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MethodHandle glLogicOp$handle() {
        return glLogicOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MemorySegment glLogicOp$address() {
        return glLogicOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static void glLogicOp(int opcode) {
        var mh$ = glLogicOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLogicOp", opcode);
            }
            mh$.invokeExact(opcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap1d$descriptor() {
        return glMap1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap1d$handle() {
        return glMap1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap1d$address() {
        return glMap1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static void glMap1d(int target, double u1, double u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1d", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap1f$descriptor() {
        return glMap1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap1f$handle() {
        return glMap1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap1f$address() {
        return glMap1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static void glMap1f(int target, float u1, float u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1f", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap2d$descriptor() {
        return glMap2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap2d$handle() {
        return glMap2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap2d$address() {
        return glMap2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2d", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap2f$descriptor() {
        return glMap2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap2f$handle() {
        return glMap2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap2f$address() {
        return glMap2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2f", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1d$descriptor() {
        return glMapGrid1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MethodHandle glMapGrid1d$handle() {
        return glMapGrid1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MemorySegment glMapGrid1d$address() {
        return glMapGrid1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static void glMapGrid1d(int un, double u1, double u2) {
        var mh$ = glMapGrid1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1d", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1f$descriptor() {
        return glMapGrid1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MethodHandle glMapGrid1f$handle() {
        return glMapGrid1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MemorySegment glMapGrid1f$address() {
        return glMapGrid1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static void glMapGrid1f(int un, float u1, float u2) {
        var mh$ = glMapGrid1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1f", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2d$descriptor() {
        return glMapGrid2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MethodHandle glMapGrid2d$handle() {
        return glMapGrid2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MemorySegment glMapGrid2d$address() {
        return glMapGrid2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
        var mh$ = glMapGrid2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2d", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2f$descriptor() {
        return glMapGrid2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glMapGrid2f$handle() {
        return glMapGrid2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glMapGrid2f$address() {
        return glMapGrid2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
        var mh$ = glMapGrid2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2f", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMaterialf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glMaterialf$descriptor() {
        return glMaterialf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glMaterialf$handle() {
        return glMaterialf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glMaterialf$address() {
        return glMaterialf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static void glMaterialf(int face, int pname, float param) {
        var mh$ = glMaterialf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialf", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glMaterialfv$descriptor() {
        return glMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glMaterialfv$handle() {
        return glMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glMaterialfv$address() {
        return glMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMateriali {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMateriali");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glMateriali$descriptor() {
        return glMateriali.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glMateriali$handle() {
        return glMateriali.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glMateriali$address() {
        return glMateriali.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static void glMateriali(int face, int pname, int param) {
        var mh$ = glMateriali.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMateriali", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glMaterialiv$descriptor() {
        return glMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glMaterialiv$handle() {
        return glMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glMaterialiv$address() {
        return glMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static void glMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMatrixMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMatrixMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glMatrixMode$descriptor() {
        return glMatrixMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MethodHandle glMatrixMode$handle() {
        return glMatrixMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MemorySegment glMatrixMode$address() {
        return glMatrixMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static void glMatrixMode(int mode) {
        var mh$ = glMatrixMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMatrixMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixd$descriptor() {
        return glMultMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glMultMatrixd$handle() {
        return glMultMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glMultMatrixd$address() {
        return glMultMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static void glMultMatrixd(MemorySegment m) {
        var mh$ = glMultMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixf$descriptor() {
        return glMultMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glMultMatrixf$handle() {
        return glMultMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glMultMatrixf$address() {
        return glMultMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static void glMultMatrixf(MemorySegment m) {
        var mh$ = glMultMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNewList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNewList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static FunctionDescriptor glNewList$descriptor() {
        return glNewList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MethodHandle glNewList$handle() {
        return glNewList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MemorySegment glNewList$address() {
        return glNewList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static void glNewList(int list, int mode) {
        var mh$ = glNewList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNewList", list, mode);
            }
            mh$.invokeExact(list, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static FunctionDescriptor glNormal3b$descriptor() {
        return glNormal3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MethodHandle glNormal3b$handle() {
        return glNormal3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MemorySegment glNormal3b$address() {
        return glNormal3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static void glNormal3b(byte nx, byte ny, byte nz) {
        var mh$ = glNormal3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3b", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glNormal3bv$descriptor() {
        return glNormal3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glNormal3bv$handle() {
        return glNormal3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glNormal3bv$address() {
        return glNormal3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static void glNormal3bv(MemorySegment v) {
        var mh$ = glNormal3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static FunctionDescriptor glNormal3d$descriptor() {
        return glNormal3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MethodHandle glNormal3d$handle() {
        return glNormal3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MemorySegment glNormal3d$address() {
        return glNormal3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static void glNormal3d(double nx, double ny, double nz) {
        var mh$ = glNormal3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3d", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glNormal3dv$descriptor() {
        return glNormal3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glNormal3dv$handle() {
        return glNormal3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glNormal3dv$address() {
        return glNormal3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static void glNormal3dv(MemorySegment v) {
        var mh$ = glNormal3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static FunctionDescriptor glNormal3f$descriptor() {
        return glNormal3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MethodHandle glNormal3f$handle() {
        return glNormal3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MemorySegment glNormal3f$address() {
        return glNormal3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static void glNormal3f(float nx, float ny, float nz) {
        var mh$ = glNormal3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3f", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glNormal3fv$descriptor() {
        return glNormal3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glNormal3fv$handle() {
        return glNormal3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glNormal3fv$address() {
        return glNormal3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static void glNormal3fv(MemorySegment v) {
        var mh$ = glNormal3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static FunctionDescriptor glNormal3i$descriptor() {
        return glNormal3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MethodHandle glNormal3i$handle() {
        return glNormal3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MemorySegment glNormal3i$address() {
        return glNormal3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static void glNormal3i(int nx, int ny, int nz) {
        var mh$ = glNormal3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3i", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glNormal3iv$descriptor() {
        return glNormal3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MethodHandle glNormal3iv$handle() {
        return glNormal3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MemorySegment glNormal3iv$address() {
        return glNormal3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static void glNormal3iv(MemorySegment v) {
        var mh$ = glNormal3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static FunctionDescriptor glNormal3s$descriptor() {
        return glNormal3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MethodHandle glNormal3s$handle() {
        return glNormal3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MemorySegment glNormal3s$address() {
        return glNormal3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static void glNormal3s(short nx, short ny, short nz) {
        var mh$ = glNormal3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3s", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glNormal3sv$descriptor() {
        return glNormal3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glNormal3sv$handle() {
        return glNormal3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glNormal3sv$address() {
        return glNormal3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static void glNormal3sv(MemorySegment v) {
        var mh$ = glNormal3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormalPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormalPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glNormalPointer$descriptor() {
        return glNormalPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glNormalPointer$handle() {
        return glNormalPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glNormalPointer$address() {
        return glNormalPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glNormalPointer(int type, int stride, MemorySegment pointer) {
        var mh$ = glNormalPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormalPointer", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor glOrtho$descriptor() {
        return glOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle glOrtho$handle() {
        return glOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment glOrtho$address() {
        return glOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void glOrtho(double left, double right, double bottom, double top, double zNear, double zFar) {
        var mh$ = glOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glOrtho", left, right, bottom, top, zNear, zFar);
            }
            mh$.invokeExact(left, right, bottom, top, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPassThrough {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPassThrough");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static FunctionDescriptor glPassThrough$descriptor() {
        return glPassThrough.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MethodHandle glPassThrough$handle() {
        return glPassThrough.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MemorySegment glPassThrough$address() {
        return glPassThrough.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static void glPassThrough(float token) {
        var mh$ = glPassThrough.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPassThrough", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static FunctionDescriptor glPixelMapfv$descriptor() {
        return glPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MethodHandle glPixelMapfv$handle() {
        return glPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MemorySegment glPixelMapfv$address() {
        return glPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static void glPixelMapfv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapfv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static FunctionDescriptor glPixelMapuiv$descriptor() {
        return glPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MethodHandle glPixelMapuiv$handle() {
        return glPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MemorySegment glPixelMapuiv$address() {
        return glPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static void glPixelMapuiv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapuiv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static FunctionDescriptor glPixelMapusv$descriptor() {
        return glPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MethodHandle glPixelMapusv$handle() {
        return glPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MemorySegment glPixelMapusv$address() {
        return glPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static void glPixelMapusv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapusv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStoref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelStoref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelStoref$descriptor() {
        return glPixelStoref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelStoref$handle() {
        return glPixelStoref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelStoref$address() {
        return glPixelStoref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelStoref(int pname, float param) {
        var mh$ = glPixelStoref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStoref", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStorei {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelStorei");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelStorei$descriptor() {
        return glPixelStorei.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelStorei$handle() {
        return glPixelStorei.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelStorei$address() {
        return glPixelStorei.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static void glPixelStorei(int pname, int param) {
        var mh$ = glPixelStorei.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStorei", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelTransferf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelTransferf$descriptor() {
        return glPixelTransferf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelTransferf$handle() {
        return glPixelTransferf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelTransferf$address() {
        return glPixelTransferf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelTransferf(int pname, float param) {
        var mh$ = glPixelTransferf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelTransferi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelTransferi$descriptor() {
        return glPixelTransferi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelTransferi$handle() {
        return glPixelTransferi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelTransferi$address() {
        return glPixelTransferi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static void glPixelTransferi(int pname, int param) {
        var mh$ = glPixelTransferi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static FunctionDescriptor glPixelZoom$descriptor() {
        return glPixelZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MethodHandle glPixelZoom$handle() {
        return glPixelZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MemorySegment glPixelZoom$address() {
        return glPixelZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static void glPixelZoom(float xfactor, float yfactor) {
        var mh$ = glPixelZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelZoom", xfactor, yfactor);
            }
            mh$.invokeExact(xfactor, yfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static FunctionDescriptor glPointSize$descriptor() {
        return glPointSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MethodHandle glPointSize$handle() {
        return glPointSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MemorySegment glPointSize$address() {
        return glPointSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static void glPointSize(float size) {
        var mh$ = glPointSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointSize", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPolygonMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glPolygonMode$descriptor() {
        return glPolygonMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glPolygonMode$handle() {
        return glPolygonMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glPolygonMode$address() {
        return glPolygonMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static void glPolygonMode(int face, int mode) {
        var mh$ = glPolygonMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonMode", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPolygonOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static FunctionDescriptor glPolygonOffset$descriptor() {
        return glPolygonOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MethodHandle glPolygonOffset$handle() {
        return glPolygonOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MemorySegment glPolygonOffset$address() {
        return glPolygonOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static void glPolygonOffset(float factor, float units) {
        var mh$ = glPolygonOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonOffset", factor, units);
            }
            mh$.invokeExact(factor, units);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glPolygonStipple$descriptor() {
        return glPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MethodHandle glPolygonStipple$handle() {
        return glPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MemorySegment glPolygonStipple$address() {
        return glPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static void glPolygonStipple(MemorySegment mask) {
        var mh$ = glPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static FunctionDescriptor glPopAttrib$descriptor() {
        return glPopAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MethodHandle glPopAttrib$handle() {
        return glPopAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MemorySegment glPopAttrib$address() {
        return glPopAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static void glPopAttrib() {
        var mh$ = glPopAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static FunctionDescriptor glPopClientAttrib$descriptor() {
        return glPopClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MethodHandle glPopClientAttrib$handle() {
        return glPopClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MemorySegment glPopClientAttrib$address() {
        return glPopClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static void glPopClientAttrib() {
        var mh$ = glPopClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopClientAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static FunctionDescriptor glPopMatrix$descriptor() {
        return glPopMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MethodHandle glPopMatrix$handle() {
        return glPopMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MemorySegment glPopMatrix$address() {
        return glPopMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static void glPopMatrix() {
        var mh$ = glPopMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static FunctionDescriptor glPopName$descriptor() {
        return glPopName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MethodHandle glPopName$handle() {
        return glPopName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MemorySegment glPopName$address() {
        return glPopName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static void glPopName() {
        var mh$ = glPopName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopName");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPrioritizeTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPrioritizeTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static FunctionDescriptor glPrioritizeTextures$descriptor() {
        return glPrioritizeTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MethodHandle glPrioritizeTextures$handle() {
        return glPrioritizeTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MemorySegment glPrioritizeTextures$address() {
        return glPrioritizeTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static void glPrioritizeTextures(int n, MemorySegment textures, MemorySegment priorities) {
        var mh$ = glPrioritizeTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPrioritizeTextures", n, textures, priorities);
            }
            mh$.invokeExact(n, textures, priorities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushAttrib$descriptor() {
        return glPushAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushAttrib$handle() {
        return glPushAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushAttrib$address() {
        return glPushAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static void glPushAttrib(int mask) {
        var mh$ = glPushAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushClientAttrib$descriptor() {
        return glPushClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushClientAttrib$handle() {
        return glPushClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushClientAttrib$address() {
        return glPushClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static void glPushClientAttrib(int mask) {
        var mh$ = glPushClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushClientAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static FunctionDescriptor glPushMatrix$descriptor() {
        return glPushMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MethodHandle glPushMatrix$handle() {
        return glPushMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MemorySegment glPushMatrix$address() {
        return glPushMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static void glPushMatrix() {
        var mh$ = glPushMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static FunctionDescriptor glPushName$descriptor() {
        return glPushName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MethodHandle glPushName$handle() {
        return glPushName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MemorySegment glPushName$address() {
        return glPushName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static void glPushName(int name) {
        var mh$ = glPushName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glRasterPos2d$descriptor() {
        return glRasterPos2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glRasterPos2d$handle() {
        return glRasterPos2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glRasterPos2d$address() {
        return glRasterPos2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glRasterPos2d(double x, double y) {
        var mh$ = glRasterPos2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2dv$descriptor() {
        return glRasterPos2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos2dv$handle() {
        return glRasterPos2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos2dv$address() {
        return glRasterPos2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos2dv(MemorySegment v) {
        var mh$ = glRasterPos2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glRasterPos2f$descriptor() {
        return glRasterPos2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glRasterPos2f$handle() {
        return glRasterPos2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glRasterPos2f$address() {
        return glRasterPos2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glRasterPos2f(float x, float y) {
        var mh$ = glRasterPos2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2fv$descriptor() {
        return glRasterPos2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos2fv$handle() {
        return glRasterPos2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos2fv$address() {
        return glRasterPos2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos2fv(MemorySegment v) {
        var mh$ = glRasterPos2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glRasterPos2i$descriptor() {
        return glRasterPos2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glRasterPos2i$handle() {
        return glRasterPos2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glRasterPos2i$address() {
        return glRasterPos2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static void glRasterPos2i(int x, int y) {
        var mh$ = glRasterPos2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2iv$descriptor() {
        return glRasterPos2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos2iv$handle() {
        return glRasterPos2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos2iv$address() {
        return glRasterPos2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static void glRasterPos2iv(MemorySegment v) {
        var mh$ = glRasterPos2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glRasterPos2s$descriptor() {
        return glRasterPos2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glRasterPos2s$handle() {
        return glRasterPos2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glRasterPos2s$address() {
        return glRasterPos2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static void glRasterPos2s(short x, short y) {
        var mh$ = glRasterPos2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2sv$descriptor() {
        return glRasterPos2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos2sv$handle() {
        return glRasterPos2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos2sv$address() {
        return glRasterPos2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static void glRasterPos2sv(MemorySegment v) {
        var mh$ = glRasterPos2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRasterPos3d$descriptor() {
        return glRasterPos3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRasterPos3d$handle() {
        return glRasterPos3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRasterPos3d$address() {
        return glRasterPos3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRasterPos3d(double x, double y, double z) {
        var mh$ = glRasterPos3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3dv$descriptor() {
        return glRasterPos3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos3dv$handle() {
        return glRasterPos3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos3dv$address() {
        return glRasterPos3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos3dv(MemorySegment v) {
        var mh$ = glRasterPos3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRasterPos3f$descriptor() {
        return glRasterPos3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRasterPos3f$handle() {
        return glRasterPos3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRasterPos3f$address() {
        return glRasterPos3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRasterPos3f(float x, float y, float z) {
        var mh$ = glRasterPos3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3fv$descriptor() {
        return glRasterPos3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos3fv$handle() {
        return glRasterPos3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos3fv$address() {
        return glRasterPos3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos3fv(MemorySegment v) {
        var mh$ = glRasterPos3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glRasterPos3i$descriptor() {
        return glRasterPos3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glRasterPos3i$handle() {
        return glRasterPos3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glRasterPos3i$address() {
        return glRasterPos3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glRasterPos3i(int x, int y, int z) {
        var mh$ = glRasterPos3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3iv$descriptor() {
        return glRasterPos3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos3iv$handle() {
        return glRasterPos3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos3iv$address() {
        return glRasterPos3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static void glRasterPos3iv(MemorySegment v) {
        var mh$ = glRasterPos3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glRasterPos3s$descriptor() {
        return glRasterPos3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glRasterPos3s$handle() {
        return glRasterPos3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glRasterPos3s$address() {
        return glRasterPos3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glRasterPos3s(short x, short y, short z) {
        var mh$ = glRasterPos3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3sv$descriptor() {
        return glRasterPos3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos3sv$handle() {
        return glRasterPos3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos3sv$address() {
        return glRasterPos3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static void glRasterPos3sv(MemorySegment v) {
        var mh$ = glRasterPos3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glRasterPos4d$descriptor() {
        return glRasterPos4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glRasterPos4d$handle() {
        return glRasterPos4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glRasterPos4d$address() {
        return glRasterPos4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glRasterPos4d(double x, double y, double z, double w) {
        var mh$ = glRasterPos4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4dv$descriptor() {
        return glRasterPos4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos4dv$handle() {
        return glRasterPos4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos4dv$address() {
        return glRasterPos4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos4dv(MemorySegment v) {
        var mh$ = glRasterPos4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glRasterPos4f$descriptor() {
        return glRasterPos4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glRasterPos4f$handle() {
        return glRasterPos4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glRasterPos4f$address() {
        return glRasterPos4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glRasterPos4f(float x, float y, float z, float w) {
        var mh$ = glRasterPos4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4fv$descriptor() {
        return glRasterPos4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos4fv$handle() {
        return glRasterPos4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos4fv$address() {
        return glRasterPos4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos4fv(MemorySegment v) {
        var mh$ = glRasterPos4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glRasterPos4i$descriptor() {
        return glRasterPos4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glRasterPos4i$handle() {
        return glRasterPos4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glRasterPos4i$address() {
        return glRasterPos4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glRasterPos4i(int x, int y, int z, int w) {
        var mh$ = glRasterPos4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4iv$descriptor() {
        return glRasterPos4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos4iv$handle() {
        return glRasterPos4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos4iv$address() {
        return glRasterPos4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static void glRasterPos4iv(MemorySegment v) {
        var mh$ = glRasterPos4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glRasterPos4s$descriptor() {
        return glRasterPos4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glRasterPos4s$handle() {
        return glRasterPos4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glRasterPos4s$address() {
        return glRasterPos4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glRasterPos4s(short x, short y, short z, short w) {
        var mh$ = glRasterPos4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4sv$descriptor() {
        return glRasterPos4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos4sv$handle() {
        return glRasterPos4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos4sv$address() {
        return glRasterPos4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static void glRasterPos4sv(MemorySegment v) {
        var mh$ = glRasterPos4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glReadBuffer$descriptor() {
        return glReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glReadBuffer$handle() {
        return glReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glReadBuffer$address() {
        return glReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static void glReadBuffer(int mode) {
        var mh$ = glReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glReadPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glReadPixels$descriptor() {
        return glReadPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glReadPixels$handle() {
        return glReadPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glReadPixels$address() {
        return glReadPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glReadPixels(int x, int y, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glReadPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadPixels", x, y, width, height, format, type, pixels);
            }
            mh$.invokeExact(x, y, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static FunctionDescriptor glRectd$descriptor() {
        return glRectd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MethodHandle glRectd$handle() {
        return glRectd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MemorySegment glRectd$address() {
        return glRectd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static void glRectd(double x1, double y1, double x2, double y2) {
        var mh$ = glRectd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectd", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static FunctionDescriptor glRectdv$descriptor() {
        return glRectdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MethodHandle glRectdv$handle() {
        return glRectdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MemorySegment glRectdv$address() {
        return glRectdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static void glRectdv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectdv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static FunctionDescriptor glRectf$descriptor() {
        return glRectf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MethodHandle glRectf$handle() {
        return glRectf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MemorySegment glRectf$address() {
        return glRectf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static void glRectf(float x1, float y1, float x2, float y2) {
        var mh$ = glRectf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectf", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static FunctionDescriptor glRectfv$descriptor() {
        return glRectfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MethodHandle glRectfv$handle() {
        return glRectfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MemorySegment glRectfv$address() {
        return glRectfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static void glRectfv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectfv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRecti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRecti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static FunctionDescriptor glRecti$descriptor() {
        return glRecti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MethodHandle glRecti$handle() {
        return glRecti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MemorySegment glRecti$address() {
        return glRecti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static void glRecti(int x1, int y1, int x2, int y2) {
        var mh$ = glRecti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRecti", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static FunctionDescriptor glRectiv$descriptor() {
        return glRectiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MethodHandle glRectiv$handle() {
        return glRectiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MemorySegment glRectiv$address() {
        return glRectiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static void glRectiv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectiv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static FunctionDescriptor glRects$descriptor() {
        return glRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MethodHandle glRects$handle() {
        return glRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MemorySegment glRects$address() {
        return glRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static void glRects(short x1, short y1, short x2, short y2) {
        var mh$ = glRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRects", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static FunctionDescriptor glRectsv$descriptor() {
        return glRectsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MethodHandle glRectsv$handle() {
        return glRectsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MemorySegment glRectsv$address() {
        return glRectsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static void glRectsv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectsv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRenderMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glRenderMode$descriptor() {
        return glRenderMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MethodHandle glRenderMode$handle() {
        return glRenderMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MemorySegment glRenderMode$address() {
        return glRenderMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static int glRenderMode(int mode) {
        var mh$ = glRenderMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderMode", mode);
            }
            return (int)mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRotated$descriptor() {
        return glRotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRotated$handle() {
        return glRotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRotated$address() {
        return glRotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRotated(double angle, double x, double y, double z) {
        var mh$ = glRotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotated", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRotatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRotatef$descriptor() {
        return glRotatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRotatef$handle() {
        return glRotatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRotatef$address() {
        return glRotatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRotatef(float angle, float x, float y, float z) {
        var mh$ = glRotatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotatef", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glScaled$descriptor() {
        return glScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glScaled$handle() {
        return glScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glScaled$address() {
        return glScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glScaled(double x, double y, double z) {
        var mh$ = glScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScaled", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScalef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glScalef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glScalef$descriptor() {
        return glScalef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glScalef$handle() {
        return glScalef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glScalef$address() {
        return glScalef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glScalef(float x, float y, float z) {
        var mh$ = glScalef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScalef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glScissor$descriptor() {
        return glScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glScissor$handle() {
        return glScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glScissor$address() {
        return glScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glScissor(int x, int y, int width, int height) {
        var mh$ = glScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScissor", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSelectBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSelectBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static FunctionDescriptor glSelectBuffer$descriptor() {
        return glSelectBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MethodHandle glSelectBuffer$handle() {
        return glSelectBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MemorySegment glSelectBuffer$address() {
        return glSelectBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static void glSelectBuffer(int size, MemorySegment buffer) {
        var mh$ = glSelectBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSelectBuffer", size, buffer);
            }
            mh$.invokeExact(size, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShadeModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glShadeModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static FunctionDescriptor glShadeModel$descriptor() {
        return glShadeModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MethodHandle glShadeModel$handle() {
        return glShadeModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MemorySegment glShadeModel$address() {
        return glShadeModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static void glShadeModel(int mode) {
        var mh$ = glShadeModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShadeModel", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFunc$descriptor() {
        return glStencilFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFunc$handle() {
        return glStencilFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFunc$address() {
        return glStencilFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFunc(int func, int ref, int mask) {
        var mh$ = glStencilFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFunc", func, ref, mask);
            }
            mh$.invokeExact(func, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilMask$descriptor() {
        return glStencilMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MethodHandle glStencilMask$handle() {
        return glStencilMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MemorySegment glStencilMask$address() {
        return glStencilMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static void glStencilMask(int mask) {
        var mh$ = glStencilMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static FunctionDescriptor glStencilOp$descriptor() {
        return glStencilOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MethodHandle glStencilOp$handle() {
        return glStencilOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MemorySegment glStencilOp$address() {
        return glStencilOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static void glStencilOp(int fail, int zfail, int zpass) {
        var mh$ = glStencilOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOp", fail, zfail, zpass);
            }
            mh$.invokeExact(fail, zfail, zpass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static FunctionDescriptor glTexCoord1d$descriptor() {
        return glTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MethodHandle glTexCoord1d$handle() {
        return glTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MemorySegment glTexCoord1d$address() {
        return glTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static void glTexCoord1d(double s) {
        var mh$ = glTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1d", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1dv$descriptor() {
        return glTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord1dv$handle() {
        return glTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord1dv$address() {
        return glTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord1dv(MemorySegment v) {
        var mh$ = glTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static FunctionDescriptor glTexCoord1f$descriptor() {
        return glTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MethodHandle glTexCoord1f$handle() {
        return glTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MemorySegment glTexCoord1f$address() {
        return glTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static void glTexCoord1f(float s) {
        var mh$ = glTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1f", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1fv$descriptor() {
        return glTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord1fv$handle() {
        return glTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord1fv$address() {
        return glTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord1fv(MemorySegment v) {
        var mh$ = glTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static FunctionDescriptor glTexCoord1i$descriptor() {
        return glTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MethodHandle glTexCoord1i$handle() {
        return glTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MemorySegment glTexCoord1i$address() {
        return glTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static void glTexCoord1i(int s) {
        var mh$ = glTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1i", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1iv$descriptor() {
        return glTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord1iv$handle() {
        return glTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord1iv$address() {
        return glTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static void glTexCoord1iv(MemorySegment v) {
        var mh$ = glTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static FunctionDescriptor glTexCoord1s$descriptor() {
        return glTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MethodHandle glTexCoord1s$handle() {
        return glTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MemorySegment glTexCoord1s$address() {
        return glTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static void glTexCoord1s(short s) {
        var mh$ = glTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1s", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1sv$descriptor() {
        return glTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord1sv$handle() {
        return glTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord1sv$address() {
        return glTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static void glTexCoord1sv(MemorySegment v) {
        var mh$ = glTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glTexCoord2d$descriptor() {
        return glTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glTexCoord2d$handle() {
        return glTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glTexCoord2d$address() {
        return glTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static void glTexCoord2d(double s, double t) {
        var mh$ = glTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2d", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2dv$descriptor() {
        return glTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord2dv$handle() {
        return glTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord2dv$address() {
        return glTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord2dv(MemorySegment v) {
        var mh$ = glTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glTexCoord2f$descriptor() {
        return glTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glTexCoord2f$handle() {
        return glTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glTexCoord2f$address() {
        return glTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static void glTexCoord2f(float s, float t) {
        var mh$ = glTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2f", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2fv$descriptor() {
        return glTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord2fv$handle() {
        return glTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord2fv$address() {
        return glTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord2fv(MemorySegment v) {
        var mh$ = glTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glTexCoord2i$descriptor() {
        return glTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MethodHandle glTexCoord2i$handle() {
        return glTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MemorySegment glTexCoord2i$address() {
        return glTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static void glTexCoord2i(int s, int t) {
        var mh$ = glTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2i", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2iv$descriptor() {
        return glTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord2iv$handle() {
        return glTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord2iv$address() {
        return glTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static void glTexCoord2iv(MemorySegment v) {
        var mh$ = glTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glTexCoord2s$descriptor() {
        return glTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glTexCoord2s$handle() {
        return glTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glTexCoord2s$address() {
        return glTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static void glTexCoord2s(short s, short t) {
        var mh$ = glTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2s", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2sv$descriptor() {
        return glTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord2sv$handle() {
        return glTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord2sv$address() {
        return glTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static void glTexCoord2sv(MemorySegment v) {
        var mh$ = glTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glTexCoord3d$descriptor() {
        return glTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glTexCoord3d$handle() {
        return glTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glTexCoord3d$address() {
        return glTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glTexCoord3d(double s, double t, double r) {
        var mh$ = glTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3d", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3dv$descriptor() {
        return glTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord3dv$handle() {
        return glTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord3dv$address() {
        return glTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord3dv(MemorySegment v) {
        var mh$ = glTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glTexCoord3f$descriptor() {
        return glTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glTexCoord3f$handle() {
        return glTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glTexCoord3f$address() {
        return glTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glTexCoord3f(float s, float t, float r) {
        var mh$ = glTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3f", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3fv$descriptor() {
        return glTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord3fv$handle() {
        return glTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord3fv$address() {
        return glTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord3fv(MemorySegment v) {
        var mh$ = glTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glTexCoord3i$descriptor() {
        return glTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glTexCoord3i$handle() {
        return glTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glTexCoord3i$address() {
        return glTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static void glTexCoord3i(int s, int t, int r) {
        var mh$ = glTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3i", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3iv$descriptor() {
        return glTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord3iv$handle() {
        return glTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord3iv$address() {
        return glTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static void glTexCoord3iv(MemorySegment v) {
        var mh$ = glTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glTexCoord3s$descriptor() {
        return glTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glTexCoord3s$handle() {
        return glTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glTexCoord3s$address() {
        return glTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glTexCoord3s(short s, short t, short r) {
        var mh$ = glTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3s", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3sv$descriptor() {
        return glTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord3sv$handle() {
        return glTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord3sv$address() {
        return glTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static void glTexCoord3sv(MemorySegment v) {
        var mh$ = glTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glTexCoord4d$descriptor() {
        return glTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glTexCoord4d$handle() {
        return glTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glTexCoord4d$address() {
        return glTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glTexCoord4d(double s, double t, double r, double q) {
        var mh$ = glTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4d", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4dv$descriptor() {
        return glTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord4dv$handle() {
        return glTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord4dv$address() {
        return glTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord4dv(MemorySegment v) {
        var mh$ = glTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glTexCoord4f$descriptor() {
        return glTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glTexCoord4f$handle() {
        return glTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glTexCoord4f$address() {
        return glTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glTexCoord4f(float s, float t, float r, float q) {
        var mh$ = glTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4f", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4fv$descriptor() {
        return glTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord4fv$handle() {
        return glTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord4fv$address() {
        return glTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord4fv(MemorySegment v) {
        var mh$ = glTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glTexCoord4i$descriptor() {
        return glTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glTexCoord4i$handle() {
        return glTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glTexCoord4i$address() {
        return glTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glTexCoord4i(int s, int t, int r, int q) {
        var mh$ = glTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4i", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4iv$descriptor() {
        return glTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord4iv$handle() {
        return glTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord4iv$address() {
        return glTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static void glTexCoord4iv(MemorySegment v) {
        var mh$ = glTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glTexCoord4s$descriptor() {
        return glTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glTexCoord4s$handle() {
        return glTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glTexCoord4s$address() {
        return glTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glTexCoord4s(short s, short t, short r, short q) {
        var mh$ = glTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4s", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4sv$descriptor() {
        return glTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord4sv$handle() {
        return glTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord4sv$address() {
        return glTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static void glTexCoord4sv(MemorySegment v) {
        var mh$ = glTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoordPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoordPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glTexCoordPointer$descriptor() {
        return glTexCoordPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glTexCoordPointer$handle() {
        return glTexCoordPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glTexCoordPointer$address() {
        return glTexCoordPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glTexCoordPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glTexCoordPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoordPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnvf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexEnvf$descriptor() {
        return glTexEnvf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexEnvf$handle() {
        return glTexEnvf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexEnvf$address() {
        return glTexEnvf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexEnvf(int target, int pname, float param) {
        var mh$ = glTexEnvf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexEnvfv$descriptor() {
        return glTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexEnvfv$handle() {
        return glTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexEnvfv$address() {
        return glTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnvi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexEnvi$descriptor() {
        return glTexEnvi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexEnvi$handle() {
        return glTexEnvi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexEnvi$address() {
        return glTexEnvi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexEnvi(int target, int pname, int param) {
        var mh$ = glTexEnvi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvi", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexEnviv$descriptor() {
        return glTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexEnviv$handle() {
        return glTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexEnviv$address() {
        return glTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static FunctionDescriptor glTexGend$descriptor() {
        return glTexGend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MethodHandle glTexGend$handle() {
        return glTexGend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MemorySegment glTexGend$address() {
        return glTexGend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static void glTexGend(int coord, int pname, double param) {
        var mh$ = glTexGend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGend", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glTexGendv$descriptor() {
        return glTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MethodHandle glTexGendv$handle() {
        return glTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MemorySegment glTexGendv$address() {
        return glTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static void glTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGenf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexGenf$descriptor() {
        return glTexGenf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexGenf$handle() {
        return glTexGenf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexGenf$address() {
        return glTexGenf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexGenf(int coord, int pname, float param) {
        var mh$ = glTexGenf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenf", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexGenfv$descriptor() {
        return glTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexGenfv$handle() {
        return glTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexGenfv$address() {
        return glTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGeni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexGeni$descriptor() {
        return glTexGeni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexGeni$handle() {
        return glTexGeni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexGeni$address() {
        return glTexGeni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static void glTexGeni(int coord, int pname, int param) {
        var mh$ = glTexGeni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeni", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexGeniv$descriptor() {
        return glTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexGeniv$handle() {
        return glTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexGeniv$address() {
        return glTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage1D$descriptor() {
        return glTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage1D$handle() {
        return glTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage1D$address() {
        return glTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage1D(int target, int level, int internalformat, int width, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage1D", target, level, internalformat, width, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalformat, width, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage2D$descriptor() {
        return glTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage2D$handle() {
        return glTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage2D$address() {
        return glTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage2D", target, level, internalformat, width, height, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexParameterf$descriptor() {
        return glTexParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexParameterf$handle() {
        return glTexParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexParameterf$address() {
        return glTexParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexParameterf(int target, int pname, float param) {
        var mh$ = glTexParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexParameterfv$descriptor() {
        return glTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexParameterfv$handle() {
        return glTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexParameterfv$address() {
        return glTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexParameteri$descriptor() {
        return glTexParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexParameteri$handle() {
        return glTexParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexParameteri$address() {
        return glTexParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexParameteri(int target, int pname, int param) {
        var mh$ = glTexParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteri", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexParameteriv$descriptor() {
        return glTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexParameteriv$handle() {
        return glTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexParameteriv$address() {
        return glTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage1D$descriptor() {
        return glTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage1D$handle() {
        return glTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage1D$address() {
        return glTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage1D", target, level, xoffset, width, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, width, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage2D$descriptor() {
        return glTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage2D$handle() {
        return glTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage2D$address() {
        return glTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage2D", target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTranslated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glTranslated$descriptor() {
        return glTranslated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glTranslated$handle() {
        return glTranslated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glTranslated$address() {
        return glTranslated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glTranslated(double x, double y, double z) {
        var mh$ = glTranslated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslated", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTranslatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glTranslatef$descriptor() {
        return glTranslatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glTranslatef$handle() {
        return glTranslatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glTranslatef$address() {
        return glTranslatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glTranslatef(float x, float y, float z) {
        var mh$ = glTranslatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslatef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glVertex2d$descriptor() {
        return glVertex2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glVertex2d$handle() {
        return glVertex2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glVertex2d$address() {
        return glVertex2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glVertex2d(double x, double y) {
        var mh$ = glVertex2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex2dv$descriptor() {
        return glVertex2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex2dv$handle() {
        return glVertex2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex2dv$address() {
        return glVertex2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static void glVertex2dv(MemorySegment v) {
        var mh$ = glVertex2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glVertex2f$descriptor() {
        return glVertex2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glVertex2f$handle() {
        return glVertex2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glVertex2f$address() {
        return glVertex2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glVertex2f(float x, float y) {
        var mh$ = glVertex2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex2fv$descriptor() {
        return glVertex2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex2fv$handle() {
        return glVertex2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex2fv$address() {
        return glVertex2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static void glVertex2fv(MemorySegment v) {
        var mh$ = glVertex2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glVertex2i$descriptor() {
        return glVertex2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glVertex2i$handle() {
        return glVertex2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glVertex2i$address() {
        return glVertex2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static void glVertex2i(int x, int y) {
        var mh$ = glVertex2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex2iv$descriptor() {
        return glVertex2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex2iv$handle() {
        return glVertex2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex2iv$address() {
        return glVertex2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static void glVertex2iv(MemorySegment v) {
        var mh$ = glVertex2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glVertex2s$descriptor() {
        return glVertex2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glVertex2s$handle() {
        return glVertex2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glVertex2s$address() {
        return glVertex2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static void glVertex2s(short x, short y) {
        var mh$ = glVertex2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex2sv$descriptor() {
        return glVertex2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex2sv$handle() {
        return glVertex2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex2sv$address() {
        return glVertex2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static void glVertex2sv(MemorySegment v) {
        var mh$ = glVertex2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glVertex3d$descriptor() {
        return glVertex3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glVertex3d$handle() {
        return glVertex3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glVertex3d$address() {
        return glVertex3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glVertex3d(double x, double y, double z) {
        var mh$ = glVertex3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex3dv$descriptor() {
        return glVertex3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex3dv$handle() {
        return glVertex3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex3dv$address() {
        return glVertex3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static void glVertex3dv(MemorySegment v) {
        var mh$ = glVertex3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glVertex3f$descriptor() {
        return glVertex3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glVertex3f$handle() {
        return glVertex3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glVertex3f$address() {
        return glVertex3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glVertex3f(float x, float y, float z) {
        var mh$ = glVertex3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex3fv$descriptor() {
        return glVertex3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex3fv$handle() {
        return glVertex3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex3fv$address() {
        return glVertex3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static void glVertex3fv(MemorySegment v) {
        var mh$ = glVertex3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glVertex3i$descriptor() {
        return glVertex3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glVertex3i$handle() {
        return glVertex3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glVertex3i$address() {
        return glVertex3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glVertex3i(int x, int y, int z) {
        var mh$ = glVertex3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex3iv$descriptor() {
        return glVertex3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex3iv$handle() {
        return glVertex3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex3iv$address() {
        return glVertex3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static void glVertex3iv(MemorySegment v) {
        var mh$ = glVertex3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glVertex3s$descriptor() {
        return glVertex3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glVertex3s$handle() {
        return glVertex3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glVertex3s$address() {
        return glVertex3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glVertex3s(short x, short y, short z) {
        var mh$ = glVertex3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex3sv$descriptor() {
        return glVertex3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex3sv$handle() {
        return glVertex3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex3sv$address() {
        return glVertex3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static void glVertex3sv(MemorySegment v) {
        var mh$ = glVertex3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glVertex4d$descriptor() {
        return glVertex4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glVertex4d$handle() {
        return glVertex4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glVertex4d$address() {
        return glVertex4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glVertex4d(double x, double y, double z, double w) {
        var mh$ = glVertex4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex4dv$descriptor() {
        return glVertex4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex4dv$handle() {
        return glVertex4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex4dv$address() {
        return glVertex4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static void glVertex4dv(MemorySegment v) {
        var mh$ = glVertex4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glVertex4f$descriptor() {
        return glVertex4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glVertex4f$handle() {
        return glVertex4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glVertex4f$address() {
        return glVertex4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glVertex4f(float x, float y, float z, float w) {
        var mh$ = glVertex4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex4fv$descriptor() {
        return glVertex4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex4fv$handle() {
        return glVertex4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex4fv$address() {
        return glVertex4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static void glVertex4fv(MemorySegment v) {
        var mh$ = glVertex4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glVertex4i$descriptor() {
        return glVertex4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glVertex4i$handle() {
        return glVertex4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glVertex4i$address() {
        return glVertex4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glVertex4i(int x, int y, int z, int w) {
        var mh$ = glVertex4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex4iv$descriptor() {
        return glVertex4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex4iv$handle() {
        return glVertex4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex4iv$address() {
        return glVertex4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static void glVertex4iv(MemorySegment v) {
        var mh$ = glVertex4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glVertex4s$descriptor() {
        return glVertex4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glVertex4s$handle() {
        return glVertex4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glVertex4s$address() {
        return glVertex4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glVertex4s(short x, short y, short z, short w) {
        var mh$ = glVertex4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex4sv$descriptor() {
        return glVertex4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex4sv$handle() {
        return glVertex4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex4sv$address() {
        return glVertex4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static void glVertex4sv(MemorySegment v) {
        var mh$ = glVertex4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glVertexPointer$descriptor() {
        return glVertexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glVertexPointer$handle() {
        return glVertexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glVertexPointer$address() {
        return glVertexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glVertexPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glVertexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glViewport$descriptor() {
        return glViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glViewport$handle() {
        return glViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glViewport$address() {
        return glViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glViewport(int x, int y, int width, int height) {
        var mh$ = glViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glViewport", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluErrorString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluErrorString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static FunctionDescriptor gluErrorString$descriptor() {
        return gluErrorString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static MethodHandle gluErrorString$handle() {
        return gluErrorString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorString$address() {
        return gluErrorString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *gluErrorString(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorString(int errCode) {
        var mh$ = gluErrorString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluErrorString", errCode);
            }
            return (MemorySegment)mh$.invokeExact(errCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluErrorUnicodeStringEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluErrorUnicodeStringEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static FunctionDescriptor gluErrorUnicodeStringEXT$descriptor() {
        return gluErrorUnicodeStringEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static MethodHandle gluErrorUnicodeStringEXT$handle() {
        return gluErrorUnicodeStringEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorUnicodeStringEXT$address() {
        return gluErrorUnicodeStringEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *gluErrorUnicodeStringEXT(GLenum errCode)
     * }
     */
    public static MemorySegment gluErrorUnicodeStringEXT(int errCode) {
        var mh$ = gluErrorUnicodeStringEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluErrorUnicodeStringEXT", errCode);
            }
            return (MemorySegment)mh$.invokeExact(errCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor gluGetString$descriptor() {
        return gluGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MethodHandle gluGetString$handle() {
        return gluGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString$address() {
        return gluGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString(int name) {
        var mh$ = gluGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluOrtho2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluOrtho2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static FunctionDescriptor gluOrtho2D$descriptor() {
        return gluOrtho2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MethodHandle gluOrtho2D$handle() {
        return gluOrtho2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MemorySegment gluOrtho2D$address() {
        return gluOrtho2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static void gluOrtho2D(double left, double right, double bottom, double top) {
        var mh$ = gluOrtho2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluOrtho2D", left, right, bottom, top);
            }
            mh$.invokeExact(left, right, bottom, top);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor gluPerspective$descriptor() {
        return gluPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle gluPerspective$handle() {
        return gluPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment gluPerspective$address() {
        return gluPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void gluPerspective(double fovy, double aspect, double zNear, double zFar) {
        var mh$ = gluPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPerspective", fovy, aspect, zNear, zFar);
            }
            mh$.invokeExact(fovy, aspect, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPickMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPickMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static FunctionDescriptor gluPickMatrix$descriptor() {
        return gluPickMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static MethodHandle gluPickMatrix$handle() {
        return gluPickMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static MemorySegment gluPickMatrix$address() {
        return gluPickMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPickMatrix(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4])
     * }
     */
    public static void gluPickMatrix(double x, double y, double width, double height, MemorySegment viewport) {
        var mh$ = gluPickMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPickMatrix", x, y, width, height, viewport);
            }
            mh$.invokeExact(x, y, width, height, viewport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLookAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluLookAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static FunctionDescriptor gluLookAt$descriptor() {
        return gluLookAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static MethodHandle gluLookAt$handle() {
        return gluLookAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static MemorySegment gluLookAt$address() {
        return gluLookAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz)
     * }
     */
    public static void gluLookAt(double eyex, double eyey, double eyez, double centerx, double centery, double centerz, double upx, double upy, double upz) {
        var mh$ = gluLookAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLookAt", eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz);
            }
            mh$.invokeExact(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static FunctionDescriptor gluProject$descriptor() {
        return gluProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static MethodHandle gluProject$handle() {
        return gluProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static MemorySegment gluProject$address() {
        return gluProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluProject(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz)
     * }
     */
    public static int gluProject(double objx, double objy, double objz, MemorySegment modelMatrix, MemorySegment projMatrix, MemorySegment viewport, MemorySegment winx, MemorySegment winy, MemorySegment winz) {
        var mh$ = gluProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluProject", objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz);
            }
            return (int)mh$.invokeExact(objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluUnProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluUnProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static FunctionDescriptor gluUnProject$descriptor() {
        return gluUnProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static MethodHandle gluUnProject$handle() {
        return gluUnProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static MemorySegment gluUnProject$address() {
        return gluUnProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz)
     * }
     */
    public static int gluUnProject(double winx, double winy, double winz, MemorySegment modelMatrix, MemorySegment projMatrix, MemorySegment viewport, MemorySegment objx, MemorySegment objy, MemorySegment objz) {
        var mh$ = gluUnProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluUnProject", winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz);
            }
            return (int)mh$.invokeExact(winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluScaleImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluScaleImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static FunctionDescriptor gluScaleImage$descriptor() {
        return gluScaleImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static MethodHandle gluScaleImage$handle() {
        return gluScaleImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static MemorySegment gluScaleImage$address() {
        return gluScaleImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluScaleImage(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout)
     * }
     */
    public static int gluScaleImage(int format, int widthin, int heightin, int typein, MemorySegment datain, int widthout, int heightout, int typeout, MemorySegment dataout) {
        var mh$ = gluScaleImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluScaleImage", format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout);
            }
            return (int)mh$.invokeExact(format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild1DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild1DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild1DMipmaps$descriptor() {
        return gluBuild1DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild1DMipmaps$handle() {
        return gluBuild1DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild1DMipmaps$address() {
        return gluBuild1DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluBuild1DMipmaps(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild1DMipmaps(int target, int components, int width, int format, int type, MemorySegment data) {
        var mh$ = gluBuild1DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild1DMipmaps", target, components, width, format, type, data);
            }
            return (int)mh$.invokeExact(target, components, width, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild2DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild2DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild2DMipmaps$descriptor() {
        return gluBuild2DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild2DMipmaps$handle() {
        return gluBuild2DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild2DMipmaps$address() {
        return gluBuild2DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gluBuild2DMipmaps(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild2DMipmaps(int target, int components, int width, int height, int format, int type, MemorySegment data) {
        var mh$ = gluBuild2DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild2DMipmaps", target, components, width, height, format, type, data);
            }
            return (int)mh$.invokeExact(target, components, width, height, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNewQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static FunctionDescriptor gluNewQuadric$descriptor() {
        return gluNewQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MethodHandle gluNewQuadric$handle() {
        return gluNewQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric$address() {
        return gluNewQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric() {
        var mh$ = gluNewQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewQuadric");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDeleteQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static FunctionDescriptor gluDeleteQuadric$descriptor() {
        return gluDeleteQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static MethodHandle gluDeleteQuadric$handle() {
        return gluDeleteQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static MemorySegment gluDeleteQuadric$address() {
        return gluDeleteQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteQuadric(GLUquadric *state)
     * }
     */
    public static void gluDeleteQuadric(MemorySegment state) {
        var mh$ = gluDeleteQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteQuadric", state);
            }
            mh$.invokeExact(state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricNormals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricNormals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static FunctionDescriptor gluQuadricNormals$descriptor() {
        return gluQuadricNormals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static MethodHandle gluQuadricNormals$handle() {
        return gluQuadricNormals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static MemorySegment gluQuadricNormals$address() {
        return gluQuadricNormals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricNormals(GLUquadric *quadObject, GLenum normals)
     * }
     */
    public static void gluQuadricNormals(MemorySegment quadObject, int normals) {
        var mh$ = gluQuadricNormals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricNormals", quadObject, normals);
            }
            mh$.invokeExact(quadObject, normals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static FunctionDescriptor gluQuadricTexture$descriptor() {
        return gluQuadricTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static MethodHandle gluQuadricTexture$handle() {
        return gluQuadricTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static MemorySegment gluQuadricTexture$address() {
        return gluQuadricTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricTexture(GLUquadric *quadObject, GLboolean textureCoords)
     * }
     */
    public static void gluQuadricTexture(MemorySegment quadObject, byte textureCoords) {
        var mh$ = gluQuadricTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricTexture", quadObject, textureCoords);
            }
            mh$.invokeExact(quadObject, textureCoords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static FunctionDescriptor gluQuadricOrientation$descriptor() {
        return gluQuadricOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static MethodHandle gluQuadricOrientation$handle() {
        return gluQuadricOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static MemorySegment gluQuadricOrientation$address() {
        return gluQuadricOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricOrientation(GLUquadric *quadObject, GLenum orientation)
     * }
     */
    public static void gluQuadricOrientation(MemorySegment quadObject, int orientation) {
        var mh$ = gluQuadricOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricOrientation", quadObject, orientation);
            }
            mh$.invokeExact(quadObject, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricDrawStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricDrawStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static FunctionDescriptor gluQuadricDrawStyle$descriptor() {
        return gluQuadricDrawStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static MethodHandle gluQuadricDrawStyle$handle() {
        return gluQuadricDrawStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static MemorySegment gluQuadricDrawStyle$address() {
        return gluQuadricDrawStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricDrawStyle(GLUquadric *quadObject, GLenum drawStyle)
     * }
     */
    public static void gluQuadricDrawStyle(MemorySegment quadObject, int drawStyle) {
        var mh$ = gluQuadricDrawStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricDrawStyle", quadObject, drawStyle);
            }
            mh$.invokeExact(quadObject, drawStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluCylinder$descriptor() {
        return gluCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluCylinder$handle() {
        return gluCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluCylinder$address() {
        return gluCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static void gluCylinder(MemorySegment qobj, double baseRadius, double topRadius, double height, int slices, int stacks) {
        var mh$ = gluCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluCylinder", qobj, baseRadius, topRadius, height, slices, stacks);
            }
            mh$.invokeExact(qobj, baseRadius, topRadius, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static FunctionDescriptor gluDisk$descriptor() {
        return gluDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static MethodHandle gluDisk$handle() {
        return gluDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static MemorySegment gluDisk$address() {
        return gluDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops)
     * }
     */
    public static void gluDisk(MemorySegment qobj, double innerRadius, double outerRadius, int slices, int loops) {
        var mh$ = gluDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDisk", qobj, innerRadius, outerRadius, slices, loops);
            }
            mh$.invokeExact(qobj, innerRadius, outerRadius, slices, loops);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPartialDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPartialDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static FunctionDescriptor gluPartialDisk$descriptor() {
        return gluPartialDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static MethodHandle gluPartialDisk$handle() {
        return gluPartialDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static MemorySegment gluPartialDisk$address() {
        return gluPartialDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle)
     * }
     */
    public static void gluPartialDisk(MemorySegment qobj, double innerRadius, double outerRadius, int slices, int loops, double startAngle, double sweepAngle) {
        var mh$ = gluPartialDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPartialDisk", qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle);
            }
            mh$.invokeExact(qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluSphere$descriptor() {
        return gluSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluSphere$handle() {
        return gluSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluSphere$address() {
        return gluSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static void gluSphere(MemorySegment qobj, double radius, int slices, int stacks) {
        var mh$ = gluSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluSphere", qobj, radius, slices, stacks);
            }
            mh$.invokeExact(qobj, radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static FunctionDescriptor gluQuadricCallback$descriptor() {
        return gluQuadricCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MethodHandle gluQuadricCallback$handle() {
        return gluQuadricCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MemorySegment gluQuadricCallback$address() {
        return gluQuadricCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluQuadricCallback(GLUquadric *qobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static void gluQuadricCallback(MemorySegment qobj, int which, MemorySegment fn) {
        var mh$ = gluQuadricCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricCallback", qobj, which, fn);
            }
            mh$.invokeExact(qobj, which, fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNewTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static FunctionDescriptor gluNewTess$descriptor() {
        return gluNewTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MethodHandle gluNewTess$handle() {
        return gluNewTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess$address() {
        return gluNewTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess() {
        var mh$ = gluNewTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewTess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDeleteTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluDeleteTess$descriptor() {
        return gluDeleteTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluDeleteTess$handle() {
        return gluDeleteTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluDeleteTess$address() {
        return gluDeleteTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static void gluDeleteTess(MemorySegment tess) {
        var mh$ = gluDeleteTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteTess", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static FunctionDescriptor gluTessBeginPolygon$descriptor() {
        return gluTessBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static MethodHandle gluTessBeginPolygon$handle() {
        return gluTessBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static MemorySegment gluTessBeginPolygon$address() {
        return gluTessBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessBeginPolygon(GLUtesselator *tess, void *polygon_data)
     * }
     */
    public static void gluTessBeginPolygon(MemorySegment tess, MemorySegment polygon_data) {
        var mh$ = gluTessBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginPolygon", tess, polygon_data);
            }
            mh$.invokeExact(tess, polygon_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessBeginContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessBeginContour$descriptor() {
        return gluTessBeginContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessBeginContour$handle() {
        return gluTessBeginContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessBeginContour$address() {
        return gluTessBeginContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessBeginContour(MemorySegment tess) {
        var mh$ = gluTessBeginContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static FunctionDescriptor gluTessVertex$descriptor() {
        return gluTessVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static MethodHandle gluTessVertex$handle() {
        return gluTessVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static MemorySegment gluTessVertex$address() {
        return gluTessVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessVertex(GLUtesselator *tess, GLdouble coords[3], void *data)
     * }
     */
    public static void gluTessVertex(MemorySegment tess, MemorySegment coords, MemorySegment data) {
        var mh$ = gluTessVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessVertex", tess, coords, data);
            }
            mh$.invokeExact(tess, coords, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessEndContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndContour$descriptor() {
        return gluTessEndContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndContour$handle() {
        return gluTessEndContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndContour$address() {
        return gluTessEndContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndContour(MemorySegment tess) {
        var mh$ = gluTessEndContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndPolygon$descriptor() {
        return gluTessEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndPolygon$handle() {
        return gluTessEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndPolygon$address() {
        return gluTessEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndPolygon(MemorySegment tess) {
        var mh$ = gluTessEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static FunctionDescriptor gluTessProperty$descriptor() {
        return gluTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static MethodHandle gluTessProperty$handle() {
        return gluTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static MemorySegment gluTessProperty$address() {
        return gluTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble value)
     * }
     */
    public static void gluTessProperty(MemorySegment tess, int which, double value) {
        var mh$ = gluTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessProperty", tess, which, value);
            }
            mh$.invokeExact(tess, which, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessNormal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessNormal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor gluTessNormal$descriptor() {
        return gluTessNormal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle gluTessNormal$handle() {
        return gluTessNormal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment gluTessNormal$address() {
        return gluTessNormal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessNormal(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void gluTessNormal(MemorySegment tess, double x, double y, double z) {
        var mh$ = gluTessNormal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessNormal", tess, x, y, z);
            }
            mh$.invokeExact(tess, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static FunctionDescriptor gluTessCallback$descriptor() {
        return gluTessCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MethodHandle gluTessCallback$handle() {
        return gluTessCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MemorySegment gluTessCallback$address() {
        return gluTessCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluTessCallback(GLUtesselator *tess, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static void gluTessCallback(MemorySegment tess, int which, MemorySegment fn) {
        var mh$ = gluTessCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessCallback", tess, which, fn);
            }
            mh$.invokeExact(tess, which, fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluGetTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static FunctionDescriptor gluGetTessProperty$descriptor() {
        return gluGetTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static MethodHandle gluGetTessProperty$handle() {
        return gluGetTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static MemorySegment gluGetTessProperty$address() {
        return gluGetTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *value)
     * }
     */
    public static void gluGetTessProperty(MemorySegment tess, int which, MemorySegment value) {
        var mh$ = gluGetTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetTessProperty", tess, which, value);
            }
            mh$.invokeExact(tess, which, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNewNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static FunctionDescriptor gluNewNurbsRenderer$descriptor() {
        return gluNewNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MethodHandle gluNewNurbsRenderer$handle() {
        return gluNewNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer$address() {
        return gluNewNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer() {
        var mh$ = gluNewNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewNurbsRenderer");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDeleteNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluDeleteNurbsRenderer$descriptor() {
        return gluDeleteNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluDeleteNurbsRenderer$handle() {
        return gluDeleteNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluDeleteNurbsRenderer$address() {
        return gluDeleteNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluDeleteNurbsRenderer(GLUnurbs *nobj)
     * }
     */
    public static void gluDeleteNurbsRenderer(MemorySegment nobj) {
        var mh$ = gluDeleteNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteNurbsRenderer", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluBeginSurface$descriptor() {
        return gluBeginSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluBeginSurface$handle() {
        return gluBeginSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluBeginSurface$address() {
        return gluBeginSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginSurface(GLUnurbs *nobj)
     * }
     */
    public static void gluBeginSurface(MemorySegment nobj) {
        var mh$ = gluBeginSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginSurface", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluBeginCurve$descriptor() {
        return gluBeginCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluBeginCurve$handle() {
        return gluBeginCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluBeginCurve$address() {
        return gluBeginCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginCurve(GLUnurbs *nobj)
     * }
     */
    public static void gluBeginCurve(MemorySegment nobj) {
        var mh$ = gluBeginCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginCurve", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluEndCurve$descriptor() {
        return gluEndCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluEndCurve$handle() {
        return gluEndCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluEndCurve$address() {
        return gluEndCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndCurve(GLUnurbs *nobj)
     * }
     */
    public static void gluEndCurve(MemorySegment nobj) {
        var mh$ = gluEndCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndCurve", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluEndSurface$descriptor() {
        return gluEndSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluEndSurface$handle() {
        return gluEndSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluEndSurface$address() {
        return gluEndSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndSurface(GLUnurbs *nobj)
     * }
     */
    public static void gluEndSurface(MemorySegment nobj) {
        var mh$ = gluEndSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndSurface", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluBeginTrim$descriptor() {
        return gluBeginTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluBeginTrim$handle() {
        return gluBeginTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluBeginTrim$address() {
        return gluBeginTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginTrim(GLUnurbs *nobj)
     * }
     */
    public static void gluBeginTrim(MemorySegment nobj) {
        var mh$ = gluBeginTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginTrim", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static FunctionDescriptor gluEndTrim$descriptor() {
        return gluEndTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static MethodHandle gluEndTrim$handle() {
        return gluEndTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static MemorySegment gluEndTrim$address() {
        return gluEndTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndTrim(GLUnurbs *nobj)
     * }
     */
    public static void gluEndTrim(MemorySegment nobj) {
        var mh$ = gluEndTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndTrim", nobj);
            }
            mh$.invokeExact(nobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPwlCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPwlCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static FunctionDescriptor gluPwlCurve$descriptor() {
        return gluPwlCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static MethodHandle gluPwlCurve$handle() {
        return gluPwlCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static MemorySegment gluPwlCurve$address() {
        return gluPwlCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluPwlCurve(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type)
     * }
     */
    public static void gluPwlCurve(MemorySegment nobj, int count, MemorySegment array, int stride, int type) {
        var mh$ = gluPwlCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPwlCurve", nobj, count, array, stride, type);
            }
            mh$.invokeExact(nobj, count, array, stride, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsCurve$descriptor() {
        return gluNurbsCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsCurve$handle() {
        return gluNurbsCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsCurve$address() {
        return gluNurbsCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCurve(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type)
     * }
     */
    public static void gluNurbsCurve(MemorySegment nobj, int nknots, MemorySegment knot, int stride, MemorySegment ctlarray, int order, int type) {
        var mh$ = gluNurbsCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCurve", nobj, nknots, knot, stride, ctlarray, order, type);
            }
            mh$.invokeExact(nobj, nknots, knot, stride, ctlarray, order, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsSurface$descriptor() {
        return gluNurbsSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsSurface$handle() {
        return gluNurbsSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsSurface$address() {
        return gluNurbsSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsSurface(GLUnurbs *nobj, GLint sknot_count, float *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type)
     * }
     */
    public static void gluNurbsSurface(MemorySegment nobj, int sknot_count, MemorySegment sknot, int tknot_count, MemorySegment tknot, int s_stride, int t_stride, MemorySegment ctlarray, int sorder, int torder, int type) {
        var mh$ = gluNurbsSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsSurface", nobj, sknot_count, sknot, tknot_count, tknot, s_stride, t_stride, ctlarray, sorder, torder, type);
            }
            mh$.invokeExact(nobj, sknot_count, sknot, tknot_count, tknot, s_stride, t_stride, ctlarray, sorder, torder, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLoadSamplingMatrices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluLoadSamplingMatrices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static FunctionDescriptor gluLoadSamplingMatrices$descriptor() {
        return gluLoadSamplingMatrices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static MethodHandle gluLoadSamplingMatrices$handle() {
        return gluLoadSamplingMatrices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static MemorySegment gluLoadSamplingMatrices$address() {
        return gluLoadSamplingMatrices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluLoadSamplingMatrices(GLUnurbs *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4])
     * }
     */
    public static void gluLoadSamplingMatrices(MemorySegment nobj, MemorySegment modelMatrix, MemorySegment projMatrix, MemorySegment viewport) {
        var mh$ = gluLoadSamplingMatrices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLoadSamplingMatrices", nobj, modelMatrix, projMatrix, viewport);
            }
            mh$.invokeExact(nobj, modelMatrix, projMatrix, viewport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static FunctionDescriptor gluNurbsProperty$descriptor() {
        return gluNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static MethodHandle gluNurbsProperty$handle() {
        return gluNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static MemorySegment gluNurbsProperty$address() {
        return gluNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat value)
     * }
     */
    public static void gluNurbsProperty(MemorySegment nobj, int property, float value) {
        var mh$ = gluNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsProperty", nobj, property, value);
            }
            mh$.invokeExact(nobj, property, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluGetNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static FunctionDescriptor gluGetNurbsProperty$descriptor() {
        return gluGetNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static MethodHandle gluGetNurbsProperty$handle() {
        return gluGetNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static MemorySegment gluGetNurbsProperty$address() {
        return gluGetNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluGetNurbsProperty(GLUnurbs *nobj, GLenum property, GLfloat *value)
     * }
     */
    public static void gluGetNurbsProperty(MemorySegment nobj, int property, MemorySegment value) {
        var mh$ = gluGetNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetNurbsProperty", nobj, property, value);
            }
            mh$.invokeExact(nobj, property, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static FunctionDescriptor gluNurbsCallback$descriptor() {
        return gluNurbsCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MethodHandle gluNurbsCallback$handle() {
        return gluNurbsCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static MemorySegment gluNurbsCallback$address() {
        return gluNurbsCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNurbsCallback(GLUnurbs *nobj, GLenum which, void (*fn)() __attribute__((stdcall)))
     * }
     */
    public static void gluNurbsCallback(MemorySegment nobj, int which, MemorySegment fn) {
        var mh$ = gluNurbsCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallback", nobj, which, fn);
            }
            mh$.invokeExact(nobj, which, fn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluBeginPolygon$descriptor() {
        return gluBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluBeginPolygon$handle() {
        return gluBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluBeginPolygon$address() {
        return gluBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluBeginPolygon(MemorySegment tess) {
        var mh$ = gluBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNextContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNextContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNextContour$descriptor() {
        return gluNextContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MethodHandle gluNextContour$handle() {
        return gluNextContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MemorySegment gluNextContour$address() {
        return gluNextContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static void gluNextContour(MemorySegment tess, int type) {
        var mh$ = gluNextContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNextContour", tess, type);
            }
            mh$.invokeExact(tess, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluEndPolygon$descriptor() {
        return gluEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluEndPolygon$handle() {
        return gluEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluEndPolygon$address() {
        return gluEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluEndPolygon(MemorySegment tess) {
        var mh$ = gluEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static FunctionDescriptor glutInit$descriptor() {
        return glutInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static MethodHandle glutInit$handle() {
        return glutInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static MemorySegment glutInit$address() {
        return glutInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static void glutInit(MemorySegment pargc, MemorySegment argv) {
        var mh$ = glutInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInit", pargc, argv);
            }
            mh$.invokeExact(pargc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWindowPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static FunctionDescriptor glutInitWindowPosition$descriptor() {
        return glutInitWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static MethodHandle glutInitWindowPosition$handle() {
        return glutInitWindowPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static MemorySegment glutInitWindowPosition$address() {
        return glutInitWindowPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static void glutInitWindowPosition(int x, int y) {
        var mh$ = glutInitWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWindowPosition", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static FunctionDescriptor glutInitWindowSize$descriptor() {
        return glutInitWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static MethodHandle glutInitWindowSize$handle() {
        return glutInitWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static MemorySegment glutInitWindowSize$address() {
        return glutInitWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static void glutInitWindowSize(int width, int height) {
        var mh$ = glutInitWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWindowSize", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitDisplayMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static FunctionDescriptor glutInitDisplayMode$descriptor() {
        return glutInitDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static MethodHandle glutInitDisplayMode$handle() {
        return glutInitDisplayMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static MemorySegment glutInitDisplayMode$address() {
        return glutInitDisplayMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static void glutInitDisplayMode(int displayMode) {
        var mh$ = glutInitDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitDisplayMode", displayMode);
            }
            mh$.invokeExact(displayMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitDisplayString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitDisplayString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static FunctionDescriptor glutInitDisplayString$descriptor() {
        return glutInitDisplayString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static MethodHandle glutInitDisplayString$handle() {
        return glutInitDisplayString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static MemorySegment glutInitDisplayString$address() {
        return glutInitDisplayString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static void glutInitDisplayString(MemorySegment displayMode) {
        var mh$ = glutInitDisplayString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitDisplayString", displayMode);
            }
            mh$.invokeExact(displayMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMainLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMainLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static FunctionDescriptor glutMainLoop$descriptor() {
        return glutMainLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static MethodHandle glutMainLoop$handle() {
        return glutMainLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static MemorySegment glutMainLoop$address() {
        return glutMainLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static void glutMainLoop() {
        var mh$ = glutMainLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMainLoop");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static FunctionDescriptor glutCreateWindow$descriptor() {
        return glutCreateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static MethodHandle glutCreateWindow$handle() {
        return glutCreateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static MemorySegment glutCreateWindow$address() {
        return glutCreateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static int glutCreateWindow(MemorySegment title) {
        var mh$ = glutCreateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateWindow", title);
            }
            return (int)mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateSubWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateSubWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutCreateSubWindow$descriptor() {
        return glutCreateSubWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutCreateSubWindow$handle() {
        return glutCreateSubWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutCreateSubWindow$address() {
        return glutCreateSubWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static int glutCreateSubWindow(int window, int x, int y, int width, int height) {
        var mh$ = glutCreateSubWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateSubWindow", window, x, y, width, height);
            }
            return (int)mh$.invokeExact(window, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDestroyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static FunctionDescriptor glutDestroyWindow$descriptor() {
        return glutDestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static MethodHandle glutDestroyWindow$handle() {
        return glutDestroyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static MemorySegment glutDestroyWindow$address() {
        return glutDestroyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static void glutDestroyWindow(int window) {
        var mh$ = glutDestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDestroyWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static FunctionDescriptor glutSetWindow$descriptor() {
        return glutSetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static MethodHandle glutSetWindow$handle() {
        return glutSetWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static MemorySegment glutSetWindow$address() {
        return glutSetWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static void glutSetWindow(int window) {
        var mh$ = glutSetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static FunctionDescriptor glutGetWindow$descriptor() {
        return glutGetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static MethodHandle glutGetWindow$handle() {
        return glutGetWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static MemorySegment glutGetWindow$address() {
        return glutGetWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static int glutGetWindow() {
        var mh$ = glutGetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetWindow");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindowTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetWindowTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static FunctionDescriptor glutSetWindowTitle$descriptor() {
        return glutSetWindowTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static MethodHandle glutSetWindowTitle$handle() {
        return glutSetWindowTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static MemorySegment glutSetWindowTitle$address() {
        return glutSetWindowTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static void glutSetWindowTitle(MemorySegment title) {
        var mh$ = glutSetWindowTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindowTitle", title);
            }
            mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetIconTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetIconTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static FunctionDescriptor glutSetIconTitle$descriptor() {
        return glutSetIconTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static MethodHandle glutSetIconTitle$handle() {
        return glutSetIconTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static MemorySegment glutSetIconTitle$address() {
        return glutSetIconTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static void glutSetIconTitle(MemorySegment title) {
        var mh$ = glutSetIconTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetIconTitle", title);
            }
            mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReshapeWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static FunctionDescriptor glutReshapeWindow$descriptor() {
        return glutReshapeWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static MethodHandle glutReshapeWindow$handle() {
        return glutReshapeWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static MemorySegment glutReshapeWindow$address() {
        return glutReshapeWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static void glutReshapeWindow(int width, int height) {
        var mh$ = glutReshapeWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeWindow", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPositionWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPositionWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static FunctionDescriptor glutPositionWindow$descriptor() {
        return glutPositionWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static MethodHandle glutPositionWindow$handle() {
        return glutPositionWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static MemorySegment glutPositionWindow$address() {
        return glutPositionWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static void glutPositionWindow(int x, int y) {
        var mh$ = glutPositionWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPositionWindow", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutShowWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutShowWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static FunctionDescriptor glutShowWindow$descriptor() {
        return glutShowWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static MethodHandle glutShowWindow$handle() {
        return glutShowWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static MemorySegment glutShowWindow$address() {
        return glutShowWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static void glutShowWindow() {
        var mh$ = glutShowWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutShowWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutHideWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutHideWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static FunctionDescriptor glutHideWindow$descriptor() {
        return glutHideWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static MethodHandle glutHideWindow$handle() {
        return glutHideWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static MemorySegment glutHideWindow$address() {
        return glutHideWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static void glutHideWindow() {
        var mh$ = glutHideWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutHideWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIconifyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIconifyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static FunctionDescriptor glutIconifyWindow$descriptor() {
        return glutIconifyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static MethodHandle glutIconifyWindow$handle() {
        return glutIconifyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static MemorySegment glutIconifyWindow$address() {
        return glutIconifyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static void glutIconifyWindow() {
        var mh$ = glutIconifyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIconifyWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPushWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPushWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static FunctionDescriptor glutPushWindow$descriptor() {
        return glutPushWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static MethodHandle glutPushWindow$handle() {
        return glutPushWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static MemorySegment glutPushWindow$address() {
        return glutPushWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static void glutPushWindow() {
        var mh$ = glutPushWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPushWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPopWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPopWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static FunctionDescriptor glutPopWindow$descriptor() {
        return glutPopWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static MethodHandle glutPopWindow$handle() {
        return glutPopWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static MemorySegment glutPopWindow$address() {
        return glutPopWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static void glutPopWindow() {
        var mh$ = glutPopWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPopWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutFullScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutFullScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static FunctionDescriptor glutFullScreen$descriptor() {
        return glutFullScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static MethodHandle glutFullScreen$handle() {
        return glutFullScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static MemorySegment glutFullScreen$address() {
        return glutFullScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static void glutFullScreen() {
        var mh$ = glutFullScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutFullScreen");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostWindowRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostWindowRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static FunctionDescriptor glutPostWindowRedisplay$descriptor() {
        return glutPostWindowRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static MethodHandle glutPostWindowRedisplay$handle() {
        return glutPostWindowRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static MemorySegment glutPostWindowRedisplay$address() {
        return glutPostWindowRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static void glutPostWindowRedisplay(int window) {
        var mh$ = glutPostWindowRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostWindowRedisplay", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static FunctionDescriptor glutPostRedisplay$descriptor() {
        return glutPostRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static MethodHandle glutPostRedisplay$handle() {
        return glutPostRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static MemorySegment glutPostRedisplay$address() {
        return glutPostRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static void glutPostRedisplay() {
        var mh$ = glutPostRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostRedisplay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static FunctionDescriptor glutSwapBuffers$descriptor() {
        return glutSwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static MethodHandle glutSwapBuffers$handle() {
        return glutSwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static MemorySegment glutSwapBuffers$address() {
        return glutSwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static void glutSwapBuffers() {
        var mh$ = glutSwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSwapBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWarpPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWarpPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static FunctionDescriptor glutWarpPointer$descriptor() {
        return glutWarpPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static MethodHandle glutWarpPointer$handle() {
        return glutWarpPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static MemorySegment glutWarpPointer$address() {
        return glutWarpPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static void glutWarpPointer(int x, int y) {
        var mh$ = glutWarpPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWarpPointer", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static FunctionDescriptor glutSetCursor$descriptor() {
        return glutSetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static MethodHandle glutSetCursor$handle() {
        return glutSetCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static MemorySegment glutSetCursor$address() {
        return glutSetCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static void glutSetCursor(int cursor) {
        var mh$ = glutSetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetCursor", cursor);
            }
            mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEstablishOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEstablishOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static FunctionDescriptor glutEstablishOverlay$descriptor() {
        return glutEstablishOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static MethodHandle glutEstablishOverlay$handle() {
        return glutEstablishOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static MemorySegment glutEstablishOverlay$address() {
        return glutEstablishOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static void glutEstablishOverlay() {
        var mh$ = glutEstablishOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEstablishOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutRemoveOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutRemoveOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static FunctionDescriptor glutRemoveOverlay$descriptor() {
        return glutRemoveOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static MethodHandle glutRemoveOverlay$handle() {
        return glutRemoveOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static MemorySegment glutRemoveOverlay$address() {
        return glutRemoveOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static void glutRemoveOverlay() {
        var mh$ = glutRemoveOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutRemoveOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutUseLayer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutUseLayer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static FunctionDescriptor glutUseLayer$descriptor() {
        return glutUseLayer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static MethodHandle glutUseLayer$handle() {
        return glutUseLayer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static MemorySegment glutUseLayer$address() {
        return glutUseLayer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static void glutUseLayer(int layer) {
        var mh$ = glutUseLayer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutUseLayer", layer);
            }
            mh$.invokeExact(layer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostOverlayRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostOverlayRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static FunctionDescriptor glutPostOverlayRedisplay$descriptor() {
        return glutPostOverlayRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static MethodHandle glutPostOverlayRedisplay$handle() {
        return glutPostOverlayRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static MemorySegment glutPostOverlayRedisplay$address() {
        return glutPostOverlayRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static void glutPostOverlayRedisplay() {
        var mh$ = glutPostOverlayRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostOverlayRedisplay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostWindowOverlayRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostWindowOverlayRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static FunctionDescriptor glutPostWindowOverlayRedisplay$descriptor() {
        return glutPostWindowOverlayRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static MethodHandle glutPostWindowOverlayRedisplay$handle() {
        return glutPostWindowOverlayRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static MemorySegment glutPostWindowOverlayRedisplay$address() {
        return glutPostWindowOverlayRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static void glutPostWindowOverlayRedisplay(int window) {
        var mh$ = glutPostWindowOverlayRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostWindowOverlayRedisplay", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutShowOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutShowOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static FunctionDescriptor glutShowOverlay$descriptor() {
        return glutShowOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static MethodHandle glutShowOverlay$handle() {
        return glutShowOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static MemorySegment glutShowOverlay$address() {
        return glutShowOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static void glutShowOverlay() {
        var mh$ = glutShowOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutShowOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutHideOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutHideOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static FunctionDescriptor glutHideOverlay$descriptor() {
        return glutHideOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static MethodHandle glutHideOverlay$handle() {
        return glutHideOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static MemorySegment glutHideOverlay$address() {
        return glutHideOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static void glutHideOverlay() {
        var mh$ = glutHideOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutHideOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutCreateMenu$descriptor() {
        return glutCreateMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static MethodHandle glutCreateMenu$handle() {
        return glutCreateMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static MemorySegment glutCreateMenu$address() {
        return glutCreateMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static int glutCreateMenu(MemorySegment callback) {
        var mh$ = glutCreateMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateMenu", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDestroyMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDestroyMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static FunctionDescriptor glutDestroyMenu$descriptor() {
        return glutDestroyMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static MethodHandle glutDestroyMenu$handle() {
        return glutDestroyMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static MemorySegment glutDestroyMenu$address() {
        return glutDestroyMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static void glutDestroyMenu(int menu) {
        var mh$ = glutDestroyMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDestroyMenu", menu);
            }
            mh$.invokeExact(menu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static FunctionDescriptor glutGetMenu$descriptor() {
        return glutGetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static MethodHandle glutGetMenu$handle() {
        return glutGetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static MemorySegment glutGetMenu$address() {
        return glutGetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static int glutGetMenu() {
        var mh$ = glutGetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetMenu");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static FunctionDescriptor glutSetMenu$descriptor() {
        return glutSetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static MethodHandle glutSetMenu$handle() {
        return glutSetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static MemorySegment glutSetMenu$address() {
        return glutSetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static void glutSetMenu(int menu) {
        var mh$ = glutSetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetMenu", menu);
            }
            mh$.invokeExact(menu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAddMenuEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAddMenuEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutAddMenuEntry$descriptor() {
        return glutAddMenuEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static MethodHandle glutAddMenuEntry$handle() {
        return glutAddMenuEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static MemorySegment glutAddMenuEntry$address() {
        return glutAddMenuEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static void glutAddMenuEntry(MemorySegment label, int value) {
        var mh$ = glutAddMenuEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAddMenuEntry", label, value);
            }
            mh$.invokeExact(label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAddSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAddSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static FunctionDescriptor glutAddSubMenu$descriptor() {
        return glutAddSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static MethodHandle glutAddSubMenu$handle() {
        return glutAddSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static MemorySegment glutAddSubMenu$address() {
        return glutAddSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static void glutAddSubMenu(MemorySegment label, int subMenu) {
        var mh$ = glutAddSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAddSubMenu", label, subMenu);
            }
            mh$.invokeExact(label, subMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutChangeToMenuEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutChangeToMenuEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutChangeToMenuEntry$descriptor() {
        return glutChangeToMenuEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static MethodHandle glutChangeToMenuEntry$handle() {
        return glutChangeToMenuEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static MemorySegment glutChangeToMenuEntry$address() {
        return glutChangeToMenuEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static void glutChangeToMenuEntry(int item, MemorySegment label, int value) {
        var mh$ = glutChangeToMenuEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutChangeToMenuEntry", item, label, value);
            }
            mh$.invokeExact(item, label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutChangeToSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutChangeToSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutChangeToSubMenu$descriptor() {
        return glutChangeToSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static MethodHandle glutChangeToSubMenu$handle() {
        return glutChangeToSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static MemorySegment glutChangeToSubMenu$address() {
        return glutChangeToSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static void glutChangeToSubMenu(int item, MemorySegment label, int value) {
        var mh$ = glutChangeToSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutChangeToSubMenu", item, label, value);
            }
            mh$.invokeExact(item, label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutRemoveMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutRemoveMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static FunctionDescriptor glutRemoveMenuItem$descriptor() {
        return glutRemoveMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static MethodHandle glutRemoveMenuItem$handle() {
        return glutRemoveMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static MemorySegment glutRemoveMenuItem$address() {
        return glutRemoveMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static void glutRemoveMenuItem(int item) {
        var mh$ = glutRemoveMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutRemoveMenuItem", item);
            }
            mh$.invokeExact(item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAttachMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAttachMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static FunctionDescriptor glutAttachMenu$descriptor() {
        return glutAttachMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static MethodHandle glutAttachMenu$handle() {
        return glutAttachMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static MemorySegment glutAttachMenu$address() {
        return glutAttachMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static void glutAttachMenu(int button) {
        var mh$ = glutAttachMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAttachMenu", button);
            }
            mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDetachMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDetachMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static FunctionDescriptor glutDetachMenu$descriptor() {
        return glutDetachMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static MethodHandle glutDetachMenu$handle() {
        return glutDetachMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static MemorySegment glutDetachMenu$address() {
        return glutDetachMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static void glutDetachMenu(int button) {
        var mh$ = glutDetachMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDetachMenu", button);
            }
            mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTimerFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTimerFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static FunctionDescriptor glutTimerFunc$descriptor() {
        return glutTimerFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static MethodHandle glutTimerFunc$handle() {
        return glutTimerFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static MemorySegment glutTimerFunc$address() {
        return glutTimerFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static void glutTimerFunc(int time, MemorySegment callback, int value) {
        var mh$ = glutTimerFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTimerFunc", time, callback, value);
            }
            mh$.invokeExact(time, callback, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIdleFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIdleFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutIdleFunc$descriptor() {
        return glutIdleFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutIdleFunc$handle() {
        return glutIdleFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutIdleFunc$address() {
        return glutIdleFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static void glutIdleFunc(MemorySegment callback) {
        var mh$ = glutIdleFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIdleFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static FunctionDescriptor glutKeyboardFunc$descriptor() {
        return glutKeyboardFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MethodHandle glutKeyboardFunc$handle() {
        return glutKeyboardFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MemorySegment glutKeyboardFunc$address() {
        return glutKeyboardFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static void glutKeyboardFunc(MemorySegment callback) {
        var mh$ = glutKeyboardFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpecialFunc$descriptor() {
        return glutSpecialFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpecialFunc$handle() {
        return glutSpecialFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpecialFunc$address() {
        return glutSpecialFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpecialFunc(MemorySegment callback) {
        var mh$ = glutSpecialFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReshapeFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutReshapeFunc$descriptor() {
        return glutReshapeFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutReshapeFunc$handle() {
        return glutReshapeFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutReshapeFunc$address() {
        return glutReshapeFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static void glutReshapeFunc(MemorySegment callback) {
        var mh$ = glutReshapeFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVisibilityFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVisibilityFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutVisibilityFunc$descriptor() {
        return glutVisibilityFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutVisibilityFunc$handle() {
        return glutVisibilityFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutVisibilityFunc$address() {
        return glutVisibilityFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static void glutVisibilityFunc(MemorySegment callback) {
        var mh$ = glutVisibilityFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVisibilityFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDisplayFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDisplayFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutDisplayFunc$descriptor() {
        return glutDisplayFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutDisplayFunc$handle() {
        return glutDisplayFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutDisplayFunc$address() {
        return glutDisplayFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static void glutDisplayFunc(MemorySegment callback) {
        var mh$ = glutDisplayFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDisplayFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutMouseFunc$descriptor() {
        return glutMouseFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutMouseFunc$handle() {
        return glutMouseFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutMouseFunc$address() {
        return glutMouseFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutMouseFunc(MemorySegment callback) {
        var mh$ = glutMouseFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutMotionFunc$descriptor() {
        return glutMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutMotionFunc$handle() {
        return glutMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutMotionFunc$address() {
        return glutMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutMotionFunc(MemorySegment callback) {
        var mh$ = glutMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPassiveMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPassiveMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutPassiveMotionFunc$descriptor() {
        return glutPassiveMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutPassiveMotionFunc$handle() {
        return glutPassiveMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutPassiveMotionFunc$address() {
        return glutPassiveMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutPassiveMotionFunc(MemorySegment callback) {
        var mh$ = glutPassiveMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPassiveMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEntryFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEntryFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutEntryFunc$descriptor() {
        return glutEntryFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutEntryFunc$handle() {
        return glutEntryFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutEntryFunc$address() {
        return glutEntryFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static void glutEntryFunc(MemorySegment callback) {
        var mh$ = glutEntryFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEntryFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardUpFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardUpFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static FunctionDescriptor glutKeyboardUpFunc$descriptor() {
        return glutKeyboardUpFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MethodHandle glutKeyboardUpFunc$handle() {
        return glutKeyboardUpFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MemorySegment glutKeyboardUpFunc$address() {
        return glutKeyboardUpFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static void glutKeyboardUpFunc(MemorySegment callback) {
        var mh$ = glutKeyboardUpFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardUpFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialUpFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialUpFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpecialUpFunc$descriptor() {
        return glutSpecialUpFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpecialUpFunc$handle() {
        return glutSpecialUpFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpecialUpFunc$address() {
        return glutSpecialUpFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpecialUpFunc(MemorySegment callback) {
        var mh$ = glutSpecialUpFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialUpFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static FunctionDescriptor glutJoystickFunc$descriptor() {
        return glutJoystickFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static MethodHandle glutJoystickFunc$handle() {
        return glutJoystickFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static MemorySegment glutJoystickFunc$address() {
        return glutJoystickFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static void glutJoystickFunc(MemorySegment callback, int pollInterval) {
        var mh$ = glutJoystickFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickFunc", callback, pollInterval);
            }
            mh$.invokeExact(callback, pollInterval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStateFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuStateFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutMenuStateFunc$descriptor() {
        return glutMenuStateFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutMenuStateFunc$handle() {
        return glutMenuStateFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutMenuStateFunc$address() {
        return glutMenuStateFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static void glutMenuStateFunc(MemorySegment callback) {
        var mh$ = glutMenuStateFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStateFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutMenuStatusFunc$descriptor() {
        return glutMenuStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutMenuStatusFunc$handle() {
        return glutMenuStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutMenuStatusFunc$address() {
        return glutMenuStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutMenuStatusFunc(MemorySegment callback) {
        var mh$ = glutMenuStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutOverlayDisplayFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutOverlayDisplayFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutOverlayDisplayFunc$descriptor() {
        return glutOverlayDisplayFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutOverlayDisplayFunc$handle() {
        return glutOverlayDisplayFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutOverlayDisplayFunc$address() {
        return glutOverlayDisplayFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static void glutOverlayDisplayFunc(MemorySegment callback) {
        var mh$ = glutOverlayDisplayFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutOverlayDisplayFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWindowStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWindowStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutWindowStatusFunc$descriptor() {
        return glutWindowStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutWindowStatusFunc$handle() {
        return glutWindowStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutWindowStatusFunc$address() {
        return glutWindowStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static void glutWindowStatusFunc(MemorySegment callback) {
        var mh$ = glutWindowStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWindowStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballMotionFunc$descriptor() {
        return glutSpaceballMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpaceballMotionFunc$handle() {
        return glutSpaceballMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpaceballMotionFunc$address() {
        return glutSpaceballMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpaceballMotionFunc(MemorySegment callback) {
        var mh$ = glutSpaceballMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballRotateFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballRotateFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballRotateFunc$descriptor() {
        return glutSpaceballRotateFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpaceballRotateFunc$handle() {
        return glutSpaceballRotateFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpaceballRotateFunc$address() {
        return glutSpaceballRotateFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpaceballRotateFunc(MemorySegment callback) {
        var mh$ = glutSpaceballRotateFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballRotateFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballButtonFunc$descriptor() {
        return glutSpaceballButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutSpaceballButtonFunc$handle() {
        return glutSpaceballButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutSpaceballButtonFunc$address() {
        return glutSpaceballButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static void glutSpaceballButtonFunc(MemorySegment callback) {
        var mh$ = glutSpaceballButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutButtonBoxFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutButtonBoxFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutButtonBoxFunc$descriptor() {
        return glutButtonBoxFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutButtonBoxFunc$handle() {
        return glutButtonBoxFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutButtonBoxFunc$address() {
        return glutButtonBoxFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static void glutButtonBoxFunc(MemorySegment callback) {
        var mh$ = glutButtonBoxFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutButtonBoxFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDialsFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDialsFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutDialsFunc$descriptor() {
        return glutDialsFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutDialsFunc$handle() {
        return glutDialsFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutDialsFunc$address() {
        return glutDialsFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static void glutDialsFunc(MemorySegment callback) {
        var mh$ = glutDialsFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDialsFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutTabletMotionFunc$descriptor() {
        return glutTabletMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutTabletMotionFunc$handle() {
        return glutTabletMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutTabletMotionFunc$address() {
        return glutTabletMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutTabletMotionFunc(MemorySegment callback) {
        var mh$ = glutTabletMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutTabletButtonFunc$descriptor() {
        return glutTabletButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutTabletButtonFunc$handle() {
        return glutTabletButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutTabletButtonFunc$address() {
        return glutTabletButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutTabletButtonFunc(MemorySegment callback) {
        var mh$ = glutTabletButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutGet$descriptor() {
        return glutGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static MethodHandle glutGet$handle() {
        return glutGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static MemorySegment glutGet$address() {
        return glutGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static int glutGet(int query) {
        var mh$ = glutGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDeviceGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDeviceGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutDeviceGet$descriptor() {
        return glutDeviceGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static MethodHandle glutDeviceGet$handle() {
        return glutDeviceGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static MemorySegment glutDeviceGet$address() {
        return glutDeviceGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static int glutDeviceGet(int query) {
        var mh$ = glutDeviceGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDeviceGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetModifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetModifiers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static FunctionDescriptor glutGetModifiers$descriptor() {
        return glutGetModifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static MethodHandle glutGetModifiers$handle() {
        return glutGetModifiers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static MemorySegment glutGetModifiers$address() {
        return glutGetModifiers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static int glutGetModifiers() {
        var mh$ = glutGetModifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetModifiers");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLayerGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLayerGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutLayerGet$descriptor() {
        return glutLayerGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static MethodHandle glutLayerGet$handle() {
        return glutLayerGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static MemorySegment glutLayerGet$address() {
        return glutLayerGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static int glutLayerGet(int query) {
        var mh$ = glutLayerGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLayerGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapCharacter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapCharacter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutBitmapCharacter$descriptor() {
        return glutBitmapCharacter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static MethodHandle glutBitmapCharacter$handle() {
        return glutBitmapCharacter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static MemorySegment glutBitmapCharacter$address() {
        return glutBitmapCharacter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static void glutBitmapCharacter(MemorySegment font, int character) {
        var mh$ = glutBitmapCharacter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapCharacter", font, character);
            }
            mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutBitmapWidth$descriptor() {
        return glutBitmapWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static MethodHandle glutBitmapWidth$handle() {
        return glutBitmapWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static MemorySegment glutBitmapWidth$address() {
        return glutBitmapWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static int glutBitmapWidth(MemorySegment font, int character) {
        var mh$ = glutBitmapWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapWidth", font, character);
            }
            return (int)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeCharacter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeCharacter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeCharacter$descriptor() {
        return glutStrokeCharacter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeCharacter$handle() {
        return glutStrokeCharacter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeCharacter$address() {
        return glutStrokeCharacter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static void glutStrokeCharacter(MemorySegment font, int character) {
        var mh$ = glutStrokeCharacter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeCharacter", font, character);
            }
            mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeWidth$descriptor() {
        return glutStrokeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeWidth$handle() {
        return glutStrokeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeWidth$address() {
        return glutStrokeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static int glutStrokeWidth(MemorySegment font, int character) {
        var mh$ = glutStrokeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeWidth", font, character);
            }
            return (int)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeWidthf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeWidthf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeWidthf$descriptor() {
        return glutStrokeWidthf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeWidthf$handle() {
        return glutStrokeWidthf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeWidthf$address() {
        return glutStrokeWidthf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static float glutStrokeWidthf(MemorySegment font, int character) {
        var mh$ = glutStrokeWidthf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeWidthf", font, character);
            }
            return (float)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutBitmapLength$descriptor() {
        return glutBitmapLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutBitmapLength$handle() {
        return glutBitmapLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutBitmapLength$address() {
        return glutBitmapLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static int glutBitmapLength(MemorySegment font, MemorySegment string) {
        var mh$ = glutBitmapLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapLength", font, string);
            }
            return (int)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutStrokeLength$descriptor() {
        return glutStrokeLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutStrokeLength$handle() {
        return glutStrokeLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutStrokeLength$address() {
        return glutStrokeLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static int glutStrokeLength(MemorySegment font, MemorySegment string) {
        var mh$ = glutStrokeLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeLength", font, string);
            }
            return (int)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeLengthf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeLengthf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutStrokeLengthf$descriptor() {
        return glutStrokeLengthf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutStrokeLengthf$handle() {
        return glutStrokeLengthf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutStrokeLengthf$address() {
        return glutStrokeLengthf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static float glutStrokeLengthf(MemorySegment font, MemorySegment string) {
        var mh$ = glutStrokeLengthf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeLengthf", font, string);
            }
            return (float)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static FunctionDescriptor glutWireCube$descriptor() {
        return glutWireCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static MethodHandle glutWireCube$handle() {
        return glutWireCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static MemorySegment glutWireCube$address() {
        return glutWireCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static void glutWireCube(double size) {
        var mh$ = glutWireCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCube", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static FunctionDescriptor glutSolidCube$descriptor() {
        return glutSolidCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static MethodHandle glutSolidCube$handle() {
        return glutSolidCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static MemorySegment glutSolidCube$address() {
        return glutSolidCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static void glutSolidCube(double size) {
        var mh$ = glutSolidCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCube", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireSphere$descriptor() {
        return glutWireSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireSphere$handle() {
        return glutWireSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireSphere$address() {
        return glutWireSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireSphere(double radius, int slices, int stacks) {
        var mh$ = glutWireSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireSphere", radius, slices, stacks);
            }
            mh$.invokeExact(radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidSphere$descriptor() {
        return glutSolidSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidSphere$handle() {
        return glutSolidSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidSphere$address() {
        return glutSolidSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidSphere(double radius, int slices, int stacks) {
        var mh$ = glutSolidSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidSphere", radius, slices, stacks);
            }
            mh$.invokeExact(radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireCone$descriptor() {
        return glutWireCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireCone$handle() {
        return glutWireCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireCone$address() {
        return glutWireCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireCone(double base, double height, int slices, int stacks) {
        var mh$ = glutWireCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCone", base, height, slices, stacks);
            }
            mh$.invokeExact(base, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidCone$descriptor() {
        return glutSolidCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidCone$handle() {
        return glutSolidCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidCone$address() {
        return glutSolidCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidCone(double base, double height, int slices, int stacks) {
        var mh$ = glutSolidCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCone", base, height, slices, stacks);
            }
            mh$.invokeExact(base, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static FunctionDescriptor glutWireTorus$descriptor() {
        return glutWireTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MethodHandle glutWireTorus$handle() {
        return glutWireTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MemorySegment glutWireTorus$address() {
        return glutWireTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static void glutWireTorus(double innerRadius, double outerRadius, int sides, int rings) {
        var mh$ = glutWireTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTorus", innerRadius, outerRadius, sides, rings);
            }
            mh$.invokeExact(innerRadius, outerRadius, sides, rings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static FunctionDescriptor glutSolidTorus$descriptor() {
        return glutSolidTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MethodHandle glutSolidTorus$handle() {
        return glutSolidTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MemorySegment glutSolidTorus$address() {
        return glutSolidTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static void glutSolidTorus(double innerRadius, double outerRadius, int sides, int rings) {
        var mh$ = glutSolidTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTorus", innerRadius, outerRadius, sides, rings);
            }
            mh$.invokeExact(innerRadius, outerRadius, sides, rings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static FunctionDescriptor glutWireDodecahedron$descriptor() {
        return glutWireDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static MethodHandle glutWireDodecahedron$handle() {
        return glutWireDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static MemorySegment glutWireDodecahedron$address() {
        return glutWireDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static void glutWireDodecahedron() {
        var mh$ = glutWireDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static FunctionDescriptor glutSolidDodecahedron$descriptor() {
        return glutSolidDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static MethodHandle glutSolidDodecahedron$handle() {
        return glutSolidDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static MemorySegment glutSolidDodecahedron$address() {
        return glutSolidDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static void glutSolidDodecahedron() {
        var mh$ = glutSolidDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireOctahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireOctahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static FunctionDescriptor glutWireOctahedron$descriptor() {
        return glutWireOctahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static MethodHandle glutWireOctahedron$handle() {
        return glutWireOctahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static MemorySegment glutWireOctahedron$address() {
        return glutWireOctahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static void glutWireOctahedron() {
        var mh$ = glutWireOctahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireOctahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidOctahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidOctahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static FunctionDescriptor glutSolidOctahedron$descriptor() {
        return glutSolidOctahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static MethodHandle glutSolidOctahedron$handle() {
        return glutSolidOctahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static MemorySegment glutSolidOctahedron$address() {
        return glutSolidOctahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static void glutSolidOctahedron() {
        var mh$ = glutSolidOctahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidOctahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTetrahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTetrahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static FunctionDescriptor glutWireTetrahedron$descriptor() {
        return glutWireTetrahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static MethodHandle glutWireTetrahedron$handle() {
        return glutWireTetrahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static MemorySegment glutWireTetrahedron$address() {
        return glutWireTetrahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static void glutWireTetrahedron() {
        var mh$ = glutWireTetrahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTetrahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTetrahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTetrahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static FunctionDescriptor glutSolidTetrahedron$descriptor() {
        return glutSolidTetrahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static MethodHandle glutSolidTetrahedron$handle() {
        return glutSolidTetrahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static MemorySegment glutSolidTetrahedron$address() {
        return glutSolidTetrahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static void glutSolidTetrahedron() {
        var mh$ = glutSolidTetrahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTetrahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireIcosahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireIcosahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static FunctionDescriptor glutWireIcosahedron$descriptor() {
        return glutWireIcosahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static MethodHandle glutWireIcosahedron$handle() {
        return glutWireIcosahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static MemorySegment glutWireIcosahedron$address() {
        return glutWireIcosahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static void glutWireIcosahedron() {
        var mh$ = glutWireIcosahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireIcosahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidIcosahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidIcosahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static FunctionDescriptor glutSolidIcosahedron$descriptor() {
        return glutSolidIcosahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static MethodHandle glutSolidIcosahedron$handle() {
        return glutSolidIcosahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static MemorySegment glutSolidIcosahedron$address() {
        return glutSolidIcosahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static void glutSolidIcosahedron() {
        var mh$ = glutSolidIcosahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidIcosahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTeapot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTeapot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static FunctionDescriptor glutWireTeapot$descriptor() {
        return glutWireTeapot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static MethodHandle glutWireTeapot$handle() {
        return glutWireTeapot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static MemorySegment glutWireTeapot$address() {
        return glutWireTeapot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static void glutWireTeapot(double size) {
        var mh$ = glutWireTeapot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTeapot", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTeapot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTeapot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static FunctionDescriptor glutSolidTeapot$descriptor() {
        return glutSolidTeapot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static MethodHandle glutSolidTeapot$handle() {
        return glutSolidTeapot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static MemorySegment glutSolidTeapot$address() {
        return glutSolidTeapot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static void glutSolidTeapot(double size) {
        var mh$ = glutSolidTeapot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTeapot", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGameModeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGameModeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static FunctionDescriptor glutGameModeString$descriptor() {
        return glutGameModeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static MethodHandle glutGameModeString$handle() {
        return glutGameModeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static MemorySegment glutGameModeString$address() {
        return glutGameModeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static void glutGameModeString(MemorySegment string) {
        var mh$ = glutGameModeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGameModeString", string);
            }
            mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEnterGameMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEnterGameMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static FunctionDescriptor glutEnterGameMode$descriptor() {
        return glutEnterGameMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static MethodHandle glutEnterGameMode$handle() {
        return glutEnterGameMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static MemorySegment glutEnterGameMode$address() {
        return glutEnterGameMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static int glutEnterGameMode() {
        var mh$ = glutEnterGameMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEnterGameMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLeaveGameMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLeaveGameMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static FunctionDescriptor glutLeaveGameMode$descriptor() {
        return glutLeaveGameMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static MethodHandle glutLeaveGameMode$handle() {
        return glutLeaveGameMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static MemorySegment glutLeaveGameMode$address() {
        return glutLeaveGameMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static void glutLeaveGameMode() {
        var mh$ = glutLeaveGameMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLeaveGameMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGameModeGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGameModeGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutGameModeGet$descriptor() {
        return glutGameModeGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static MethodHandle glutGameModeGet$handle() {
        return glutGameModeGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static MemorySegment glutGameModeGet$address() {
        return glutGameModeGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static int glutGameModeGet(int query) {
        var mh$ = glutGameModeGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGameModeGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoResizeGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVideoResizeGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutVideoResizeGet$descriptor() {
        return glutVideoResizeGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static MethodHandle glutVideoResizeGet$handle() {
        return glutVideoResizeGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static MemorySegment glutVideoResizeGet$address() {
        return glutVideoResizeGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static int glutVideoResizeGet(int query) {
        var mh$ = glutVideoResizeGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoResizeGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetupVideoResizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetupVideoResizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static FunctionDescriptor glutSetupVideoResizing$descriptor() {
        return glutSetupVideoResizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static MethodHandle glutSetupVideoResizing$handle() {
        return glutSetupVideoResizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static MemorySegment glutSetupVideoResizing$address() {
        return glutSetupVideoResizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static void glutSetupVideoResizing() {
        var mh$ = glutSetupVideoResizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetupVideoResizing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStopVideoResizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStopVideoResizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static FunctionDescriptor glutStopVideoResizing$descriptor() {
        return glutStopVideoResizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static MethodHandle glutStopVideoResizing$handle() {
        return glutStopVideoResizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static MemorySegment glutStopVideoResizing$address() {
        return glutStopVideoResizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static void glutStopVideoResizing() {
        var mh$ = glutStopVideoResizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStopVideoResizing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoResize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVideoResize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutVideoResize$descriptor() {
        return glutVideoResize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutVideoResize$handle() {
        return glutVideoResize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutVideoResize$address() {
        return glutVideoResize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static void glutVideoResize(int x, int y, int width, int height) {
        var mh$ = glutVideoResize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoResize", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVideoPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutVideoPan$descriptor() {
        return glutVideoPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutVideoPan$handle() {
        return glutVideoPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutVideoPan$address() {
        return glutVideoPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static void glutVideoPan(int x, int y, int width, int height) {
        var mh$ = glutVideoPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoPan", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glutSetColor$descriptor() {
        return glutSetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glutSetColor$handle() {
        return glutSetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glutSetColor$address() {
        return glutSetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glutSetColor(int color, float red, float green, float blue) {
        var mh$ = glutSetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetColor", color, red, green, blue);
            }
            mh$.invokeExact(color, red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static FunctionDescriptor glutGetColor$descriptor() {
        return glutGetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static MethodHandle glutGetColor$handle() {
        return glutGetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static MemorySegment glutGetColor$address() {
        return glutGetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static float glutGetColor(int color, int component) {
        var mh$ = glutGetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetColor", color, component);
            }
            return (float)mh$.invokeExact(color, component);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCopyColormap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCopyColormap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static FunctionDescriptor glutCopyColormap$descriptor() {
        return glutCopyColormap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static MethodHandle glutCopyColormap$handle() {
        return glutCopyColormap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static MemorySegment glutCopyColormap$address() {
        return glutCopyColormap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static void glutCopyColormap(int window) {
        var mh$ = glutCopyColormap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCopyColormap", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIgnoreKeyRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIgnoreKeyRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static FunctionDescriptor glutIgnoreKeyRepeat$descriptor() {
        return glutIgnoreKeyRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static MethodHandle glutIgnoreKeyRepeat$handle() {
        return glutIgnoreKeyRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static MemorySegment glutIgnoreKeyRepeat$address() {
        return glutIgnoreKeyRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static void glutIgnoreKeyRepeat(int ignore) {
        var mh$ = glutIgnoreKeyRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIgnoreKeyRepeat", ignore);
            }
            mh$.invokeExact(ignore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetKeyRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetKeyRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static FunctionDescriptor glutSetKeyRepeat$descriptor() {
        return glutSetKeyRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static MethodHandle glutSetKeyRepeat$handle() {
        return glutSetKeyRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static MemorySegment glutSetKeyRepeat$address() {
        return glutSetKeyRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static void glutSetKeyRepeat(int repeatMode) {
        var mh$ = glutSetKeyRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetKeyRepeat", repeatMode);
            }
            mh$.invokeExact(repeatMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutForceJoystickFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutForceJoystickFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static FunctionDescriptor glutForceJoystickFunc$descriptor() {
        return glutForceJoystickFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static MethodHandle glutForceJoystickFunc$handle() {
        return glutForceJoystickFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static MemorySegment glutForceJoystickFunc$address() {
        return glutForceJoystickFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static void glutForceJoystickFunc() {
        var mh$ = glutForceJoystickFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutForceJoystickFunc");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutExtensionSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutExtensionSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static FunctionDescriptor glutExtensionSupported$descriptor() {
        return glutExtensionSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static MethodHandle glutExtensionSupported$handle() {
        return glutExtensionSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static MemorySegment glutExtensionSupported$address() {
        return glutExtensionSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static int glutExtensionSupported(MemorySegment extension) {
        var mh$ = glutExtensionSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutExtensionSupported", extension);
            }
            return (int)mh$.invokeExact(extension);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReportErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReportErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static FunctionDescriptor glutReportErrors$descriptor() {
        return glutReportErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static MethodHandle glutReportErrors$handle() {
        return glutReportErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static MemorySegment glutReportErrors$address() {
        return glutReportErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static void glutReportErrors() {
        var mh$ = glutReportErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReportErrors");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _calloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_calloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _calloc_base$descriptor() {
        return _calloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _calloc_base$handle() {
        return _calloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base$address() {
        return _calloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base(long _Count, long _Size) {
        var mh$ = _calloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_calloc_base", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc(long _Count, long _Size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _callnewh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_callnewh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static FunctionDescriptor _callnewh$descriptor() {
        return _callnewh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MethodHandle _callnewh$handle() {
        return _callnewh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MemorySegment _callnewh$address() {
        return _callnewh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static int _callnewh(long _Size) {
        var mh$ = _callnewh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_callnewh", _Size);
            }
            return (int)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _expand$descriptor() {
        return _expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _expand$handle() {
        return _expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand$address() {
        return _expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand(MemorySegment _Block, long _Size) {
        var mh$ = _expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_expand", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _free_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_free_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _free_base$descriptor() {
        return _free_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MethodHandle _free_base$handle() {
        return _free_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MemorySegment _free_base$address() {
        return _free_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static void _free_base(MemorySegment _Block) {
        var mh$ = _free_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_free_base", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static void free(MemorySegment _Block) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _malloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_malloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static FunctionDescriptor _malloc_base$descriptor() {
        return _malloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MethodHandle _malloc_base$handle() {
        return _malloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base$address() {
        return _malloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base(long _Size) {
        var mh$ = _malloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_malloc_base", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc(long _Size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_msize_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize_base$descriptor() {
        return _msize_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MethodHandle _msize_base$handle() {
        return _msize_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MemorySegment _msize_base$address() {
        return _msize_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static long _msize_base(MemorySegment _Block) {
        var mh$ = _msize_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize_base", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize$descriptor() {
        return _msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MethodHandle _msize$handle() {
        return _msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MemorySegment _msize$address() {
        return _msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static long _msize(MemorySegment _Block) {
        var mh$ = _msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _realloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_realloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _realloc_base$descriptor() {
        return _realloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _realloc_base$handle() {
        return _realloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base$address() {
        return _realloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base(MemorySegment _Block, long _Size) {
        var mh$ = _realloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_realloc_base", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc(MemorySegment _Block, long _Size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_recalloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc_base$descriptor() {
        return _recalloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc_base$handle() {
        return _recalloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base$address() {
        return _recalloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc_base", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc$descriptor() {
        return _recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc$handle() {
        return _recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc$address() {
        return _recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static FunctionDescriptor _aligned_free$descriptor() {
        return _aligned_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MethodHandle _aligned_free$handle() {
        return _aligned_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MemorySegment _aligned_free$address() {
        return _aligned_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static void _aligned_free(MemorySegment _Block) {
        var mh$ = _aligned_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_malloc$descriptor() {
        return _aligned_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_malloc$handle() {
        return _aligned_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc$address() {
        return _aligned_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc(long _Size, long _Alignment) {
        var mh$ = _aligned_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_malloc", _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_offset_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_malloc$descriptor() {
        return _aligned_offset_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_malloc$handle() {
        return _aligned_offset_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc$address() {
        return _aligned_offset_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc(long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_malloc", _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_msize$descriptor() {
        return _aligned_msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_msize$handle() {
        return _aligned_msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_msize$address() {
        return _aligned_msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static long _aligned_msize(MemorySegment _Block, long _Alignment, long _Offset) {
        var mh$ = _aligned_msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_msize", _Block, _Alignment, _Offset);
            }
            return (long)mh$.invokeExact(_Block, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_offset_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_realloc$descriptor() {
        return _aligned_offset_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_realloc$handle() {
        return _aligned_offset_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc$address() {
        return _aligned_offset_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc(MemorySegment _Block, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_realloc", _Block, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_offset_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_recalloc$descriptor() {
        return _aligned_offset_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_recalloc$handle() {
        return _aligned_offset_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc$address() {
        return _aligned_offset_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_recalloc", _Block, _Count, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_realloc$descriptor() {
        return _aligned_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_realloc$handle() {
        return _aligned_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc$address() {
        return _aligned_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc(MemorySegment _Block, long _Size, long _Alignment) {
        var mh$ = _aligned_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_realloc", _Block, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_aligned_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_recalloc$descriptor() {
        return _aligned_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_recalloc$handle() {
        return _aligned_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc$address() {
        return _aligned_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment) {
        var mh$ = _aligned_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_recalloc", _Block, _Count, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = freeglut_h.C_DOUBLE;

    private static class bsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("bsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor bsearch_s$descriptor() {
        return bsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle bsearch_s$handle() {
        return bsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s$address() {
        return bsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = bsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("qsort_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor qsort_s$descriptor() {
        return qsort_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle qsort_s$handle() {
        return qsort_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment qsort_s$address() {
        return qsort_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static void qsort_s(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = qsort_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_s", _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static void qsort(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lfind_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lfind_s$descriptor() {
        return _lfind_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lfind_s$handle() {
        return _lfind_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s$address() {
        return _lfind_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lfind_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lfind$descriptor() {
        return _lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lfind$handle() {
        return _lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind$address() {
        return _lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lsearch_s$descriptor() {
        return _lsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lsearch_s$handle() {
        return _lsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s$address() {
        return _lsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lsearch$descriptor() {
        return _lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lsearch$handle() {
        return _lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch$address() {
        return _lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lfind$descriptor() {
        return lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lfind$handle() {
        return lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind$address() {
        return lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lsearch$descriptor() {
        return lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lsearch$handle() {
        return lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch$address() {
        return lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_itow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow_s$descriptor() {
        return _itow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itow_s$handle() {
        return _itow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itow_s$address() {
        return _itow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_itow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow$descriptor() {
        return _itow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itow$handle() {
        return _itow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow$address() {
        return _itow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ltow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow_s$descriptor() {
        return _ltow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltow_s$handle() {
        return _ltow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltow_s$address() {
        return _ltow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ltow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow$descriptor() {
        return _ltow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltow$handle() {
        return _ltow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow$address() {
        return _ltow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ultow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow_s$descriptor() {
        return _ultow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultow_s$handle() {
        return _ultow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultow_s$address() {
        return _ultow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ultow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow$descriptor() {
        return _ultow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultow$handle() {
        return _ultow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow$address() {
        return _ultow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstod$address() {
        return wcstod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstod_l$descriptor() {
        return _wcstod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstod_l$handle() {
        return _wcstod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstod_l$address() {
        return _wcstod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstol$address() {
        return wcstol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstol_l$descriptor() {
        return _wcstol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstol_l$handle() {
        return _wcstol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstol_l$address() {
        return _wcstol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoll$address() {
        return wcstoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoll_l$descriptor() {
        return _wcstoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoll_l$handle() {
        return _wcstoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoll_l$address() {
        return _wcstoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoul$address() {
        return wcstoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoul_l$descriptor() {
        return _wcstoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoul_l$handle() {
        return _wcstoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoul_l$address() {
        return _wcstoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoull$address() {
        return wcstoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoull_l$descriptor() {
        return _wcstoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoull_l$handle() {
        return _wcstoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoull_l$address() {
        return _wcstoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstold$descriptor() {
        return wcstold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstold$handle() {
        return wcstold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstold$address() {
        return wcstold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstold_l$descriptor() {
        return _wcstold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstold_l$handle() {
        return _wcstold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstold_l$address() {
        return _wcstold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstof$address() {
        return wcstof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static float wcstof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstof_l$descriptor() {
        return _wcstof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstof_l$handle() {
        return _wcstof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstof_l$address() {
        return _wcstof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _wcstof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtof$descriptor() {
        return _wtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtof$handle() {
        return _wtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtof$address() {
        return _wtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static double _wtof(MemorySegment _String) {
        var mh$ = _wtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtof_l$descriptor() {
        return _wtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtof_l$handle() {
        return _wtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtof_l$address() {
        return _wtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static double _wtof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi$descriptor() {
        return _wtoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi$handle() {
        return _wtoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi$address() {
        return _wtoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static int _wtoi(MemorySegment _String) {
        var mh$ = _wtoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi_l$descriptor() {
        return _wtoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi_l$handle() {
        return _wtoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi_l$address() {
        return _wtoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtol$descriptor() {
        return _wtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtol$handle() {
        return _wtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtol$address() {
        return _wtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static int _wtol(MemorySegment _String) {
        var mh$ = _wtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtol_l$descriptor() {
        return _wtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtol_l$handle() {
        return _wtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtol_l$address() {
        return _wtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoll$descriptor() {
        return _wtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoll$handle() {
        return _wtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoll$address() {
        return _wtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static long _wtoll(MemorySegment _String) {
        var mh$ = _wtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoll_l$descriptor() {
        return _wtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoll_l$handle() {
        return _wtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoll_l$address() {
        return _wtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_i64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow_s$descriptor() {
        return _i64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64tow_s$handle() {
        return _i64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64tow_s$address() {
        return _i64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_i64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow$descriptor() {
        return _i64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64tow$handle() {
        return _i64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow$address() {
        return _i64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ui64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow_s$descriptor() {
        return _ui64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow_s$handle() {
        return _ui64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow_s$address() {
        return _ui64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ui64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow$descriptor() {
        return _ui64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow$handle() {
        return _ui64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow$address() {
        return _ui64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi64$descriptor() {
        return _wtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi64$handle() {
        return _wtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi64$address() {
        return _wtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static long _wtoi64(MemorySegment _String) {
        var mh$ = _wtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi64_l$descriptor() {
        return _wtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi64_l$handle() {
        return _wtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi64_l$address() {
        return _wtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoi64$descriptor() {
        return _wcstoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoi64$handle() {
        return _wcstoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoi64$address() {
        return _wcstoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoi64_l$descriptor() {
        return _wcstoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoi64_l$handle() {
        return _wcstoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoi64_l$address() {
        return _wcstoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoui64$descriptor() {
        return _wcstoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoui64$handle() {
        return _wcstoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoui64$address() {
        return _wcstoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoui64_l$descriptor() {
        return _wcstoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoui64_l$handle() {
        return _wcstoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoui64_l$address() {
        return _wcstoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wfullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wfullpath$descriptor() {
        return _wfullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wfullpath$handle() {
        return _wfullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath$address() {
        return _wfullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _wfullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wmakepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath_s$descriptor() {
        return _wmakepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath_s$handle() {
        return _wmakepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath_s$address() {
        return _wmakepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static int _wmakepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wmakepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath$descriptor() {
        return _wmakepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath$handle() {
        return _wmakepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath$address() {
        return _wmakepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static void _wmakepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wperror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment _wperror$address() {
        return _wperror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wsplitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wsplitpath$descriptor() {
        return _wsplitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wsplitpath$handle() {
        return _wsplitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wsplitpath$address() {
        return _wsplitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static void _wsplitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wsplitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wsplitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _wsplitpath_s$descriptor() {
        return _wsplitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _wsplitpath_s$handle() {
        return _wsplitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _wsplitpath_s$address() {
        return _wsplitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static int _wsplitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _wsplitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wdupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wdupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wdupenv_s$descriptor() {
        return _wdupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wdupenv_s$handle() {
        return _wdupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wdupenv_s$address() {
        return _wdupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wdupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _wdupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wdupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wgetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv$descriptor() {
        return _wgetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv$handle() {
        return _wgetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv$address() {
        return _wgetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv(MemorySegment _VarName) {
        var mh$ = _wgetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wgetenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv_s$descriptor() {
        return _wgetenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv_s$handle() {
        return _wgetenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv_s$address() {
        return _wgetenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wgetenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = _wgetenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wputenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static FunctionDescriptor _wputenv$descriptor() {
        return _wputenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MethodHandle _wputenv$handle() {
        return _wputenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MemorySegment _wputenv$address() {
        return _wputenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static int _wputenv(MemorySegment _EnvString) {
        var mh$ = _wputenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wputenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static FunctionDescriptor _wputenv_s$descriptor() {
        return _wputenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MethodHandle _wputenv_s$handle() {
        return _wputenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MemorySegment _wputenv_s$address() {
        return _wputenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static int _wputenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _wputenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wsearchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wsearchenv_s$descriptor() {
        return _wsearchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wsearchenv_s$handle() {
        return _wsearchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wsearchenv_s$address() {
        return _wsearchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wsearchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wsearchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wsearchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static FunctionDescriptor _wsearchenv$descriptor() {
        return _wsearchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MethodHandle _wsearchenv$handle() {
        return _wsearchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MemorySegment _wsearchenv$address() {
        return _wsearchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static void _wsearchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _ResultPath) {
        var mh$ = _wsearchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv", _Filename, _VarName, _ResultPath);
            }
            mh$.invokeExact(_Filename, _VarName, _ResultPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wsystem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static FunctionDescriptor _wsystem$descriptor() {
        return _wsystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MethodHandle _wsystem$handle() {
        return _wsystem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MemorySegment _wsystem$address() {
        return _wsystem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static int _wsystem(MemorySegment _Command) {
        var mh$ = _wsystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsystem", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _swab$descriptor() {
        return _swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle _swab$handle() {
        return _swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment _swab$address() {
        return _swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void _swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = _swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static void exit(int _Code) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static void _exit(int _Code) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static void _Exit(int _Code) {
        var mh$ = _Exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static void quick_exit(int _Code) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_abort_behavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_abort_behavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _set_abort_behavior$descriptor() {
        return _set_abort_behavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MethodHandle _set_abort_behavior$handle() {
        return _set_abort_behavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MemorySegment _set_abort_behavior$address() {
        return _set_abort_behavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static int _set_abort_behavior(int _Flags, int _Mask) {
        var mh$ = _set_abort_behavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_abort_behavior", _Flags, _Mask);
            }
            return (int)mh$.invokeExact(_Flags, _Mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor _onexit$descriptor() {
        return _onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle _onexit$handle() {
        return _onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit$address() {
        return _onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit(MemorySegment _Func) {
        var mh$ = _onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_purecall_handler$descriptor() {
        return _set_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MethodHandle _set_purecall_handler$handle() {
        return _set_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler$address() {
        return _set_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler(MemorySegment _Handler) {
        var mh$ = _set_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_purecall_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static FunctionDescriptor _get_purecall_handler$descriptor() {
        return _get_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MethodHandle _get_purecall_handler$handle() {
        return _get_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler$address() {
        return _get_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler() {
        var mh$ = _get_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_purecall_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_invalid_parameter_handler$descriptor() {
        return _set_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_invalid_parameter_handler$handle() {
        return _set_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler$address() {
        return _set_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_invalid_parameter_handler$descriptor() {
        return _get_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_invalid_parameter_handler$handle() {
        return _get_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler$address() {
        return _get_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler() {
        var mh$ = _get_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_thread_local_invalid_parameter_handler$descriptor() {
        return _set_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_thread_local_invalid_parameter_handler$handle() {
        return _set_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler$address() {
        return _set_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_thread_local_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_thread_local_invalid_parameter_handler$descriptor() {
        return _get_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_thread_local_invalid_parameter_handler$handle() {
        return _get_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler$address() {
        return _get_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler() {
        var mh$ = _get_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_thread_local_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_error_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_error_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_error_mode$descriptor() {
        return _set_error_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MethodHandle _set_error_mode$handle() {
        return _set_error_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MemorySegment _set_error_mode$address() {
        return _set_error_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static int _set_error_mode(int _Mode) {
        var mh$ = _set_error_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_error_mode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_errlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__sys_errlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static FunctionDescriptor __sys_errlist$descriptor() {
        return __sys_errlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MethodHandle __sys_errlist$handle() {
        return __sys_errlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist$address() {
        return __sys_errlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist() {
        var mh$ = __sys_errlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_errlist");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_nerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__sys_nerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static FunctionDescriptor __sys_nerr$descriptor() {
        return __sys_nerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MethodHandle __sys_nerr$handle() {
        return __sys_nerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr$address() {
        return __sys_nerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr() {
        var mh$ = __sys_nerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_nerr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static void perror(MemorySegment _ErrMsg) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrMsg);
            }
            mh$.invokeExact(_ErrMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p__pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static FunctionDescriptor __p__pgmptr$descriptor() {
        return __p__pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MethodHandle __p__pgmptr$handle() {
        return __p__pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr$address() {
        return __p__pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr() {
        var mh$ = __p__pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__pgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p__wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static FunctionDescriptor __p__wpgmptr$descriptor() {
        return __p__wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MethodHandle __p__wpgmptr$handle() {
        return __p__wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr$address() {
        return __p__wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr() {
        var mh$ = __p__wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wpgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p__fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static FunctionDescriptor __p__fmode$descriptor() {
        return __p__fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MethodHandle __p__fmode$handle() {
        return __p__fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode$address() {
        return __p__fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode() {
        var mh$ = __p__fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__fmode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static FunctionDescriptor _get_pgmptr$descriptor() {
        return _get_pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MethodHandle _get_pgmptr$handle() {
        return _get_pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MemorySegment _get_pgmptr$address() {
        return _get_pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static int _get_pgmptr(MemorySegment _Value) {
        var mh$ = _get_pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_pgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static FunctionDescriptor _get_wpgmptr$descriptor() {
        return _get_wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MethodHandle _get_wpgmptr$handle() {
        return _get_wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MemorySegment _get_wpgmptr$address() {
        return _get_wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static int _get_wpgmptr(MemorySegment _Value) {
        var mh$ = _get_wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_wpgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_set_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_fmode$descriptor() {
        return _set_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MethodHandle _set_fmode$handle() {
        return _set_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MemorySegment _set_fmode$address() {
        return _set_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static int _set_fmode(int _Mode) {
        var mh$ = _set_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_fmode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_get_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static FunctionDescriptor _get_fmode$descriptor() {
        return _get_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MethodHandle _get_fmode$handle() {
        return _get_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MemorySegment _get_fmode$address() {
        return _get_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static int _get_fmode(MemorySegment _PMode) {
        var mh$ = _get_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_fmode", _PMode);
            }
            return (int)mh$.invokeExact(_PMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static int abs(int _Number) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static int labs(int _Number) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static long llabs(long _Number) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _abs64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_abs64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static FunctionDescriptor _abs64$descriptor() {
        return _abs64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MethodHandle _abs64$handle() {
        return _abs64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MemorySegment _abs64$address() {
        return _abs64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static long _abs64(long _Number) {
        var mh$ = _abs64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_abs64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ushort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_byteswap_ushort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ushort$descriptor() {
        return _byteswap_ushort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MethodHandle _byteswap_ushort$handle() {
        return _byteswap_ushort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MemorySegment _byteswap_ushort$address() {
        return _byteswap_ushort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static short _byteswap_ushort(short _Number) {
        var mh$ = _byteswap_ushort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ushort", _Number);
            }
            return (short)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ulong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_byteswap_ulong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ulong$descriptor() {
        return _byteswap_ulong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MethodHandle _byteswap_ulong$handle() {
        return _byteswap_ulong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MemorySegment _byteswap_ulong$address() {
        return _byteswap_ulong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static int _byteswap_ulong(int _Number) {
        var mh$ = _byteswap_ulong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ulong", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_byteswap_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_uint64$descriptor() {
        return _byteswap_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MethodHandle _byteswap_uint64$handle() {
        return _byteswap_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MemorySegment _byteswap_uint64$address() {
        return _byteswap_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static long _byteswap_uint64(long _Number) {
        var mh$ = _byteswap_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_uint64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _div_t.layout(),
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _ldiv_t.layout(),
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _lldiv_t.layout(),
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lrotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotl$descriptor() {
        return _lrotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotl$handle() {
        return _lrotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotl$address() {
        return _lrotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotl(int _Value, int _Shift) {
        var mh$ = _lrotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lrotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotr$descriptor() {
        return _lrotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotr$handle() {
        return _lrotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotr$address() {
        return _lrotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotr(int _Value, int _Shift) {
        var mh$ = _lrotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static void srand(int _Seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", _Seed);
            }
            mh$.invokeExact(_Seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static double atof(MemorySegment _String) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static int atoi(MemorySegment _String) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static int atol(MemorySegment _String) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static long atoll(MemorySegment _String) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static FunctionDescriptor _atoi64$descriptor() {
        return _atoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MethodHandle _atoi64$handle() {
        return _atoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MemorySegment _atoi64$address() {
        return _atoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static long _atoi64(MemorySegment _String) {
        var mh$ = _atoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atof_l$descriptor() {
        return _atof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atof_l$handle() {
        return _atof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atof_l$address() {
        return _atof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static double _atof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi_l$descriptor() {
        return _atoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi_l$handle() {
        return _atoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi_l$address() {
        return _atoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atol_l$descriptor() {
        return _atol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atol_l$handle() {
        return _atol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atol_l$address() {
        return _atol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoll_l$descriptor() {
        return _atoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoll_l$handle() {
        return _atoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoll_l$address() {
        return _atoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi64_l$descriptor() {
        return _atoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi64_l$handle() {
        return _atoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi64_l$address() {
        return _atoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoflt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static FunctionDescriptor _atoflt$descriptor() {
        return _atoflt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MethodHandle _atoflt$handle() {
        return _atoflt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MemorySegment _atoflt$address() {
        return _atoflt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static int _atoflt(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoflt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atodbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atodbl$descriptor() {
        return _atodbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atodbl$handle() {
        return _atodbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atodbl$address() {
        return _atodbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static int _atodbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atodbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoldbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atoldbl$descriptor() {
        return _atoldbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atoldbl$handle() {
        return _atoldbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atoldbl$address() {
        return _atoldbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static int _atoldbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoldbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoflt_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoflt_l$descriptor() {
        return _atoflt_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoflt_l$handle() {
        return _atoflt_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoflt_l$address() {
        return _atoflt_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoflt_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoflt_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atodbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atodbl_l$descriptor() {
        return _atodbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atodbl_l$handle() {
        return _atodbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atodbl_l$address() {
        return _atodbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atodbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atodbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_atoldbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoldbl_l$descriptor() {
        return _atoldbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoldbl_l$handle() {
        return _atoldbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoldbl_l$address() {
        return _atoldbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoldbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoldbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static float strtof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtof_l$descriptor() {
        return _strtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtof_l$handle() {
        return _strtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtof_l$address() {
        return _strtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _strtof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtod_l$descriptor() {
        return _strtod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtod_l$handle() {
        return _strtod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtod_l$address() {
        return _strtod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtold$descriptor() {
        return strtold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtold$handle() {
        return strtold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtold$address() {
        return strtold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtold_l$descriptor() {
        return _strtold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtold_l$handle() {
        return _strtold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtold_l$address() {
        return _strtold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtol_l$descriptor() {
        return _strtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtol_l$handle() {
        return _strtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtol_l$address() {
        return _strtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoll_l$descriptor() {
        return _strtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoll_l$handle() {
        return _strtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoll_l$address() {
        return _strtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoul_l$descriptor() {
        return _strtoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoul_l$handle() {
        return _strtoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoul_l$address() {
        return _strtoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoull_l$descriptor() {
        return _strtoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoull_l$handle() {
        return _strtoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoull_l$address() {
        return _strtoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoi64$descriptor() {
        return _strtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoi64$handle() {
        return _strtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoi64$address() {
        return _strtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoi64_l$descriptor() {
        return _strtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoi64_l$handle() {
        return _strtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoi64_l$address() {
        return _strtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoui64$descriptor() {
        return _strtoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoui64$handle() {
        return _strtoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoui64$address() {
        return _strtoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_strtoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoui64_l$descriptor() {
        return _strtoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoui64_l$handle() {
        return _strtoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoui64_l$address() {
        return _strtoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_itoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa_s$descriptor() {
        return _itoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itoa_s$handle() {
        return _itoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itoa_s$address() {
        return _itoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa$descriptor() {
        return _itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itoa$handle() {
        return _itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa$address() {
        return _itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ltoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa_s$descriptor() {
        return _ltoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltoa_s$handle() {
        return _ltoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltoa_s$address() {
        return _ltoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa$descriptor() {
        return _ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltoa$handle() {
        return _ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa$address() {
        return _ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ultoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa_s$descriptor() {
        return _ultoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultoa_s$handle() {
        return _ultoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultoa_s$address() {
        return _ultoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa$descriptor() {
        return _ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultoa$handle() {
        return _ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa$address() {
        return _ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_i64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa_s$descriptor() {
        return _i64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64toa_s$handle() {
        return _i64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64toa_s$address() {
        return _i64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_i64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa$descriptor() {
        return _i64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64toa$handle() {
        return _i64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa$address() {
        return _i64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ui64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa_s$descriptor() {
        return _ui64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa_s$handle() {
        return _ui64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa_s$address() {
        return _ui64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ui64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa$descriptor() {
        return _ui64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa$handle() {
        return _ui64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa$address() {
        return _ui64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ecvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt_s$descriptor() {
        return _ecvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt_s$handle() {
        return _ecvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt_s$address() {
        return _ecvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _ecvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt_s", _Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt$descriptor() {
        return _ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt$handle() {
        return _ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt$address() {
        return _ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_fcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt_s$descriptor() {
        return _fcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt_s$handle() {
        return _fcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt_s$address() {
        return _fcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _fcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt_s", _Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt$descriptor() {
        return _fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt$handle() {
        return _fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt$address() {
        return _fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_gcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static FunctionDescriptor _gcvt_s$descriptor() {
        return _gcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MethodHandle _gcvt_s$handle() {
        return _gcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MemorySegment _gcvt_s$address() {
        return _gcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static int _gcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount) {
        var mh$ = _gcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt_s", _Buffer, _BufferCount, _Value, _DigitCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _gcvt$descriptor() {
        return _gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MethodHandle _gcvt$handle() {
        return _gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt$address() {
        return _gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt(double _Value, int _DigitCount, MemorySegment _Buffer) {
        var mh$ = _gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt", _Value, _DigitCount, _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static int mblen(MemorySegment _Ch, long _MaxCount) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", _Ch, _MaxCount);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mblen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mblen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mblen_l$descriptor() {
        return _mblen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mblen_l$handle() {
        return _mblen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mblen_l$address() {
        return _mblen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mblen_l(MemorySegment _Ch, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mblen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mblen_l", _Ch, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mbstrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static FunctionDescriptor _mbstrlen$descriptor() {
        return _mbstrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MethodHandle _mbstrlen$handle() {
        return _mbstrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MemorySegment _mbstrlen$address() {
        return _mbstrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static long _mbstrlen(MemorySegment _String) {
        var mh$ = _mbstrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mbstrlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrlen_l$descriptor() {
        return _mbstrlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrlen_l$handle() {
        return _mbstrlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrlen_l$address() {
        return _mbstrlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _mbstrlen_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _mbstrlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mbstrnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _mbstrnlen$descriptor() {
        return _mbstrnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle _mbstrnlen$handle() {
        return _mbstrnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment _mbstrnlen$address() {
        return _mbstrnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long _mbstrnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = _mbstrnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mbstrnlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrnlen_l$descriptor() {
        return _mbstrnlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrnlen_l$handle() {
        return _mbstrnlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrnlen_l$address() {
        return _mbstrnlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstrnlen_l(MemorySegment _String, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstrnlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen_l", _String, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_String, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static int mbtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", _DstCh, _SrcCh, _SrcSizeInBytes);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbtowc_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mbtowc_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbtowc_l$descriptor() {
        return _mbtowc_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbtowc_l$handle() {
        return _mbtowc_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbtowc_l$address() {
        return _mbtowc_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static int _mbtowc_l(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes, MemorySegment _Locale) {
        var mh$ = _mbtowc_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbtowc_l", _DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mbstowcs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs_s$descriptor() {
        return mbstowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs_s$handle() {
        return mbstowcs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs_s$address() {
        return mbstowcs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static int mbstowcs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount) {
        var mh$ = mbstowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs_s", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long mbstowcs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mbstowcs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_s_l$descriptor() {
        return _mbstowcs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_s_l$handle() {
        return _mbstowcs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_s_l$address() {
        return _mbstowcs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mbstowcs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_s_l", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_mbstowcs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_l$descriptor() {
        return _mbstowcs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_l$handle() {
        return _mbstowcs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_l$address() {
        return _mbstowcs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstowcs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static int wctomb(MemorySegment _MbCh, short _WCh) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", _MbCh, _WCh);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wctomb_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_l$descriptor() {
        return _wctomb_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_l$handle() {
        return _wctomb_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_l$address() {
        return _wctomb_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_l(MemorySegment _MbCh, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_l", _MbCh, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wctomb_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb_s$descriptor() {
        return wctomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb_s$handle() {
        return wctomb_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb_s$address() {
        return wctomb_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static int wctomb_s(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh) {
        var mh$ = wctomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb_s", _SizeConverted, _MbCh, _SizeInBytes, _WCh);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wctomb_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_s_l$descriptor() {
        return _wctomb_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_s_l$handle() {
        return _wctomb_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_s_l$address() {
        return _wctomb_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_s_l(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_s_l", _SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstombs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static FunctionDescriptor wcstombs_s$descriptor() {
        return wcstombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MethodHandle wcstombs_s$handle() {
        return wcstombs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MemorySegment wcstombs_s$address() {
        return wcstombs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static int wcstombs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes) {
        var mh$ = wcstombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs_s", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcstombs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstombs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_s_l$descriptor() {
        return _wcstombs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_s_l$handle() {
        return _wcstombs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_s_l$address() {
        return _wcstombs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static int _wcstombs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes, MemorySegment _Locale) {
        var mh$ = _wcstombs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_s_l", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_wcstombs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_l$descriptor() {
        return _wcstombs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_l$handle() {
        return _wcstombs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_l$address() {
        return _wcstombs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcstombs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcstombs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_fullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _fullpath$descriptor() {
        return _fullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _fullpath$handle() {
        return _fullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath$address() {
        return _fullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _fullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_makepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath_s$descriptor() {
        return _makepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath_s$handle() {
        return _makepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath_s$address() {
        return _makepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static int _makepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_makepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath$descriptor() {
        return _makepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath$handle() {
        return _makepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath$address() {
        return _makepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static void _makepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_splitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static FunctionDescriptor _splitpath$descriptor() {
        return _splitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MethodHandle _splitpath$handle() {
        return _splitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MemorySegment _splitpath$address() {
        return _splitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static void _splitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _splitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_splitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _splitpath_s$descriptor() {
        return _splitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _splitpath_s$handle() {
        return _splitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _splitpath_s$address() {
        return _splitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static int _splitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _splitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv_s$descriptor() {
        return getenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle getenv_s$handle() {
        return getenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment getenv_s$address() {
        return getenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static int getenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = getenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p___argc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static FunctionDescriptor __p___argc$descriptor() {
        return __p___argc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MethodHandle __p___argc$handle() {
        return __p___argc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc$address() {
        return __p___argc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc() {
        var mh$ = __p___argc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p___argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static FunctionDescriptor __p___argv$descriptor() {
        return __p___argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MethodHandle __p___argv$handle() {
        return __p___argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv$address() {
        return __p___argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv() {
        var mh$ = __p___argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___wargv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p___wargv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static FunctionDescriptor __p___wargv$descriptor() {
        return __p___wargv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MethodHandle __p___wargv$handle() {
        return __p___wargv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv$address() {
        return __p___wargv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv() {
        var mh$ = __p___wargv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___wargv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__environ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p__environ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static FunctionDescriptor __p__environ$descriptor() {
        return __p__environ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MethodHandle __p__environ$handle() {
        return __p__environ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ$address() {
        return __p__environ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ() {
        var mh$ = __p__environ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__environ");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wenviron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__p__wenviron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static FunctionDescriptor __p__wenviron$descriptor() {
        return __p__wenviron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MethodHandle __p__wenviron$handle() {
        return __p__wenviron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron$address() {
        return __p__wenviron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron() {
        var mh$ = __p__wenviron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wenviron");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv(MemorySegment _VarName) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_dupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor _dupenv_s$descriptor() {
        return _dupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle _dupenv_s$handle() {
        return _dupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment _dupenv_s$address() {
        return _dupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static int _dupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _dupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static int system(MemorySegment _Command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor _putenv$descriptor() {
        return _putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle _putenv$handle() {
        return _putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment _putenv$address() {
        return _putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static int _putenv(MemorySegment _EnvString) {
        var mh$ = _putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_putenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static FunctionDescriptor _putenv_s$descriptor() {
        return _putenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MethodHandle _putenv_s$handle() {
        return _putenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MemorySegment _putenv_s$address() {
        return _putenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static int _putenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _putenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_searchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _searchenv_s$descriptor() {
        return _searchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _searchenv_s$handle() {
        return _searchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _searchenv_s$address() {
        return _searchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _searchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _searchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_searchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _searchenv$descriptor() {
        return _searchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MethodHandle _searchenv$handle() {
        return _searchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MemorySegment _searchenv$address() {
        return _searchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static void _searchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer) {
        var mh$ = _searchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv", _Filename, _VarName, _Buffer);
            }
            mh$.invokeExact(_Filename, _VarName, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _seterrormode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_seterrormode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static FunctionDescriptor _seterrormode$descriptor() {
        return _seterrormode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MethodHandle _seterrormode$handle() {
        return _seterrormode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MemorySegment _seterrormode$address() {
        return _seterrormode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static void _seterrormode(int _Mode) {
        var mh$ = _seterrormode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_seterrormode", _Mode);
            }
            mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static FunctionDescriptor _beep$descriptor() {
        return _beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MethodHandle _beep$handle() {
        return _beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MemorySegment _beep$address() {
        return _beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static void _beep(int _Frequency, int _Duration) {
        var mh$ = _beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_beep", _Frequency, _Duration);
            }
            mh$.invokeExact(_Frequency, _Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static FunctionDescriptor _sleep$descriptor() {
        return _sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MethodHandle _sleep$handle() {
        return _sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MemorySegment _sleep$address() {
        return _sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static void _sleep(int _Duration) {
        var mh$ = _sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sleep", _Duration);
            }
            mh$.invokeExact(_Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt(double _Value, int _DigitCount, MemorySegment _DstBuf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", _Value, _DigitCount, _DstBuf);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _DstBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor itoa$descriptor() {
        return itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle itoa$handle() {
        return itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa$address() {
        return itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ltoa$descriptor() {
        return ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ltoa$handle() {
        return ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa$address() {
        return ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ultoa$descriptor() {
        return ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ultoa$handle() {
        return ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa$address() {
        return ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static int putenv(MemorySegment _EnvString) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor onexit$descriptor() {
        return onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle onexit$handle() {
        return onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit$address() {
        return onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit(MemorySegment _Func) {
        var mh$ = onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __glutInitWithExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__glutInitWithExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __glutInitWithExit(int *argcp, char **argv, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor __glutInitWithExit$descriptor() {
        return __glutInitWithExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __glutInitWithExit(int *argcp, char **argv, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle __glutInitWithExit$handle() {
        return __glutInitWithExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __glutInitWithExit(int *argcp, char **argv, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment __glutInitWithExit$address() {
        return __glutInitWithExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __glutInitWithExit(int *argcp, char **argv, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static void __glutInitWithExit(MemorySegment argcp, MemorySegment argv, MemorySegment exitfunc) {
        var mh$ = __glutInitWithExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__glutInitWithExit", argcp, argv, exitfunc);
            }
            mh$.invokeExact(argcp, argv, exitfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __glutCreateWindowWithExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__glutCreateWindowWithExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __glutCreateWindowWithExit(const char *title, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor __glutCreateWindowWithExit$descriptor() {
        return __glutCreateWindowWithExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __glutCreateWindowWithExit(const char *title, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle __glutCreateWindowWithExit$handle() {
        return __glutCreateWindowWithExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __glutCreateWindowWithExit(const char *title, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment __glutCreateWindowWithExit$address() {
        return __glutCreateWindowWithExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __glutCreateWindowWithExit(const char *title, void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static int __glutCreateWindowWithExit(MemorySegment title, MemorySegment exitfunc) {
        var mh$ = __glutCreateWindowWithExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__glutCreateWindowWithExit", title, exitfunc);
            }
            return (int)mh$.invokeExact(title, exitfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __glutCreateMenuWithExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__glutCreateMenuWithExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __glutCreateMenuWithExit(void (*func)(int), void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor __glutCreateMenuWithExit$descriptor() {
        return __glutCreateMenuWithExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __glutCreateMenuWithExit(void (*func)(int), void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle __glutCreateMenuWithExit$handle() {
        return __glutCreateMenuWithExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __glutCreateMenuWithExit(void (*func)(int), void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment __glutCreateMenuWithExit$address() {
        return __glutCreateMenuWithExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __glutCreateMenuWithExit(void (*func)(int), void (*exitfunc)(int) __attribute__((cdecl)))
     * }
     */
    public static int __glutCreateMenuWithExit(MemorySegment func, MemorySegment exitfunc) {
        var mh$ = __glutCreateMenuWithExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__glutCreateMenuWithExit", func, exitfunc);
            }
            return (int)mh$.invokeExact(func, exitfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMainLoopEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMainLoopEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static FunctionDescriptor glutMainLoopEvent$descriptor() {
        return glutMainLoopEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static MethodHandle glutMainLoopEvent$handle() {
        return glutMainLoopEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static MemorySegment glutMainLoopEvent$address() {
        return glutMainLoopEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static void glutMainLoopEvent() {
        var mh$ = glutMainLoopEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMainLoopEvent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLeaveMainLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLeaveMainLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static FunctionDescriptor glutLeaveMainLoop$descriptor() {
        return glutLeaveMainLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static MethodHandle glutLeaveMainLoop$handle() {
        return glutLeaveMainLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static MemorySegment glutLeaveMainLoop$address() {
        return glutLeaveMainLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static void glutLeaveMainLoop() {
        var mh$ = glutLeaveMainLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLeaveMainLoop");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static FunctionDescriptor glutExit$descriptor() {
        return glutExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static MethodHandle glutExit$handle() {
        return glutExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static MemorySegment glutExit$address() {
        return glutExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static void glutExit() {
        var mh$ = glutExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutExit");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutFullScreenToggle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutFullScreenToggle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static FunctionDescriptor glutFullScreenToggle$descriptor() {
        return glutFullScreenToggle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static MethodHandle glutFullScreenToggle$handle() {
        return glutFullScreenToggle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static MemorySegment glutFullScreenToggle$address() {
        return glutFullScreenToggle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static void glutFullScreenToggle() {
        var mh$ = glutFullScreenToggle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutFullScreenToggle");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLeaveFullScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLeaveFullScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static FunctionDescriptor glutLeaveFullScreen$descriptor() {
        return glutLeaveFullScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static MethodHandle glutLeaveFullScreen$handle() {
        return glutLeaveFullScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static MemorySegment glutLeaveFullScreen$address() {
        return glutLeaveFullScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static void glutLeaveFullScreen() {
        var mh$ = glutLeaveFullScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLeaveFullScreen");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetMenuFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetMenuFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static FunctionDescriptor glutSetMenuFont$descriptor() {
        return glutSetMenuFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static MethodHandle glutSetMenuFont$handle() {
        return glutSetMenuFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static MemorySegment glutSetMenuFont$address() {
        return glutSetMenuFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static void glutSetMenuFont(int menuID, MemorySegment font) {
        var mh$ = glutSetMenuFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetMenuFont", menuID, font);
            }
            mh$.invokeExact(menuID, font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseWheelFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseWheelFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutMouseWheelFunc$descriptor() {
        return glutMouseWheelFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutMouseWheelFunc$handle() {
        return glutMouseWheelFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutMouseWheelFunc$address() {
        return glutMouseWheelFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutMouseWheelFunc(MemorySegment callback) {
        var mh$ = glutMouseWheelFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseWheelFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPositionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPositionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutPositionFunc$descriptor() {
        return glutPositionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutPositionFunc$handle() {
        return glutPositionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutPositionFunc$address() {
        return glutPositionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutPositionFunc(MemorySegment callback) {
        var mh$ = glutPositionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPositionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCloseFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCloseFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutCloseFunc$descriptor() {
        return glutCloseFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutCloseFunc$handle() {
        return glutCloseFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutCloseFunc$address() {
        return glutCloseFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static void glutCloseFunc(MemorySegment callback) {
        var mh$ = glutCloseFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCloseFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWMCloseFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWMCloseFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutWMCloseFunc$descriptor() {
        return glutWMCloseFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutWMCloseFunc$handle() {
        return glutWMCloseFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutWMCloseFunc$address() {
        return glutWMCloseFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static void glutWMCloseFunc(MemorySegment callback) {
        var mh$ = glutWMCloseFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWMCloseFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuDestroyFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuDestroyFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutMenuDestroyFunc$descriptor() {
        return glutMenuDestroyFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutMenuDestroyFunc$handle() {
        return glutMenuDestroyFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutMenuDestroyFunc$address() {
        return glutMenuDestroyFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static void glutMenuDestroyFunc(MemorySegment callback) {
        var mh$ = glutMenuDestroyFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuDestroyFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static FunctionDescriptor glutSetOption$descriptor() {
        return glutSetOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static MethodHandle glutSetOption$handle() {
        return glutSetOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static MemorySegment glutSetOption$address() {
        return glutSetOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static void glutSetOption(int option_flag, int value) {
        var mh$ = glutSetOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetOption", option_flag, value);
            }
            mh$.invokeExact(option_flag, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetModeValues {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetModeValues");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static FunctionDescriptor glutGetModeValues$descriptor() {
        return glutGetModeValues.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static MethodHandle glutGetModeValues$handle() {
        return glutGetModeValues.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static MemorySegment glutGetModeValues$address() {
        return glutGetModeValues.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static MemorySegment glutGetModeValues(int mode, MemorySegment size) {
        var mh$ = glutGetModeValues.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetModeValues", mode, size);
            }
            return (MemorySegment)mh$.invokeExact(mode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetWindowData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetWindowData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static FunctionDescriptor glutGetWindowData$descriptor() {
        return glutGetWindowData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static MethodHandle glutGetWindowData$handle() {
        return glutGetWindowData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static MemorySegment glutGetWindowData$address() {
        return glutGetWindowData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static MemorySegment glutGetWindowData() {
        var mh$ = glutGetWindowData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetWindowData");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindowData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetWindowData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static FunctionDescriptor glutSetWindowData$descriptor() {
        return glutSetWindowData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static MethodHandle glutSetWindowData$handle() {
        return glutSetWindowData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static MemorySegment glutSetWindowData$address() {
        return glutSetWindowData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static void glutSetWindowData(MemorySegment data) {
        var mh$ = glutSetWindowData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindowData", data);
            }
            mh$.invokeExact(data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetMenuData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetMenuData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static FunctionDescriptor glutGetMenuData$descriptor() {
        return glutGetMenuData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static MethodHandle glutGetMenuData$handle() {
        return glutGetMenuData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static MemorySegment glutGetMenuData$address() {
        return glutGetMenuData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static MemorySegment glutGetMenuData() {
        var mh$ = glutGetMenuData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetMenuData");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetMenuData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetMenuData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static FunctionDescriptor glutSetMenuData$descriptor() {
        return glutSetMenuData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static MethodHandle glutSetMenuData$handle() {
        return glutSetMenuData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static MemorySegment glutSetMenuData$address() {
        return glutSetMenuData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static void glutSetMenuData(MemorySegment data) {
        var mh$ = glutSetMenuData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetMenuData", data);
            }
            mh$.invokeExact(data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static FunctionDescriptor glutBitmapHeight$descriptor() {
        return glutBitmapHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static MethodHandle glutBitmapHeight$handle() {
        return glutBitmapHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static MemorySegment glutBitmapHeight$address() {
        return glutBitmapHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static int glutBitmapHeight(MemorySegment font) {
        var mh$ = glutBitmapHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapHeight", font);
            }
            return (int)mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static FunctionDescriptor glutStrokeHeight$descriptor() {
        return glutStrokeHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static MethodHandle glutStrokeHeight$handle() {
        return glutStrokeHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static MemorySegment glutStrokeHeight$address() {
        return glutStrokeHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static float glutStrokeHeight(MemorySegment font) {
        var mh$ = glutStrokeHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeHeight", font);
            }
            return (float)mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutBitmapString$descriptor() {
        return glutBitmapString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutBitmapString$handle() {
        return glutBitmapString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutBitmapString$address() {
        return glutBitmapString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static void glutBitmapString(MemorySegment font, MemorySegment string) {
        var mh$ = glutBitmapString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapString", font, string);
            }
            mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutStrokeString$descriptor() {
        return glutStrokeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutStrokeString$handle() {
        return glutStrokeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutStrokeString$address() {
        return glutStrokeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static void glutStrokeString(MemorySegment font, MemorySegment string) {
        var mh$ = glutStrokeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeString", font, string);
            }
            mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireRhombicDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireRhombicDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static FunctionDescriptor glutWireRhombicDodecahedron$descriptor() {
        return glutWireRhombicDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static MethodHandle glutWireRhombicDodecahedron$handle() {
        return glutWireRhombicDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static MemorySegment glutWireRhombicDodecahedron$address() {
        return glutWireRhombicDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static void glutWireRhombicDodecahedron() {
        var mh$ = glutWireRhombicDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireRhombicDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidRhombicDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidRhombicDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static FunctionDescriptor glutSolidRhombicDodecahedron$descriptor() {
        return glutSolidRhombicDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static MethodHandle glutSolidRhombicDodecahedron$handle() {
        return glutSolidRhombicDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static MemorySegment glutSolidRhombicDodecahedron$address() {
        return glutSolidRhombicDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static void glutSolidRhombicDodecahedron() {
        var mh$ = glutSolidRhombicDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidRhombicDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireSierpinskiSponge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireSierpinskiSponge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static FunctionDescriptor glutWireSierpinskiSponge$descriptor() {
        return glutWireSierpinskiSponge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MethodHandle glutWireSierpinskiSponge$handle() {
        return glutWireSierpinskiSponge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MemorySegment glutWireSierpinskiSponge$address() {
        return glutWireSierpinskiSponge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static void glutWireSierpinskiSponge(int num_levels, MemorySegment offset, double scale) {
        var mh$ = glutWireSierpinskiSponge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireSierpinskiSponge", num_levels, offset, scale);
            }
            mh$.invokeExact(num_levels, offset, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidSierpinskiSponge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidSierpinskiSponge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static FunctionDescriptor glutSolidSierpinskiSponge$descriptor() {
        return glutSolidSierpinskiSponge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MethodHandle glutSolidSierpinskiSponge$handle() {
        return glutSolidSierpinskiSponge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MemorySegment glutSolidSierpinskiSponge$address() {
        return glutSolidSierpinskiSponge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static void glutSolidSierpinskiSponge(int num_levels, MemorySegment offset, double scale) {
        var mh$ = glutSolidSierpinskiSponge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidSierpinskiSponge", num_levels, offset, scale);
            }
            mh$.invokeExact(num_levels, offset, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireCylinder$descriptor() {
        return glutWireCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireCylinder$handle() {
        return glutWireCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireCylinder$address() {
        return glutWireCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireCylinder(double radius, double height, int slices, int stacks) {
        var mh$ = glutWireCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCylinder", radius, height, slices, stacks);
            }
            mh$.invokeExact(radius, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidCylinder$descriptor() {
        return glutSolidCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidCylinder$handle() {
        return glutSolidCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidCylinder$address() {
        return glutSolidCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidCylinder(double radius, double height, int slices, int stacks) {
        var mh$ = glutSolidCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCylinder", radius, height, slices, stacks);
            }
            mh$.invokeExact(radius, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTeacup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTeacup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static FunctionDescriptor glutWireTeacup$descriptor() {
        return glutWireTeacup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static MethodHandle glutWireTeacup$handle() {
        return glutWireTeacup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static MemorySegment glutWireTeacup$address() {
        return glutWireTeacup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static void glutWireTeacup(double size) {
        var mh$ = glutWireTeacup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTeacup", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTeacup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTeacup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static FunctionDescriptor glutSolidTeacup$descriptor() {
        return glutSolidTeacup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static MethodHandle glutSolidTeacup$handle() {
        return glutSolidTeacup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static MemorySegment glutSolidTeacup$address() {
        return glutSolidTeacup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static void glutSolidTeacup(double size) {
        var mh$ = glutSolidTeacup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTeacup", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTeaspoon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTeaspoon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static FunctionDescriptor glutWireTeaspoon$descriptor() {
        return glutWireTeaspoon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static MethodHandle glutWireTeaspoon$handle() {
        return glutWireTeaspoon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static MemorySegment glutWireTeaspoon$address() {
        return glutWireTeaspoon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static void glutWireTeaspoon(double size) {
        var mh$ = glutWireTeaspoon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTeaspoon", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTeaspoon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTeaspoon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static FunctionDescriptor glutSolidTeaspoon$descriptor() {
        return glutSolidTeaspoon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static MethodHandle glutSolidTeaspoon$handle() {
        return glutSolidTeaspoon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static MemorySegment glutSolidTeaspoon$address() {
        return glutSolidTeaspoon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static void glutSolidTeaspoon(double size) {
        var mh$ = glutSolidTeaspoon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTeaspoon", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static FunctionDescriptor glutGetProcAddress$descriptor() {
        return glutGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static MethodHandle glutGetProcAddress$handle() {
        return glutGetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static MemorySegment glutGetProcAddress$address() {
        return glutGetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static MemorySegment glutGetProcAddress(MemorySegment procName) {
        var mh$ = glutGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetProcAddress", procName);
            }
            return (MemorySegment)mh$.invokeExact(procName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiEntryFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiEntryFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutMultiEntryFunc$descriptor() {
        return glutMultiEntryFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutMultiEntryFunc$handle() {
        return glutMultiEntryFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutMultiEntryFunc$address() {
        return glutMultiEntryFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static void glutMultiEntryFunc(MemorySegment callback) {
        var mh$ = glutMultiEntryFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiEntryFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutMultiButtonFunc$descriptor() {
        return glutMultiButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static MethodHandle glutMultiButtonFunc$handle() {
        return glutMultiButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static MemorySegment glutMultiButtonFunc$address() {
        return glutMultiButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static void glutMultiButtonFunc(MemorySegment callback) {
        var mh$ = glutMultiButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutMultiMotionFunc$descriptor() {
        return glutMultiMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutMultiMotionFunc$handle() {
        return glutMultiMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutMultiMotionFunc$address() {
        return glutMultiMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutMultiMotionFunc(MemorySegment callback) {
        var mh$ = glutMultiMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiPassiveFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiPassiveFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutMultiPassiveFunc$descriptor() {
        return glutMultiPassiveFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutMultiPassiveFunc$handle() {
        return glutMultiPassiveFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutMultiPassiveFunc$address() {
        return glutMultiPassiveFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutMultiPassiveFunc(MemorySegment callback) {
        var mh$ = glutMultiPassiveFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiPassiveFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetNumAxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetNumAxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static FunctionDescriptor glutJoystickGetNumAxes$descriptor() {
        return glutJoystickGetNumAxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static MethodHandle glutJoystickGetNumAxes$handle() {
        return glutJoystickGetNumAxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static MemorySegment glutJoystickGetNumAxes$address() {
        return glutJoystickGetNumAxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static int glutJoystickGetNumAxes(int ident) {
        var mh$ = glutJoystickGetNumAxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetNumAxes", ident);
            }
            return (int)mh$.invokeExact(ident);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetNumButtons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetNumButtons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static FunctionDescriptor glutJoystickGetNumButtons$descriptor() {
        return glutJoystickGetNumButtons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static MethodHandle glutJoystickGetNumButtons$handle() {
        return glutJoystickGetNumButtons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static MemorySegment glutJoystickGetNumButtons$address() {
        return glutJoystickGetNumButtons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static int glutJoystickGetNumButtons(int ident) {
        var mh$ = glutJoystickGetNumButtons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetNumButtons", ident);
            }
            return (int)mh$.invokeExact(ident);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickNotWorking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickNotWorking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static FunctionDescriptor glutJoystickNotWorking$descriptor() {
        return glutJoystickNotWorking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static MethodHandle glutJoystickNotWorking$handle() {
        return glutJoystickNotWorking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static MemorySegment glutJoystickNotWorking$address() {
        return glutJoystickNotWorking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static int glutJoystickNotWorking(int ident) {
        var mh$ = glutJoystickNotWorking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickNotWorking", ident);
            }
            return (int)mh$.invokeExact(ident);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetDeadBand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetDeadBand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static FunctionDescriptor glutJoystickGetDeadBand$descriptor() {
        return glutJoystickGetDeadBand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static MethodHandle glutJoystickGetDeadBand$handle() {
        return glutJoystickGetDeadBand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static MemorySegment glutJoystickGetDeadBand$address() {
        return glutJoystickGetDeadBand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static float glutJoystickGetDeadBand(int ident, int axis) {
        var mh$ = glutJoystickGetDeadBand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetDeadBand", ident, axis);
            }
            return (float)mh$.invokeExact(ident, axis);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetDeadBand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetDeadBand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static FunctionDescriptor glutJoystickSetDeadBand$descriptor() {
        return glutJoystickSetDeadBand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static MethodHandle glutJoystickSetDeadBand$handle() {
        return glutJoystickSetDeadBand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static MemorySegment glutJoystickSetDeadBand$address() {
        return glutJoystickSetDeadBand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static void glutJoystickSetDeadBand(int ident, int axis, float db) {
        var mh$ = glutJoystickSetDeadBand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetDeadBand", ident, axis, db);
            }
            mh$.invokeExact(ident, axis, db);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetSaturation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetSaturation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static FunctionDescriptor glutJoystickGetSaturation$descriptor() {
        return glutJoystickGetSaturation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static MethodHandle glutJoystickGetSaturation$handle() {
        return glutJoystickGetSaturation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static MemorySegment glutJoystickGetSaturation$address() {
        return glutJoystickGetSaturation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static float glutJoystickGetSaturation(int ident, int axis) {
        var mh$ = glutJoystickGetSaturation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetSaturation", ident, axis);
            }
            return (float)mh$.invokeExact(ident, axis);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetSaturation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetSaturation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static FunctionDescriptor glutJoystickSetSaturation$descriptor() {
        return glutJoystickSetSaturation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static MethodHandle glutJoystickSetSaturation$handle() {
        return glutJoystickSetSaturation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static MemorySegment glutJoystickSetSaturation$address() {
        return glutJoystickSetSaturation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static void glutJoystickSetSaturation(int ident, int axis, float st) {
        var mh$ = glutJoystickSetSaturation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetSaturation", ident, axis, st);
            }
            mh$.invokeExact(ident, axis, st);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetMinRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetMinRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickSetMinRange$descriptor() {
        return glutJoystickSetMinRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickSetMinRange$handle() {
        return glutJoystickSetMinRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickSetMinRange$address() {
        return glutJoystickSetMinRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickSetMinRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickSetMinRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetMinRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetMaxRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetMaxRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickSetMaxRange$descriptor() {
        return glutJoystickSetMaxRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickSetMaxRange$handle() {
        return glutJoystickSetMaxRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickSetMaxRange$address() {
        return glutJoystickSetMaxRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickSetMaxRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickSetMaxRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetMaxRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetCenter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetCenter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickSetCenter$descriptor() {
        return glutJoystickSetCenter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickSetCenter$handle() {
        return glutJoystickSetCenter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickSetCenter$address() {
        return glutJoystickSetCenter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static void glutJoystickSetCenter(int ident, MemorySegment axes) {
        var mh$ = glutJoystickSetCenter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetCenter", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetMinRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetMinRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickGetMinRange$descriptor() {
        return glutJoystickGetMinRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickGetMinRange$handle() {
        return glutJoystickGetMinRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickGetMinRange$address() {
        return glutJoystickGetMinRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickGetMinRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickGetMinRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetMinRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetMaxRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetMaxRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickGetMaxRange$descriptor() {
        return glutJoystickGetMaxRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickGetMaxRange$handle() {
        return glutJoystickGetMaxRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickGetMaxRange$address() {
        return glutJoystickGetMaxRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickGetMaxRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickGetMaxRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetMaxRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetCenter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetCenter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickGetCenter$descriptor() {
        return glutJoystickGetCenter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickGetCenter$handle() {
        return glutJoystickGetCenter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickGetCenter$address() {
        return glutJoystickGetCenter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static void glutJoystickGetCenter(int ident, MemorySegment axes) {
        var mh$ = glutJoystickGetCenter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetCenter", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static FunctionDescriptor glutInitContextVersion$descriptor() {
        return glutInitContextVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static MethodHandle glutInitContextVersion$handle() {
        return glutInitContextVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static MemorySegment glutInitContextVersion$address() {
        return glutInitContextVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static void glutInitContextVersion(int majorVersion, int minorVersion) {
        var mh$ = glutInitContextVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextVersion", majorVersion, minorVersion);
            }
            mh$.invokeExact(majorVersion, minorVersion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static FunctionDescriptor glutInitContextFlags$descriptor() {
        return glutInitContextFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static MethodHandle glutInitContextFlags$handle() {
        return glutInitContextFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static MemorySegment glutInitContextFlags$address() {
        return glutInitContextFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static void glutInitContextFlags(int flags) {
        var mh$ = glutInitContextFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextFlags", flags);
            }
            mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static FunctionDescriptor glutInitContextProfile$descriptor() {
        return glutInitContextProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static MethodHandle glutInitContextProfile$handle() {
        return glutInitContextProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static MemorySegment glutInitContextProfile$address() {
        return glutInitContextProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static void glutInitContextProfile(int profile) {
        var mh$ = glutInitContextProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextProfile", profile);
            }
            mh$.invokeExact(profile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitErrorFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitErrorFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static FunctionDescriptor glutInitErrorFunc$descriptor() {
        return glutInitErrorFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MethodHandle glutInitErrorFunc$handle() {
        return glutInitErrorFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MemorySegment glutInitErrorFunc$address() {
        return glutInitErrorFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static void glutInitErrorFunc(MemorySegment callback) {
        var mh$ = glutInitErrorFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitErrorFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWarningFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWarningFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static FunctionDescriptor glutInitWarningFunc$descriptor() {
        return glutInitWarningFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MethodHandle glutInitWarningFunc$handle() {
        return glutInitWarningFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MemorySegment glutInitWarningFunc$address() {
        return glutInitWarningFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static void glutInitWarningFunc(MemorySegment callback) {
        var mh$ = glutInitWarningFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWarningFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetVertexAttribCoord3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetVertexAttribCoord3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static FunctionDescriptor glutSetVertexAttribCoord3$descriptor() {
        return glutSetVertexAttribCoord3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static MethodHandle glutSetVertexAttribCoord3$handle() {
        return glutSetVertexAttribCoord3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static MemorySegment glutSetVertexAttribCoord3$address() {
        return glutSetVertexAttribCoord3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static void glutSetVertexAttribCoord3(int attrib) {
        var mh$ = glutSetVertexAttribCoord3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetVertexAttribCoord3", attrib);
            }
            mh$.invokeExact(attrib);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetVertexAttribNormal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetVertexAttribNormal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static FunctionDescriptor glutSetVertexAttribNormal$descriptor() {
        return glutSetVertexAttribNormal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static MethodHandle glutSetVertexAttribNormal$handle() {
        return glutSetVertexAttribNormal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static MemorySegment glutSetVertexAttribNormal$address() {
        return glutSetVertexAttribNormal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static void glutSetVertexAttribNormal(int attrib) {
        var mh$ = glutSetVertexAttribNormal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetVertexAttribNormal", attrib);
            }
            mh$.invokeExact(attrib);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetVertexAttribTexCoord2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetVertexAttribTexCoord2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static FunctionDescriptor glutSetVertexAttribTexCoord2$descriptor() {
        return glutSetVertexAttribTexCoord2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static MethodHandle glutSetVertexAttribTexCoord2$handle() {
        return glutSetVertexAttribTexCoord2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static MemorySegment glutSetVertexAttribTexCoord2$address() {
        return glutSetVertexAttribTexCoord2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static void glutSetVertexAttribTexCoord2(int attrib) {
        var mh$ = glutSetVertexAttribTexCoord2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetVertexAttribTexCoord2", attrib);
            }
            mh$.invokeExact(attrib);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutInitContextFunc$descriptor() {
        return glutInitContextFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutInitContextFunc$handle() {
        return glutInitContextFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutInitContextFunc$address() {
        return glutInitContextFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static void glutInitContextFunc(MemorySegment callback) {
        var mh$ = glutInitContextFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAppStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAppStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutAppStatusFunc$descriptor() {
        return glutAppStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutAppStatusFunc$handle() {
        return glutAppStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutAppStatusFunc$address() {
        return glutAppStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static void glutAppStatusFunc(MemorySegment callback) {
        var mh$ = glutAppStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAppStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateMenuUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateMenuUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutCreateMenuUcall$descriptor() {
        return glutCreateMenuUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutCreateMenuUcall$handle() {
        return glutCreateMenuUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutCreateMenuUcall$address() {
        return glutCreateMenuUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static int glutCreateMenuUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutCreateMenuUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateMenuUcall", callback, user_data);
            }
            return (int)mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTimerFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTimerFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static FunctionDescriptor glutTimerFuncUcall$descriptor() {
        return glutTimerFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static MethodHandle glutTimerFuncUcall$handle() {
        return glutTimerFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static MemorySegment glutTimerFuncUcall$address() {
        return glutTimerFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static void glutTimerFuncUcall(int time, MemorySegment callback, int value, MemorySegment user_data) {
        var mh$ = glutTimerFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTimerFuncUcall", time, callback, value, user_data);
            }
            mh$.invokeExact(time, callback, value, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIdleFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIdleFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutIdleFuncUcall$descriptor() {
        return glutIdleFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutIdleFuncUcall$handle() {
        return glutIdleFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutIdleFuncUcall$address() {
        return glutIdleFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutIdleFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutIdleFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIdleFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutKeyboardFuncUcall$descriptor() {
        return glutKeyboardFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutKeyboardFuncUcall$handle() {
        return glutKeyboardFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutKeyboardFuncUcall$address() {
        return glutKeyboardFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static void glutKeyboardFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutKeyboardFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpecialFuncUcall$descriptor() {
        return glutSpecialFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpecialFuncUcall$handle() {
        return glutSpecialFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpecialFuncUcall$address() {
        return glutSpecialFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpecialFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpecialFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReshapeFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutReshapeFuncUcall$descriptor() {
        return glutReshapeFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutReshapeFuncUcall$handle() {
        return glutReshapeFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutReshapeFuncUcall$address() {
        return glutReshapeFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutReshapeFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutReshapeFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVisibilityFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVisibilityFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutVisibilityFuncUcall$descriptor() {
        return glutVisibilityFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutVisibilityFuncUcall$handle() {
        return glutVisibilityFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutVisibilityFuncUcall$address() {
        return glutVisibilityFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutVisibilityFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutVisibilityFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVisibilityFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDisplayFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDisplayFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutDisplayFuncUcall$descriptor() {
        return glutDisplayFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutDisplayFuncUcall$handle() {
        return glutDisplayFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutDisplayFuncUcall$address() {
        return glutDisplayFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutDisplayFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutDisplayFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDisplayFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMouseFuncUcall$descriptor() {
        return glutMouseFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMouseFuncUcall$handle() {
        return glutMouseFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMouseFuncUcall$address() {
        return glutMouseFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMouseFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMouseFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMotionFuncUcall$descriptor() {
        return glutMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMotionFuncUcall$handle() {
        return glutMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMotionFuncUcall$address() {
        return glutMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPassiveMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPassiveMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutPassiveMotionFuncUcall$descriptor() {
        return glutPassiveMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutPassiveMotionFuncUcall$handle() {
        return glutPassiveMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutPassiveMotionFuncUcall$address() {
        return glutPassiveMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutPassiveMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutPassiveMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPassiveMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEntryFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEntryFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutEntryFuncUcall$descriptor() {
        return glutEntryFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutEntryFuncUcall$handle() {
        return glutEntryFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutEntryFuncUcall$address() {
        return glutEntryFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutEntryFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutEntryFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEntryFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardUpFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardUpFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutKeyboardUpFuncUcall$descriptor() {
        return glutKeyboardUpFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutKeyboardUpFuncUcall$handle() {
        return glutKeyboardUpFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutKeyboardUpFuncUcall$address() {
        return glutKeyboardUpFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static void glutKeyboardUpFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutKeyboardUpFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardUpFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialUpFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialUpFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpecialUpFuncUcall$descriptor() {
        return glutSpecialUpFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpecialUpFuncUcall$handle() {
        return glutSpecialUpFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpecialUpFuncUcall$address() {
        return glutSpecialUpFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpecialUpFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpecialUpFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialUpFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static FunctionDescriptor glutJoystickFuncUcall$descriptor() {
        return glutJoystickFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static MethodHandle glutJoystickFuncUcall$handle() {
        return glutJoystickFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static MemorySegment glutJoystickFuncUcall$address() {
        return glutJoystickFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static void glutJoystickFuncUcall(MemorySegment callback, int pollInterval, MemorySegment user_data) {
        var mh$ = glutJoystickFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickFuncUcall", callback, pollInterval, user_data);
            }
            mh$.invokeExact(callback, pollInterval, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStatusFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuStatusFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMenuStatusFuncUcall$descriptor() {
        return glutMenuStatusFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMenuStatusFuncUcall$handle() {
        return glutMenuStatusFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMenuStatusFuncUcall$address() {
        return glutMenuStatusFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMenuStatusFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMenuStatusFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStatusFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutOverlayDisplayFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutOverlayDisplayFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutOverlayDisplayFuncUcall$descriptor() {
        return glutOverlayDisplayFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutOverlayDisplayFuncUcall$handle() {
        return glutOverlayDisplayFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutOverlayDisplayFuncUcall$address() {
        return glutOverlayDisplayFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutOverlayDisplayFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutOverlayDisplayFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutOverlayDisplayFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWindowStatusFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWindowStatusFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutWindowStatusFuncUcall$descriptor() {
        return glutWindowStatusFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutWindowStatusFuncUcall$handle() {
        return glutWindowStatusFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutWindowStatusFuncUcall$address() {
        return glutWindowStatusFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutWindowStatusFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutWindowStatusFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWindowStatusFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpaceballMotionFuncUcall$descriptor() {
        return glutSpaceballMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpaceballMotionFuncUcall$handle() {
        return glutSpaceballMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpaceballMotionFuncUcall$address() {
        return glutSpaceballMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpaceballMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpaceballMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballRotateFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballRotateFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpaceballRotateFuncUcall$descriptor() {
        return glutSpaceballRotateFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpaceballRotateFuncUcall$handle() {
        return glutSpaceballRotateFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpaceballRotateFuncUcall$address() {
        return glutSpaceballRotateFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpaceballRotateFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpaceballRotateFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballRotateFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballButtonFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballButtonFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpaceballButtonFuncUcall$descriptor() {
        return glutSpaceballButtonFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpaceballButtonFuncUcall$handle() {
        return glutSpaceballButtonFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpaceballButtonFuncUcall$address() {
        return glutSpaceballButtonFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutSpaceballButtonFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpaceballButtonFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballButtonFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutButtonBoxFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutButtonBoxFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutButtonBoxFuncUcall$descriptor() {
        return glutButtonBoxFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutButtonBoxFuncUcall$handle() {
        return glutButtonBoxFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutButtonBoxFuncUcall$address() {
        return glutButtonBoxFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutButtonBoxFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutButtonBoxFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutButtonBoxFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDialsFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDialsFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutDialsFuncUcall$descriptor() {
        return glutDialsFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutDialsFuncUcall$handle() {
        return glutDialsFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutDialsFuncUcall$address() {
        return glutDialsFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutDialsFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutDialsFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDialsFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutTabletMotionFuncUcall$descriptor() {
        return glutTabletMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutTabletMotionFuncUcall$handle() {
        return glutTabletMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutTabletMotionFuncUcall$address() {
        return glutTabletMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutTabletMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutTabletMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletButtonFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletButtonFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutTabletButtonFuncUcall$descriptor() {
        return glutTabletButtonFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutTabletButtonFuncUcall$handle() {
        return glutTabletButtonFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutTabletButtonFuncUcall$address() {
        return glutTabletButtonFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutTabletButtonFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutTabletButtonFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletButtonFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseWheelFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseWheelFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMouseWheelFuncUcall$descriptor() {
        return glutMouseWheelFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMouseWheelFuncUcall$handle() {
        return glutMouseWheelFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMouseWheelFuncUcall$address() {
        return glutMouseWheelFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMouseWheelFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMouseWheelFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseWheelFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPositionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPositionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutPositionFuncUcall$descriptor() {
        return glutPositionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutPositionFuncUcall$handle() {
        return glutPositionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutPositionFuncUcall$address() {
        return glutPositionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutPositionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutPositionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPositionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCloseFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCloseFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutCloseFuncUcall$descriptor() {
        return glutCloseFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutCloseFuncUcall$handle() {
        return glutCloseFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutCloseFuncUcall$address() {
        return glutCloseFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutCloseFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutCloseFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCloseFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWMCloseFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWMCloseFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutWMCloseFuncUcall$descriptor() {
        return glutWMCloseFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutWMCloseFuncUcall$handle() {
        return glutWMCloseFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutWMCloseFuncUcall$address() {
        return glutWMCloseFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutWMCloseFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutWMCloseFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWMCloseFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuDestroyFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuDestroyFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMenuDestroyFuncUcall$descriptor() {
        return glutMenuDestroyFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutMenuDestroyFuncUcall$handle() {
        return glutMenuDestroyFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutMenuDestroyFuncUcall$address() {
        return glutMenuDestroyFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutMenuDestroyFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMenuDestroyFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuDestroyFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiEntryFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiEntryFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiEntryFuncUcall$descriptor() {
        return glutMultiEntryFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiEntryFuncUcall$handle() {
        return glutMultiEntryFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiEntryFuncUcall$address() {
        return glutMultiEntryFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiEntryFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiEntryFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiEntryFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiButtonFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiButtonFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiButtonFuncUcall$descriptor() {
        return glutMultiButtonFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiButtonFuncUcall$handle() {
        return glutMultiButtonFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiButtonFuncUcall$address() {
        return glutMultiButtonFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiButtonFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiButtonFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiButtonFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiMotionFuncUcall$descriptor() {
        return glutMultiMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiMotionFuncUcall$handle() {
        return glutMultiMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiMotionFuncUcall$address() {
        return glutMultiMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiPassiveFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiPassiveFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiPassiveFuncUcall$descriptor() {
        return glutMultiPassiveFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiPassiveFuncUcall$handle() {
        return glutMultiPassiveFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiPassiveFuncUcall$address() {
        return glutMultiPassiveFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiPassiveFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiPassiveFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiPassiveFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitErrorFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitErrorFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutInitErrorFuncUcall$descriptor() {
        return glutInitErrorFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MethodHandle glutInitErrorFuncUcall$handle() {
        return glutInitErrorFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MemorySegment glutInitErrorFuncUcall$address() {
        return glutInitErrorFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static void glutInitErrorFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutInitErrorFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitErrorFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWarningFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWarningFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutInitWarningFuncUcall$descriptor() {
        return glutInitWarningFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MethodHandle glutInitWarningFuncUcall$handle() {
        return glutInitWarningFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MemorySegment glutInitWarningFuncUcall$address() {
        return glutInitWarningFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static void glutInitWarningFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutInitWarningFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWarningFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutInitContextFuncUcall$descriptor() {
        return glutInitContextFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutInitContextFuncUcall$handle() {
        return glutInitContextFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutInitContextFuncUcall$address() {
        return glutInitContextFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutInitContextFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutInitContextFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAppStatusFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAppStatusFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutAppStatusFuncUcall$descriptor() {
        return glutAppStatusFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutAppStatusFuncUcall$handle() {
        return glutAppStatusFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutAppStatusFuncUcall$address() {
        return glutAppStatusFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutAppStatusFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutAppStatusFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAppStatusFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __glutCreateMenuUcallWithExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("__glutCreateMenuUcallWithExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __glutCreateMenuUcallWithExit(void (*func)(int, void *), void (*exitfunc)(int) __attribute__((cdecl)), void *user_data)
     * }
     */
    public static FunctionDescriptor __glutCreateMenuUcallWithExit$descriptor() {
        return __glutCreateMenuUcallWithExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __glutCreateMenuUcallWithExit(void (*func)(int, void *), void (*exitfunc)(int) __attribute__((cdecl)), void *user_data)
     * }
     */
    public static MethodHandle __glutCreateMenuUcallWithExit$handle() {
        return __glutCreateMenuUcallWithExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __glutCreateMenuUcallWithExit(void (*func)(int, void *), void (*exitfunc)(int) __attribute__((cdecl)), void *user_data)
     * }
     */
    public static MemorySegment __glutCreateMenuUcallWithExit$address() {
        return __glutCreateMenuUcallWithExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __glutCreateMenuUcallWithExit(void (*func)(int, void *), void (*exitfunc)(int) __attribute__((cdecl)), void *user_data)
     * }
     */
    public static int __glutCreateMenuUcallWithExit(MemorySegment func, MemorySegment exitfunc, MemorySegment user_data) {
        var mh$ = __glutCreateMenuUcallWithExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__glutCreateMenuUcallWithExit", func, exitfunc, user_data);
            }
            return (int)mh$.invokeExact(func, exitfunc, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int WINAPI_PARTITION_SERVER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_SERVER 0
     * }
     */
    public static int WINAPI_PARTITION_SERVER() {
        return WINAPI_PARTITION_SERVER;
    }
    private static final int WINAPI_PARTITION_PKG_WINTRUST = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WINTRUST 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WINTRUST() {
        return WINAPI_PARTITION_PKG_WINTRUST;
    }
    private static final int WINAPI_PARTITION_PKG_WEBSERVICES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WEBSERVICES 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WEBSERVICES() {
        return WINAPI_PARTITION_PKG_WEBSERVICES;
    }
    private static final int WINAPI_PARTITION_PKG_EVENTLOGSERVICE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_EVENTLOGSERVICE 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_EVENTLOGSERVICE() {
        return WINAPI_PARTITION_PKG_EVENTLOGSERVICE;
    }
    private static final int WINAPI_PARTITION_PKG_VHD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_VHD 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_VHD() {
        return WINAPI_PARTITION_PKG_VHD;
    }
    private static final int WINAPI_PARTITION_PKG_PERFCOUNTER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_PERFCOUNTER 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_PERFCOUNTER() {
        return WINAPI_PARTITION_PKG_PERFCOUNTER;
    }
    private static final int WINAPI_PARTITION_PKG_SECURESTARTUP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_SECURESTARTUP 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_SECURESTARTUP() {
        return WINAPI_PARTITION_PKG_SECURESTARTUP;
    }
    private static final int WINAPI_PARTITION_PKG_REMOTEFS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_REMOTEFS 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_REMOTEFS() {
        return WINAPI_PARTITION_PKG_REMOTEFS;
    }
    private static final int WINAPI_PARTITION_PKG_BOOTABLESKU = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_BOOTABLESKU 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_BOOTABLESKU() {
        return WINAPI_PARTITION_PKG_BOOTABLESKU;
    }
    private static final int WINAPI_PARTITION_PKG_CMDTOOLS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_CMDTOOLS 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_CMDTOOLS() {
        return WINAPI_PARTITION_PKG_CMDTOOLS;
    }
    private static final int WINAPI_PARTITION_PKG_DISM = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_DISM 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_DISM() {
        return WINAPI_PARTITION_PKG_DISM;
    }
    private static final int WINAPI_PARTITION_PKG_CORESETUP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_CORESETUP 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_CORESETUP() {
        return WINAPI_PARTITION_PKG_CORESETUP;
    }
    private static final int WINAPI_PARTITION_PKG_APPRUNTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_APPRUNTIME 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_APPRUNTIME() {
        return WINAPI_PARTITION_PKG_APPRUNTIME;
    }
    private static final int WINAPI_PARTITION_PKG_ESENT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_ESENT 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_ESENT() {
        return WINAPI_PARTITION_PKG_ESENT;
    }
    private static final int WINAPI_PARTITION_PKG_WINMGMT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WINMGMT 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WINMGMT() {
        return WINAPI_PARTITION_PKG_WINMGMT;
    }
    private static final int WINAPI_PARTITION_PKG_WNV = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WNV 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WNV() {
        return WINAPI_PARTITION_PKG_WNV;
    }
    private static final int WINAPI_PARTITION_PKG_CLUSTER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_CLUSTER 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_CLUSTER() {
        return WINAPI_PARTITION_PKG_CLUSTER;
    }
    private static final int WINAPI_PARTITION_PKG_VSS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_VSS 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_VSS() {
        return WINAPI_PARTITION_PKG_VSS;
    }
    private static final int WINAPI_PARTITION_PKG_TRAFFIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_TRAFFIC 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_TRAFFIC() {
        return WINAPI_PARTITION_PKG_TRAFFIC;
    }
    private static final int WINAPI_PARTITION_PKG_ISCSI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_ISCSI 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_ISCSI() {
        return WINAPI_PARTITION_PKG_ISCSI;
    }
    private static final int WINAPI_PARTITION_PKG_STORAGE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_STORAGE 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_STORAGE() {
        return WINAPI_PARTITION_PKG_STORAGE;
    }
    private static final int WINAPI_PARTITION_PKG_MPSSVC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_MPSSVC 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_MPSSVC() {
        return WINAPI_PARTITION_PKG_MPSSVC;
    }
    private static final int WINAPI_PARTITION_PKG_APPXDEPLOYMENT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_APPXDEPLOYMENT 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_APPXDEPLOYMENT() {
        return WINAPI_PARTITION_PKG_APPXDEPLOYMENT;
    }
    private static final int WINAPI_PARTITION_PKG_WER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PKG_WER 0
     * }
     */
    public static int WINAPI_PARTITION_PKG_WER() {
        return WINAPI_PARTITION_PKG_WER;
    }
    private static final int WINAPI_FAMILY_APP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_FAMILY_APP 2
     * }
     */
    public static int WINAPI_FAMILY_APP() {
        return WINAPI_FAMILY_APP;
    }
    private static final int WINAPI_FAMILY = (int)100L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_FAMILY 100
     * }
     */
    public static int WINAPI_FAMILY() {
        return WINAPI_FAMILY;
    }
    private static final int WINAPI_PARTITION_DESKTOP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_DESKTOP 1
     * }
     */
    public static int WINAPI_PARTITION_DESKTOP() {
        return WINAPI_PARTITION_DESKTOP;
    }
    private static final int WINAPI_PARTITION_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_APP 1
     * }
     */
    public static int WINAPI_PARTITION_APP() {
        return WINAPI_PARTITION_APP;
    }
    private static final int WINAPI_PARTITION_PC_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PC_APP 1
     * }
     */
    public static int WINAPI_PARTITION_PC_APP() {
        return WINAPI_PARTITION_PC_APP;
    }
    private static final int WINAPI_PARTITION_PHONE_APP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PHONE_APP 0
     * }
     */
    public static int WINAPI_PARTITION_PHONE_APP() {
        return WINAPI_PARTITION_PHONE_APP;
    }
    private static final int WINAPI_PARTITION_GAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_GAMES 1
     * }
     */
    public static int WINAPI_PARTITION_GAMES() {
        return WINAPI_PARTITION_GAMES;
    }
    private static final int WINAPI_PARTITION_SYSTEM = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_SYSTEM 0
     * }
     */
    public static int WINAPI_PARTITION_SYSTEM() {
        return WINAPI_PARTITION_SYSTEM;
    }
    private static final int WINAPI_PARTITION_PHONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINAPI_PARTITION_PHONE 0
     * }
     */
    public static int WINAPI_PARTITION_PHONE() {
        return WINAPI_PARTITION_PHONE;
    }
    private static final int _WIN32_IE_NT4 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4 512
     * }
     */
    public static int _WIN32_IE_NT4() {
        return _WIN32_IE_NT4;
    }
    private static final int _WIN32_IE_NT4SP1 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP1 512
     * }
     */
    public static int _WIN32_IE_NT4SP1() {
        return _WIN32_IE_NT4SP1;
    }
    private static final int _WIN32_IE_NT4SP2 = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP2 512
     * }
     */
    public static int _WIN32_IE_NT4SP2() {
        return _WIN32_IE_NT4SP2;
    }
    private static final int _WIN32_IE_NT4SP3 = (int)770L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP3 770
     * }
     */
    public static int _WIN32_IE_NT4SP3() {
        return _WIN32_IE_NT4SP3;
    }
    private static final int _WIN32_IE_NT4SP4 = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP4 1025
     * }
     */
    public static int _WIN32_IE_NT4SP4() {
        return _WIN32_IE_NT4SP4;
    }
    private static final int _WIN32_IE_NT4SP5 = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP5 1025
     * }
     */
    public static int _WIN32_IE_NT4SP5() {
        return _WIN32_IE_NT4SP5;
    }
    private static final int _WIN32_IE_NT4SP6 = (int)1280L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_NT4SP6 1280
     * }
     */
    public static int _WIN32_IE_NT4SP6() {
        return _WIN32_IE_NT4SP6;
    }
    private static final int _WIN32_IE_WIN98 = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN98 1025
     * }
     */
    public static int _WIN32_IE_WIN98() {
        return _WIN32_IE_WIN98;
    }
    private static final int _WIN32_IE_WIN98SE = (int)1280L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN98SE 1280
     * }
     */
    public static int _WIN32_IE_WIN98SE() {
        return _WIN32_IE_WIN98SE;
    }
    private static final int _WIN32_IE_WINME = (int)1360L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WINME 1360
     * }
     */
    public static int _WIN32_IE_WINME() {
        return _WIN32_IE_WINME;
    }
    private static final int _WIN32_IE_WIN2K = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2K 1281
     * }
     */
    public static int _WIN32_IE_WIN2K() {
        return _WIN32_IE_WIN2K;
    }
    private static final int _WIN32_IE_WIN2KSP1 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP1 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP1() {
        return _WIN32_IE_WIN2KSP1;
    }
    private static final int _WIN32_IE_WIN2KSP2 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP2 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP2() {
        return _WIN32_IE_WIN2KSP2;
    }
    private static final int _WIN32_IE_WIN2KSP3 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP3 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP3() {
        return _WIN32_IE_WIN2KSP3;
    }
    private static final int _WIN32_IE_WIN2KSP4 = (int)1281L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN2KSP4 1281
     * }
     */
    public static int _WIN32_IE_WIN2KSP4() {
        return _WIN32_IE_WIN2KSP4;
    }
    private static final int _WIN32_IE_XP = (int)1536L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_XP 1536
     * }
     */
    public static int _WIN32_IE_XP() {
        return _WIN32_IE_XP;
    }
    private static final int _WIN32_IE_XPSP1 = (int)1537L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_XPSP1 1537
     * }
     */
    public static int _WIN32_IE_XPSP1() {
        return _WIN32_IE_XPSP1;
    }
    private static final int _WIN32_IE_XPSP2 = (int)1539L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_XPSP2 1539
     * }
     */
    public static int _WIN32_IE_XPSP2() {
        return _WIN32_IE_XPSP2;
    }
    private static final int _WIN32_IE_WS03SP1 = (int)1539L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WS03SP1 1539
     * }
     */
    public static int _WIN32_IE_WS03SP1() {
        return _WIN32_IE_WS03SP1;
    }
    private static final int _WIN32_IE_WIN6 = (int)1792L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN6 1792
     * }
     */
    public static int _WIN32_IE_WIN6() {
        return _WIN32_IE_WIN6;
    }
    private static final int _WIN32_IE_LONGHORN = (int)1792L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_LONGHORN 1792
     * }
     */
    public static int _WIN32_IE_LONGHORN() {
        return _WIN32_IE_LONGHORN;
    }
    private static final int _WIN32_IE_WIN7 = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN7 2048
     * }
     */
    public static int _WIN32_IE_WIN7() {
        return _WIN32_IE_WIN7;
    }
    private static final int _WIN32_IE_WIN8 = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN8 2560
     * }
     */
    public static int _WIN32_IE_WIN8() {
        return _WIN32_IE_WIN8;
    }
    private static final int _WIN32_IE_WINBLUE = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WINBLUE 2560
     * }
     */
    public static int _WIN32_IE_WINBLUE() {
        return _WIN32_IE_WINBLUE;
    }
    private static final int _WIN32_IE_WINTHRESHOLD = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WINTHRESHOLD 2560
     * }
     */
    public static int _WIN32_IE_WINTHRESHOLD() {
        return _WIN32_IE_WINTHRESHOLD;
    }
    private static final int _WIN32_IE_WIN10 = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define _WIN32_IE_WIN10 2560
     * }
     */
    public static int _WIN32_IE_WIN10() {
        return _WIN32_IE_WIN10;
    }
    private static final int NTDDI_VISTA = (int)100663296L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTA 100663296
     * }
     */
    public static int NTDDI_VISTA() {
        return NTDDI_VISTA;
    }
    private static final int NTDDI_VISTASP1 = (int)100663552L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP1 100663552
     * }
     */
    public static int NTDDI_VISTASP1() {
        return NTDDI_VISTASP1;
    }
    private static final int NTDDI_VISTASP2 = (int)100663808L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP2 100663808
     * }
     */
    public static int NTDDI_VISTASP2() {
        return NTDDI_VISTASP2;
    }
    private static final int NTDDI_VISTASP3 = (int)100664064L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP3 100664064
     * }
     */
    public static int NTDDI_VISTASP3() {
        return NTDDI_VISTASP3;
    }
    private static final int NTDDI_VISTASP4 = (int)100664320L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VISTASP4 100664320
     * }
     */
    public static int NTDDI_VISTASP4() {
        return NTDDI_VISTASP4;
    }
    private static final int NTDDI_LONGHORN = (int)100663296L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_LONGHORN 100663296
     * }
     */
    public static int NTDDI_LONGHORN() {
        return NTDDI_LONGHORN;
    }
    private static final int NTDDI_WS08 = (int)100663552L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08 100663552
     * }
     */
    public static int NTDDI_WS08() {
        return NTDDI_WS08;
    }
    private static final int NTDDI_WS08SP2 = (int)100663808L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08SP2 100663808
     * }
     */
    public static int NTDDI_WS08SP2() {
        return NTDDI_WS08SP2;
    }
    private static final int NTDDI_WS08SP3 = (int)100664064L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08SP3 100664064
     * }
     */
    public static int NTDDI_WS08SP3() {
        return NTDDI_WS08SP3;
    }
    private static final int NTDDI_WS08SP4 = (int)100664320L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_WS08SP4 100664320
     * }
     */
    public static int NTDDI_WS08SP4() {
        return NTDDI_WS08SP4;
    }
    private static final int WDK_NTDDI_VERSION = (int)167772168L;
    /**
     * {@snippet lang=c :
     * #define WDK_NTDDI_VERSION 167772168
     * }
     */
    public static int WDK_NTDDI_VERSION() {
        return WDK_NTDDI_VERSION;
    }
    private static final int OSVERSION_MASK = (int)4294901760L;
    /**
     * {@snippet lang=c :
     * #define OSVERSION_MASK 4294901760
     * }
     */
    public static int OSVERSION_MASK() {
        return OSVERSION_MASK;
    }
    private static final int NTDDI_VERSION = (int)167772168L;
    /**
     * {@snippet lang=c :
     * #define NTDDI_VERSION 167772168
     * }
     */
    public static int NTDDI_VERSION() {
        return NTDDI_VERSION;
    }
    private static final int WINVER = (int)2560L;
    /**
     * {@snippet lang=c :
     * #define WINVER 2560
     * }
     */
    public static int WINVER() {
        return WINVER;
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EXCEPTION_CONTINUE_EXECUTION = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_CONTINUE_EXECUTION -1
     * }
     */
    public static int EXCEPTION_CONTINUE_EXECUTION() {
        return EXCEPTION_CONTINUE_EXECUTION;
    }
    private static final int _UCRT_DISABLED_WARNINGS = (int)4324L;
    /**
     * {@snippet lang=c :
     * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }
    private static final long _TRUNCATE = -1L;
    /**
     * {@snippet lang=c :
     * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }
    private static final long _CRT_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __FILEW__ "C"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__
                = freeglut_h.LIBRARY_ARENA.allocateFrom("C");
        }
        return Holder.__FILEW__;
    }
    private static final int __STDC_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }
    private static final int __GOT_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }
    private static final short WEOF = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define WEOF 65535
     * }
     */
    public static short WEOF() {
        return WEOF;
    }
    private static final int _ALPHA = (int)259L;
    /**
     * {@snippet lang=c :
     * #define _ALPHA 259
     * }
     */
    public static int _ALPHA() {
        return _ALPHA;
    }
    private static final long MAX_NATURAL_ALIGNMENT = 8L;
    /**
     * {@snippet lang=c :
     * #define MAX_NATURAL_ALIGNMENT 8
     * }
     */
    public static long MAX_NATURAL_ALIGNMENT() {
        return MAX_NATURAL_ALIGNMENT;
    }
    private static final long ADDRESS_TAG_BIT = 4398046511104L;
    /**
     * {@snippet lang=c :
     * #define ADDRESS_TAG_BIT 4398046511104
     * }
     */
    public static long ADDRESS_TAG_BIT() {
        return ADDRESS_TAG_BIT;
    }
    private static final long MAXUINT_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT_PTR -1
     * }
     */
    public static long MAXUINT_PTR() {
        return MAXUINT_PTR;
    }
    private static final long MAXINT_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXINT_PTR 9223372036854775807
     * }
     */
    public static long MAXINT_PTR() {
        return MAXINT_PTR;
    }
    private static final long MININT_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MININT_PTR -9223372036854775808
     * }
     */
    public static long MININT_PTR() {
        return MININT_PTR;
    }
    private static final long MAXULONG_PTR = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG_PTR -1
     * }
     */
    public static long MAXULONG_PTR() {
        return MAXULONG_PTR;
    }
    private static final long MAXLONG_PTR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG_PTR 9223372036854775807
     * }
     */
    public static long MAXLONG_PTR() {
        return MAXLONG_PTR;
    }
    private static final long MINLONG_PTR = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONG_PTR -9223372036854775808
     * }
     */
    public static long MINLONG_PTR() {
        return MINLONG_PTR;
    }
    private static final int MAXUHALF_PTR = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUHALF_PTR 4294967295
     * }
     */
    public static int MAXUHALF_PTR() {
        return MAXUHALF_PTR;
    }
    private static final int MAXHALF_PTR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXHALF_PTR 2147483647
     * }
     */
    public static int MAXHALF_PTR() {
        return MAXHALF_PTR;
    }
    private static final int MINHALF_PTR = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINHALF_PTR -2147483648
     * }
     */
    public static int MINHALF_PTR() {
        return MINHALF_PTR;
    }
    private static final byte MAXUINT8 = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT8 255
     * }
     */
    public static byte MAXUINT8() {
        return MAXUINT8;
    }
    private static final byte MAXINT8 = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define MAXINT8 127
     * }
     */
    public static byte MAXINT8() {
        return MAXINT8;
    }
    private static final byte MININT8 = (byte)-128L;
    /**
     * {@snippet lang=c :
     * #define MININT8 -128
     * }
     */
    public static byte MININT8() {
        return MININT8;
    }
    private static final short MAXUINT16 = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT16 65535
     * }
     */
    public static short MAXUINT16() {
        return MAXUINT16;
    }
    private static final short MAXINT16 = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define MAXINT16 32767
     * }
     */
    public static short MAXINT16() {
        return MAXINT16;
    }
    private static final short MININT16 = (short)-32768L;
    /**
     * {@snippet lang=c :
     * #define MININT16 -32768
     * }
     */
    public static short MININT16() {
        return MININT16;
    }
    private static final int MAXUINT32 = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT32 4294967295
     * }
     */
    public static int MAXUINT32() {
        return MAXUINT32;
    }
    private static final int MAXINT32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXINT32 2147483647
     * }
     */
    public static int MAXINT32() {
        return MAXINT32;
    }
    private static final int MININT32 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MININT32 -2147483648
     * }
     */
    public static int MININT32() {
        return MININT32;
    }
    private static final long MAXUINT64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT64 -1
     * }
     */
    public static long MAXUINT64() {
        return MAXUINT64;
    }
    private static final long MAXINT64 = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXINT64 9223372036854775807
     * }
     */
    public static long MAXINT64() {
        return MAXINT64;
    }
    private static final long MININT64 = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MININT64 -9223372036854775808
     * }
     */
    public static long MININT64() {
        return MININT64;
    }
    private static final int MAXULONG32 = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG32 4294967295
     * }
     */
    public static int MAXULONG32() {
        return MAXULONG32;
    }
    private static final int MAXLONG32 = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG32 2147483647
     * }
     */
    public static int MAXLONG32() {
        return MAXLONG32;
    }
    private static final int MINLONG32 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINLONG32 -2147483648
     * }
     */
    public static int MINLONG32() {
        return MINLONG32;
    }
    private static final long MAXULONG64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONG64 -1
     * }
     */
    public static long MAXULONG64() {
        return MAXULONG64;
    }
    private static final long MAXLONG64 = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONG64 9223372036854775807
     * }
     */
    public static long MAXLONG64() {
        return MAXLONG64;
    }
    private static final long MINLONG64 = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONG64 -9223372036854775808
     * }
     */
    public static long MINLONG64() {
        return MINLONG64;
    }
    private static final long MAXULONGLONG = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXULONGLONG -1
     * }
     */
    public static long MAXULONGLONG() {
        return MAXULONGLONG;
    }
    private static final long MINLONGLONG = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINLONGLONG -9223372036854775808
     * }
     */
    public static long MINLONGLONG() {
        return MINLONGLONG;
    }
    private static final long MAXSIZE_T = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXSIZE_T -1
     * }
     */
    public static long MAXSIZE_T() {
        return MAXSIZE_T;
    }
    private static final long MAXSSIZE_T = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXSSIZE_T 9223372036854775807
     * }
     */
    public static long MAXSSIZE_T() {
        return MAXSSIZE_T;
    }
    private static final long MINSSIZE_T = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define MINSSIZE_T -9223372036854775808
     * }
     */
    public static long MINSSIZE_T() {
        return MINSSIZE_T;
    }
    private static final int MAXUINT = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXUINT 4294967295
     * }
     */
    public static int MAXUINT() {
        return MAXUINT;
    }
    private static final int MAXINT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define MAXINT 2147483647
     * }
     */
    public static int MAXINT() {
        return MAXINT;
    }
    private static final int MININT = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define MININT -2147483648
     * }
     */
    public static int MININT() {
        return MININT;
    }
    private static final int MAXDWORD32 = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXDWORD32 4294967295
     * }
     */
    public static int MAXDWORD32() {
        return MAXDWORD32;
    }
    private static final long MAXDWORD64 = -1L;
    /**
     * {@snippet lang=c :
     * #define MAXDWORD64 -1
     * }
     */
    public static long MAXDWORD64() {
        return MAXDWORD64;
    }
    private static final int UCSCHAR_INVALID_CHARACTER = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UCSCHAR_INVALID_CHARACTER 4294967295
     * }
     */
    public static int UCSCHAR_INVALID_CHARACTER() {
        return UCSCHAR_INVALID_CHARACTER;
    }
    private static final int MIN_UCSCHAR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MIN_UCSCHAR 0
     * }
     */
    public static int MIN_UCSCHAR() {
        return MIN_UCSCHAR;
    }
    private static final int MAX_UCSCHAR = (int)1114111L;
    /**
     * {@snippet lang=c :
     * #define MAX_UCSCHAR 1114111
     * }
     */
    public static int MAX_UCSCHAR() {
        return MAX_UCSCHAR;
    }
    private static final int MAXIMUM_PROCESSORS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MAXIMUM_PROCESSORS 64
     * }
     */
    public static int MAXIMUM_PROCESSORS() {
        return MAXIMUM_PROCESSORS;
    }
    private static final int ERROR_SEVERITY_WARNING = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define ERROR_SEVERITY_WARNING 2147483648
     * }
     */
    public static int ERROR_SEVERITY_WARNING() {
        return ERROR_SEVERITY_WARNING;
    }
    private static final int ERROR_SEVERITY_ERROR = (int)3221225472L;
    /**
     * {@snippet lang=c :
     * #define ERROR_SEVERITY_ERROR 3221225472
     * }
     */
    public static int ERROR_SEVERITY_ERROR() {
        return ERROR_SEVERITY_ERROR;
    }
    private static final long MAXLONGLONG = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define MAXLONGLONG 9223372036854775807
     * }
     */
    public static long MAXLONGLONG() {
        return MAXLONGLONG;
    }
    private static final byte ANSI_NULL = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define ANSI_NULL 0
     * }
     */
    public static byte ANSI_NULL() {
        return ANSI_NULL;
    }
    private static final short UNICODE_NULL = (short)0L;
    /**
     * {@snippet lang=c :
     * #define UNICODE_NULL 0
     * }
     */
    public static short UNICODE_NULL() {
        return UNICODE_NULL;
    }
    private static final short UNICODE_STRING_MAX_BYTES = (short)65534L;
    /**
     * {@snippet lang=c :
     * #define UNICODE_STRING_MAX_BYTES 65534
     * }
     */
    public static short UNICODE_STRING_MAX_BYTES() {
        return UNICODE_STRING_MAX_BYTES;
    }
    private static final int UNICODE_STRING_MAX_CHARS = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define UNICODE_STRING_MAX_CHARS 32767
     * }
     */
    public static int UNICODE_STRING_MAX_CHARS() {
        return UNICODE_STRING_MAX_CHARS;
    }
    private static final int EDEADLOCK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLOCK 36
     * }
     */
    public static int EDEADLOCK() {
        return EDEADLOCK;
    }
    private static final int _NLSCMPERROR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _NLSCMPERROR 2147483647
     * }
     */
    public static int _NLSCMPERROR() {
        return _NLSCMPERROR;
    }
    private static final int MINLONG = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define MINLONG 2147483648
     * }
     */
    public static int MINLONG() {
        return MINLONG;
    }
    private static final int MAXDWORD = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define MAXDWORD 4294967295
     * }
     */
    public static int MAXDWORD() {
        return MAXDWORD;
    }
    private static final int VER_SERVER_NT = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define VER_SERVER_NT 2147483648
     * }
     */
    public static int VER_SERVER_NT() {
        return VER_SERVER_NT;
    }
    private static final int PRODUCT_UNLICENSED = (int)2882382797L;
    /**
     * {@snippet lang=c :
     * #define PRODUCT_UNLICENSED 2882382797
     * }
     */
    public static int PRODUCT_UNLICENSED() {
        return PRODUCT_UNLICENSED;
    }
    private static final int LANG_SYSTEM_DEFAULT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LANG_SYSTEM_DEFAULT 2048
     * }
     */
    public static int LANG_SYSTEM_DEFAULT() {
        return LANG_SYSTEM_DEFAULT;
    }
    private static final int LANG_USER_DEFAULT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define LANG_USER_DEFAULT 1024
     * }
     */
    public static int LANG_USER_DEFAULT() {
        return LANG_USER_DEFAULT;
    }
    private static final int LOCALE_SYSTEM_DEFAULT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_SYSTEM_DEFAULT 2048
     * }
     */
    public static int LOCALE_SYSTEM_DEFAULT() {
        return LOCALE_SYSTEM_DEFAULT;
    }
    private static final int LOCALE_USER_DEFAULT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_USER_DEFAULT 1024
     * }
     */
    public static int LOCALE_USER_DEFAULT() {
        return LOCALE_USER_DEFAULT;
    }
    private static final int LOCALE_CUSTOM_DEFAULT = (int)3072L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_CUSTOM_DEFAULT 3072
     * }
     */
    public static int LOCALE_CUSTOM_DEFAULT() {
        return LOCALE_CUSTOM_DEFAULT;
    }
    private static final int LOCALE_CUSTOM_UNSPECIFIED = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_CUSTOM_UNSPECIFIED 4096
     * }
     */
    public static int LOCALE_CUSTOM_UNSPECIFIED() {
        return LOCALE_CUSTOM_UNSPECIFIED;
    }
    private static final int LOCALE_CUSTOM_UI_DEFAULT = (int)5120L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_CUSTOM_UI_DEFAULT 5120
     * }
     */
    public static int LOCALE_CUSTOM_UI_DEFAULT() {
        return LOCALE_CUSTOM_UI_DEFAULT;
    }
    private static final int LOCALE_NEUTRAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_NEUTRAL 0
     * }
     */
    public static int LOCALE_NEUTRAL() {
        return LOCALE_NEUTRAL;
    }
    private static final int LOCALE_INVARIANT = (int)127L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_INVARIANT 127
     * }
     */
    public static int LOCALE_INVARIANT() {
        return LOCALE_INVARIANT;
    }
    private static final int LOCALE_UNASSIGNED_LCID = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define LOCALE_UNASSIGNED_LCID 4096
     * }
     */
    public static int LOCALE_UNASSIGNED_LCID() {
        return LOCALE_UNASSIGNED_LCID;
    }
    private static final int STATUS_WAIT_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define STATUS_WAIT_0 0
     * }
     */
    public static int STATUS_WAIT_0() {
        return STATUS_WAIT_0;
    }
    private static final int STATUS_ABANDONED_WAIT_0 = (int)128L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ABANDONED_WAIT_0 128
     * }
     */
    public static int STATUS_ABANDONED_WAIT_0() {
        return STATUS_ABANDONED_WAIT_0;
    }
    private static final int STATUS_USER_APC = (int)192L;
    /**
     * {@snippet lang=c :
     * #define STATUS_USER_APC 192
     * }
     */
    public static int STATUS_USER_APC() {
        return STATUS_USER_APC;
    }
    private static final int STATUS_TIMEOUT = (int)258L;
    /**
     * {@snippet lang=c :
     * #define STATUS_TIMEOUT 258
     * }
     */
    public static int STATUS_TIMEOUT() {
        return STATUS_TIMEOUT;
    }
    private static final int STATUS_PENDING = (int)259L;
    /**
     * {@snippet lang=c :
     * #define STATUS_PENDING 259
     * }
     */
    public static int STATUS_PENDING() {
        return STATUS_PENDING;
    }
    private static final int DBG_EXCEPTION_HANDLED = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define DBG_EXCEPTION_HANDLED 65537
     * }
     */
    public static int DBG_EXCEPTION_HANDLED() {
        return DBG_EXCEPTION_HANDLED;
    }
    private static final int DBG_CONTINUE = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define DBG_CONTINUE 65538
     * }
     */
    public static int DBG_CONTINUE() {
        return DBG_CONTINUE;
    }
    private static final int STATUS_SEGMENT_NOTIFICATION = (int)1073741829L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SEGMENT_NOTIFICATION 1073741829
     * }
     */
    public static int STATUS_SEGMENT_NOTIFICATION() {
        return STATUS_SEGMENT_NOTIFICATION;
    }
    private static final int STATUS_FATAL_APP_EXIT = (int)1073741845L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FATAL_APP_EXIT 1073741845
     * }
     */
    public static int STATUS_FATAL_APP_EXIT() {
        return STATUS_FATAL_APP_EXIT;
    }
    private static final int DBG_REPLY_LATER = (int)1073807361L;
    /**
     * {@snippet lang=c :
     * #define DBG_REPLY_LATER 1073807361
     * }
     */
    public static int DBG_REPLY_LATER() {
        return DBG_REPLY_LATER;
    }
    private static final int DBG_TERMINATE_THREAD = (int)1073807363L;
    /**
     * {@snippet lang=c :
     * #define DBG_TERMINATE_THREAD 1073807363
     * }
     */
    public static int DBG_TERMINATE_THREAD() {
        return DBG_TERMINATE_THREAD;
    }
    private static final int DBG_TERMINATE_PROCESS = (int)1073807364L;
    /**
     * {@snippet lang=c :
     * #define DBG_TERMINATE_PROCESS 1073807364
     * }
     */
    public static int DBG_TERMINATE_PROCESS() {
        return DBG_TERMINATE_PROCESS;
    }
    private static final int DBG_CONTROL_C = (int)1073807365L;
    /**
     * {@snippet lang=c :
     * #define DBG_CONTROL_C 1073807365
     * }
     */
    public static int DBG_CONTROL_C() {
        return DBG_CONTROL_C;
    }
    private static final int DBG_PRINTEXCEPTION_C = (int)1073807366L;
    /**
     * {@snippet lang=c :
     * #define DBG_PRINTEXCEPTION_C 1073807366
     * }
     */
    public static int DBG_PRINTEXCEPTION_C() {
        return DBG_PRINTEXCEPTION_C;
    }
    private static final int DBG_RIPEXCEPTION = (int)1073807367L;
    /**
     * {@snippet lang=c :
     * #define DBG_RIPEXCEPTION 1073807367
     * }
     */
    public static int DBG_RIPEXCEPTION() {
        return DBG_RIPEXCEPTION;
    }
    private static final int DBG_CONTROL_BREAK = (int)1073807368L;
    /**
     * {@snippet lang=c :
     * #define DBG_CONTROL_BREAK 1073807368
     * }
     */
    public static int DBG_CONTROL_BREAK() {
        return DBG_CONTROL_BREAK;
    }
    private static final int DBG_COMMAND_EXCEPTION = (int)1073807369L;
    /**
     * {@snippet lang=c :
     * #define DBG_COMMAND_EXCEPTION 1073807369
     * }
     */
    public static int DBG_COMMAND_EXCEPTION() {
        return DBG_COMMAND_EXCEPTION;
    }
    private static final int DBG_PRINTEXCEPTION_WIDE_C = (int)1073807370L;
    /**
     * {@snippet lang=c :
     * #define DBG_PRINTEXCEPTION_WIDE_C 1073807370
     * }
     */
    public static int DBG_PRINTEXCEPTION_WIDE_C() {
        return DBG_PRINTEXCEPTION_WIDE_C;
    }
    private static final int STATUS_GUARD_PAGE_VIOLATION = (int)2147483649L;
    /**
     * {@snippet lang=c :
     * #define STATUS_GUARD_PAGE_VIOLATION 2147483649
     * }
     */
    public static int STATUS_GUARD_PAGE_VIOLATION() {
        return STATUS_GUARD_PAGE_VIOLATION;
    }
    private static final int STATUS_DATATYPE_MISALIGNMENT = (int)2147483650L;
    /**
     * {@snippet lang=c :
     * #define STATUS_DATATYPE_MISALIGNMENT 2147483650
     * }
     */
    public static int STATUS_DATATYPE_MISALIGNMENT() {
        return STATUS_DATATYPE_MISALIGNMENT;
    }
    private static final int STATUS_BREAKPOINT = (int)2147483651L;
    /**
     * {@snippet lang=c :
     * #define STATUS_BREAKPOINT 2147483651
     * }
     */
    public static int STATUS_BREAKPOINT() {
        return STATUS_BREAKPOINT;
    }
    private static final int STATUS_SINGLE_STEP = (int)2147483652L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SINGLE_STEP 2147483652
     * }
     */
    public static int STATUS_SINGLE_STEP() {
        return STATUS_SINGLE_STEP;
    }
    private static final int STATUS_LONGJUMP = (int)2147483686L;
    /**
     * {@snippet lang=c :
     * #define STATUS_LONGJUMP 2147483686
     * }
     */
    public static int STATUS_LONGJUMP() {
        return STATUS_LONGJUMP;
    }
    private static final int STATUS_UNWIND_CONSOLIDATE = (int)2147483689L;
    /**
     * {@snippet lang=c :
     * #define STATUS_UNWIND_CONSOLIDATE 2147483689
     * }
     */
    public static int STATUS_UNWIND_CONSOLIDATE() {
        return STATUS_UNWIND_CONSOLIDATE;
    }
    private static final int DBG_EXCEPTION_NOT_HANDLED = (int)2147549185L;
    /**
     * {@snippet lang=c :
     * #define DBG_EXCEPTION_NOT_HANDLED 2147549185
     * }
     */
    public static int DBG_EXCEPTION_NOT_HANDLED() {
        return DBG_EXCEPTION_NOT_HANDLED;
    }
    private static final int STATUS_ACCESS_VIOLATION = (int)3221225477L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ACCESS_VIOLATION 3221225477
     * }
     */
    public static int STATUS_ACCESS_VIOLATION() {
        return STATUS_ACCESS_VIOLATION;
    }
    private static final int STATUS_IN_PAGE_ERROR = (int)3221225478L;
    /**
     * {@snippet lang=c :
     * #define STATUS_IN_PAGE_ERROR 3221225478
     * }
     */
    public static int STATUS_IN_PAGE_ERROR() {
        return STATUS_IN_PAGE_ERROR;
    }
    private static final int STATUS_INVALID_HANDLE = (int)3221225480L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_HANDLE 3221225480
     * }
     */
    public static int STATUS_INVALID_HANDLE() {
        return STATUS_INVALID_HANDLE;
    }
    private static final int STATUS_INVALID_PARAMETER = (int)3221225485L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_PARAMETER 3221225485
     * }
     */
    public static int STATUS_INVALID_PARAMETER() {
        return STATUS_INVALID_PARAMETER;
    }
    private static final int STATUS_NO_MEMORY = (int)3221225495L;
    /**
     * {@snippet lang=c :
     * #define STATUS_NO_MEMORY 3221225495
     * }
     */
    public static int STATUS_NO_MEMORY() {
        return STATUS_NO_MEMORY;
    }
    private static final int STATUS_ILLEGAL_INSTRUCTION = (int)3221225501L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ILLEGAL_INSTRUCTION 3221225501
     * }
     */
    public static int STATUS_ILLEGAL_INSTRUCTION() {
        return STATUS_ILLEGAL_INSTRUCTION;
    }
    private static final int STATUS_NONCONTINUABLE_EXCEPTION = (int)3221225509L;
    /**
     * {@snippet lang=c :
     * #define STATUS_NONCONTINUABLE_EXCEPTION 3221225509
     * }
     */
    public static int STATUS_NONCONTINUABLE_EXCEPTION() {
        return STATUS_NONCONTINUABLE_EXCEPTION;
    }
    private static final int STATUS_INVALID_DISPOSITION = (int)3221225510L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_DISPOSITION 3221225510
     * }
     */
    public static int STATUS_INVALID_DISPOSITION() {
        return STATUS_INVALID_DISPOSITION;
    }
    private static final int STATUS_ARRAY_BOUNDS_EXCEEDED = (int)3221225612L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ARRAY_BOUNDS_EXCEEDED 3221225612
     * }
     */
    public static int STATUS_ARRAY_BOUNDS_EXCEEDED() {
        return STATUS_ARRAY_BOUNDS_EXCEEDED;
    }
    private static final int STATUS_FLOAT_DENORMAL_OPERAND = (int)3221225613L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_DENORMAL_OPERAND 3221225613
     * }
     */
    public static int STATUS_FLOAT_DENORMAL_OPERAND() {
        return STATUS_FLOAT_DENORMAL_OPERAND;
    }
    private static final int STATUS_FLOAT_DIVIDE_BY_ZERO = (int)3221225614L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_DIVIDE_BY_ZERO 3221225614
     * }
     */
    public static int STATUS_FLOAT_DIVIDE_BY_ZERO() {
        return STATUS_FLOAT_DIVIDE_BY_ZERO;
    }
    private static final int STATUS_FLOAT_INEXACT_RESULT = (int)3221225615L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_INEXACT_RESULT 3221225615
     * }
     */
    public static int STATUS_FLOAT_INEXACT_RESULT() {
        return STATUS_FLOAT_INEXACT_RESULT;
    }
    private static final int STATUS_FLOAT_INVALID_OPERATION = (int)3221225616L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_INVALID_OPERATION 3221225616
     * }
     */
    public static int STATUS_FLOAT_INVALID_OPERATION() {
        return STATUS_FLOAT_INVALID_OPERATION;
    }
    private static final int STATUS_FLOAT_OVERFLOW = (int)3221225617L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_OVERFLOW 3221225617
     * }
     */
    public static int STATUS_FLOAT_OVERFLOW() {
        return STATUS_FLOAT_OVERFLOW;
    }
    private static final int STATUS_FLOAT_STACK_CHECK = (int)3221225618L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_STACK_CHECK 3221225618
     * }
     */
    public static int STATUS_FLOAT_STACK_CHECK() {
        return STATUS_FLOAT_STACK_CHECK;
    }
    private static final int STATUS_FLOAT_UNDERFLOW = (int)3221225619L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_UNDERFLOW 3221225619
     * }
     */
    public static int STATUS_FLOAT_UNDERFLOW() {
        return STATUS_FLOAT_UNDERFLOW;
    }
    private static final int STATUS_INTEGER_DIVIDE_BY_ZERO = (int)3221225620L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INTEGER_DIVIDE_BY_ZERO 3221225620
     * }
     */
    public static int STATUS_INTEGER_DIVIDE_BY_ZERO() {
        return STATUS_INTEGER_DIVIDE_BY_ZERO;
    }
    private static final int STATUS_INTEGER_OVERFLOW = (int)3221225621L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INTEGER_OVERFLOW 3221225621
     * }
     */
    public static int STATUS_INTEGER_OVERFLOW() {
        return STATUS_INTEGER_OVERFLOW;
    }
    private static final int STATUS_PRIVILEGED_INSTRUCTION = (int)3221225622L;
    /**
     * {@snippet lang=c :
     * #define STATUS_PRIVILEGED_INSTRUCTION 3221225622
     * }
     */
    public static int STATUS_PRIVILEGED_INSTRUCTION() {
        return STATUS_PRIVILEGED_INSTRUCTION;
    }
    private static final int STATUS_STACK_OVERFLOW = (int)3221225725L;
    /**
     * {@snippet lang=c :
     * #define STATUS_STACK_OVERFLOW 3221225725
     * }
     */
    public static int STATUS_STACK_OVERFLOW() {
        return STATUS_STACK_OVERFLOW;
    }
    private static final int STATUS_DLL_NOT_FOUND = (int)3221225781L;
    /**
     * {@snippet lang=c :
     * #define STATUS_DLL_NOT_FOUND 3221225781
     * }
     */
    public static int STATUS_DLL_NOT_FOUND() {
        return STATUS_DLL_NOT_FOUND;
    }
    private static final int STATUS_ORDINAL_NOT_FOUND = (int)3221225784L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ORDINAL_NOT_FOUND 3221225784
     * }
     */
    public static int STATUS_ORDINAL_NOT_FOUND() {
        return STATUS_ORDINAL_NOT_FOUND;
    }
    private static final int STATUS_ENTRYPOINT_NOT_FOUND = (int)3221225785L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ENTRYPOINT_NOT_FOUND 3221225785
     * }
     */
    public static int STATUS_ENTRYPOINT_NOT_FOUND() {
        return STATUS_ENTRYPOINT_NOT_FOUND;
    }
    private static final int STATUS_CONTROL_C_EXIT = (int)3221225786L;
    /**
     * {@snippet lang=c :
     * #define STATUS_CONTROL_C_EXIT 3221225786
     * }
     */
    public static int STATUS_CONTROL_C_EXIT() {
        return STATUS_CONTROL_C_EXIT;
    }
    private static final int STATUS_DLL_INIT_FAILED = (int)3221225794L;
    /**
     * {@snippet lang=c :
     * #define STATUS_DLL_INIT_FAILED 3221225794
     * }
     */
    public static int STATUS_DLL_INIT_FAILED() {
        return STATUS_DLL_INIT_FAILED;
    }
    private static final int STATUS_CONTROL_STACK_VIOLATION = (int)3221225906L;
    /**
     * {@snippet lang=c :
     * #define STATUS_CONTROL_STACK_VIOLATION 3221225906
     * }
     */
    public static int STATUS_CONTROL_STACK_VIOLATION() {
        return STATUS_CONTROL_STACK_VIOLATION;
    }
    private static final int STATUS_FLOAT_MULTIPLE_FAULTS = (int)3221226164L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_MULTIPLE_FAULTS 3221226164
     * }
     */
    public static int STATUS_FLOAT_MULTIPLE_FAULTS() {
        return STATUS_FLOAT_MULTIPLE_FAULTS;
    }
    private static final int STATUS_FLOAT_MULTIPLE_TRAPS = (int)3221226165L;
    /**
     * {@snippet lang=c :
     * #define STATUS_FLOAT_MULTIPLE_TRAPS 3221226165
     * }
     */
    public static int STATUS_FLOAT_MULTIPLE_TRAPS() {
        return STATUS_FLOAT_MULTIPLE_TRAPS;
    }
    private static final int STATUS_REG_NAT_CONSUMPTION = (int)3221226185L;
    /**
     * {@snippet lang=c :
     * #define STATUS_REG_NAT_CONSUMPTION 3221226185
     * }
     */
    public static int STATUS_REG_NAT_CONSUMPTION() {
        return STATUS_REG_NAT_CONSUMPTION;
    }
    private static final int STATUS_HEAP_CORRUPTION = (int)3221226356L;
    /**
     * {@snippet lang=c :
     * #define STATUS_HEAP_CORRUPTION 3221226356
     * }
     */
    public static int STATUS_HEAP_CORRUPTION() {
        return STATUS_HEAP_CORRUPTION;
    }
    private static final int STATUS_STACK_BUFFER_OVERRUN = (int)3221226505L;
    /**
     * {@snippet lang=c :
     * #define STATUS_STACK_BUFFER_OVERRUN 3221226505
     * }
     */
    public static int STATUS_STACK_BUFFER_OVERRUN() {
        return STATUS_STACK_BUFFER_OVERRUN;
    }
    private static final int STATUS_INVALID_CRUNTIME_PARAMETER = (int)3221226519L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INVALID_CRUNTIME_PARAMETER 3221226519
     * }
     */
    public static int STATUS_INVALID_CRUNTIME_PARAMETER() {
        return STATUS_INVALID_CRUNTIME_PARAMETER;
    }
    private static final int STATUS_ASSERTION_FAILURE = (int)3221226528L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ASSERTION_FAILURE 3221226528
     * }
     */
    public static int STATUS_ASSERTION_FAILURE() {
        return STATUS_ASSERTION_FAILURE;
    }
    private static final int STATUS_ENCLAVE_VIOLATION = (int)3221226658L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ENCLAVE_VIOLATION 3221226658
     * }
     */
    public static int STATUS_ENCLAVE_VIOLATION() {
        return STATUS_ENCLAVE_VIOLATION;
    }
    private static final int STATUS_INTERRUPTED = (int)3221226773L;
    /**
     * {@snippet lang=c :
     * #define STATUS_INTERRUPTED 3221226773
     * }
     */
    public static int STATUS_INTERRUPTED() {
        return STATUS_INTERRUPTED;
    }
    private static final int STATUS_THREAD_NOT_RUNNING = (int)3221226774L;
    /**
     * {@snippet lang=c :
     * #define STATUS_THREAD_NOT_RUNNING 3221226774
     * }
     */
    public static int STATUS_THREAD_NOT_RUNNING() {
        return STATUS_THREAD_NOT_RUNNING;
    }
    private static final int STATUS_ALREADY_REGISTERED = (int)3221227288L;
    /**
     * {@snippet lang=c :
     * #define STATUS_ALREADY_REGISTERED 3221227288
     * }
     */
    public static int STATUS_ALREADY_REGISTERED() {
        return STATUS_ALREADY_REGISTERED;
    }
    private static final int STATUS_SXS_EARLY_DEACTIVATION = (int)3222601743L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SXS_EARLY_DEACTIVATION 3222601743
     * }
     */
    public static int STATUS_SXS_EARLY_DEACTIVATION() {
        return STATUS_SXS_EARLY_DEACTIVATION;
    }
    private static final int STATUS_SXS_INVALID_DEACTIVATION = (int)3222601744L;
    /**
     * {@snippet lang=c :
     * #define STATUS_SXS_INVALID_DEACTIVATION 3222601744
     * }
     */
    public static int STATUS_SXS_INVALID_DEACTIVATION() {
        return STATUS_SXS_INVALID_DEACTIVATION;
    }
    private static final int MAXIMUM_SUSPEND_COUNT = (int)127L;
    /**
     * {@snippet lang=c :
     * #define MAXIMUM_SUSPEND_COUNT 127
     * }
     */
    public static int MAXIMUM_SUSPEND_COUNT() {
        return MAXIMUM_SUSPEND_COUNT;
    }
    private static final int PF_TEMPORAL_LEVEL_1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_TEMPORAL_LEVEL_1 1
     * }
     */
    public static int PF_TEMPORAL_LEVEL_1() {
        return PF_TEMPORAL_LEVEL_1;
    }
    private static final int PF_TEMPORAL_LEVEL_2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PF_TEMPORAL_LEVEL_2 2
     * }
     */
    public static int PF_TEMPORAL_LEVEL_2() {
        return PF_TEMPORAL_LEVEL_2;
    }
    private static final int PF_TEMPORAL_LEVEL_3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PF_TEMPORAL_LEVEL_3 3
     * }
     */
    public static int PF_TEMPORAL_LEVEL_3() {
        return PF_TEMPORAL_LEVEL_3;
    }
    private static final int PF_NON_TEMPORAL_LEVEL_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PF_NON_TEMPORAL_LEVEL_ALL 0
     * }
     */
    public static int PF_NON_TEMPORAL_LEVEL_ALL() {
        return PF_NON_TEMPORAL_LEVEL_ALL;
    }
    private static final int CONTEXT_AMD64 = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_AMD64 1048576
     * }
     */
    public static int CONTEXT_AMD64() {
        return CONTEXT_AMD64;
    }
    private static final int CONTEXT_CONTROL = (int)1048577L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_CONTROL 1048577
     * }
     */
    public static int CONTEXT_CONTROL() {
        return CONTEXT_CONTROL;
    }
    private static final int CONTEXT_INTEGER = (int)1048578L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_INTEGER 1048578
     * }
     */
    public static int CONTEXT_INTEGER() {
        return CONTEXT_INTEGER;
    }
    private static final int CONTEXT_SEGMENTS = (int)1048580L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_SEGMENTS 1048580
     * }
     */
    public static int CONTEXT_SEGMENTS() {
        return CONTEXT_SEGMENTS;
    }
    private static final int CONTEXT_FLOATING_POINT = (int)1048584L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_FLOATING_POINT 1048584
     * }
     */
    public static int CONTEXT_FLOATING_POINT() {
        return CONTEXT_FLOATING_POINT;
    }
    private static final int CONTEXT_DEBUG_REGISTERS = (int)1048592L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_DEBUG_REGISTERS 1048592
     * }
     */
    public static int CONTEXT_DEBUG_REGISTERS() {
        return CONTEXT_DEBUG_REGISTERS;
    }
    private static final int CONTEXT_FULL = (int)1048587L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_FULL 1048587
     * }
     */
    public static int CONTEXT_FULL() {
        return CONTEXT_FULL;
    }
    private static final int CONTEXT_ALL = (int)1048607L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_ALL 1048607
     * }
     */
    public static int CONTEXT_ALL() {
        return CONTEXT_ALL;
    }
    private static final int CONTEXT_XSTATE = (int)1048640L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_XSTATE 1048640
     * }
     */
    public static int CONTEXT_XSTATE() {
        return CONTEXT_XSTATE;
    }
    private static final int CONTEXT_EXCEPTION_ACTIVE = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_EXCEPTION_ACTIVE 134217728
     * }
     */
    public static int CONTEXT_EXCEPTION_ACTIVE() {
        return CONTEXT_EXCEPTION_ACTIVE;
    }
    private static final int CONTEXT_SERVICE_ACTIVE = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_SERVICE_ACTIVE 268435456
     * }
     */
    public static int CONTEXT_SERVICE_ACTIVE() {
        return CONTEXT_SERVICE_ACTIVE;
    }
    private static final int CONTEXT_EXCEPTION_REQUEST = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_EXCEPTION_REQUEST 1073741824
     * }
     */
    public static int CONTEXT_EXCEPTION_REQUEST() {
        return CONTEXT_EXCEPTION_REQUEST;
    }
    private static final int CONTEXT_EXCEPTION_REPORTING = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define CONTEXT_EXCEPTION_REPORTING 2147483648
     * }
     */
    public static int CONTEXT_EXCEPTION_REPORTING() {
        return CONTEXT_EXCEPTION_REPORTING;
    }
    private static final int UNW_FLAG_NO_EPILOGUE = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define UNW_FLAG_NO_EPILOGUE 2147483648
     * }
     */
    public static int UNW_FLAG_NO_EPILOGUE() {
        return UNW_FLAG_NO_EPILOGUE;
    }
    /**
     * {@snippet lang=c :
     * #define OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME "OutOfProcessFunctionTableCallback"
     * }
     */
    public static MemorySegment OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME() {
        class Holder {
            static final MemorySegment OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME
                = freeglut_h.LIBRARY_ARENA.allocateFrom("OutOfProcessFunctionTableCallback");
        }
        return Holder.OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME;
    }
    private static final int WOW64_CONTEXT_CONTROL = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_CONTROL 65537
     * }
     */
    public static int WOW64_CONTEXT_CONTROL() {
        return WOW64_CONTEXT_CONTROL;
    }
    private static final int WOW64_CONTEXT_INTEGER = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_INTEGER 65538
     * }
     */
    public static int WOW64_CONTEXT_INTEGER() {
        return WOW64_CONTEXT_INTEGER;
    }
    private static final int WOW64_CONTEXT_SEGMENTS = (int)65540L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_SEGMENTS 65540
     * }
     */
    public static int WOW64_CONTEXT_SEGMENTS() {
        return WOW64_CONTEXT_SEGMENTS;
    }
    private static final int WOW64_CONTEXT_FLOATING_POINT = (int)65544L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_FLOATING_POINT 65544
     * }
     */
    public static int WOW64_CONTEXT_FLOATING_POINT() {
        return WOW64_CONTEXT_FLOATING_POINT;
    }
    private static final int WOW64_CONTEXT_DEBUG_REGISTERS = (int)65552L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_DEBUG_REGISTERS 65552
     * }
     */
    public static int WOW64_CONTEXT_DEBUG_REGISTERS() {
        return WOW64_CONTEXT_DEBUG_REGISTERS;
    }
    private static final int WOW64_CONTEXT_EXTENDED_REGISTERS = (int)65568L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_EXTENDED_REGISTERS 65568
     * }
     */
    public static int WOW64_CONTEXT_EXTENDED_REGISTERS() {
        return WOW64_CONTEXT_EXTENDED_REGISTERS;
    }
    private static final int WOW64_CONTEXT_FULL = (int)65543L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_FULL 65543
     * }
     */
    public static int WOW64_CONTEXT_FULL() {
        return WOW64_CONTEXT_FULL;
    }
    private static final int WOW64_CONTEXT_ALL = (int)65599L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_ALL 65599
     * }
     */
    public static int WOW64_CONTEXT_ALL() {
        return WOW64_CONTEXT_ALL;
    }
    private static final int WOW64_CONTEXT_XSTATE = (int)65600L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_XSTATE 65600
     * }
     */
    public static int WOW64_CONTEXT_XSTATE() {
        return WOW64_CONTEXT_XSTATE;
    }
    private static final int WOW64_CONTEXT_EXCEPTION_REPORTING = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define WOW64_CONTEXT_EXCEPTION_REPORTING 2147483648
     * }
     */
    public static int WOW64_CONTEXT_EXCEPTION_REPORTING() {
        return WOW64_CONTEXT_EXCEPTION_REPORTING;
    }
    private static final int EXCEPTION_UNWIND = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EXCEPTION_UNWIND 102
     * }
     */
    public static int EXCEPTION_UNWIND() {
        return EXCEPTION_UNWIND;
    }
    private static final int DELETE = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define DELETE 65536
     * }
     */
    public static int DELETE() {
        return DELETE;
    }
    private static final int READ_CONTROL = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define READ_CONTROL 131072
     * }
     */
    public static int READ_CONTROL() {
        return READ_CONTROL;
    }
    private static final int WRITE_DAC = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define WRITE_DAC 262144
     * }
     */
    public static int WRITE_DAC() {
        return WRITE_DAC;
    }
    private static final int WRITE_OWNER = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define WRITE_OWNER 524288
     * }
     */
    public static int WRITE_OWNER() {
        return WRITE_OWNER;
    }
    private static final int SYNCHRONIZE = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define SYNCHRONIZE 1048576
     * }
     */
    public static int SYNCHRONIZE() {
        return SYNCHRONIZE;
    }
    private static final int STANDARD_RIGHTS_REQUIRED = (int)983040L;
    /**
     * {@snippet lang=c :
     * #define STANDARD_RIGHTS_REQUIRED 983040
     * }
     */
    public static int STANDARD_RIGHTS_REQUIRED() {
        return STANDARD_RIGHTS_REQUIRED;
    }
    private static final int STANDARD_RIGHTS_READ = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define STANDARD_RIGHTS_READ 131072
     * }
     */
    public static int STANDARD_RIGHTS_READ() {
        return STANDARD_RIGHTS_READ;
    }
    private static final int STANDARD_RIGHTS_WRITE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define STANDARD_RIGHTS_WRITE 131072
     * }
     */
    public static int STANDARD_RIGHTS_WRITE() {
        return STANDARD_RIGHTS_WRITE;
    }
    private static final int STANDARD_RIGHTS_EXECUTE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define STANDARD_RIGHTS_EXECUTE 131072
     * }
     */
    public static int STANDARD_RIGHTS_EXECUTE() {
        return STANDARD_RIGHTS_EXECUTE;
    }
    private static final int STANDARD_RIGHTS_ALL = (int)2031616L;
    /**
     * {@snippet lang=c :
     * #define STANDARD_RIGHTS_ALL 2031616
     * }
     */
    public static int STANDARD_RIGHTS_ALL() {
        return STANDARD_RIGHTS_ALL;
    }
    private static final int SPECIFIC_RIGHTS_ALL = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define SPECIFIC_RIGHTS_ALL 65535
     * }
     */
    public static int SPECIFIC_RIGHTS_ALL() {
        return SPECIFIC_RIGHTS_ALL;
    }
    private static final int ACCESS_SYSTEM_SECURITY = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define ACCESS_SYSTEM_SECURITY 16777216
     * }
     */
    public static int ACCESS_SYSTEM_SECURITY() {
        return ACCESS_SYSTEM_SECURITY;
    }
    private static final int MAXIMUM_ALLOWED = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define MAXIMUM_ALLOWED 33554432
     * }
     */
    public static int MAXIMUM_ALLOWED() {
        return MAXIMUM_ALLOWED;
    }
    private static final int GENERIC_READ = (int)2147483648L;
    /**
     * {@snippet lang=c :
     * #define GENERIC_READ 2147483648
     * }
     */
    public static int GENERIC_READ() {
        return GENERIC_READ;
    }
    private static final int GENERIC_WRITE = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define GENERIC_WRITE 1073741824
     * }
     */
    public static int GENERIC_WRITE() {
        return GENERIC_WRITE;
    }
}

