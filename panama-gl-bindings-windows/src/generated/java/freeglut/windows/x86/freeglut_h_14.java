// Generated by jextract

package freeglut.windows.x86;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h_14 extends freeglut_h_15 {

    freeglut_h_14() {
        // Should not be called directly
    }

    private static class GetDiskFreeSpaceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDiskFreeSpaceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceExW$descriptor() {
        return GetDiskFreeSpaceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceExW$handle() {
        return GetDiskFreeSpaceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MemorySegment GetDiskFreeSpaceExW$address() {
        return GetDiskFreeSpaceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static int GetDiskFreeSpaceExW(MemorySegment lpDirectoryName, MemorySegment lpFreeBytesAvailableToCaller, MemorySegment lpTotalNumberOfBytes, MemorySegment lpTotalNumberOfFreeBytes) {
        var mh$ = GetDiskFreeSpaceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceExW", lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDiskSpaceInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationA$descriptor() {
        return GetDiskSpaceInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationA$handle() {
        return GetDiskSpaceInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MemorySegment GetDiskSpaceInformationA$address() {
        return GetDiskSpaceInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationA(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationA", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDiskSpaceInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationW$descriptor() {
        return GetDiskSpaceInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationW$handle() {
        return GetDiskSpaceInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MemorySegment GetDiskSpaceInformationW$address() {
        return GetDiskSpaceInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationW(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationW", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDriveTypeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeA$descriptor() {
        return GetDriveTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeA$handle() {
        return GetDriveTypeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static MemorySegment GetDriveTypeA$address() {
        return GetDriveTypeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeA(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeA", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDriveTypeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeW$descriptor() {
        return GetDriveTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeW$handle() {
        return GetDriveTypeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static MemorySegment GetDriveTypeW$address() {
        return GetDriveTypeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeW(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeW", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     * } *LPWIN32_FILE_ATTRIBUTE_DATA
     * }
     */
    public static final AddressLayout LPWIN32_FILE_ATTRIBUTE_DATA = freeglut_h.C_POINTER;

    private static class GetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileAttributesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesA$descriptor() {
        return GetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesA$handle() {
        return GetFileAttributesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetFileAttributesA$address() {
        return GetFileAttributesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static int GetFileAttributesA(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileAttributesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesW$descriptor() {
        return GetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesW$handle() {
        return GetFileAttributesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetFileAttributesW$address() {
        return GetFileAttributesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static int GetFileAttributesW(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileAttributesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExA$descriptor() {
        return GetFileAttributesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExA$handle() {
        return GetFileAttributesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExA$address() {
        return GetFileAttributesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExA", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileAttributesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExW$descriptor() {
        return GetFileAttributesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExW$handle() {
        return GetFileAttributesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExW$address() {
        return GetFileAttributesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *PBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout PBY_HANDLE_FILE_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *LPBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout LPBY_HANDLE_FILE_INFORMATION = freeglut_h.C_POINTER;

    private static class GetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileInformationByHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandle$descriptor() {
        return GetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static MethodHandle GetFileInformationByHandle$handle() {
        return GetFileInformationByHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static MemorySegment GetFileInformationByHandle$address() {
        return GetFileInformationByHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static int GetFileInformationByHandle(MemorySegment hFile, MemorySegment lpFileInformation) {
        var mh$ = GetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandle", hFile, lpFileInformation);
            }
            return (int)mh$.invokeExact(hFile, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetFileSize$descriptor() {
        return GetFileSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetFileSize$handle() {
        return GetFileSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetFileSize$address() {
        return GetFileSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetFileSize(MemorySegment hFile, MemorySegment lpFileSizeHigh) {
        var mh$ = GetFileSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSize", hFile, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(hFile, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileSizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static FunctionDescriptor GetFileSizeEx$descriptor() {
        return GetFileSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static MethodHandle GetFileSizeEx$handle() {
        return GetFileSizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static MemorySegment GetFileSizeEx$address() {
        return GetFileSizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static int GetFileSizeEx(MemorySegment hFile, MemorySegment lpFileSize) {
        var mh$ = GetFileSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSizeEx", hFile, lpFileSize);
            }
            return (int)mh$.invokeExact(hFile, lpFileSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor GetFileType$descriptor() {
        return GetFileType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MethodHandle GetFileType$handle() {
        return GetFileType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MemorySegment GetFileType$address() {
        return GetFileType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static int GetFileType(MemorySegment hFile) {
        var mh$ = GetFileType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileType", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFinalPathNameByHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleA$descriptor() {
        return GetFinalPathNameByHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleA$handle() {
        return GetFinalPathNameByHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetFinalPathNameByHandleA$address() {
        return GetFinalPathNameByHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleA(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleA", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFinalPathNameByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleW$descriptor() {
        return GetFinalPathNameByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleW$handle() {
        return GetFinalPathNameByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MemorySegment GetFinalPathNameByHandleW$address() {
        return GetFinalPathNameByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleW(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleW", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor GetFileTime$descriptor() {
        return GetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static MethodHandle GetFileTime$handle() {
        return GetFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static MemorySegment GetFileTime$address() {
        return GetFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static int GetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = GetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFullPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameW$descriptor() {
        return GetFullPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameW$handle() {
        return GetFullPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MemorySegment GetFullPathNameW$address() {
        return GetFullPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameW(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameW", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFullPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameA$descriptor() {
        return GetFullPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameA$handle() {
        return GetFullPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MemorySegment GetFullPathNameA$address() {
        return GetFullPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameA(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameA", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDrives {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLogicalDrives");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static FunctionDescriptor GetLogicalDrives$descriptor() {
        return GetLogicalDrives.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static MethodHandle GetLogicalDrives$handle() {
        return GetLogicalDrives.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static MemorySegment GetLogicalDrives$address() {
        return GetLogicalDrives.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static int GetLogicalDrives() {
        var mh$ = GetLogicalDrives.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDrives");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDriveStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLogicalDriveStringsW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetLogicalDriveStringsW$descriptor() {
        return GetLogicalDriveStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetLogicalDriveStringsW$handle() {
        return GetLogicalDriveStringsW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetLogicalDriveStringsW$address() {
        return GetLogicalDriveStringsW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetLogicalDriveStringsW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetLogicalDriveStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDriveStringsW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLongPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameA$descriptor() {
        return GetLongPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameA$handle() {
        return GetLongPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetLongPathNameA$address() {
        return GetLongPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameA(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameA", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLongPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameW$descriptor() {
        return GetLongPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameW$handle() {
        return GetLongPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetLongPathNameW$address() {
        return GetLongPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameW(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameW", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShortPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetShortPathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetShortPathNameW$descriptor() {
        return GetShortPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetShortPathNameW$handle() {
        return GetShortPathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetShortPathNameW$address() {
        return GetShortPathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static int GetShortPathNameW(MemorySegment lpszLongPath, MemorySegment lpszShortPath, int cchBuffer) {
        var mh$ = GetShortPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShortPathNameW", lpszLongPath, lpszShortPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszLongPath, lpszShortPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTempFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameW$descriptor() {
        return GetTempFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameW$handle() {
        return GetTempFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static MemorySegment GetTempFileNameW$address() {
        return GetTempFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameW(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameW", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumeInformationByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationByHandleW$descriptor() {
        return GetVolumeInformationByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationByHandleW$handle() {
        return GetVolumeInformationByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationByHandleW$address() {
        return GetVolumeInformationByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationByHandleW(MemorySegment hFile, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationByHandleW", hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumeInformationW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationW$descriptor() {
        return GetVolumeInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationW$handle() {
        return GetVolumeInformationW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationW$address() {
        return GetVolumeInformationW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationW(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationW", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumePathNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameW$descriptor() {
        return GetVolumePathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameW$handle() {
        return GetVolumePathNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumePathNameW$address() {
        return GetVolumePathNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameW(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameW", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFileTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalFileTimeToFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor LocalFileTimeToFileTime$descriptor() {
        return LocalFileTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle LocalFileTimeToFileTime$handle() {
        return LocalFileTimeToFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static MemorySegment LocalFileTimeToFileTime$address() {
        return LocalFileTimeToFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static int LocalFileTimeToFileTime(MemorySegment lpLocalFileTime, MemorySegment lpFileTime) {
        var mh$ = LocalFileTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFileTimeToFileTime", lpLocalFileTime, lpFileTime);
            }
            return (int)mh$.invokeExact(lpLocalFileTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LockFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static FunctionDescriptor LockFile$descriptor() {
        return LockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static MethodHandle LockFile$handle() {
        return LockFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static MemorySegment LockFile$address() {
        return LockFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static int LockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh) {
        var mh$ = LockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LockFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor LockFileEx$descriptor() {
        return LockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle LockFileEx$handle() {
        return LockFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment LockFileEx$address() {
        return LockFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int LockFileEx(MemorySegment hFile, int dwFlags, int dwReserved, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh, MemorySegment lpOverlapped) {
        var mh$ = LockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFileEx", hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDosDeviceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryDosDeviceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static FunctionDescriptor QueryDosDeviceW$descriptor() {
        return QueryDosDeviceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MethodHandle QueryDosDeviceW$handle() {
        return QueryDosDeviceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MemorySegment QueryDosDeviceW$address() {
        return QueryDosDeviceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static int QueryDosDeviceW(MemorySegment lpDeviceName, MemorySegment lpTargetPath, int ucchMax) {
        var mh$ = QueryDosDeviceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDosDeviceW", lpDeviceName, lpTargetPath, ucchMax);
            }
            return (int)mh$.invokeExact(lpDeviceName, lpTargetPath, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFile$descriptor() {
        return ReadFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFile$handle() {
        return ReadFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ReadFile$address() {
        return ReadFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, MemorySegment lpOverlapped) {
        var mh$ = ReadFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFile", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor ReadFileEx$descriptor() {
        return ReadFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle ReadFileEx$handle() {
        return ReadFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment ReadFileEx$address() {
        return ReadFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int ReadFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = ReadFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileEx", hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadFileScatter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFileScatter$descriptor() {
        return ReadFileScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFileScatter$handle() {
        return ReadFileScatter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ReadFileScatter$address() {
        return ReadFileScatter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFileScatter(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToRead, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = ReadFileScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileScatter", hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryA$descriptor() {
        return RemoveDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryA$handle() {
        return RemoveDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryA$address() {
        return RemoveDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryA(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryW$descriptor() {
        return RemoveDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryW$handle() {
        return RemoveDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryW$address() {
        return RemoveDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEndOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetEndOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor SetEndOfFile$descriptor() {
        return SetEndOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static MethodHandle SetEndOfFile$handle() {
        return SetEndOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static MemorySegment SetEndOfFile$address() {
        return SetEndOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static int SetEndOfFile(MemorySegment hFile) {
        var mh$ = SetEndOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEndOfFile", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileAttributesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesA$descriptor() {
        return SetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesA$handle() {
        return SetFileAttributesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesA$address() {
        return SetFileAttributesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesA(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesA", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileAttributesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesW$descriptor() {
        return SetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesW$handle() {
        return SetFileAttributesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesW$address() {
        return SetFileAttributesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileInformationByHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor SetFileInformationByHandle$descriptor() {
        return SetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle SetFileInformationByHandle$handle() {
        return SetFileInformationByHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MemorySegment SetFileInformationByHandle$address() {
        return SetFileInformationByHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int SetFileInformationByHandle(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = SetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileInformationByHandle", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFilePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointer$descriptor() {
        return SetFilePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointer$handle() {
        return SetFilePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static MemorySegment SetFilePointer$address() {
        return SetFilePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointer(MemorySegment hFile, int lDistanceToMove, MemorySegment lpDistanceToMoveHigh, int dwMoveMethod) {
        var mh$ = SetFilePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointer", hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            _LARGE_INTEGER.layout(),
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFilePointerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointerEx$descriptor() {
        return SetFilePointerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointerEx$handle() {
        return SetFilePointerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static MemorySegment SetFilePointerEx$address() {
        return SetFilePointerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointerEx(MemorySegment hFile, MemorySegment liDistanceToMove, MemorySegment lpNewFilePointer, int dwMoveMethod) {
        var mh$ = SetFilePointerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointerEx", hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor SetFileTime$descriptor() {
        return SetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static MethodHandle SetFileTime$handle() {
        return SetFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static MemorySegment SetFileTime$address() {
        return SetFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static int SetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = SetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileValidData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileValidData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static FunctionDescriptor SetFileValidData$descriptor() {
        return SetFileValidData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static MethodHandle SetFileValidData$handle() {
        return SetFileValidData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static MemorySegment SetFileValidData$address() {
        return SetFileValidData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static int SetFileValidData(MemorySegment hFile, long ValidDataLength) {
        var mh$ = SetFileValidData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileValidData", hFile, ValidDataLength);
            }
            return (int)mh$.invokeExact(hFile, ValidDataLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnlockFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static FunctionDescriptor UnlockFile$descriptor() {
        return UnlockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static MethodHandle UnlockFile$handle() {
        return UnlockFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static MemorySegment UnlockFile$address() {
        return UnlockFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static int UnlockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh) {
        var mh$ = UnlockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnlockFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor UnlockFileEx$descriptor() {
        return UnlockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle UnlockFileEx$handle() {
        return UnlockFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment UnlockFileEx$address() {
        return UnlockFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int UnlockFileEx(MemorySegment hFile, int dwReserved, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh, MemorySegment lpOverlapped) {
        var mh$ = UnlockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFileEx", hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFile$descriptor() {
        return WriteFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFile$handle() {
        return WriteFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WriteFile$address() {
        return WriteFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, MemorySegment lpOverlapped) {
        var mh$ = WriteFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFile", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor WriteFileEx$descriptor() {
        return WriteFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle WriteFileEx$handle() {
        return WriteFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment WriteFileEx$address() {
        return WriteFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int WriteFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = WriteFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileEx", hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileGather {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteFileGather");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFileGather$descriptor() {
        return WriteFileGather.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFileGather$handle() {
        return WriteFileGather.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WriteFileGather$address() {
        return WriteFileGather.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFileGather(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToWrite, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = WriteFileGather.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileGather", hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTempPathW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathW$descriptor() {
        return GetTempPathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathW$handle() {
        return GetTempPathW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MemorySegment GetTempPathW$address() {
        return GetTempPathW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetTempPathW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumeNameForVolumeMountPointW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointW$descriptor() {
        return GetVolumeNameForVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointW$handle() {
        return GetVolumeNameForVolumeMountPointW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment GetVolumeNameForVolumeMountPointW$address() {
        return GetVolumeNameForVolumeMountPointW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumePathNamesForVolumeNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameW$descriptor() {
        return GetVolumePathNamesForVolumeNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameW$handle() {
        return GetVolumePathNamesForVolumeNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MemorySegment GetVolumePathNamesForVolumeNameW$address() {
        return GetVolumePathNamesForVolumeNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameW(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameW", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *PCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout PCREATEFILE2_EXTENDED_PARAMETERS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *LPCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout LPCREATEFILE2_EXTENDED_PARAMETERS = freeglut_h.C_POINTER;

    private static class CreateFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFile2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2$descriptor() {
        return CreateFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2$handle() {
        return CreateFile2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2$address() {
        return CreateFile2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileIoOverlappedRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileIoOverlappedRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static FunctionDescriptor SetFileIoOverlappedRange$descriptor() {
        return SetFileIoOverlappedRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static MethodHandle SetFileIoOverlappedRange$handle() {
        return SetFileIoOverlappedRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static MemorySegment SetFileIoOverlappedRange$address() {
        return SetFileIoOverlappedRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static int SetFileIoOverlappedRange(MemorySegment FileHandle, MemorySegment OverlappedRangeStart, int Length) {
        var mh$ = SetFileIoOverlappedRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileIoOverlappedRange", FileHandle, OverlappedRangeStart, Length);
            }
            return (int)mh$.invokeExact(FileHandle, OverlappedRangeStart, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCompressedFileSizeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeA$descriptor() {
        return GetCompressedFileSizeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeA$handle() {
        return GetCompressedFileSizeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetCompressedFileSizeA$address() {
        return GetCompressedFileSizeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeA(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeA", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCompressedFileSizeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeW$descriptor() {
        return GetCompressedFileSizeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeW$handle() {
        return GetCompressedFileSizeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MemorySegment GetCompressedFileSizeW$address() {
        return GetCompressedFileSizeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeW(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeW", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FindStreamInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoStandard = 0
     * }
     */
    public static int FindStreamInfoStandard() {
        return FindStreamInfoStandard;
    }
    private static final int FindStreamInfoMaxInfoLevel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoMaxInfoLevel = 1
     * }
     */
    public static int FindStreamInfoMaxInfoLevel() {
        return FindStreamInfoMaxInfoLevel;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_STREAM_DATA {
     *     LARGE_INTEGER StreamSize;
     *     WCHAR cStreamName[296];
     * } *PWIN32_FIND_STREAM_DATA
     * }
     */
    public static final AddressLayout PWIN32_FIND_STREAM_DATA = freeglut_h.C_POINTER;

    private static class FindFirstStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstStreamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor FindFirstStreamW$descriptor() {
        return FindFirstStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MethodHandle FindFirstStreamW$handle() {
        return FindFirstStreamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MemorySegment FindFirstStreamW$address() {
        return FindFirstStreamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MemorySegment FindFirstStreamW(MemorySegment lpFileName, int InfoLevel, MemorySegment lpFindStreamData, int dwFlags) {
        var mh$ = FindFirstStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstStreamW", lpFileName, InfoLevel, lpFindStreamData, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, InfoLevel, lpFindStreamData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindNextStreamW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static FunctionDescriptor FindNextStreamW$descriptor() {
        return FindNextStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static MethodHandle FindNextStreamW$handle() {
        return FindNextStreamW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static MemorySegment FindNextStreamW$address() {
        return FindNextStreamW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static int FindNextStreamW(MemorySegment hFindStream, MemorySegment lpFindStreamData) {
        var mh$ = FindNextStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextStreamW", hFindStream, lpFindStreamData);
            }
            return (int)mh$.invokeExact(hFindStream, lpFindStreamData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreFileApisANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AreFileApisANSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static FunctionDescriptor AreFileApisANSI$descriptor() {
        return AreFileApisANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static MethodHandle AreFileApisANSI$handle() {
        return AreFileApisANSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static MemorySegment AreFileApisANSI$address() {
        return AreFileApisANSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static int AreFileApisANSI() {
        var mh$ = AreFileApisANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreFileApisANSI");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTempPathA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathA$descriptor() {
        return GetTempPathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathA$handle() {
        return GetTempPathA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetTempPathA$address() {
        return GetTempPathA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetTempPathA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindFirstFileNameW$descriptor() {
        return FindFirstFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindFirstFileNameW$handle() {
        return FindFirstFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindFirstFileNameW$address() {
        return FindFirstFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindFirstFileNameW(MemorySegment lpFileName, int dwFlags, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindFirstFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileNameW", lpFileName, dwFlags, StringLength, LinkName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwFlags, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindNextFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindNextFileNameW$descriptor() {
        return FindNextFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindNextFileNameW$handle() {
        return FindNextFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindNextFileNameW$address() {
        return FindNextFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static int FindNextFileNameW(MemorySegment hFindStream, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindNextFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileNameW", hFindStream, StringLength, LinkName);
            }
            return (int)mh$.invokeExact(hFindStream, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVolumeInformationA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationA$descriptor() {
        return GetVolumeInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationA$handle() {
        return GetVolumeInformationA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MemorySegment GetVolumeInformationA$address() {
        return GetVolumeInformationA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationA(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationA", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTempFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameA$descriptor() {
        return GetTempFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameA$handle() {
        return GetTempFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static MemorySegment GetTempFileNameA$address() {
        return GetTempFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameA(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameA", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToOEM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileApisToOEM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static FunctionDescriptor SetFileApisToOEM$descriptor() {
        return SetFileApisToOEM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static MethodHandle SetFileApisToOEM$handle() {
        return SetFileApisToOEM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static MemorySegment SetFileApisToOEM$address() {
        return SetFileApisToOEM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static void SetFileApisToOEM() {
        var mh$ = SetFileApisToOEM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToOEM");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileApisToANSI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static FunctionDescriptor SetFileApisToANSI$descriptor() {
        return SetFileApisToANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static MethodHandle SetFileApisToANSI$handle() {
        return SetFileApisToANSI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static MemorySegment SetFileApisToANSI$address() {
        return SetFileApisToANSI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static void SetFileApisToANSI() {
        var mh$ = SetFileApisToANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToANSI");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopyFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileFromAppW$descriptor() {
        return CopyFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileFromAppW$handle() {
        return CopyFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MemorySegment CopyFileFromAppW$address() {
        return CopyFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileFromAppW", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateDirectoryFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryFromAppW$descriptor() {
        return CreateDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryFromAppW$handle() {
        return CreateDirectoryFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateDirectoryFromAppW$address() {
        return CreateDirectoryFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryFromAppW(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryFromAppW", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileFromAppW$descriptor() {
        return CreateFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileFromAppW$handle() {
        return CreateFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileFromAppW$address() {
        return CreateFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileFromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileFromAppW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFile2FromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFile2FromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2FromAppW$descriptor() {
        return CreateFile2FromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2FromAppW$handle() {
        return CreateFile2FromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2FromAppW$address() {
        return CreateFile2FromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2FromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2FromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2FromAppW", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileFromAppW$descriptor() {
        return DeleteFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileFromAppW$handle() {
        return DeleteFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment DeleteFileFromAppW$address() {
        return DeleteFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static int DeleteFileFromAppW(MemorySegment lpFileName) {
        var mh$ = DeleteFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileFromAppW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstFileExFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExFromAppW$descriptor() {
        return FindFirstFileExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExFromAppW$handle() {
        return FindFirstFileExFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExFromAppW$address() {
        return FindFirstFileExFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExFromAppW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileAttributesExFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExFromAppW$descriptor() {
        return GetFileAttributesExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExFromAppW$handle() {
        return GetFileAttributesExFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MemorySegment GetFileAttributesExFromAppW$address() {
        return GetFileAttributesExFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExFromAppW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MoveFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileFromAppW$descriptor() {
        return MoveFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileFromAppW$handle() {
        return MoveFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MemorySegment MoveFileFromAppW$address() {
        return MoveFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static int MoveFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileFromAppW", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveDirectoryFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryFromAppW$descriptor() {
        return RemoveDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryFromAppW$handle() {
        return RemoveDirectoryFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static MemorySegment RemoveDirectoryFromAppW$address() {
        return RemoveDirectoryFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryFromAppW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryFromAppW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReplaceFileFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileFromAppW$descriptor() {
        return ReplaceFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileFromAppW$handle() {
        return ReplaceFileFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MemorySegment ReplaceFileFromAppW$address() {
        return ReplaceFileFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileFromAppW(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileFromAppW", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileAttributesFromAppW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesFromAppW$descriptor() {
        return SetFileAttributesFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesFromAppW$handle() {
        return SetFileAttributesFromAppW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MemorySegment SetFileAttributesFromAppW$address() {
        return SetFileAttributesFromAppW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesFromAppW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesFromAppW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsDebuggerPresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static FunctionDescriptor IsDebuggerPresent$descriptor() {
        return IsDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static MethodHandle IsDebuggerPresent$handle() {
        return IsDebuggerPresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static MemorySegment IsDebuggerPresent$address() {
        return IsDebuggerPresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static int IsDebuggerPresent() {
        var mh$ = IsDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDebuggerPresent");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DebugBreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static FunctionDescriptor DebugBreak$descriptor() {
        return DebugBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static MethodHandle DebugBreak$handle() {
        return DebugBreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static MemorySegment DebugBreak$address() {
        return DebugBreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static void DebugBreak() {
        var mh$ = DebugBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugBreak");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OutputDebugStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringA$descriptor() {
        return OutputDebugStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringA$handle() {
        return OutputDebugStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static MemorySegment OutputDebugStringA$address() {
        return OutputDebugStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringA(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringA", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OutputDebugStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringW$descriptor() {
        return OutputDebugStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringW$handle() {
        return OutputDebugStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static MemorySegment OutputDebugStringW$address() {
        return OutputDebugStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringW(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringW", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ContinueDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ContinueDebugEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static FunctionDescriptor ContinueDebugEvent$descriptor() {
        return ContinueDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static MethodHandle ContinueDebugEvent$handle() {
        return ContinueDebugEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static MemorySegment ContinueDebugEvent$address() {
        return ContinueDebugEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static int ContinueDebugEvent(int dwProcessId, int dwThreadId, int dwContinueStatus) {
        var mh$ = ContinueDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ContinueDebugEvent", dwProcessId, dwThreadId, dwContinueStatus);
            }
            return (int)mh$.invokeExact(dwProcessId, dwThreadId, dwContinueStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForDebugEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEvent$descriptor() {
        return WaitForDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEvent$handle() {
        return WaitForDebugEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForDebugEvent$address() {
        return WaitForDebugEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEvent(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEvent", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DebugActiveProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcess$descriptor() {
        return DebugActiveProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcess$handle() {
        return DebugActiveProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static MemorySegment DebugActiveProcess$address() {
        return DebugActiveProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcess(int dwProcessId) {
        var mh$ = DebugActiveProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcess", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcessStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DebugActiveProcessStop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcessStop$descriptor() {
        return DebugActiveProcessStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcessStop$handle() {
        return DebugActiveProcessStop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static MemorySegment DebugActiveProcessStop$address() {
        return DebugActiveProcessStop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcessStop(int dwProcessId) {
        var mh$ = DebugActiveProcessStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcessStop", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckRemoteDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckRemoteDebuggerPresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static FunctionDescriptor CheckRemoteDebuggerPresent$descriptor() {
        return CheckRemoteDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static MethodHandle CheckRemoteDebuggerPresent$handle() {
        return CheckRemoteDebuggerPresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static MemorySegment CheckRemoteDebuggerPresent$address() {
        return CheckRemoteDebuggerPresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static int CheckRemoteDebuggerPresent(MemorySegment hProcess, MemorySegment pbDebuggerPresent) {
        var mh$ = CheckRemoteDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckRemoteDebuggerPresent", hProcess, pbDebuggerPresent);
            }
            return (int)mh$.invokeExact(hProcess, pbDebuggerPresent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEventEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForDebugEventEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEventEx$descriptor() {
        return WaitForDebugEventEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEventEx$handle() {
        return WaitForDebugEventEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForDebugEventEx$address() {
        return WaitForDebugEventEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEventEx(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEventEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEventEx", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EncodePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodePointer$descriptor() {
        return EncodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodePointer$handle() {
        return EncodePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodePointer$address() {
        return EncodePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodePointer(MemorySegment Ptr) {
        var mh$ = EncodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DecodePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodePointer$descriptor() {
        return DecodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodePointer$handle() {
        return DecodePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodePointer$address() {
        return DecodePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodePointer(MemorySegment Ptr) {
        var mh$ = DecodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EncodeSystemPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodeSystemPointer$descriptor() {
        return EncodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodeSystemPointer$handle() {
        return EncodeSystemPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodeSystemPointer$address() {
        return EncodeSystemPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodeSystemPointer(MemorySegment Ptr) {
        var mh$ = EncodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DecodeSystemPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodeSystemPointer$descriptor() {
        return DecodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodeSystemPointer$handle() {
        return DecodeSystemPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodeSystemPointer$address() {
        return DecodeSystemPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodeSystemPointer(MemorySegment Ptr) {
        var mh$ = DecodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EncodeRemotePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static FunctionDescriptor EncodeRemotePointer$descriptor() {
        return EncodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static MethodHandle EncodeRemotePointer$handle() {
        return EncodeRemotePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static MemorySegment EncodeRemotePointer$address() {
        return EncodeRemotePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static int EncodeRemotePointer(MemorySegment ProcessHandle, MemorySegment Ptr, MemorySegment EncodedPtr) {
        var mh$ = EncodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeRemotePointer", ProcessHandle, Ptr, EncodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle, Ptr, EncodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DecodeRemotePointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static FunctionDescriptor DecodeRemotePointer$descriptor() {
        return DecodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static MethodHandle DecodeRemotePointer$handle() {
        return DecodeRemotePointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static MemorySegment DecodeRemotePointer$address() {
        return DecodeRemotePointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static int DecodeRemotePointer(MemorySegment ProcessHandle, MemorySegment Ptr, MemorySegment DecodedPtr) {
        var mh$ = DecodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeRemotePointer", ProcessHandle, Ptr, DecodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle, Ptr, DecodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static FunctionDescriptor Beep$descriptor() {
        return Beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static MethodHandle Beep$handle() {
        return Beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static MemorySegment Beep$address() {
        return Beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static int Beep(int dwFreq, int dwDuration) {
        var mh$ = Beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Beep", dwFreq, dwDuration);
            }
            return (int)mh$.invokeExact(dwFreq, dwDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static FunctionDescriptor CloseHandle$descriptor() {
        return CloseHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MethodHandle CloseHandle$handle() {
        return CloseHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MemorySegment CloseHandle$address() {
        return CloseHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseHandle", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DuplicateHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static FunctionDescriptor DuplicateHandle$descriptor() {
        return DuplicateHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static MethodHandle DuplicateHandle$handle() {
        return DuplicateHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static MemorySegment DuplicateHandle$address() {
        return DuplicateHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static int DuplicateHandle(MemorySegment hSourceProcessHandle, MemorySegment hSourceHandle, MemorySegment hTargetProcessHandle, MemorySegment lpTargetHandle, int dwDesiredAccess, int bInheritHandle, int dwOptions) {
        var mh$ = DuplicateHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateHandle", hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
            }
            return (int)mh$.invokeExact(hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareObjectHandles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CompareObjectHandles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static FunctionDescriptor CompareObjectHandles$descriptor() {
        return CompareObjectHandles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static MethodHandle CompareObjectHandles$handle() {
        return CompareObjectHandles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static MemorySegment CompareObjectHandles$address() {
        return CompareObjectHandles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static int CompareObjectHandles(MemorySegment hFirstObjectHandle, MemorySegment hSecondObjectHandle) {
        var mh$ = CompareObjectHandles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareObjectHandles", hFirstObjectHandle, hSecondObjectHandle);
            }
            return (int)mh$.invokeExact(hFirstObjectHandle, hSecondObjectHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetHandleInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor GetHandleInformation$descriptor() {
        return GetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle GetHandleInformation$handle() {
        return GetHandleInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static MemorySegment GetHandleInformation$address() {
        return GetHandleInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static int GetHandleInformation(MemorySegment hObject, MemorySegment lpdwFlags) {
        var mh$ = GetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetHandleInformation", hObject, lpdwFlags);
            }
            return (int)mh$.invokeExact(hObject, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetHandleInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetHandleInformation$descriptor() {
        return SetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetHandleInformation$handle() {
        return SetHandleInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetHandleInformation$address() {
        return SetHandleInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static int SetHandleInformation(MemorySegment hObject, int dwMask, int dwFlags) {
        var mh$ = SetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetHandleInformation", hObject, dwMask, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, dwMask, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RaiseException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static FunctionDescriptor RaiseException$descriptor() {
        return RaiseException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static MethodHandle RaiseException$handle() {
        return RaiseException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static MemorySegment RaiseException$address() {
        return RaiseException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static void RaiseException(int dwExceptionCode, int dwExceptionFlags, int nNumberOfArguments, MemorySegment lpArguments) {
        var mh$ = RaiseException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseException", dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
            }
            mh$.invokeExact(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnhandledExceptionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static FunctionDescriptor UnhandledExceptionFilter$descriptor() {
        return UnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static MethodHandle UnhandledExceptionFilter$handle() {
        return UnhandledExceptionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static MemorySegment UnhandledExceptionFilter$address() {
        return UnhandledExceptionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static int UnhandledExceptionFilter(MemorySegment ExceptionInfo) {
        var mh$ = UnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhandledExceptionFilter", ExceptionInfo);
            }
            return (int)mh$.invokeExact(ExceptionInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetUnhandledExceptionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static FunctionDescriptor SetUnhandledExceptionFilter$descriptor() {
        return SetUnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MethodHandle SetUnhandledExceptionFilter$handle() {
        return SetUnhandledExceptionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MemorySegment SetUnhandledExceptionFilter$address() {
        return SetUnhandledExceptionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MemorySegment SetUnhandledExceptionFilter(MemorySegment lpTopLevelExceptionFilter) {
        var mh$ = SetUnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUnhandledExceptionFilter", lpTopLevelExceptionFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpTopLevelExceptionFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static FunctionDescriptor GetLastError$descriptor() {
        return GetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MethodHandle GetLastError$handle() {
        return GetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MemorySegment GetLastError$address() {
        return GetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static FunctionDescriptor SetLastError$descriptor() {
        return SetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static MethodHandle SetLastError$handle() {
        return SetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static MemorySegment SetLastError$address() {
        return SetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static void SetLastError(int dwErrCode) {
        var mh$ = SetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLastError", dwErrCode);
            }
            mh$.invokeExact(dwErrCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static FunctionDescriptor GetErrorMode$descriptor() {
        return GetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static MethodHandle GetErrorMode$handle() {
        return GetErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static MemorySegment GetErrorMode$address() {
        return GetErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static int GetErrorMode() {
        var mh$ = GetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static FunctionDescriptor SetErrorMode$descriptor() {
        return SetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static MethodHandle SetErrorMode$handle() {
        return SetErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static MemorySegment SetErrorMode$address() {
        return SetErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static int SetErrorMode(int uMode) {
        var mh$ = SetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetErrorMode", uMode);
            }
            return (int)mh$.invokeExact(uMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddVectoredExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredExceptionHandler$descriptor() {
        return AddVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredExceptionHandler$handle() {
        return AddVectoredExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredExceptionHandler$address() {
        return AddVectoredExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredExceptionHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredExceptionHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveVectoredExceptionHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredExceptionHandler$descriptor() {
        return RemoveVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredExceptionHandler$handle() {
        return RemoveVectoredExceptionHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static MemorySegment RemoveVectoredExceptionHandler$address() {
        return RemoveVectoredExceptionHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredExceptionHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredExceptionHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddVectoredContinueHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredContinueHandler$descriptor() {
        return AddVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredContinueHandler$handle() {
        return AddVectoredContinueHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredContinueHandler$address() {
        return AddVectoredContinueHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredContinueHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredContinueHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveVectoredContinueHandler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredContinueHandler$descriptor() {
        return RemoveVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredContinueHandler$handle() {
        return RemoveVectoredContinueHandler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static MemorySegment RemoveVectoredContinueHandler$address() {
        return RemoveVectoredContinueHandler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredContinueHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredContinueHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseFailFastException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RaiseFailFastException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RaiseFailFastException$descriptor() {
        return RaiseFailFastException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static MethodHandle RaiseFailFastException$handle() {
        return RaiseFailFastException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static MemorySegment RaiseFailFastException$address() {
        return RaiseFailFastException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static void RaiseFailFastException(MemorySegment pExceptionRecord, MemorySegment pContextRecord, int dwFlags) {
        var mh$ = RaiseFailFastException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseFailFastException", pExceptionRecord, pContextRecord, dwFlags);
            }
            mh$.invokeExact(pExceptionRecord, pContextRecord, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FatalAppExitA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitA$descriptor() {
        return FatalAppExitA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitA$handle() {
        return FatalAppExitA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static MemorySegment FatalAppExitA$address() {
        return FatalAppExitA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static void FatalAppExitA(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitA", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FatalAppExitW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitW$descriptor() {
        return FatalAppExitW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitW$handle() {
        return FatalAppExitW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static MemorySegment FatalAppExitW$address() {
        return FatalAppExitW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static void FatalAppExitW(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitW", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static FunctionDescriptor GetThreadErrorMode$descriptor() {
        return GetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static MethodHandle GetThreadErrorMode$handle() {
        return GetThreadErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static MemorySegment GetThreadErrorMode$address() {
        return GetThreadErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static int GetThreadErrorMode() {
        var mh$ = GetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadErrorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static FunctionDescriptor SetThreadErrorMode$descriptor() {
        return SetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static MethodHandle SetThreadErrorMode$handle() {
        return SetThreadErrorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static MemorySegment SetThreadErrorMode$address() {
        return SetThreadErrorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static int SetThreadErrorMode(int dwNewMode, MemorySegment lpOldMode) {
        var mh$ = SetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadErrorMode", dwNewMode, lpOldMode);
            }
            return (int)mh$.invokeExact(dwNewMode, lpOldMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcessOnMemoryExhaustion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TerminateProcessOnMemoryExhaustion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static FunctionDescriptor TerminateProcessOnMemoryExhaustion$descriptor() {
        return TerminateProcessOnMemoryExhaustion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static MethodHandle TerminateProcessOnMemoryExhaustion$handle() {
        return TerminateProcessOnMemoryExhaustion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static MemorySegment TerminateProcessOnMemoryExhaustion$address() {
        return TerminateProcessOnMemoryExhaustion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static void TerminateProcessOnMemoryExhaustion(long FailedAllocationSize) {
        var mh$ = TerminateProcessOnMemoryExhaustion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcessOnMemoryExhaustion", FailedAllocationSize);
            }
            mh$.invokeExact(FailedAllocationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlsAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static FunctionDescriptor FlsAlloc$descriptor() {
        return FlsAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static MethodHandle FlsAlloc$handle() {
        return FlsAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static MemorySegment FlsAlloc$address() {
        return FlsAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static int FlsAlloc(MemorySegment lpCallback) {
        var mh$ = FlsAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsAlloc", lpCallback);
            }
            return (int)mh$.invokeExact(lpCallback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlsGetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsGetValue$descriptor() {
        return FlsGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsGetValue$handle() {
        return FlsGetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue$address() {
        return FlsGetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue(int dwFlsIndex) {
        var mh$ = FlsGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsGetValue", dwFlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsSetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlsSetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static FunctionDescriptor FlsSetValue$descriptor() {
        return FlsSetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static MethodHandle FlsSetValue$handle() {
        return FlsSetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static MemorySegment FlsSetValue$address() {
        return FlsSetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static int FlsSetValue(int dwFlsIndex, MemorySegment lpFlsData) {
        var mh$ = FlsSetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsSetValue", dwFlsIndex, lpFlsData);
            }
            return (int)mh$.invokeExact(dwFlsIndex, lpFlsData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsFree$descriptor() {
        return FlsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsFree$handle() {
        return FlsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsFree$address() {
        return FlsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static int FlsFree(int dwFlsIndex) {
        var mh$ = FlsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsFree", dwFlsIndex);
            }
            return (int)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsThreadAFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsThreadAFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static FunctionDescriptor IsThreadAFiber$descriptor() {
        return IsThreadAFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static MethodHandle IsThreadAFiber$handle() {
        return IsThreadAFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static MemorySegment IsThreadAFiber$address() {
        return IsThreadAFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static int IsThreadAFiber() {
        var mh$ = IsThreadAFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsThreadAFiber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static FunctionDescriptor CreatePipe$descriptor() {
        return CreatePipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static MethodHandle CreatePipe$handle() {
        return CreatePipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static MemorySegment CreatePipe$address() {
        return CreatePipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static int CreatePipe(MemorySegment hReadPipe, MemorySegment hWritePipe, MemorySegment lpPipeAttributes, int nSize) {
        var mh$ = CreatePipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePipe", hReadPipe, hWritePipe, lpPipeAttributes, nSize);
            }
            return (int)mh$.invokeExact(hReadPipe, hWritePipe, lpPipeAttributes, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConnectNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ConnectNamedPipe$descriptor() {
        return ConnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ConnectNamedPipe$handle() {
        return ConnectNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment ConnectNamedPipe$address() {
        return ConnectNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ConnectNamedPipe(MemorySegment hNamedPipe, MemorySegment lpOverlapped) {
        var mh$ = ConnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConnectNamedPipe", hNamedPipe, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisconnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DisconnectNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor DisconnectNamedPipe$descriptor() {
        return DisconnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle DisconnectNamedPipe$handle() {
        return DisconnectNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static MemorySegment DisconnectNamedPipe$address() {
        return DisconnectNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static int DisconnectNamedPipe(MemorySegment hNamedPipe) {
        var mh$ = DisconnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisconnectNamedPipe", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetNamedPipeHandleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetNamedPipeHandleState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static FunctionDescriptor SetNamedPipeHandleState$descriptor() {
        return SetNamedPipeHandleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static MethodHandle SetNamedPipeHandleState$handle() {
        return SetNamedPipeHandleState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static MemorySegment SetNamedPipeHandleState$address() {
        return SetNamedPipeHandleState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static int SetNamedPipeHandleState(MemorySegment hNamedPipe, MemorySegment lpMode, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout) {
        var mh$ = SetNamedPipeHandleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetNamedPipeHandleState", hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PeekNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static FunctionDescriptor PeekNamedPipe$descriptor() {
        return PeekNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static MethodHandle PeekNamedPipe$handle() {
        return PeekNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static MemorySegment PeekNamedPipe$address() {
        return PeekNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static int PeekNamedPipe(MemorySegment hNamedPipe, MemorySegment lpBuffer, int nBufferSize, MemorySegment lpBytesRead, MemorySegment lpTotalBytesAvail, MemorySegment lpBytesLeftThisMessage) {
        var mh$ = PeekNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekNamedPipe", hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransactNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TransactNamedPipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor TransactNamedPipe$descriptor() {
        return TransactNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle TransactNamedPipe$handle() {
        return TransactNamedPipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment TransactNamedPipe$address() {
        return TransactNamedPipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int TransactNamedPipe(MemorySegment hNamedPipe, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, MemorySegment lpOverlapped) {
        var mh$ = TransactNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransactNamedPipe", hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateNamedPipeW$descriptor() {
        return CreateNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateNamedPipeW$handle() {
        return CreateNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeW$address() {
        return CreateNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeW(MemorySegment lpName, int dwOpenMode, int dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateNamedPipeW", lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor WaitNamedPipeW$descriptor() {
        return WaitNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MethodHandle WaitNamedPipeW$handle() {
        return WaitNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MemorySegment WaitNamedPipeW$address() {
        return WaitNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static int WaitNamedPipeW(MemorySegment lpNamedPipeName, int nTimeOut) {
        var mh$ = WaitNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitNamedPipeW", lpNamedPipeName, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeClientComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientComputerNameW$descriptor() {
        return GetNamedPipeClientComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MethodHandle GetNamedPipeClientComputerNameW$handle() {
        return GetNamedPipeClientComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MemorySegment GetNamedPipeClientComputerNameW$address() {
        return GetNamedPipeClientComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static int GetNamedPipeClientComputerNameW(MemorySegment Pipe, MemorySegment ClientComputerName, int ClientComputerNameLength) {
        var mh$ = GetNamedPipeClientComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientComputerNameW", Pipe, ClientComputerName, ClientComputerNameLength);
            }
            return (int)mh$.invokeExact(Pipe, ClientComputerName, ClientComputerNameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateNamedPipeClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImpersonateNamedPipeClient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor ImpersonateNamedPipeClient$descriptor() {
        return ImpersonateNamedPipeClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle ImpersonateNamedPipeClient$handle() {
        return ImpersonateNamedPipeClient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static MemorySegment ImpersonateNamedPipeClient$address() {
        return ImpersonateNamedPipeClient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static int ImpersonateNamedPipeClient(MemorySegment hNamedPipe) {
        var mh$ = ImpersonateNamedPipeClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateNamedPipeClient", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static FunctionDescriptor GetNamedPipeInfo$descriptor() {
        return GetNamedPipeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static MethodHandle GetNamedPipeInfo$handle() {
        return GetNamedPipeInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static MemorySegment GetNamedPipeInfo$address() {
        return GetNamedPipeInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static int GetNamedPipeInfo(MemorySegment hNamedPipe, MemorySegment lpFlags, MemorySegment lpOutBufferSize, MemorySegment lpInBufferSize, MemorySegment lpMaxInstances) {
        var mh$ = GetNamedPipeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeInfo", hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeHandleStateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNamedPipeHandleStateW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static FunctionDescriptor GetNamedPipeHandleStateW$descriptor() {
        return GetNamedPipeHandleStateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MethodHandle GetNamedPipeHandleStateW$handle() {
        return GetNamedPipeHandleStateW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MemorySegment GetNamedPipeHandleStateW$address() {
        return GetNamedPipeHandleStateW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static int GetNamedPipeHandleStateW(MemorySegment hNamedPipe, MemorySegment lpState, MemorySegment lpCurInstances, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout, MemorySegment lpUserName, int nMaxUserNameSize) {
        var mh$ = GetNamedPipeHandleStateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeHandleStateW", hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallNamedPipeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor CallNamedPipeW$descriptor() {
        return CallNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MethodHandle CallNamedPipeW$handle() {
        return CallNamedPipeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MemorySegment CallNamedPipeW$address() {
        return CallNamedPipeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static int CallNamedPipeW(MemorySegment lpNamedPipeName, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, int nTimeOut) {
        var mh$ = CallNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNamedPipeW", lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryPerformanceCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static FunctionDescriptor QueryPerformanceCounter$descriptor() {
        return QueryPerformanceCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static MethodHandle QueryPerformanceCounter$handle() {
        return QueryPerformanceCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static MemorySegment QueryPerformanceCounter$address() {
        return QueryPerformanceCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static int QueryPerformanceCounter(MemorySegment lpPerformanceCount) {
        var mh$ = QueryPerformanceCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceCounter", lpPerformanceCount);
            }
            return (int)mh$.invokeExact(lpPerformanceCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryPerformanceFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static FunctionDescriptor QueryPerformanceFrequency$descriptor() {
        return QueryPerformanceFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static MethodHandle QueryPerformanceFrequency$handle() {
        return QueryPerformanceFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static MemorySegment QueryPerformanceFrequency$address() {
        return QueryPerformanceFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static int QueryPerformanceFrequency(MemorySegment lpFrequency) {
        var mh$ = QueryPerformanceFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceFrequency", lpFrequency);
            }
            return (int)mh$.invokeExact(lpFrequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _HEAP_SUMMARY {
     *     DWORD cb;
     *     SIZE_T cbAllocated;
     *     SIZE_T cbCommitted;
     *     SIZE_T cbReserved;
     *     SIZE_T cbMaxReserve;
     * } *PHEAP_SUMMARY
     * }
     */
    public static final AddressLayout PHEAP_SUMMARY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PHEAP_SUMMARY LPHEAP_SUMMARY
     * }
     */
    public static final AddressLayout LPHEAP_SUMMARY = freeglut_h.C_POINTER;

    private static class HeapCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static FunctionDescriptor HeapCreate$descriptor() {
        return HeapCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MethodHandle HeapCreate$handle() {
        return HeapCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MemorySegment HeapCreate$address() {
        return HeapCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MemorySegment HeapCreate(int flOptions, long dwInitialSize, long dwMaximumSize) {
        var mh$ = HeapCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCreate", flOptions, dwInitialSize, dwMaximumSize);
            }
            return (MemorySegment)mh$.invokeExact(flOptions, dwInitialSize, dwMaximumSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapDestroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapDestroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapDestroy$descriptor() {
        return HeapDestroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapDestroy$handle() {
        return HeapDestroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapDestroy$address() {
        return HeapDestroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static int HeapDestroy(MemorySegment hHeap) {
        var mh$ = HeapDestroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapDestroy", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapAlloc$descriptor() {
        return HeapAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapAlloc$handle() {
        return HeapAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapAlloc$address() {
        return HeapAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapAlloc(MemorySegment hHeap, int dwFlags, long dwBytes) {
        var mh$ = HeapAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapAlloc", hHeap, dwFlags, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapReAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapReAlloc$descriptor() {
        return HeapReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapReAlloc$handle() {
        return HeapReAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapReAlloc$address() {
        return HeapReAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapReAlloc(MemorySegment hHeap, int dwFlags, MemorySegment lpMem, long dwBytes) {
        var mh$ = HeapReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapReAlloc", hHeap, dwFlags, lpMem, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, lpMem, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapFree$descriptor() {
        return HeapFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static MethodHandle HeapFree$handle() {
        return HeapFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static MemorySegment HeapFree$address() {
        return HeapFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static int HeapFree(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapFree", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapSize$descriptor() {
        return HeapSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapSize$handle() {
        return HeapSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MemorySegment HeapSize$address() {
        return HeapSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static long HeapSize(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSize", hHeap, dwFlags, lpMem);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessHeap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static FunctionDescriptor GetProcessHeap$descriptor() {
        return GetProcessHeap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MethodHandle GetProcessHeap$handle() {
        return GetProcessHeap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MemorySegment GetProcessHeap$address() {
        return GetProcessHeap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MemorySegment GetProcessHeap() {
        var mh$ = GetProcessHeap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeap");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor HeapCompact$descriptor() {
        return HeapCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static MethodHandle HeapCompact$handle() {
        return HeapCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static MemorySegment HeapCompact$address() {
        return HeapCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static long HeapCompact(MemorySegment hHeap, int dwFlags) {
        var mh$ = HeapCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCompact", hHeap, dwFlags);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSetInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapSetInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static FunctionDescriptor HeapSetInformation$descriptor() {
        return HeapSetInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static MethodHandle HeapSetInformation$handle() {
        return HeapSetInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static MemorySegment HeapSetInformation$address() {
        return HeapSetInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static int HeapSetInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength) {
        var mh$ = HeapSetInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSetInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapValidate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapValidate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapValidate$descriptor() {
        return HeapValidate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapValidate$handle() {
        return HeapValidate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MemorySegment HeapValidate$address() {
        return HeapValidate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static int HeapValidate(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapValidate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapValidate", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSummary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapSummary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static FunctionDescriptor HeapSummary$descriptor() {
        return HeapSummary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static MethodHandle HeapSummary$handle() {
        return HeapSummary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static MemorySegment HeapSummary$address() {
        return HeapSummary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static int HeapSummary(MemorySegment hHeap, int dwFlags, MemorySegment lpSummary) {
        var mh$ = HeapSummary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSummary", hHeap, dwFlags, lpSummary);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpSummary);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessHeaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static FunctionDescriptor GetProcessHeaps$descriptor() {
        return GetProcessHeaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static MethodHandle GetProcessHeaps$handle() {
        return GetProcessHeaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static MemorySegment GetProcessHeaps$address() {
        return GetProcessHeaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static int GetProcessHeaps(int NumberOfHeaps, MemorySegment ProcessHeaps) {
        var mh$ = GetProcessHeaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeaps", NumberOfHeaps, ProcessHeaps);
            }
            return (int)mh$.invokeExact(NumberOfHeaps, ProcessHeaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapLock$descriptor() {
        return HeapLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapLock$handle() {
        return HeapLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapLock$address() {
        return HeapLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static int HeapLock(MemorySegment hHeap) {
        var mh$ = HeapLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapLock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapUnlock$descriptor() {
        return HeapUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapUnlock$handle() {
        return HeapUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static MemorySegment HeapUnlock$address() {
        return HeapUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static int HeapUnlock(MemorySegment hHeap) {
        var mh$ = HeapUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapUnlock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapWalk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapWalk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static FunctionDescriptor HeapWalk$descriptor() {
        return HeapWalk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static MethodHandle HeapWalk$handle() {
        return HeapWalk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static MemorySegment HeapWalk$address() {
        return HeapWalk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static int HeapWalk(MemorySegment hHeap, MemorySegment lpEntry) {
        var mh$ = HeapWalk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapWalk", hHeap, lpEntry);
            }
            return (int)mh$.invokeExact(hHeap, lpEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapQueryInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("HeapQueryInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static FunctionDescriptor HeapQueryInformation$descriptor() {
        return HeapQueryInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static MethodHandle HeapQueryInformation$handle() {
        return HeapQueryInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static MemorySegment HeapQueryInformation$address() {
        return HeapQueryInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static int HeapQueryInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength, MemorySegment ReturnLength) {
        var mh$ = HeapQueryInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapQueryInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIoCompletionPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateIoCompletionPort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static FunctionDescriptor CreateIoCompletionPort$descriptor() {
        return CreateIoCompletionPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MethodHandle CreateIoCompletionPort$handle() {
        return CreateIoCompletionPort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort$address() {
        return CreateIoCompletionPort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort(MemorySegment FileHandle, MemorySegment ExistingCompletionPort, long CompletionKey, int NumberOfConcurrentThreads) {
        var mh$ = CreateIoCompletionPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIoCompletionPort", FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
            }
            return (MemorySegment)mh$.invokeExact(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetQueuedCompletionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatus$descriptor() {
        return GetQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatus$handle() {
        return GetQueuedCompletionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatus$address() {
        return GetQueuedCompletionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static int GetQueuedCompletionStatus(MemorySegment CompletionPort, MemorySegment lpNumberOfBytesTransferred, MemorySegment lpCompletionKey, MemorySegment lpOverlapped, int dwMilliseconds) {
        var mh$ = GetQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatus", CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
            }
            return (int)mh$.invokeExact(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetQueuedCompletionStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatusEx$descriptor() {
        return GetQueuedCompletionStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatusEx$handle() {
        return GetQueuedCompletionStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatusEx$address() {
        return GetQueuedCompletionStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static int GetQueuedCompletionStatusEx(MemorySegment CompletionPort, MemorySegment lpCompletionPortEntries, int ulCount, MemorySegment ulNumEntriesRemoved, int dwMilliseconds, int fAlertable) {
        var mh$ = GetQueuedCompletionStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatusEx", CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
            }
            return (int)mh$.invokeExact(CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PostQueuedCompletionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor PostQueuedCompletionStatus$descriptor() {
        return PostQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle PostQueuedCompletionStatus$handle() {
        return PostQueuedCompletionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment PostQueuedCompletionStatus$address() {
        return PostQueuedCompletionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int PostQueuedCompletionStatus(MemorySegment CompletionPort, int dwNumberOfBytesTransferred, long dwCompletionKey, MemorySegment lpOverlapped) {
        var mh$ = PostQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostQueuedCompletionStatus", CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
            }
            return (int)mh$.invokeExact(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceIoControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeviceIoControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor DeviceIoControl$descriptor() {
        return DeviceIoControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle DeviceIoControl$handle() {
        return DeviceIoControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment DeviceIoControl$address() {
        return DeviceIoControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int DeviceIoControl(MemorySegment hDevice, int dwIoControlCode, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesReturned, MemorySegment lpOverlapped) {
        var mh$ = DeviceIoControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceIoControl", hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
            }
            return (int)mh$.invokeExact(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOverlappedResult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static FunctionDescriptor GetOverlappedResult$descriptor() {
        return GetOverlappedResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MethodHandle GetOverlappedResult$handle() {
        return GetOverlappedResult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MemorySegment GetOverlappedResult$address() {
        return GetOverlappedResult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResult", hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelIoEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor CancelIoEx$descriptor() {
        return CancelIoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle CancelIoEx$handle() {
        return CancelIoEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment CancelIoEx$address() {
        return CancelIoEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int CancelIoEx(MemorySegment hFile, MemorySegment lpOverlapped) {
        var mh$ = CancelIoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIoEx", hFile, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor CancelIo$descriptor() {
        return CancelIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static MethodHandle CancelIo$handle() {
        return CancelIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static MemorySegment CancelIo$address() {
        return CancelIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static int CancelIo(MemorySegment hFile) {
        var mh$ = CancelIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIo", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResultEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOverlappedResultEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor GetOverlappedResultEx$descriptor() {
        return GetOverlappedResultEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle GetOverlappedResultEx$handle() {
        return GetOverlappedResultEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment GetOverlappedResultEx$address() {
        return GetOverlappedResultEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int GetOverlappedResultEx(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int dwMilliseconds, int bAlertable) {
        var mh$ = GetOverlappedResultEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResultEx", hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelSynchronousIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelSynchronousIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor CancelSynchronousIo$descriptor() {
        return CancelSynchronousIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static MethodHandle CancelSynchronousIo$handle() {
        return CancelSynchronousIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static MemorySegment CancelSynchronousIo$address() {
        return CancelSynchronousIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static int CancelSynchronousIo(MemorySegment hThread) {
        var mh$ = CancelSynchronousIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelSynchronousIo", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_SRWLOCK *PSRWLOCK
     * }
     */
    public static final AddressLayout PSRWLOCK = freeglut_h.C_POINTER;

    private static class InitializeSRWLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeSRWLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor InitializeSRWLock$descriptor() {
        return InitializeSRWLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle InitializeSRWLock$handle() {
        return InitializeSRWLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment InitializeSRWLock$address() {
        return InitializeSRWLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static void InitializeSRWLock(MemorySegment SRWLock) {
        var mh$ = InitializeSRWLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSRWLock", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockExclusive$descriptor() {
        return ReleaseSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockExclusive$handle() {
        return ReleaseSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment ReleaseSRWLockExclusive$address() {
        return ReleaseSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockShared$descriptor() {
        return ReleaseSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockShared$handle() {
        return ReleaseSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment ReleaseSRWLockShared$address() {
        return ReleaseSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockShared(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AcquireSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockExclusive$descriptor() {
        return AcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockExclusive$handle() {
        return AcquireSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment AcquireSRWLockExclusive$address() {
        return AcquireSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AcquireSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockShared$descriptor() {
        return AcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockShared$handle() {
        return AcquireSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment AcquireSRWLockShared$address() {
        return AcquireSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TryAcquireSRWLockExclusive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockExclusive$descriptor() {
        return TryAcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockExclusive$handle() {
        return TryAcquireSRWLockExclusive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment TryAcquireSRWLockExclusive$address() {
        return TryAcquireSRWLockExclusive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockExclusive", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TryAcquireSRWLockShared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockShared$descriptor() {
        return TryAcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockShared$handle() {
        return TryAcquireSRWLockShared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MemorySegment TryAcquireSRWLockShared$address() {
        return TryAcquireSRWLockShared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockShared", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSection$descriptor() {
        return InitializeCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle InitializeCriticalSection$handle() {
        return InitializeCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment InitializeCriticalSection$address() {
        return InitializeCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void InitializeCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = InitializeCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnterCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor EnterCriticalSection$descriptor() {
        return EnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle EnterCriticalSection$handle() {
        return EnterCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment EnterCriticalSection$address() {
        return EnterCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void EnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = EnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LeaveCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LeaveCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor LeaveCriticalSection$descriptor() {
        return LeaveCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle LeaveCriticalSection$handle() {
        return LeaveCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment LeaveCriticalSection$address() {
        return LeaveCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void LeaveCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = LeaveCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LeaveCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionAndSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeCriticalSectionAndSpinCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionAndSpinCount$descriptor() {
        return InitializeCriticalSectionAndSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle InitializeCriticalSectionAndSpinCount$handle() {
        return InitializeCriticalSectionAndSpinCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MemorySegment InitializeCriticalSectionAndSpinCount$address() {
        return InitializeCriticalSectionAndSpinCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int InitializeCriticalSectionAndSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = InitializeCriticalSectionAndSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionAndSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeCriticalSectionEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionEx$descriptor() {
        return InitializeCriticalSectionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static MethodHandle InitializeCriticalSectionEx$handle() {
        return InitializeCriticalSectionEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static MemorySegment InitializeCriticalSectionEx$address() {
        return InitializeCriticalSectionEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static int InitializeCriticalSectionEx(MemorySegment lpCriticalSection, int dwSpinCount, int Flags) {
        var mh$ = InitializeCriticalSectionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionEx", lpCriticalSection, dwSpinCount, Flags);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCriticalSectionSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCriticalSectionSpinCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor SetCriticalSectionSpinCount$descriptor() {
        return SetCriticalSectionSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle SetCriticalSectionSpinCount$handle() {
        return SetCriticalSectionSpinCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MemorySegment SetCriticalSectionSpinCount$address() {
        return SetCriticalSectionSpinCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int SetCriticalSectionSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = SetCriticalSectionSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCriticalSectionSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryEnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TryEnterCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor TryEnterCriticalSection$descriptor() {
        return TryEnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle TryEnterCriticalSection$handle() {
        return TryEnterCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment TryEnterCriticalSection$address() {
        return TryEnterCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static int TryEnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = TryEnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryEnterCriticalSection", lpCriticalSection);
            }
            return (int)mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteCriticalSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor DeleteCriticalSection$descriptor() {
        return DeleteCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle DeleteCriticalSection$handle() {
        return DeleteCriticalSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MemorySegment DeleteCriticalSection$address() {
        return DeleteCriticalSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void DeleteCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = DeleteCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE PINIT_ONCE
     * }
     */
    public static final AddressLayout PINIT_ONCE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE LPINIT_ONCE
     * }
     */
    public static final AddressLayout LPINIT_ONCE = freeglut_h.C_POINTER;

    private static class InitOnceInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitOnceInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static FunctionDescriptor InitOnceInitialize$descriptor() {
        return InitOnceInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static MethodHandle InitOnceInitialize$handle() {
        return InitOnceInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static MemorySegment InitOnceInitialize$address() {
        return InitOnceInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static void InitOnceInitialize(MemorySegment InitOnce) {
        var mh$ = InitOnceInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceInitialize", InitOnce);
            }
            mh$.invokeExact(InitOnce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceExecuteOnce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitOnceExecuteOnce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static FunctionDescriptor InitOnceExecuteOnce$descriptor() {
        return InitOnceExecuteOnce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static MethodHandle InitOnceExecuteOnce$handle() {
        return InitOnceExecuteOnce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static MemorySegment InitOnceExecuteOnce$address() {
        return InitOnceExecuteOnce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static int InitOnceExecuteOnce(MemorySegment InitOnce, MemorySegment InitFn, MemorySegment Parameter, MemorySegment Context) {
        var mh$ = InitOnceExecuteOnce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceExecuteOnce", InitOnce, InitFn, Parameter, Context);
            }
            return (int)mh$.invokeExact(InitOnce, InitFn, Parameter, Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceBeginInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitOnceBeginInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceBeginInitialize$descriptor() {
        return InitOnceBeginInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static MethodHandle InitOnceBeginInitialize$handle() {
        return InitOnceBeginInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static MemorySegment InitOnceBeginInitialize$address() {
        return InitOnceBeginInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static int InitOnceBeginInitialize(MemorySegment lpInitOnce, int dwFlags, MemorySegment fPending, MemorySegment lpContext) {
        var mh$ = InitOnceBeginInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceBeginInitialize", lpInitOnce, dwFlags, fPending, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, fPending, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceComplete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitOnceComplete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceComplete$descriptor() {
        return InitOnceComplete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static MethodHandle InitOnceComplete$handle() {
        return InitOnceComplete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static MemorySegment InitOnceComplete$address() {
        return InitOnceComplete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static int InitOnceComplete(MemorySegment lpInitOnce, int dwFlags, MemorySegment lpContext) {
        var mh$ = InitOnceComplete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceComplete", lpInitOnce, dwFlags, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_CONDITION_VARIABLE *PCONDITION_VARIABLE
     * }
     */
    public static final AddressLayout PCONDITION_VARIABLE = freeglut_h.C_POINTER;

    private static class InitializeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor InitializeConditionVariable$descriptor() {
        return InitializeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle InitializeConditionVariable$handle() {
        return InitializeConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment InitializeConditionVariable$address() {
        return InitializeConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void InitializeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = InitializeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WakeConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeConditionVariable$descriptor() {
        return WakeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeConditionVariable$handle() {
        return WakeConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment WakeConditionVariable$address() {
        return WakeConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeAllConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WakeAllConditionVariable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeAllConditionVariable$descriptor() {
        return WakeAllConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeAllConditionVariable$handle() {
        return WakeAllConditionVariable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MemorySegment WakeAllConditionVariable$address() {
        return WakeAllConditionVariable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeAllConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeAllConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeAllConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableCS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SleepConditionVariableCS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableCS$descriptor() {
        return SleepConditionVariableCS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle SleepConditionVariableCS$handle() {
        return SleepConditionVariableCS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment SleepConditionVariableCS$address() {
        return SleepConditionVariableCS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static int SleepConditionVariableCS(MemorySegment ConditionVariable, MemorySegment CriticalSection, int dwMilliseconds) {
        var mh$ = SleepConditionVariableCS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableCS", ConditionVariable, CriticalSection, dwMilliseconds);
            }
            return (int)mh$.invokeExact(ConditionVariable, CriticalSection, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableSRW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SleepConditionVariableSRW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableSRW$descriptor() {
        return SleepConditionVariableSRW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static MethodHandle SleepConditionVariableSRW$handle() {
        return SleepConditionVariableSRW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static MemorySegment SleepConditionVariableSRW$address() {
        return SleepConditionVariableSRW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static int SleepConditionVariableSRW(MemorySegment ConditionVariable, MemorySegment SRWLock, int dwMilliseconds, int Flags) {
        var mh$ = SleepConditionVariableSRW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableSRW", ConditionVariable, SRWLock, dwMilliseconds, Flags);
            }
            return (int)mh$.invokeExact(ConditionVariable, SRWLock, dwMilliseconds, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor SetEvent$descriptor() {
        return SetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle SetEvent$handle() {
        return SetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment SetEvent$address() {
        return SetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static int SetEvent(MemorySegment hEvent) {
        var mh$ = SetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor ResetEvent$descriptor() {
        return ResetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle ResetEvent$handle() {
        return ResetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment ResetEvent$address() {
        return ResetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static int ResetEvent(MemorySegment hEvent) {
        var mh$ = ResetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSemaphore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseSemaphore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static FunctionDescriptor ReleaseSemaphore$descriptor() {
        return ReleaseSemaphore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static MethodHandle ReleaseSemaphore$handle() {
        return ReleaseSemaphore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static MemorySegment ReleaseSemaphore$address() {
        return ReleaseSemaphore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static int ReleaseSemaphore(MemorySegment hSemaphore, int lReleaseCount, MemorySegment lpPreviousCount) {
        var mh$ = ReleaseSemaphore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSemaphore", hSemaphore, lReleaseCount, lpPreviousCount);
            }
            return (int)mh$.invokeExact(hSemaphore, lReleaseCount, lpPreviousCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseMutex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseMutex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static FunctionDescriptor ReleaseMutex$descriptor() {
        return ReleaseMutex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static MethodHandle ReleaseMutex$handle() {
        return ReleaseMutex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static MemorySegment ReleaseMutex$address() {
        return ReleaseMutex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static int ReleaseMutex(MemorySegment hMutex) {
        var mh$ = ReleaseMutex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseMutex", hMutex);
            }
            return (int)mh$.invokeExact(hMutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForSingleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForSingleObject$descriptor() {
        return WaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForSingleObject$handle() {
        return WaitForSingleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForSingleObject$address() {
        return WaitForSingleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForSingleObject(MemorySegment hHandle, int dwMilliseconds) {
        var mh$ = WaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObject", hHandle, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SleepEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SleepEx$descriptor() {
        return SleepEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SleepEx$handle() {
        return SleepEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment SleepEx$address() {
        return SleepEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SleepEx(int dwMilliseconds, int bAlertable) {
        var mh$ = SleepEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepEx", dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForSingleObjectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForSingleObjectEx$descriptor() {
        return WaitForSingleObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForSingleObjectEx$handle() {
        return WaitForSingleObjectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment WaitForSingleObjectEx$address() {
        return WaitForSingleObjectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForSingleObjectEx(MemorySegment hHandle, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForSingleObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObjectEx", hHandle, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjectsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForMultipleObjectsEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjectsEx$descriptor() {
        return WaitForMultipleObjectsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForMultipleObjectsEx$handle() {
        return WaitForMultipleObjectsEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment WaitForMultipleObjectsEx$address() {
        return WaitForMultipleObjectsEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForMultipleObjectsEx(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForMultipleObjectsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjectsEx", nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMutexA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexA$descriptor() {
        return CreateMutexA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexA$handle() {
        return CreateMutexA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexA$address() {
        return CreateMutexA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexA(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexA", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMutexW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexW$descriptor() {
        return CreateMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexW$handle() {
        return CreateMutexW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexW$address() {
        return CreateMutexW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexW(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexW", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenMutexW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenMutexW$descriptor() {
        return OpenMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenMutexW$handle() {
        return OpenMutexW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexW$address() {
        return OpenMutexW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenMutexW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventA$descriptor() {
        return CreateEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateEventA$handle() {
        return CreateEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA$address() {
        return CreateEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventA", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventW$descriptor() {
        return CreateEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateEventW$handle() {
        return CreateEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateEventW$address() {
        return CreateEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateEventW(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventW", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenEventA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventA$descriptor() {
        return OpenEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenEventA$handle() {
        return OpenEventA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenEventA$address() {
        return OpenEventA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenEventA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenEventW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventW$descriptor() {
        return OpenEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenEventW$handle() {
        return OpenEventW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenEventW$address() {
        return OpenEventW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenEventW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenSemaphoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenSemaphoreW$descriptor() {
        return OpenSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenSemaphoreW$handle() {
        return OpenSemaphoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreW$address() {
        return OpenSemaphoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSemaphoreW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenWaitableTimerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor OpenWaitableTimerW$descriptor() {
        return OpenWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle OpenWaitableTimerW$handle() {
        return OpenWaitableTimerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerW$address() {
        return OpenWaitableTimerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpTimerName) {
        var mh$ = OpenWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWaitableTimerW", dwDesiredAccess, bInheritHandle, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWaitableTimerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static FunctionDescriptor SetWaitableTimerEx$descriptor() {
        return SetWaitableTimerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static MethodHandle SetWaitableTimerEx$handle() {
        return SetWaitableTimerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static MemorySegment SetWaitableTimerEx$address() {
        return SetWaitableTimerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static int SetWaitableTimerEx(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, MemorySegment WakeContext, int TolerableDelay) {
        var mh$ = SetWaitableTimerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimerEx", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetWaitableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static FunctionDescriptor SetWaitableTimer$descriptor() {
        return SetWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static MethodHandle SetWaitableTimer$handle() {
        return SetWaitableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static MemorySegment SetWaitableTimer$address() {
        return SetWaitableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static int SetWaitableTimer(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, int fResume) {
        var mh$ = SetWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimer", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelWaitableTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static FunctionDescriptor CancelWaitableTimer$descriptor() {
        return CancelWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static MethodHandle CancelWaitableTimer$handle() {
        return CancelWaitableTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static MemorySegment CancelWaitableTimer$address() {
        return CancelWaitableTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static int CancelWaitableTimer(MemorySegment hTimer) {
        var mh$ = CancelWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelWaitableTimer", hTimer);
            }
            return (int)mh$.invokeExact(hTimer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMutexExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExA$descriptor() {
        return CreateMutexExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExA$handle() {
        return CreateMutexExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExA$address() {
        return CreateMutexExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExA(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExA", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMutexExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExW$descriptor() {
        return CreateMutexExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExW$handle() {
        return CreateMutexExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExW$address() {
        return CreateMutexExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExW(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExW", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEventExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExA$descriptor() {
        return CreateEventExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExA$handle() {
        return CreateEventExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExA$address() {
        return CreateEventExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExA(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExA", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEventExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExW$descriptor() {
        return CreateEventExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExW$handle() {
        return CreateEventExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExW$address() {
        return CreateEventExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExW(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExW", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSemaphoreExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreExW$descriptor() {
        return CreateSemaphoreExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateSemaphoreExW$handle() {
        return CreateSemaphoreExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExW$address() {
        return CreateSemaphoreExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateSemaphoreExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreExW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWaitableTimerExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerExW$descriptor() {
        return CreateWaitableTimerExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateWaitableTimerExW$handle() {
        return CreateWaitableTimerExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExW$address() {
        return CreateWaitableTimerExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExW(MemorySegment lpTimerAttributes, MemorySegment lpTimerName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateWaitableTimerExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerExW", lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout PSYNCHRONIZATION_BARRIER = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout LPSYNCHRONIZATION_BARRIER = freeglut_h.C_POINTER;

    private static class EnterSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnterSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnterSynchronizationBarrier$descriptor() {
        return EnterSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnterSynchronizationBarrier$handle() {
        return EnterSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static MemorySegment EnterSynchronizationBarrier$address() {
        return EnterSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static int EnterSynchronizationBarrier(MemorySegment lpBarrier, int dwFlags) {
        var mh$ = EnterSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterSynchronizationBarrier", lpBarrier, dwFlags);
            }
            return (int)mh$.invokeExact(lpBarrier, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeSynchronizationBarrier$descriptor() {
        return InitializeSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static MethodHandle InitializeSynchronizationBarrier$handle() {
        return InitializeSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static MemorySegment InitializeSynchronizationBarrier$address() {
        return InitializeSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static int InitializeSynchronizationBarrier(MemorySegment lpBarrier, int lTotalThreads, int lSpinCount) {
        var mh$ = InitializeSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSynchronizationBarrier", lpBarrier, lTotalThreads, lSpinCount);
            }
            return (int)mh$.invokeExact(lpBarrier, lTotalThreads, lSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteSynchronizationBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static FunctionDescriptor DeleteSynchronizationBarrier$descriptor() {
        return DeleteSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static MethodHandle DeleteSynchronizationBarrier$handle() {
        return DeleteSynchronizationBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static MemorySegment DeleteSynchronizationBarrier$address() {
        return DeleteSynchronizationBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static int DeleteSynchronizationBarrier(MemorySegment lpBarrier) {
        var mh$ = DeleteSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteSynchronizationBarrier", lpBarrier);
            }
            return (int)mh$.invokeExact(lpBarrier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor Sleep$descriptor() {
        return Sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle Sleep$handle() {
        return Sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment Sleep$address() {
        return Sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static void Sleep(int dwMilliseconds) {
        var mh$ = Sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Sleep", dwMilliseconds);
            }
            mh$.invokeExact(dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitOnAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitOnAddress$descriptor() {
        return WaitOnAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitOnAddress$handle() {
        return WaitOnAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitOnAddress$address() {
        return WaitOnAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static int WaitOnAddress(MemorySegment Address, MemorySegment CompareAddress, long AddressSize, int dwMilliseconds) {
        var mh$ = WaitOnAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnAddress", Address, CompareAddress, AddressSize, dwMilliseconds);
            }
            return (int)mh$.invokeExact(Address, CompareAddress, AddressSize, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressSingle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WakeByAddressSingle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressSingle$descriptor() {
        return WakeByAddressSingle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressSingle$handle() {
        return WakeByAddressSingle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static MemorySegment WakeByAddressSingle$address() {
        return WakeByAddressSingle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static void WakeByAddressSingle(MemorySegment Address) {
        var mh$ = WakeByAddressSingle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressSingle", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WakeByAddressAll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressAll$descriptor() {
        return WakeByAddressAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressAll$handle() {
        return WakeByAddressAll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static MemorySegment WakeByAddressAll$address() {
        return WakeByAddressAll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static void WakeByAddressAll(MemorySegment Address) {
        var mh$ = WakeByAddressAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressAll", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SignalObjectAndWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SignalObjectAndWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SignalObjectAndWait$descriptor() {
        return SignalObjectAndWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SignalObjectAndWait$handle() {
        return SignalObjectAndWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MemorySegment SignalObjectAndWait$address() {
        return SignalObjectAndWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SignalObjectAndWait(MemorySegment hObjectToSignal, MemorySegment hObjectToWaitOn, int dwMilliseconds, int bAlertable) {
        var mh$ = SignalObjectAndWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SignalObjectAndWait", hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForMultipleObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjects$descriptor() {
        return WaitForMultipleObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForMultipleObjects$handle() {
        return WaitForMultipleObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment WaitForMultipleObjects$address() {
        return WaitForMultipleObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForMultipleObjects(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds) {
        var mh$ = WaitForMultipleObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjects", nCount, lpHandles, bWaitAll, dwMilliseconds);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSemaphoreW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreW$descriptor() {
        return CreateSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateSemaphoreW$handle() {
        return CreateSemaphoreW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreW$address() {
        return CreateSemaphoreW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName) {
        var mh$ = CreateSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWaitableTimerW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerW$descriptor() {
        return CreateWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle CreateWaitableTimerW$handle() {
        return CreateWaitableTimerW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerW$address() {
        return CreateWaitableTimerW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerW(MemorySegment lpTimerAttributes, int bManualReset, MemorySegment lpTimerName) {
        var mh$ = CreateWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerW", lpTimerAttributes, bManualReset, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, bManualReset, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSListHead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeSListHead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InitializeSListHead$descriptor() {
        return InitializeSListHead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InitializeSListHead$handle() {
        return InitializeSListHead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InitializeSListHead$address() {
        return InitializeSListHead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static void InitializeSListHead(MemorySegment ListHead) {
        var mh$ = InitializeSListHead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSListHead", ListHead);
            }
            mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPopEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InterlockedPopEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedPopEntrySList$descriptor() {
        return InterlockedPopEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedPopEntrySList$handle() {
        return InterlockedPopEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedPopEntrySList$address() {
        return InterlockedPopEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedPopEntrySList(MemorySegment ListHead) {
        var mh$ = InterlockedPopEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPopEntrySList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InterlockedPushEntrySList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static FunctionDescriptor InterlockedPushEntrySList$descriptor() {
        return InterlockedPushEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MethodHandle InterlockedPushEntrySList$handle() {
        return InterlockedPushEntrySList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment InterlockedPushEntrySList$address() {
        return InterlockedPushEntrySList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment InterlockedPushEntrySList(MemorySegment ListHead, MemorySegment ListEntry) {
        var mh$ = InterlockedPushEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushEntrySList", ListHead, ListEntry);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, ListEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushListSListEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InterlockedPushListSListEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static FunctionDescriptor InterlockedPushListSListEx$descriptor() {
        return InterlockedPushListSListEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MethodHandle InterlockedPushListSListEx$handle() {
        return InterlockedPushListSListEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MemorySegment InterlockedPushListSListEx$address() {
        return InterlockedPushListSListEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MemorySegment InterlockedPushListSListEx(MemorySegment ListHead, MemorySegment List, MemorySegment ListEnd, int Count) {
        var mh$ = InterlockedPushListSListEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushListSListEx", ListHead, List, ListEnd, Count);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, List, ListEnd, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedFlushSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InterlockedFlushSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedFlushSList$descriptor() {
        return InterlockedFlushSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedFlushSList$handle() {
        return InterlockedFlushSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedFlushSList$address() {
        return InterlockedFlushSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedFlushSList(MemorySegment ListHead) {
        var mh$ = InterlockedFlushSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedFlushSList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDepthSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryDepthSList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor QueryDepthSList$descriptor() {
        return QueryDepthSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle QueryDepthSList$handle() {
        return QueryDepthSList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment QueryDepthSList$address() {
        return QueryDepthSList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static short QueryDepthSList(MemorySegment ListHead) {
        var mh$ = QueryDepthSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDepthSList", ListHead);
            }
            return (short)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *PPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout PPROCESS_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *LPPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout LPPROCESS_INFORMATION = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOA {
     *     DWORD cb;
     *     LPSTR lpReserved;
     *     LPSTR lpDesktop;
     *     LPSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOA
     * }
     */
    public static final AddressLayout LPSTARTUPINFOA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOW {
     *     DWORD cb;
     *     LPWSTR lpReserved;
     *     LPWSTR lpDesktop;
     *     LPWSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOW
     * }
     */
    public static final AddressLayout LPSTARTUPINFOW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTARTUPINFOA LPSTARTUPINFO
     * }
     */
    public static final AddressLayout LPSTARTUPINFO = freeglut_h.C_POINTER;

    private static class QueueUserAPC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueueUserAPC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor QueueUserAPC$descriptor() {
        return QueueUserAPC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle QueueUserAPC$handle() {
        return QueueUserAPC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static MemorySegment QueueUserAPC$address() {
        return QueueUserAPC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static int QueueUserAPC(MemorySegment pfnAPC, MemorySegment hThread, long dwData) {
        var mh$ = QueueUserAPC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserAPC", pfnAPC, hThread, dwData);
            }
            return (int)mh$.invokeExact(pfnAPC, hThread, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessTimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetProcessTimes$descriptor() {
        return GetProcessTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetProcessTimes$handle() {
        return GetProcessTimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MemorySegment GetProcessTimes$address() {
        return GetProcessTimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static int GetProcessTimes(MemorySegment hProcess, MemorySegment lpCreationTime, MemorySegment lpExitTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetProcessTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessTimes", hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static FunctionDescriptor GetCurrentProcess$descriptor() {
        return GetCurrentProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MethodHandle GetCurrentProcess$handle() {
        return GetCurrentProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MemorySegment GetCurrentProcess$address() {
        return GetCurrentProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MemorySegment GetCurrentProcess() {
        var mh$ = GetCurrentProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static FunctionDescriptor GetCurrentProcessId$descriptor() {
        return GetCurrentProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static MethodHandle GetCurrentProcessId$handle() {
        return GetCurrentProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static MemorySegment GetCurrentProcessId$address() {
        return GetCurrentProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static int GetCurrentProcessId() {
        var mh$ = GetCurrentProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExitProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static FunctionDescriptor ExitProcess$descriptor() {
        return ExitProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static MethodHandle ExitProcess$handle() {
        return ExitProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static MemorySegment ExitProcess$address() {
        return ExitProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static void ExitProcess(int uExitCode) {
        var mh$ = ExitProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitProcess", uExitCode);
            }
            mh$.invokeExact(uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TerminateProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static FunctionDescriptor TerminateProcess$descriptor() {
        return TerminateProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static MethodHandle TerminateProcess$handle() {
        return TerminateProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static MemorySegment TerminateProcess$address() {
        return TerminateProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static int TerminateProcess(MemorySegment hProcess, int uExitCode) {
        var mh$ = TerminateProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcess", hProcess, uExitCode);
            }
            return (int)mh$.invokeExact(hProcess, uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExitCodeProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetExitCodeProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static FunctionDescriptor GetExitCodeProcess$descriptor() {
        return GetExitCodeProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static MethodHandle GetExitCodeProcess$handle() {
        return GetExitCodeProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static MemorySegment GetExitCodeProcess$address() {
        return GetExitCodeProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static int GetExitCodeProcess(MemorySegment hProcess, MemorySegment lpExitCode) {
        var mh$ = GetExitCodeProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExitCodeProcess", hProcess, lpExitCode);
            }
            return (int)mh$.invokeExact(hProcess, lpExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SwitchToThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static FunctionDescriptor SwitchToThread$descriptor() {
        return SwitchToThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static MethodHandle SwitchToThread$handle() {
        return SwitchToThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static MemorySegment SwitchToThread$address() {
        return SwitchToThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static int SwitchToThread() {
        var mh$ = SwitchToThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateThread$descriptor() {
        return CreateThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateThread$handle() {
        return CreateThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateThread$address() {
        return CreateThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateThread(MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpThreadId) {
        var mh$ = CreateThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThread", lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRemoteThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateRemoteThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateRemoteThread$descriptor() {
        return CreateRemoteThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateRemoteThread$handle() {
        return CreateRemoteThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThread$address() {
        return CreateRemoteThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThread(MemorySegment hProcess, MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpThreadId) {
        var mh$ = CreateRemoteThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRemoteThread", hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static FunctionDescriptor GetCurrentThread$descriptor() {
        return GetCurrentThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MethodHandle GetCurrentThread$handle() {
        return GetCurrentThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MemorySegment GetCurrentThread$address() {
        return GetCurrentThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MemorySegment GetCurrentThread() {
        var mh$ = GetCurrentThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThreadId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentThreadId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static FunctionDescriptor GetCurrentThreadId$descriptor() {
        return GetCurrentThreadId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static MethodHandle GetCurrentThreadId$handle() {
        return GetCurrentThreadId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static MemorySegment GetCurrentThreadId$address() {
        return GetCurrentThreadId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static int GetCurrentThreadId() {
        var mh$ = GetCurrentThreadId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThreadId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor OpenThread$descriptor() {
        return OpenThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MethodHandle OpenThread$handle() {
        return OpenThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MemorySegment OpenThread$address() {
        return OpenThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MemorySegment OpenThread(int dwDesiredAccess, int bInheritHandle, int dwThreadId) {
        var mh$ = OpenThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenThread", dwDesiredAccess, bInheritHandle, dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static FunctionDescriptor SetThreadPriority$descriptor() {
        return SetThreadPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static MethodHandle SetThreadPriority$handle() {
        return SetThreadPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static MemorySegment SetThreadPriority$address() {
        return SetThreadPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static int SetThreadPriority(MemorySegment hThread, int nPriority) {
        var mh$ = SetThreadPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPriority", hThread, nPriority);
            }
            return (int)mh$.invokeExact(hThread, nPriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor SetThreadPriorityBoost$descriptor() {
        return SetThreadPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static MethodHandle SetThreadPriorityBoost$handle() {
        return SetThreadPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static MemorySegment SetThreadPriorityBoost$address() {
        return SetThreadPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static int SetThreadPriorityBoost(MemorySegment hThread, int bDisablePriorityBoost) {
        var mh$ = SetThreadPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPriorityBoost", hThread, bDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hThread, bDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor GetThreadPriorityBoost$descriptor() {
        return GetThreadPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MethodHandle GetThreadPriorityBoost$handle() {
        return GetThreadPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MemorySegment GetThreadPriorityBoost$address() {
        return GetThreadPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static int GetThreadPriorityBoost(MemorySegment hThread, MemorySegment pDisablePriorityBoost) {
        var mh$ = GetThreadPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPriorityBoost", hThread, pDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hThread, pDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor GetThreadPriority$descriptor() {
        return GetThreadPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static MethodHandle GetThreadPriority$handle() {
        return GetThreadPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static MemorySegment GetThreadPriority$address() {
        return GetThreadPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static int GetThreadPriority(MemorySegment hThread) {
        var mh$ = GetThreadPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPriority", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExitThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor ExitThread$descriptor() {
        return ExitThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static MethodHandle ExitThread$handle() {
        return ExitThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static MemorySegment ExitThread$address() {
        return ExitThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static void ExitThread(int dwExitCode) {
        var mh$ = ExitThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitThread", dwExitCode);
            }
            mh$.invokeExact(dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TerminateThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor TerminateThread$descriptor() {
        return TerminateThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static MethodHandle TerminateThread$handle() {
        return TerminateThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static MemorySegment TerminateThread$address() {
        return TerminateThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static int TerminateThread(MemorySegment hThread, int dwExitCode) {
        var mh$ = TerminateThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateThread", hThread, dwExitCode);
            }
            return (int)mh$.invokeExact(hThread, dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExitCodeThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetExitCodeThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static FunctionDescriptor GetExitCodeThread$descriptor() {
        return GetExitCodeThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static MethodHandle GetExitCodeThread$handle() {
        return GetExitCodeThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static MemorySegment GetExitCodeThread$address() {
        return GetExitCodeThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static int GetExitCodeThread(MemorySegment hThread, MemorySegment lpExitCode) {
        var mh$ = GetExitCodeThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExitCodeThread", hThread, lpExitCode);
            }
            return (int)mh$.invokeExact(hThread, lpExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SuspendThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SuspendThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor SuspendThread$descriptor() {
        return SuspendThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static MethodHandle SuspendThread$handle() {
        return SuspendThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static MemorySegment SuspendThread$address() {
        return SuspendThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static int SuspendThread(MemorySegment hThread) {
        var mh$ = SuspendThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SuspendThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResumeThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor ResumeThread$descriptor() {
        return ResumeThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static MethodHandle ResumeThread$handle() {
        return ResumeThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static MemorySegment ResumeThread$address() {
        return ResumeThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static int ResumeThread(MemorySegment hThread) {
        var mh$ = ResumeThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TlsAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static FunctionDescriptor TlsAlloc$descriptor() {
        return TlsAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static MethodHandle TlsAlloc$handle() {
        return TlsAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static MemorySegment TlsAlloc$address() {
        return TlsAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static int TlsAlloc() {
        var mh$ = TlsAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsAlloc");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TlsGetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static FunctionDescriptor TlsGetValue$descriptor() {
        return TlsGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MethodHandle TlsGetValue$handle() {
        return TlsGetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment TlsGetValue$address() {
        return TlsGetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment TlsGetValue(int dwTlsIndex) {
        var mh$ = TlsGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsGetValue", dwTlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwTlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsSetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TlsSetValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static FunctionDescriptor TlsSetValue$descriptor() {
        return TlsSetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static MethodHandle TlsSetValue$handle() {
        return TlsSetValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static MemorySegment TlsSetValue$address() {
        return TlsSetValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static int TlsSetValue(int dwTlsIndex, MemorySegment lpTlsValue) {
        var mh$ = TlsSetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsSetValue", dwTlsIndex, lpTlsValue);
            }
            return (int)mh$.invokeExact(dwTlsIndex, lpTlsValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TlsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static FunctionDescriptor TlsFree$descriptor() {
        return TlsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static MethodHandle TlsFree$handle() {
        return TlsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment TlsFree$address() {
        return TlsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static int TlsFree(int dwTlsIndex) {
        var mh$ = TlsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsFree", dwTlsIndex);
            }
            return (int)mh$.invokeExact(dwTlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateProcessA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessA$descriptor() {
        return CreateProcessA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessA$handle() {
        return CreateProcessA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessA$address() {
        return CreateProcessA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessA(MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessA", lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateProcessW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessW$descriptor() {
        return CreateProcessW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessW$handle() {
        return CreateProcessW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessW$address() {
        return CreateProcessW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessW(MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessW", lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessShutdownParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessShutdownParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessShutdownParameters$descriptor() {
        return SetProcessShutdownParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessShutdownParameters$handle() {
        return SetProcessShutdownParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetProcessShutdownParameters$address() {
        return SetProcessShutdownParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static int SetProcessShutdownParameters(int dwLevel, int dwFlags) {
        var mh$ = SetProcessShutdownParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessShutdownParameters", dwLevel, dwFlags);
            }
            return (int)mh$.invokeExact(dwLevel, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static FunctionDescriptor GetProcessVersion$descriptor() {
        return GetProcessVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static MethodHandle GetProcessVersion$handle() {
        return GetProcessVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static MemorySegment GetProcessVersion$address() {
        return GetProcessVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static int GetProcessVersion(int ProcessId) {
        var mh$ = GetProcessVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessVersion", ProcessId);
            }
            return (int)mh$.invokeExact(ProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStartupInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStartupInfoW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static FunctionDescriptor GetStartupInfoW$descriptor() {
        return GetStartupInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static MethodHandle GetStartupInfoW$handle() {
        return GetStartupInfoW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static MemorySegment GetStartupInfoW$address() {
        return GetStartupInfoW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static void GetStartupInfoW(MemorySegment lpStartupInfo) {
        var mh$ = GetStartupInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStartupInfoW", lpStartupInfo);
            }
            mh$.invokeExact(lpStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessAsUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateProcessAsUserW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessAsUserW$descriptor() {
        return CreateProcessAsUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessAsUserW$handle() {
        return CreateProcessAsUserW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessAsUserW$address() {
        return CreateProcessAsUserW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessAsUserW(MemorySegment hToken, MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessAsUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessAsUserW", hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetThreadToken$descriptor() {
        return SetThreadToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static MethodHandle SetThreadToken$handle() {
        return SetThreadToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static MemorySegment SetThreadToken$address() {
        return SetThreadToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static int SetThreadToken(MemorySegment Thread, MemorySegment Token) {
        var mh$ = SetThreadToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadToken", Thread, Token);
            }
            return (int)mh$.invokeExact(Thread, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenProcessToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenProcessToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor OpenProcessToken$descriptor() {
        return OpenProcessToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static MethodHandle OpenProcessToken$handle() {
        return OpenProcessToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static MemorySegment OpenProcessToken$address() {
        return OpenProcessToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static int OpenProcessToken(MemorySegment ProcessHandle, int DesiredAccess, MemorySegment TokenHandle) {
        var mh$ = OpenProcessToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenProcessToken", ProcessHandle, DesiredAccess, TokenHandle);
            }
            return (int)mh$.invokeExact(ProcessHandle, DesiredAccess, TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenThreadToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenThreadToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor OpenThreadToken$descriptor() {
        return OpenThreadToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static MethodHandle OpenThreadToken$handle() {
        return OpenThreadToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static MemorySegment OpenThreadToken$address() {
        return OpenThreadToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static int OpenThreadToken(MemorySegment ThreadHandle, int DesiredAccess, int OpenAsSelf, MemorySegment TokenHandle) {
        var mh$ = OpenThreadToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenThreadToken", ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPriorityClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPriorityClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static FunctionDescriptor SetPriorityClass$descriptor() {
        return SetPriorityClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static MethodHandle SetPriorityClass$handle() {
        return SetPriorityClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static MemorySegment SetPriorityClass$address() {
        return SetPriorityClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static int SetPriorityClass(MemorySegment hProcess, int dwPriorityClass) {
        var mh$ = SetPriorityClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPriorityClass", hProcess, dwPriorityClass);
            }
            return (int)mh$.invokeExact(hProcess, dwPriorityClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPriorityClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPriorityClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor GetPriorityClass$descriptor() {
        return GetPriorityClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static MethodHandle GetPriorityClass$handle() {
        return GetPriorityClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static MemorySegment GetPriorityClass$address() {
        return GetPriorityClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static int GetPriorityClass(MemorySegment hProcess) {
        var mh$ = GetPriorityClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPriorityClass", hProcess);
            }
            return (int)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadStackGuarantee {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadStackGuarantee");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static FunctionDescriptor SetThreadStackGuarantee$descriptor() {
        return SetThreadStackGuarantee.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static MethodHandle SetThreadStackGuarantee$handle() {
        return SetThreadStackGuarantee.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static MemorySegment SetThreadStackGuarantee$address() {
        return SetThreadStackGuarantee.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static int SetThreadStackGuarantee(MemorySegment StackSizeInBytes) {
        var mh$ = SetThreadStackGuarantee.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadStackGuarantee", StackSizeInBytes);
            }
            return (int)mh$.invokeExact(StackSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProcessIdToSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ProcessIdToSessionId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static FunctionDescriptor ProcessIdToSessionId$descriptor() {
        return ProcessIdToSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static MethodHandle ProcessIdToSessionId$handle() {
        return ProcessIdToSessionId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static MemorySegment ProcessIdToSessionId$address() {
        return ProcessIdToSessionId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static int ProcessIdToSessionId(int dwProcessId, MemorySegment pSessionId) {
        var mh$ = ProcessIdToSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProcessIdToSessionId", dwProcessId, pSessionId);
            }
            return (int)mh$.invokeExact(dwProcessId, pSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST
     * }
     */
    public static final AddressLayout PPROC_THREAD_ATTRIBUTE_LIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROC_THREAD_ATTRIBUTE_LIST *LPPROC_THREAD_ATTRIBUTE_LIST
     * }
     */
    public static final AddressLayout LPPROC_THREAD_ATTRIBUTE_LIST = freeglut_h.C_POINTER;

    private static class GetProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static FunctionDescriptor GetProcessId$descriptor() {
        return GetProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static MethodHandle GetProcessId$handle() {
        return GetProcessId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static MemorySegment GetProcessId$address() {
        return GetProcessId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static int GetProcessId(MemorySegment Process) {
        var mh$ = GetProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessId", Process);
            }
            return (int)mh$.invokeExact(Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static FunctionDescriptor GetThreadId$descriptor() {
        return GetThreadId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static MethodHandle GetThreadId$handle() {
        return GetThreadId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static MemorySegment GetThreadId$address() {
        return GetThreadId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static int GetThreadId(MemorySegment Thread) {
        var mh$ = GetThreadId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadId", Thread);
            }
            return (int)mh$.invokeExact(Thread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushProcessWriteBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlushProcessWriteBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static FunctionDescriptor FlushProcessWriteBuffers$descriptor() {
        return FlushProcessWriteBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static MethodHandle FlushProcessWriteBuffers$handle() {
        return FlushProcessWriteBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static MemorySegment FlushProcessWriteBuffers$address() {
        return FlushProcessWriteBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static void FlushProcessWriteBuffers() {
        var mh$ = FlushProcessWriteBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushProcessWriteBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessIdOfThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessIdOfThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static FunctionDescriptor GetProcessIdOfThread$descriptor() {
        return GetProcessIdOfThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static MethodHandle GetProcessIdOfThread$handle() {
        return GetProcessIdOfThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static MemorySegment GetProcessIdOfThread$address() {
        return GetProcessIdOfThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static int GetProcessIdOfThread(MemorySegment Thread) {
        var mh$ = GetProcessIdOfThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessIdOfThread", Thread);
            }
            return (int)mh$.invokeExact(Thread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeProcThreadAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeProcThreadAttributeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static FunctionDescriptor InitializeProcThreadAttributeList$descriptor() {
        return InitializeProcThreadAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static MethodHandle InitializeProcThreadAttributeList$handle() {
        return InitializeProcThreadAttributeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static MemorySegment InitializeProcThreadAttributeList$address() {
        return InitializeProcThreadAttributeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static int InitializeProcThreadAttributeList(MemorySegment lpAttributeList, int dwAttributeCount, int dwFlags, MemorySegment lpSize) {
        var mh$ = InitializeProcThreadAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeProcThreadAttributeList", lpAttributeList, dwAttributeCount, dwFlags, lpSize);
            }
            return (int)mh$.invokeExact(lpAttributeList, dwAttributeCount, dwFlags, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteProcThreadAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteProcThreadAttributeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static FunctionDescriptor DeleteProcThreadAttributeList$descriptor() {
        return DeleteProcThreadAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static MethodHandle DeleteProcThreadAttributeList$handle() {
        return DeleteProcThreadAttributeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static MemorySegment DeleteProcThreadAttributeList$address() {
        return DeleteProcThreadAttributeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static void DeleteProcThreadAttributeList(MemorySegment lpAttributeList) {
        var mh$ = DeleteProcThreadAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteProcThreadAttributeList", lpAttributeList);
            }
            mh$.invokeExact(lpAttributeList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateProcThreadAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateProcThreadAttribute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static FunctionDescriptor UpdateProcThreadAttribute$descriptor() {
        return UpdateProcThreadAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static MethodHandle UpdateProcThreadAttribute$handle() {
        return UpdateProcThreadAttribute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static MemorySegment UpdateProcThreadAttribute$address() {
        return UpdateProcThreadAttribute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static int UpdateProcThreadAttribute(MemorySegment lpAttributeList, int dwFlags, long Attribute, MemorySegment lpValue, long cbSize, MemorySegment lpPreviousValue, MemorySegment lpReturnSize) {
        var mh$ = UpdateProcThreadAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateProcThreadAttribute", lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize);
            }
            return (int)mh$.invokeExact(lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDynamicEHContinuationTargets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessDynamicEHContinuationTargets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static FunctionDescriptor SetProcessDynamicEHContinuationTargets$descriptor() {
        return SetProcessDynamicEHContinuationTargets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static MethodHandle SetProcessDynamicEHContinuationTargets$handle() {
        return SetProcessDynamicEHContinuationTargets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static MemorySegment SetProcessDynamicEHContinuationTargets$address() {
        return SetProcessDynamicEHContinuationTargets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static int SetProcessDynamicEHContinuationTargets(MemorySegment Process, short NumberOfTargets, MemorySegment Targets) {
        var mh$ = SetProcessDynamicEHContinuationTargets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDynamicEHContinuationTargets", Process, NumberOfTargets, Targets);
            }
            return (int)mh$.invokeExact(Process, NumberOfTargets, Targets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDynamicEnforcedCetCompatibleRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessDynamicEnforcedCetCompatibleRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static FunctionDescriptor SetProcessDynamicEnforcedCetCompatibleRanges$descriptor() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static MethodHandle SetProcessDynamicEnforcedCetCompatibleRanges$handle() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static MemorySegment SetProcessDynamicEnforcedCetCompatibleRanges$address() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static int SetProcessDynamicEnforcedCetCompatibleRanges(MemorySegment Process, short NumberOfRanges, MemorySegment Ranges) {
        var mh$ = SetProcessDynamicEnforcedCetCompatibleRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDynamicEnforcedCetCompatibleRanges", Process, NumberOfRanges, Ranges);
            }
            return (int)mh$.invokeExact(Process, NumberOfRanges, Ranges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessAffinityUpdateMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessAffinityUpdateMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessAffinityUpdateMode$descriptor() {
        return SetProcessAffinityUpdateMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessAffinityUpdateMode$handle() {
        return SetProcessAffinityUpdateMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetProcessAffinityUpdateMode$address() {
        return SetProcessAffinityUpdateMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static int SetProcessAffinityUpdateMode(MemorySegment hProcess, int dwFlags) {
        var mh$ = SetProcessAffinityUpdateMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessAffinityUpdateMode", hProcess, dwFlags);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProcessAffinityUpdateMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryProcessAffinityUpdateMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor QueryProcessAffinityUpdateMode$descriptor() {
        return QueryProcessAffinityUpdateMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle QueryProcessAffinityUpdateMode$handle() {
        return QueryProcessAffinityUpdateMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static MemorySegment QueryProcessAffinityUpdateMode$address() {
        return QueryProcessAffinityUpdateMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static int QueryProcessAffinityUpdateMode(MemorySegment hProcess, MemorySegment lpdwFlags) {
        var mh$ = QueryProcessAffinityUpdateMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProcessAffinityUpdateMode", hProcess, lpdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRemoteThreadEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateRemoteThreadEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateRemoteThreadEx$descriptor() {
        return CreateRemoteThreadEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateRemoteThreadEx$handle() {
        return CreateRemoteThreadEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThreadEx$address() {
        return CreateRemoteThreadEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThreadEx(MemorySegment hProcess, MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpAttributeList, MemorySegment lpThreadId) {
        var mh$ = CreateRemoteThreadEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRemoteThreadEx", hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpAttributeList, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpAttributeList, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThreadStackLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentThreadStackLimits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static FunctionDescriptor GetCurrentThreadStackLimits$descriptor() {
        return GetCurrentThreadStackLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static MethodHandle GetCurrentThreadStackLimits$handle() {
        return GetCurrentThreadStackLimits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static MemorySegment GetCurrentThreadStackLimits$address() {
        return GetCurrentThreadStackLimits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static void GetCurrentThreadStackLimits(MemorySegment LowLimit, MemorySegment HighLimit) {
        var mh$ = GetCurrentThreadStackLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThreadStackLimits", LowLimit, HighLimit);
            }
            mh$.invokeExact(LowLimit, HighLimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static FunctionDescriptor GetThreadContext$descriptor() {
        return GetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static MethodHandle GetThreadContext$handle() {
        return GetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static MemorySegment GetThreadContext$address() {
        return GetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static int GetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = GetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessMitigationPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessMitigationPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor GetProcessMitigationPolicy$descriptor() {
        return GetProcessMitigationPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle GetProcessMitigationPolicy$handle() {
        return GetProcessMitigationPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment GetProcessMitigationPolicy$address() {
        return GetProcessMitigationPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static int GetProcessMitigationPolicy(MemorySegment hProcess, int MitigationPolicy, MemorySegment lpBuffer, long dwLength) {
        var mh$ = GetProcessMitigationPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessMitigationPolicy", hProcess, MitigationPolicy, lpBuffer, dwLength);
            }
            return (int)mh$.invokeExact(hProcess, MitigationPolicy, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static FunctionDescriptor SetThreadContext$descriptor() {
        return SetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static MethodHandle SetThreadContext$handle() {
        return SetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static MemorySegment SetThreadContext$address() {
        return SetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static int SetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = SetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessMitigationPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessMitigationPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor SetProcessMitigationPolicy$descriptor() {
        return SetProcessMitigationPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle SetProcessMitigationPolicy$handle() {
        return SetProcessMitigationPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment SetProcessMitigationPolicy$address() {
        return SetProcessMitigationPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static int SetProcessMitigationPolicy(int MitigationPolicy, MemorySegment lpBuffer, long dwLength) {
        var mh$ = SetProcessMitigationPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessMitigationPolicy", MitigationPolicy, lpBuffer, dwLength);
            }
            return (int)mh$.invokeExact(MitigationPolicy, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushInstructionCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlushInstructionCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor FlushInstructionCache$descriptor() {
        return FlushInstructionCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle FlushInstructionCache$handle() {
        return FlushInstructionCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static MemorySegment FlushInstructionCache$address() {
        return FlushInstructionCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static int FlushInstructionCache(MemorySegment hProcess, MemorySegment lpBaseAddress, long dwSize) {
        var mh$ = FlushInstructionCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushInstructionCache", hProcess, lpBaseAddress, dwSize);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadTimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetThreadTimes$descriptor() {
        return GetThreadTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetThreadTimes$handle() {
        return GetThreadTimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MemorySegment GetThreadTimes$address() {
        return GetThreadTimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static int GetThreadTimes(MemorySegment hThread, MemorySegment lpCreationTime, MemorySegment lpExitTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetThreadTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadTimes", hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor OpenProcess$descriptor() {
        return OpenProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MethodHandle OpenProcess$handle() {
        return OpenProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MemorySegment OpenProcess$address() {
        return OpenProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MemorySegment OpenProcess(int dwDesiredAccess, int bInheritHandle, int dwProcessId) {
        var mh$ = OpenProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenProcess", dwDesiredAccess, bInheritHandle, dwProcessId);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessorFeaturePresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsProcessorFeaturePresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static FunctionDescriptor IsProcessorFeaturePresent$descriptor() {
        return IsProcessorFeaturePresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static MethodHandle IsProcessorFeaturePresent$handle() {
        return IsProcessorFeaturePresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static MemorySegment IsProcessorFeaturePresent$address() {
        return IsProcessorFeaturePresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static int IsProcessorFeaturePresent(int ProcessorFeature) {
        var mh$ = IsProcessorFeaturePresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessorFeaturePresent", ProcessorFeature);
            }
            return (int)mh$.invokeExact(ProcessorFeature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHandleCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessHandleCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static FunctionDescriptor GetProcessHandleCount$descriptor() {
        return GetProcessHandleCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static MethodHandle GetProcessHandleCount$handle() {
        return GetProcessHandleCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static MemorySegment GetProcessHandleCount$address() {
        return GetProcessHandleCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static int GetProcessHandleCount(MemorySegment hProcess, MemorySegment pdwHandleCount) {
        var mh$ = GetProcessHandleCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHandleCount", hProcess, pdwHandleCount);
            }
            return (int)mh$.invokeExact(hProcess, pdwHandleCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessorNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentProcessorNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static FunctionDescriptor GetCurrentProcessorNumber$descriptor() {
        return GetCurrentProcessorNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static MethodHandle GetCurrentProcessorNumber$handle() {
        return GetCurrentProcessorNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static MemorySegment GetCurrentProcessorNumber$address() {
        return GetCurrentProcessorNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static int GetCurrentProcessorNumber() {
        var mh$ = GetCurrentProcessorNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessorNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadIdealProcessorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadIdealProcessorEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static FunctionDescriptor SetThreadIdealProcessorEx$descriptor() {
        return SetThreadIdealProcessorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static MethodHandle SetThreadIdealProcessorEx$handle() {
        return SetThreadIdealProcessorEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static MemorySegment SetThreadIdealProcessorEx$address() {
        return SetThreadIdealProcessorEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static int SetThreadIdealProcessorEx(MemorySegment hThread, MemorySegment lpIdealProcessor, MemorySegment lpPreviousIdealProcessor) {
        var mh$ = SetThreadIdealProcessorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadIdealProcessorEx", hThread, lpIdealProcessor, lpPreviousIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, lpIdealProcessor, lpPreviousIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadIdealProcessorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadIdealProcessorEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static FunctionDescriptor GetThreadIdealProcessorEx$descriptor() {
        return GetThreadIdealProcessorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static MethodHandle GetThreadIdealProcessorEx$handle() {
        return GetThreadIdealProcessorEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static MemorySegment GetThreadIdealProcessorEx$address() {
        return GetThreadIdealProcessorEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static int GetThreadIdealProcessorEx(MemorySegment hThread, MemorySegment lpIdealProcessor) {
        var mh$ = GetThreadIdealProcessorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadIdealProcessorEx", hThread, lpIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, lpIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessorNumberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentProcessorNumberEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static FunctionDescriptor GetCurrentProcessorNumberEx$descriptor() {
        return GetCurrentProcessorNumberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static MethodHandle GetCurrentProcessorNumberEx$handle() {
        return GetCurrentProcessorNumberEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static MemorySegment GetCurrentProcessorNumberEx$address() {
        return GetCurrentProcessorNumberEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static void GetCurrentProcessorNumberEx(MemorySegment ProcNumber) {
        var mh$ = GetCurrentProcessorNumberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessorNumberEx", ProcNumber);
            }
            mh$.invokeExact(ProcNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor GetProcessPriorityBoost$descriptor() {
        return GetProcessPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MethodHandle GetProcessPriorityBoost$handle() {
        return GetProcessPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MemorySegment GetProcessPriorityBoost$address() {
        return GetProcessPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static int GetProcessPriorityBoost(MemorySegment hProcess, MemorySegment pDisablePriorityBoost) {
        var mh$ = GetProcessPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessPriorityBoost", hProcess, pDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hProcess, pDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessPriorityBoost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor SetProcessPriorityBoost$descriptor() {
        return SetProcessPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static MethodHandle SetProcessPriorityBoost$handle() {
        return SetProcessPriorityBoost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static MemorySegment SetProcessPriorityBoost$address() {
        return SetProcessPriorityBoost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static int SetProcessPriorityBoost(MemorySegment hProcess, int bDisablePriorityBoost) {
        var mh$ = SetProcessPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessPriorityBoost", hProcess, bDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hProcess, bDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadIOPendingFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadIOPendingFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static FunctionDescriptor GetThreadIOPendingFlag$descriptor() {
        return GetThreadIOPendingFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static MethodHandle GetThreadIOPendingFlag$handle() {
        return GetThreadIOPendingFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static MemorySegment GetThreadIOPendingFlag$address() {
        return GetThreadIOPendingFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static int GetThreadIOPendingFlag(MemorySegment hThread, MemorySegment lpIOIsPending) {
        var mh$ = GetThreadIOPendingFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadIOPendingFlag", hThread, lpIOIsPending);
            }
            return (int)mh$.invokeExact(hThread, lpIOIsPending);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemTimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimes$descriptor() {
        return GetSystemTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetSystemTimes$handle() {
        return GetSystemTimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static MemorySegment GetSystemTimes$address() {
        return GetSystemTimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static int GetSystemTimes(MemorySegment lpIdleTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetSystemTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimes", lpIdleTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(lpIdleTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ThreadMemoryPriority = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadMemoryPriority = 0
     * }
     */
    public static int ThreadMemoryPriority() {
        return ThreadMemoryPriority;
    }
    private static final int ThreadAbsoluteCpuPriority = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadAbsoluteCpuPriority = 1
     * }
     */
    public static int ThreadAbsoluteCpuPriority() {
        return ThreadAbsoluteCpuPriority;
    }
    private static final int ThreadDynamicCodePolicy = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadDynamicCodePolicy = 2
     * }
     */
    public static int ThreadDynamicCodePolicy() {
        return ThreadDynamicCodePolicy;
    }
    private static final int ThreadPowerThrottling = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadPowerThrottling = 3
     * }
     */
    public static int ThreadPowerThrottling() {
        return ThreadPowerThrottling;
    }
    private static final int ThreadInformationClassMax = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadInformationClassMax = 4
     * }
     */
    public static int ThreadInformationClassMax() {
        return ThreadInformationClassMax;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORY_PRIORITY_INFORMATION {
     *     ULONG MemoryPriority;
     * } *PMEMORY_PRIORITY_INFORMATION
     * }
     */
    public static final AddressLayout PMEMORY_PRIORITY_INFORMATION = freeglut_h.C_POINTER;

    private static class GetThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static FunctionDescriptor GetThreadInformation$descriptor() {
        return GetThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MethodHandle GetThreadInformation$handle() {
        return GetThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MemorySegment GetThreadInformation$address() {
        return GetThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static int GetThreadInformation(MemorySegment hThread, int ThreadInformationClass, MemorySegment ThreadInformation, int ThreadInformationSize) {
        var mh$ = GetThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadInformation", hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
            }
            return (int)mh$.invokeExact(hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static FunctionDescriptor SetThreadInformation$descriptor() {
        return SetThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MethodHandle SetThreadInformation$handle() {
        return SetThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MemorySegment SetThreadInformation$address() {
        return SetThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static int SetThreadInformation(MemorySegment hThread, int ThreadInformationClass, MemorySegment ThreadInformation, int ThreadInformationSize) {
        var mh$ = SetThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadInformation", hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
            }
            return (int)mh$.invokeExact(hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessCritical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsProcessCritical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static FunctionDescriptor IsProcessCritical$descriptor() {
        return IsProcessCritical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static MethodHandle IsProcessCritical$handle() {
        return IsProcessCritical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static MemorySegment IsProcessCritical$address() {
        return IsProcessCritical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static int IsProcessCritical(MemorySegment hProcess, MemorySegment Critical) {
        var mh$ = IsProcessCritical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessCritical", hProcess, Critical);
            }
            return (int)mh$.invokeExact(hProcess, Critical);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProtectedPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProtectedPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static FunctionDescriptor SetProtectedPolicy$descriptor() {
        return SetProtectedPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static MethodHandle SetProtectedPolicy$handle() {
        return SetProtectedPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static MemorySegment SetProtectedPolicy$address() {
        return SetProtectedPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static int SetProtectedPolicy(MemorySegment PolicyGuid, long PolicyValue, MemorySegment OldPolicyValue) {
        var mh$ = SetProtectedPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProtectedPolicy", PolicyGuid, PolicyValue, OldPolicyValue);
            }
            return (int)mh$.invokeExact(PolicyGuid, PolicyValue, OldPolicyValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProtectedPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryProtectedPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static FunctionDescriptor QueryProtectedPolicy$descriptor() {
        return QueryProtectedPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static MethodHandle QueryProtectedPolicy$handle() {
        return QueryProtectedPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static MemorySegment QueryProtectedPolicy$address() {
        return QueryProtectedPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static int QueryProtectedPolicy(MemorySegment PolicyGuid, MemorySegment PolicyValue) {
        var mh$ = QueryProtectedPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProtectedPolicy", PolicyGuid, PolicyValue);
            }
            return (int)mh$.invokeExact(PolicyGuid, PolicyValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadIdealProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadIdealProcessor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static FunctionDescriptor SetThreadIdealProcessor$descriptor() {
        return SetThreadIdealProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static MethodHandle SetThreadIdealProcessor$handle() {
        return SetThreadIdealProcessor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static MemorySegment SetThreadIdealProcessor$address() {
        return SetThreadIdealProcessor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static int SetThreadIdealProcessor(MemorySegment hThread, int dwIdealProcessor) {
        var mh$ = SetThreadIdealProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadIdealProcessor", hThread, dwIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, dwIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ProcessMemoryPriority = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessMemoryPriority = 0
     * }
     */
    public static int ProcessMemoryPriority() {
        return ProcessMemoryPriority;
    }
    private static final int ProcessMemoryExhaustionInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessMemoryExhaustionInfo = 1
     * }
     */
    public static int ProcessMemoryExhaustionInfo() {
        return ProcessMemoryExhaustionInfo;
    }
    private static final int ProcessAppMemoryInfo = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessAppMemoryInfo = 2
     * }
     */
    public static int ProcessAppMemoryInfo() {
        return ProcessAppMemoryInfo;
    }
    private static final int ProcessInPrivateInfo = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessInPrivateInfo = 3
     * }
     */
    public static int ProcessInPrivateInfo() {
        return ProcessInPrivateInfo;
    }
    private static final int ProcessPowerThrottling = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessPowerThrottling = 4
     * }
     */
    public static int ProcessPowerThrottling() {
        return ProcessPowerThrottling;
    }
    private static final int ProcessReservedValue1 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessReservedValue1 = 5
     * }
     */
    public static int ProcessReservedValue1() {
        return ProcessReservedValue1;
    }
    private static final int ProcessTelemetryCoverageInfo = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessTelemetryCoverageInfo = 6
     * }
     */
    public static int ProcessTelemetryCoverageInfo() {
        return ProcessTelemetryCoverageInfo;
    }
    private static final int ProcessProtectionLevelInfo = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessProtectionLevelInfo = 7
     * }
     */
    public static int ProcessProtectionLevelInfo() {
        return ProcessProtectionLevelInfo;
    }
    private static final int ProcessLeapSecondInfo = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo = 8
     * }
     */
    public static int ProcessLeapSecondInfo() {
        return ProcessLeapSecondInfo;
    }
    private static final int ProcessInformationClassMax = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessInformationClassMax = 9
     * }
     */
    public static int ProcessInformationClassMax() {
        return ProcessInformationClassMax;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _APP_MEMORY_INFORMATION {
     *     ULONG64 AvailableCommit;
     *     ULONG64 PrivateCommitUsage;
     *     ULONG64 PeakPrivateCommitUsage;
     *     ULONG64 TotalCommitUsage;
     * } *PAPP_MEMORY_INFORMATION
     * }
     */
    public static final AddressLayout PAPP_MEMORY_INFORMATION = freeglut_h.C_POINTER;
    private static final int PMETypeFailFastOnCommitFailure = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure = 0
     * }
     */
    public static int PMETypeFailFastOnCommitFailure() {
        return PMETypeFailFastOnCommitFailure;
    }
    private static final int PMETypeMax = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeMax = 1
     * }
     */
    public static int PMETypeMax() {
        return PMETypeMax;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
     *     PMETypeFailFastOnCommitFailure,
     *     PMETypeMax
     * } *PPROCESS_MEMORY_EXHAUSTION_TYPE
     * }
     */
    public static final AddressLayout PPROCESS_MEMORY_EXHAUSTION_TYPE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO {
     *     USHORT Version;
     *     USHORT Reserved;
     *     PROCESS_MEMORY_EXHAUSTION_TYPE Type;
     *     ULONG_PTR Value;
     * } *PPROCESS_MEMORY_EXHAUSTION_INFO
     * }
     */
    public static final AddressLayout PPROCESS_MEMORY_EXHAUSTION_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_POWER_THROTTLING_STATE {
     *     ULONG Version;
     *     ULONG ControlMask;
     *     ULONG StateMask;
     * } *PPROCESS_POWER_THROTTLING_STATE
     * }
     */
    public static final AddressLayout PPROCESS_POWER_THROTTLING_STATE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_LEAP_SECOND_INFO {
     *     ULONG Flags;
     *     ULONG Reserved;
     * } *PPROCESS_LEAP_SECOND_INFO
     * }
     */
    public static final AddressLayout PPROCESS_LEAP_SECOND_INFO = freeglut_h.C_POINTER;

    private static class SetProcessInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static FunctionDescriptor SetProcessInformation$descriptor() {
        return SetProcessInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MethodHandle SetProcessInformation$handle() {
        return SetProcessInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MemorySegment SetProcessInformation$address() {
        return SetProcessInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static int SetProcessInformation(MemorySegment hProcess, int ProcessInformationClass, MemorySegment ProcessInformation, int ProcessInformationSize) {
        var mh$ = SetProcessInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessInformation", hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
            }
            return (int)mh$.invokeExact(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static FunctionDescriptor GetProcessInformation$descriptor() {
        return GetProcessInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MethodHandle GetProcessInformation$handle() {
        return GetProcessInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MemorySegment GetProcessInformation$address() {
        return GetProcessInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static int GetProcessInformation(MemorySegment hProcess, int ProcessInformationClass, MemorySegment ProcessInformation, int ProcessInformationSize) {
        var mh$ = GetProcessInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessInformation", hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
            }
            return (int)mh$.invokeExact(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemCpuSetInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemCpuSetInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static FunctionDescriptor GetSystemCpuSetInformation$descriptor() {
        return GetSystemCpuSetInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static MethodHandle GetSystemCpuSetInformation$handle() {
        return GetSystemCpuSetInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static MemorySegment GetSystemCpuSetInformation$address() {
        return GetSystemCpuSetInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static int GetSystemCpuSetInformation(MemorySegment Information, int BufferLength, MemorySegment ReturnedLength, MemorySegment Process, int Flags) {
        var mh$ = GetSystemCpuSetInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemCpuSetInformation", Information, BufferLength, ReturnedLength, Process, Flags);
            }
            return (int)mh$.invokeExact(Information, BufferLength, ReturnedLength, Process, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDefaultCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessDefaultCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static FunctionDescriptor GetProcessDefaultCpuSets$descriptor() {
        return GetProcessDefaultCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MethodHandle GetProcessDefaultCpuSets$handle() {
        return GetProcessDefaultCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MemorySegment GetProcessDefaultCpuSets$address() {
        return GetProcessDefaultCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static int GetProcessDefaultCpuSets(MemorySegment Process, MemorySegment CpuSetIds, int CpuSetIdCount, MemorySegment RequiredIdCount) {
        var mh$ = GetProcessDefaultCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDefaultCpuSets", Process, CpuSetIds, CpuSetIdCount, RequiredIdCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetIds, CpuSetIdCount, RequiredIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDefaultCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessDefaultCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static FunctionDescriptor SetProcessDefaultCpuSets$descriptor() {
        return SetProcessDefaultCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MethodHandle SetProcessDefaultCpuSets$handle() {
        return SetProcessDefaultCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MemorySegment SetProcessDefaultCpuSets$address() {
        return SetProcessDefaultCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static int SetProcessDefaultCpuSets(MemorySegment Process, MemorySegment CpuSetIds, int CpuSetIdCount) {
        var mh$ = SetProcessDefaultCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDefaultCpuSets", Process, CpuSetIds, CpuSetIdCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetIds, CpuSetIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadSelectedCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadSelectedCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static FunctionDescriptor GetThreadSelectedCpuSets$descriptor() {
        return GetThreadSelectedCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MethodHandle GetThreadSelectedCpuSets$handle() {
        return GetThreadSelectedCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MemorySegment GetThreadSelectedCpuSets$address() {
        return GetThreadSelectedCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static int GetThreadSelectedCpuSets(MemorySegment Thread, MemorySegment CpuSetIds, int CpuSetIdCount, MemorySegment RequiredIdCount) {
        var mh$ = GetThreadSelectedCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadSelectedCpuSets", Thread, CpuSetIds, CpuSetIdCount, RequiredIdCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetIds, CpuSetIdCount, RequiredIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadSelectedCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadSelectedCpuSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static FunctionDescriptor SetThreadSelectedCpuSets$descriptor() {
        return SetThreadSelectedCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MethodHandle SetThreadSelectedCpuSets$handle() {
        return SetThreadSelectedCpuSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MemorySegment SetThreadSelectedCpuSets$address() {
        return SetThreadSelectedCpuSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static int SetThreadSelectedCpuSets(MemorySegment Thread, MemorySegment CpuSetIds, int CpuSetIdCount) {
        var mh$ = SetThreadSelectedCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadSelectedCpuSets", Thread, CpuSetIds, CpuSetIdCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetIds, CpuSetIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessAsUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateProcessAsUserA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessAsUserA$descriptor() {
        return CreateProcessAsUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessAsUserA$handle() {
        return CreateProcessAsUserA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MemorySegment CreateProcessAsUserA$address() {
        return CreateProcessAsUserA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessAsUserA(MemorySegment hToken, MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessAsUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessAsUserA", hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessShutdownParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessShutdownParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor GetProcessShutdownParameters$descriptor() {
        return GetProcessShutdownParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle GetProcessShutdownParameters$handle() {
        return GetProcessShutdownParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static MemorySegment GetProcessShutdownParameters$address() {
        return GetProcessShutdownParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static int GetProcessShutdownParameters(MemorySegment lpdwLevel, MemorySegment lpdwFlags) {
        var mh$ = GetProcessShutdownParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessShutdownParameters", lpdwLevel, lpdwFlags);
            }
            return (int)mh$.invokeExact(lpdwLevel, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static FunctionDescriptor SetThreadDescription$descriptor() {
        return SetThreadDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static MethodHandle SetThreadDescription$handle() {
        return SetThreadDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static MemorySegment SetThreadDescription$address() {
        return SetThreadDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static int SetThreadDescription(MemorySegment hThread, MemorySegment lpThreadDescription) {
        var mh$ = SetThreadDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDescription", hThread, lpThreadDescription);
            }
            return (int)mh$.invokeExact(hThread, lpThreadDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static FunctionDescriptor GetThreadDescription$descriptor() {
        return GetThreadDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static MethodHandle GetThreadDescription$handle() {
        return GetThreadDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static MemorySegment GetThreadDescription$address() {
        return GetThreadDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static int GetThreadDescription(MemorySegment hThread, MemorySegment ppszThreadDescription) {
        var mh$ = GetThreadDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDescription", hThread, ppszThreadDescription);
            }
            return (int)mh$.invokeExact(hThread, ppszThreadDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_INFO {
     *     union {
     *         DWORD dwOemId;
     *         struct {
     *             WORD wProcessorArchitecture;
     *             WORD wReserved;
     *         };
     *     };
     *     DWORD dwPageSize;
     *     LPVOID lpMinimumApplicationAddress;
     *     LPVOID lpMaximumApplicationAddress;
     *     DWORD_PTR dwActiveProcessorMask;
     *     DWORD dwNumberOfProcessors;
     *     DWORD dwProcessorType;
     *     DWORD dwAllocationGranularity;
     *     WORD wProcessorLevel;
     *     WORD wProcessorRevision;
     * } *LPSYSTEM_INFO
     * }
     */
    public static final AddressLayout LPSYSTEM_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORYSTATUSEX {
     *     DWORD dwLength;
     *     DWORD dwMemoryLoad;
     *     DWORDLONG ullTotalPhys;
     *     DWORDLONG ullAvailPhys;
     *     DWORDLONG ullTotalPageFile;
     *     DWORDLONG ullAvailPageFile;
     *     DWORDLONG ullTotalVirtual;
     *     DWORDLONG ullAvailVirtual;
     *     DWORDLONG ullAvailExtendedVirtual;
     * } *LPMEMORYSTATUSEX
     * }
     */
    public static final AddressLayout LPMEMORYSTATUSEX = freeglut_h.C_POINTER;

    private static class GlobalMemoryStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalMemoryStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static FunctionDescriptor GlobalMemoryStatusEx$descriptor() {
        return GlobalMemoryStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static MethodHandle GlobalMemoryStatusEx$handle() {
        return GlobalMemoryStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static MemorySegment GlobalMemoryStatusEx$address() {
        return GlobalMemoryStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static int GlobalMemoryStatusEx(MemorySegment lpBuffer) {
        var mh$ = GlobalMemoryStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalMemoryStatusEx", lpBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static FunctionDescriptor GetSystemInfo$descriptor() {
        return GetSystemInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MethodHandle GetSystemInfo$handle() {
        return GetSystemInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MemorySegment GetSystemInfo$address() {
        return GetSystemInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static void GetSystemInfo(MemorySegment lpSystemInfo) {
        var mh$ = GetSystemInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemInfo", lpSystemInfo);
            }
            mh$.invokeExact(lpSystemInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor GetSystemTime$descriptor() {
        return GetSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle GetSystemTime$handle() {
        return GetSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MemorySegment GetSystemTime$address() {
        return GetSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static void GetSystemTime(MemorySegment lpSystemTime) {
        var mh$ = GetSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTime", lpSystemTime);
            }
            mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAsFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemTimeAsFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAsFileTime$descriptor() {
        return GetSystemTimeAsFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MethodHandle GetSystemTimeAsFileTime$handle() {
        return GetSystemTimeAsFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MemorySegment GetSystemTimeAsFileTime$address() {
        return GetSystemTimeAsFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static void GetSystemTimeAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
        var mh$ = GetSystemTimeAsFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAsFileTime", lpSystemTimeAsFileTime);
            }
            mh$.invokeExact(lpSystemTimeAsFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLocalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor GetLocalTime$descriptor() {
        return GetLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle GetLocalTime$handle() {
        return GetLocalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MemorySegment GetLocalTime$address() {
        return GetLocalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static void GetLocalTime(MemorySegment lpSystemTime) {
        var mh$ = GetLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocalTime", lpSystemTime);
            }
            mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsUserCetAvailableInEnvironment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsUserCetAvailableInEnvironment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static FunctionDescriptor IsUserCetAvailableInEnvironment$descriptor() {
        return IsUserCetAvailableInEnvironment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static MethodHandle IsUserCetAvailableInEnvironment$handle() {
        return IsUserCetAvailableInEnvironment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static MemorySegment IsUserCetAvailableInEnvironment$address() {
        return IsUserCetAvailableInEnvironment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static int IsUserCetAvailableInEnvironment(int UserCetEnvironment) {
        var mh$ = IsUserCetAvailableInEnvironment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsUserCetAvailableInEnvironment", UserCetEnvironment);
            }
            return (int)mh$.invokeExact(UserCetEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemLeapSecondInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemLeapSecondInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetSystemLeapSecondInformation$descriptor() {
        return GetSystemLeapSecondInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static MethodHandle GetSystemLeapSecondInformation$handle() {
        return GetSystemLeapSecondInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static MemorySegment GetSystemLeapSecondInformation$address() {
        return GetSystemLeapSecondInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static int GetSystemLeapSecondInformation(MemorySegment Enabled, MemorySegment Flags) {
        var mh$ = GetSystemLeapSecondInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemLeapSecondInformation", Enabled, Flags);
            }
            return (int)mh$.invokeExact(Enabled, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static FunctionDescriptor GetVersion$descriptor() {
        return GetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static MethodHandle GetVersion$handle() {
        return GetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static MemorySegment GetVersion$address() {
        return GetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static int GetVersion() {
        var mh$ = GetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetLocalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static FunctionDescriptor SetLocalTime$descriptor() {
        return SetLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MethodHandle SetLocalTime$handle() {
        return SetLocalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MemorySegment SetLocalTime$address() {
        return SetLocalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static int SetLocalTime(MemorySegment lpSystemTime) {
        var mh$ = SetLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocalTime", lpSystemTime);
            }
            return (int)mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTickCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTickCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static FunctionDescriptor GetTickCount$descriptor() {
        return GetTickCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static MethodHandle GetTickCount$handle() {
        return GetTickCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static MemorySegment GetTickCount$address() {
        return GetTickCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static int GetTickCount() {
        var mh$ = GetTickCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTickCount");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTickCount64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTickCount64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static FunctionDescriptor GetTickCount64$descriptor() {
        return GetTickCount64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static MethodHandle GetTickCount64$handle() {
        return GetTickCount64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static MemorySegment GetTickCount64$address() {
        return GetTickCount64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static long GetTickCount64() {
        var mh$ = GetTickCount64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTickCount64");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemTimeAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAdjustment$descriptor() {
        return GetSystemTimeAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle GetSystemTimeAdjustment$handle() {
        return GetSystemTimeAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment GetSystemTimeAdjustment$address() {
        return GetSystemTimeAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static int GetSystemTimeAdjustment(MemorySegment lpTimeAdjustment, MemorySegment lpTimeIncrement, MemorySegment lpTimeAdjustmentDisabled) {
        var mh$ = GetSystemTimeAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAdjustment", lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAdjustmentPrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemTimeAdjustmentPrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAdjustmentPrecise$descriptor() {
        return GetSystemTimeAdjustmentPrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle GetSystemTimeAdjustmentPrecise$handle() {
        return GetSystemTimeAdjustmentPrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment GetSystemTimeAdjustmentPrecise$address() {
        return GetSystemTimeAdjustmentPrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static int GetSystemTimeAdjustmentPrecise(MemorySegment lpTimeAdjustment, MemorySegment lpTimeIncrement, MemorySegment lpTimeAdjustmentDisabled) {
        var mh$ = GetSystemTimeAdjustmentPrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAdjustmentPrecise", lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemDirectoryA$descriptor() {
        return GetSystemDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemDirectoryA$handle() {
        return GetSystemDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemDirectoryA$address() {
        return GetSystemDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemDirectoryW$descriptor() {
        return GetSystemDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemDirectoryW$handle() {
        return GetSystemDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemDirectoryW$address() {
        return GetSystemDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowsDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetWindowsDirectoryA$descriptor() {
        return GetWindowsDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetWindowsDirectoryA$handle() {
        return GetWindowsDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetWindowsDirectoryA$address() {
        return GetWindowsDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetWindowsDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetWindowsDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowsDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetWindowsDirectoryW$descriptor() {
        return GetWindowsDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetWindowsDirectoryW$handle() {
        return GetWindowsDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetWindowsDirectoryW$address() {
        return GetWindowsDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetWindowsDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetWindowsDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWindowsDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemWindowsDirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWindowsDirectoryA$descriptor() {
        return GetSystemWindowsDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWindowsDirectoryA$handle() {
        return GetSystemWindowsDirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWindowsDirectoryA$address() {
        return GetSystemWindowsDirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWindowsDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWindowsDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWindowsDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWindowsDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemWindowsDirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWindowsDirectoryW$descriptor() {
        return GetSystemWindowsDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWindowsDirectoryW$handle() {
        return GetSystemWindowsDirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWindowsDirectoryW$address() {
        return GetSystemWindowsDirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWindowsDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWindowsDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWindowsDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ComputerNameNetBIOS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameNetBIOS = 0
     * }
     */
    public static int ComputerNameNetBIOS() {
        return ComputerNameNetBIOS;
    }
    private static final int ComputerNameDnsHostname = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsHostname = 1
     * }
     */
    public static int ComputerNameDnsHostname() {
        return ComputerNameDnsHostname;
    }
    private static final int ComputerNameDnsDomain = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsDomain = 2
     * }
     */
    public static int ComputerNameDnsDomain() {
        return ComputerNameDnsDomain;
    }
    private static final int ComputerNameDnsFullyQualified = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsFullyQualified = 3
     * }
     */
    public static int ComputerNameDnsFullyQualified() {
        return ComputerNameDnsFullyQualified;
    }
    private static final int ComputerNamePhysicalNetBIOS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalNetBIOS = 4
     * }
     */
    public static int ComputerNamePhysicalNetBIOS() {
        return ComputerNamePhysicalNetBIOS;
    }
    private static final int ComputerNamePhysicalDnsHostname = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsHostname = 5
     * }
     */
    public static int ComputerNamePhysicalDnsHostname() {
        return ComputerNamePhysicalDnsHostname;
    }
    private static final int ComputerNamePhysicalDnsDomain = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsDomain = 6
     * }
     */
    public static int ComputerNamePhysicalDnsDomain() {
        return ComputerNamePhysicalDnsDomain;
    }
    private static final int ComputerNamePhysicalDnsFullyQualified = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsFullyQualified = 7
     * }
     */
    public static int ComputerNamePhysicalDnsFullyQualified() {
        return ComputerNamePhysicalDnsFullyQualified;
    }
    private static final int ComputerNameMax = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameMax = 8
     * }
     */
    public static int ComputerNameMax() {
        return ComputerNameMax;
    }

    private static class GetComputerNameExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetComputerNameExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameExA$descriptor() {
        return GetComputerNameExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameExA$handle() {
        return GetComputerNameExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameExA$address() {
        return GetComputerNameExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameExA(int NameType, MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameExA", NameType, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetComputerNameExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameExW$descriptor() {
        return GetComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameExW$handle() {
        return GetComputerNameExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MemorySegment GetComputerNameExW$address() {
        return GetComputerNameExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameExW(int NameType, MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameExW", NameType, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetComputerNameExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameExW$descriptor() {
        return SetComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameExW$handle() {
        return SetComputerNameExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static MemorySegment SetComputerNameExW$address() {
        return SetComputerNameExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static int SetComputerNameExW(int NameType, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameExW", NameType, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSystemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static FunctionDescriptor SetSystemTime$descriptor() {
        return SetSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MethodHandle SetSystemTime$handle() {
        return SetSystemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MemorySegment SetSystemTime$address() {
        return SetSystemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static int SetSystemTime(MemorySegment lpSystemTime) {
        var mh$ = SetSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTime", lpSystemTime);
            }
            return (int)mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersionExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVersionExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetVersionExA$descriptor() {
        return GetVersionExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static MethodHandle GetVersionExA$handle() {
        return GetVersionExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static MemorySegment GetVersionExA$address() {
        return GetVersionExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static int GetVersionExA(MemorySegment lpVersionInformation) {
        var mh$ = GetVersionExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersionExA", lpVersionInformation);
            }
            return (int)mh$.invokeExact(lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersionExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetVersionExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetVersionExW$descriptor() {
        return GetVersionExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static MethodHandle GetVersionExW$handle() {
        return GetVersionExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static MemorySegment GetVersionExW$address() {
        return GetVersionExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static int GetVersionExW(MemorySegment lpVersionInformation) {
        var mh$ = GetVersionExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersionExW", lpVersionInformation);
            }
            return (int)mh$.invokeExact(lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalProcessorInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLogicalProcessorInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetLogicalProcessorInformation$descriptor() {
        return GetLogicalProcessorInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetLogicalProcessorInformation$handle() {
        return GetLogicalProcessorInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MemorySegment GetLogicalProcessorInformation$address() {
        return GetLogicalProcessorInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetLogicalProcessorInformation(MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetLogicalProcessorInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalProcessorInformation", Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalProcessorInformationEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLogicalProcessorInformationEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetLogicalProcessorInformationEx$descriptor() {
        return GetLogicalProcessorInformationEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetLogicalProcessorInformationEx$handle() {
        return GetLogicalProcessorInformationEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MemorySegment GetLogicalProcessorInformationEx$address() {
        return GetLogicalProcessorInformationEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetLogicalProcessorInformationEx(int RelationshipType, MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetLogicalProcessorInformationEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalProcessorInformationEx", RelationshipType, Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(RelationshipType, Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNativeSystemInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNativeSystemInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static FunctionDescriptor GetNativeSystemInfo$descriptor() {
        return GetNativeSystemInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MethodHandle GetNativeSystemInfo$handle() {
        return GetNativeSystemInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MemorySegment GetNativeSystemInfo$address() {
        return GetNativeSystemInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static void GetNativeSystemInfo(MemorySegment lpSystemInfo) {
        var mh$ = GetNativeSystemInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNativeSystemInfo", lpSystemInfo);
            }
            mh$.invokeExact(lpSystemInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimePreciseAsFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemTimePreciseAsFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimePreciseAsFileTime$descriptor() {
        return GetSystemTimePreciseAsFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MethodHandle GetSystemTimePreciseAsFileTime$handle() {
        return GetSystemTimePreciseAsFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MemorySegment GetSystemTimePreciseAsFileTime$address() {
        return GetSystemTimePreciseAsFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static void GetSystemTimePreciseAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
        var mh$ = GetSystemTimePreciseAsFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimePreciseAsFileTime", lpSystemTimeAsFileTime);
            }
            mh$.invokeExact(lpSystemTimeAsFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProductInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProductInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static FunctionDescriptor GetProductInfo$descriptor() {
        return GetProductInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static MethodHandle GetProductInfo$handle() {
        return GetProductInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static MemorySegment GetProductInfo$address() {
        return GetProductInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static int GetProductInfo(int dwOSMajorVersion, int dwOSMinorVersion, int dwSpMajorVersion, int dwSpMinorVersion, MemorySegment pdwReturnedProductType) {
        var mh$ = GetProductInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProductInfo", dwOSMajorVersion, dwOSMinorVersion, dwSpMajorVersion, dwSpMinorVersion, pdwReturnedProductType);
            }
            return (int)mh$.invokeExact(dwOSMajorVersion, dwOSMinorVersion, dwSpMajorVersion, dwSpMinorVersion, pdwReturnedProductType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOsSafeBootMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOsSafeBootMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetOsSafeBootMode$descriptor() {
        return GetOsSafeBootMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static MethodHandle GetOsSafeBootMode$handle() {
        return GetOsSafeBootMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static MemorySegment GetOsSafeBootMode$address() {
        return GetOsSafeBootMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static int GetOsSafeBootMode(MemorySegment Flags) {
        var mh$ = GetOsSafeBootMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOsSafeBootMode", Flags);
            }
            return (int)mh$.invokeExact(Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemFirmwareTables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumSystemFirmwareTables");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static FunctionDescriptor EnumSystemFirmwareTables$descriptor() {
        return EnumSystemFirmwareTables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static MethodHandle EnumSystemFirmwareTables$handle() {
        return EnumSystemFirmwareTables.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static MemorySegment EnumSystemFirmwareTables$address() {
        return EnumSystemFirmwareTables.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static int EnumSystemFirmwareTables(int FirmwareTableProviderSignature, MemorySegment pFirmwareTableEnumBuffer, int BufferSize) {
        var mh$ = EnumSystemFirmwareTables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemFirmwareTables", FirmwareTableProviderSignature, pFirmwareTableEnumBuffer, BufferSize);
            }
            return (int)mh$.invokeExact(FirmwareTableProviderSignature, pFirmwareTableEnumBuffer, BufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemFirmwareTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemFirmwareTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static FunctionDescriptor GetSystemFirmwareTable$descriptor() {
        return GetSystemFirmwareTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static MethodHandle GetSystemFirmwareTable$handle() {
        return GetSystemFirmwareTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static MemorySegment GetSystemFirmwareTable$address() {
        return GetSystemFirmwareTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static int GetSystemFirmwareTable(int FirmwareTableProviderSignature, int FirmwareTableID, MemorySegment pFirmwareTableBuffer, int BufferSize) {
        var mh$ = GetSystemFirmwareTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemFirmwareTable", FirmwareTableProviderSignature, FirmwareTableID, pFirmwareTableBuffer, BufferSize);
            }
            return (int)mh$.invokeExact(FirmwareTableProviderSignature, FirmwareTableID, pFirmwareTableBuffer, BufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DnsHostnameToComputerNameExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameExW$descriptor() {
        return DnsHostnameToComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameExW$handle() {
        return DnsHostnameToComputerNameExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MemorySegment DnsHostnameToComputerNameExW$address() {
        return DnsHostnameToComputerNameExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameExW(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameExW", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPhysicallyInstalledSystemMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPhysicallyInstalledSystemMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static FunctionDescriptor GetPhysicallyInstalledSystemMemory$descriptor() {
        return GetPhysicallyInstalledSystemMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static MethodHandle GetPhysicallyInstalledSystemMemory$handle() {
        return GetPhysicallyInstalledSystemMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static MemorySegment GetPhysicallyInstalledSystemMemory$address() {
        return GetPhysicallyInstalledSystemMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static int GetPhysicallyInstalledSystemMemory(MemorySegment TotalMemoryInKilobytes) {
        var mh$ = GetPhysicallyInstalledSystemMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPhysicallyInstalledSystemMemory", TotalMemoryInKilobytes);
            }
            return (int)mh$.invokeExact(TotalMemoryInKilobytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameEx2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetComputerNameEx2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameEx2W$descriptor() {
        return SetComputerNameEx2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameEx2W$handle() {
        return SetComputerNameEx2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static MemorySegment SetComputerNameEx2W$address() {
        return SetComputerNameEx2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static int SetComputerNameEx2W(int NameType, int Flags, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameEx2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameEx2W", NameType, Flags, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, Flags, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTimeAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSystemTimeAdjustment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor SetSystemTimeAdjustment$descriptor() {
        return SetSystemTimeAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle SetSystemTimeAdjustment$handle() {
        return SetSystemTimeAdjustment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment SetSystemTimeAdjustment$address() {
        return SetSystemTimeAdjustment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static int SetSystemTimeAdjustment(int dwTimeAdjustment, int bTimeAdjustmentDisabled) {
        var mh$ = SetSystemTimeAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTimeAdjustment", dwTimeAdjustment, bTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(dwTimeAdjustment, bTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTimeAdjustmentPrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSystemTimeAdjustmentPrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor SetSystemTimeAdjustmentPrecise$descriptor() {
        return SetSystemTimeAdjustmentPrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle SetSystemTimeAdjustmentPrecise$handle() {
        return SetSystemTimeAdjustmentPrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MemorySegment SetSystemTimeAdjustmentPrecise$address() {
        return SetSystemTimeAdjustmentPrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static int SetSystemTimeAdjustmentPrecise(long dwTimeAdjustment, int bTimeAdjustmentDisabled) {
        var mh$ = SetSystemTimeAdjustmentPrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTimeAdjustmentPrecise", dwTimeAdjustment, bTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(dwTimeAdjustment, bTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InstallELAMCertificateInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InstallELAMCertificateInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static FunctionDescriptor InstallELAMCertificateInfo$descriptor() {
        return InstallELAMCertificateInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static MethodHandle InstallELAMCertificateInfo$handle() {
        return InstallELAMCertificateInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static MemorySegment InstallELAMCertificateInfo$address() {
        return InstallELAMCertificateInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static int InstallELAMCertificateInfo(MemorySegment ELAMFile) {
        var mh$ = InstallELAMCertificateInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InstallELAMCertificateInfo", ELAMFile);
            }
            return (int)mh$.invokeExact(ELAMFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessorSystemCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessorSystemCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetProcessorSystemCycleTime$descriptor() {
        return GetProcessorSystemCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetProcessorSystemCycleTime$handle() {
        return GetProcessorSystemCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MemorySegment GetProcessorSystemCycleTime$address() {
        return GetProcessorSystemCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetProcessorSystemCycleTime(short Group, MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetProcessorSystemCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessorSystemCycleTime", Group, Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(Group, Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOsManufacturingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetOsManufacturingMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static FunctionDescriptor GetOsManufacturingMode$descriptor() {
        return GetOsManufacturingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static MethodHandle GetOsManufacturingMode$handle() {
        return GetOsManufacturingMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static MemorySegment GetOsManufacturingMode$address() {
        return GetOsManufacturingMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static int GetOsManufacturingMode(MemorySegment pbEnabled) {
        var mh$ = GetOsManufacturingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOsManufacturingMode", pbEnabled);
            }
            return (int)mh$.invokeExact(pbEnabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIntegratedDisplaySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetIntegratedDisplaySize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static FunctionDescriptor GetIntegratedDisplaySize$descriptor() {
        return GetIntegratedDisplaySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static MethodHandle GetIntegratedDisplaySize$handle() {
        return GetIntegratedDisplaySize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static MemorySegment GetIntegratedDisplaySize$address() {
        return GetIntegratedDisplaySize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static int GetIntegratedDisplaySize(MemorySegment sizeInInches) {
        var mh$ = GetIntegratedDisplaySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIntegratedDisplaySize", sizeInInches);
            }
            return (int)mh$.invokeExact(sizeInInches);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetComputerNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static FunctionDescriptor SetComputerNameA$descriptor() {
        return SetComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static MethodHandle SetComputerNameA$handle() {
        return SetComputerNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static MemorySegment SetComputerNameA$address() {
        return SetComputerNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static int SetComputerNameA(MemorySegment lpComputerName) {
        var mh$ = SetComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameA", lpComputerName);
            }
            return (int)mh$.invokeExact(lpComputerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetComputerNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static FunctionDescriptor SetComputerNameW$descriptor() {
        return SetComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static MethodHandle SetComputerNameW$handle() {
        return SetComputerNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static MemorySegment SetComputerNameW$address() {
        return SetComputerNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static int SetComputerNameW(MemorySegment lpComputerName) {
        var mh$ = SetComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameW", lpComputerName);
            }
            return (int)mh$.invokeExact(lpComputerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetComputerNameExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameExA$descriptor() {
        return SetComputerNameExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameExA$handle() {
        return SetComputerNameExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static MemorySegment SetComputerNameExA$address() {
        return SetComputerNameExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static int SetComputerNameExA(int NameType, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameExA", NameType, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static FunctionDescriptor VirtualAlloc$descriptor() {
        return VirtualAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MethodHandle VirtualAlloc$handle() {
        return VirtualAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAlloc$address() {
        return VirtualAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAlloc(MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect) {
        var mh$ = VirtualAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc", lpAddress, dwSize, flAllocationType, flProtect);
            }
            return (MemorySegment)mh$.invokeExact(lpAddress, dwSize, flAllocationType, flProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualProtect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static FunctionDescriptor VirtualProtect$descriptor() {
        return VirtualProtect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MethodHandle VirtualProtect$handle() {
        return VirtualProtect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MemorySegment VirtualProtect$address() {
        return VirtualProtect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static int VirtualProtect(MemorySegment lpAddress, long dwSize, int flNewProtect, MemorySegment lpflOldProtect) {
        var mh$ = VirtualProtect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtect", lpAddress, dwSize, flNewProtect, lpflOldProtect);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize, flNewProtect, lpflOldProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static FunctionDescriptor VirtualFree$descriptor() {
        return VirtualFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MethodHandle VirtualFree$handle() {
        return VirtualFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MemorySegment VirtualFree$address() {
        return VirtualFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static int VirtualFree(MemorySegment lpAddress, long dwSize, int dwFreeType) {
        var mh$ = VirtualFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualFree", lpAddress, dwSize, dwFreeType);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize, dwFreeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor VirtualQuery$descriptor() {
        return VirtualQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle VirtualQuery$handle() {
        return VirtualQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment VirtualQuery$address() {
        return VirtualQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static long VirtualQuery(MemorySegment lpAddress, MemorySegment lpBuffer, long dwLength) {
        var mh$ = VirtualQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualQuery", lpAddress, lpBuffer, dwLength);
            }
            return (long)mh$.invokeExact(lpAddress, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualAllocEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static FunctionDescriptor VirtualAllocEx$descriptor() {
        return VirtualAllocEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MethodHandle VirtualAllocEx$handle() {
        return VirtualAllocEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAllocEx$address() {
        return VirtualAllocEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAllocEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect) {
        var mh$ = VirtualAllocEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocEx", hProcess, lpAddress, dwSize, flAllocationType, flProtect);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, flAllocationType, flProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualProtectEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static FunctionDescriptor VirtualProtectEx$descriptor() {
        return VirtualProtectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MethodHandle VirtualProtectEx$handle() {
        return VirtualProtectEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MemorySegment VirtualProtectEx$address() {
        return VirtualProtectEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static int VirtualProtectEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flNewProtect, MemorySegment lpflOldProtect) {
        var mh$ = VirtualProtectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtectEx", hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualQueryEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualQueryEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor VirtualQueryEx$descriptor() {
        return VirtualQueryEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle VirtualQueryEx$handle() {
        return VirtualQueryEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MemorySegment VirtualQueryEx$address() {
        return VirtualQueryEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static long VirtualQueryEx(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpBuffer, long dwLength) {
        var mh$ = VirtualQueryEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualQueryEx", hProcess, lpAddress, lpBuffer, dwLength);
            }
            return (long)mh$.invokeExact(hProcess, lpAddress, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadProcessMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadProcessMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static FunctionDescriptor ReadProcessMemory$descriptor() {
        return ReadProcessMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static MethodHandle ReadProcessMemory$handle() {
        return ReadProcessMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static MemorySegment ReadProcessMemory$address() {
        return ReadProcessMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static int ReadProcessMemory(MemorySegment hProcess, MemorySegment lpBaseAddress, MemorySegment lpBuffer, long nSize, MemorySegment lpNumberOfBytesRead) {
        var mh$ = ReadProcessMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadProcessMemory", hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProcessMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteProcessMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static FunctionDescriptor WriteProcessMemory$descriptor() {
        return WriteProcessMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static MethodHandle WriteProcessMemory$handle() {
        return WriteProcessMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static MemorySegment WriteProcessMemory$address() {
        return WriteProcessMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static int WriteProcessMemory(MemorySegment hProcess, MemorySegment lpBaseAddress, MemorySegment lpBuffer, long nSize, MemorySegment lpNumberOfBytesWritten) {
        var mh$ = WriteProcessMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProcessMemory", hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileMappingW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateFileMappingW$descriptor() {
        return CreateFileMappingW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateFileMappingW$handle() {
        return CreateFileMappingW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingW$address() {
        return CreateFileMappingW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingW(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName) {
        var mh$ = CreateFileMappingW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingW", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenFileMappingW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenFileMappingW$descriptor() {
        return OpenFileMappingW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenFileMappingW$handle() {
        return OpenFileMappingW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingW$address() {
        return OpenFileMappingW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenFileMappingW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapViewOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static FunctionDescriptor MapViewOfFile$descriptor() {
        return MapViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MethodHandle MapViewOfFile$handle() {
        return MapViewOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFile$address() {
        return MapViewOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFile(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap) {
        var mh$ = MapViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapViewOfFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static FunctionDescriptor MapViewOfFileEx$descriptor() {
        return MapViewOfFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MethodHandle MapViewOfFileEx$handle() {
        return MapViewOfFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MemorySegment MapViewOfFileEx$address() {
        return MapViewOfFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MemorySegment MapViewOfFileEx(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap, MemorySegment lpBaseAddress) {
        var mh$ = MapViewOfFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileEx", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualFreeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualFreeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static FunctionDescriptor VirtualFreeEx$descriptor() {
        return VirtualFreeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MethodHandle VirtualFreeEx$handle() {
        return VirtualFreeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MemorySegment VirtualFreeEx$address() {
        return VirtualFreeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static int VirtualFreeEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int dwFreeType) {
        var mh$ = VirtualFreeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualFreeEx", hProcess, lpAddress, dwSize, dwFreeType);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, dwSize, dwFreeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FlushViewOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static FunctionDescriptor FlushViewOfFile$descriptor() {
        return FlushViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static MethodHandle FlushViewOfFile$handle() {
        return FlushViewOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static MemorySegment FlushViewOfFile$address() {
        return FlushViewOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static int FlushViewOfFile(MemorySegment lpBaseAddress, long dwNumberOfBytesToFlush) {
        var mh$ = FlushViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushViewOfFile", lpBaseAddress, dwNumberOfBytesToFlush);
            }
            return (int)mh$.invokeExact(lpBaseAddress, dwNumberOfBytesToFlush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnmapViewOfFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFile$descriptor() {
        return UnmapViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static MethodHandle UnmapViewOfFile$handle() {
        return UnmapViewOfFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static MemorySegment UnmapViewOfFile$address() {
        return UnmapViewOfFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static int UnmapViewOfFile(MemorySegment lpBaseAddress) {
        var mh$ = UnmapViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFile", lpBaseAddress);
            }
            return (int)mh$.invokeExact(lpBaseAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLargePageMinimum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLargePageMinimum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static FunctionDescriptor GetLargePageMinimum$descriptor() {
        return GetLargePageMinimum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static MethodHandle GetLargePageMinimum$handle() {
        return GetLargePageMinimum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static MemorySegment GetLargePageMinimum$address() {
        return GetLargePageMinimum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static long GetLargePageMinimum() {
        var mh$ = GetLargePageMinimum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLargePageMinimum");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWorkingSetSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessWorkingSetSizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetProcessWorkingSetSizeEx$descriptor() {
        return GetProcessWorkingSetSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static MethodHandle GetProcessWorkingSetSizeEx$handle() {
        return GetProcessWorkingSetSizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static MemorySegment GetProcessWorkingSetSizeEx$address() {
        return GetProcessWorkingSetSizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static int GetProcessWorkingSetSizeEx(MemorySegment hProcess, MemorySegment lpMinimumWorkingSetSize, MemorySegment lpMaximumWorkingSetSize, MemorySegment Flags) {
        var mh$ = GetProcessWorkingSetSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWorkingSetSizeEx", hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags);
            }
            return (int)mh$.invokeExact(hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWorkingSetSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessWorkingSetSizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetProcessWorkingSetSizeEx$descriptor() {
        return SetProcessWorkingSetSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static MethodHandle SetProcessWorkingSetSizeEx$handle() {
        return SetProcessWorkingSetSizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static MemorySegment SetProcessWorkingSetSizeEx$address() {
        return SetProcessWorkingSetSizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static int SetProcessWorkingSetSizeEx(MemorySegment hProcess, long dwMinimumWorkingSetSize, long dwMaximumWorkingSetSize, int Flags) {
        var mh$ = SetProcessWorkingSetSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWorkingSetSizeEx", hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags);
            }
            return (int)mh$.invokeExact(hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor VirtualLock$descriptor() {
        return VirtualLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle VirtualLock$handle() {
        return VirtualLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MemorySegment VirtualLock$address() {
        return VirtualLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static int VirtualLock(MemorySegment lpAddress, long dwSize) {
        var mh$ = VirtualLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualLock", lpAddress, dwSize);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor VirtualUnlock$descriptor() {
        return VirtualUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle VirtualUnlock$handle() {
        return VirtualUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MemorySegment VirtualUnlock$address() {
        return VirtualUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static int VirtualUnlock(MemorySegment lpAddress, long dwSize) {
        var mh$ = VirtualUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualUnlock", lpAddress, dwSize);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWriteWatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWriteWatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static FunctionDescriptor GetWriteWatch$descriptor() {
        return GetWriteWatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static MethodHandle GetWriteWatch$handle() {
        return GetWriteWatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static MemorySegment GetWriteWatch$address() {
        return GetWriteWatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static int GetWriteWatch(int dwFlags, MemorySegment lpBaseAddress, long dwRegionSize, MemorySegment lpAddresses, MemorySegment lpdwCount, MemorySegment lpdwGranularity) {
        var mh$ = GetWriteWatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWriteWatch", dwFlags, lpBaseAddress, dwRegionSize, lpAddresses, lpdwCount, lpdwGranularity);
            }
            return (int)mh$.invokeExact(dwFlags, lpBaseAddress, dwRegionSize, lpAddresses, lpdwCount, lpdwGranularity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetWriteWatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ResetWriteWatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static FunctionDescriptor ResetWriteWatch$descriptor() {
        return ResetWriteWatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static MethodHandle ResetWriteWatch$handle() {
        return ResetWriteWatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static MemorySegment ResetWriteWatch$address() {
        return ResetWriteWatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static int ResetWriteWatch(MemorySegment lpBaseAddress, long dwRegionSize) {
        var mh$ = ResetWriteWatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetWriteWatch", lpBaseAddress, dwRegionSize);
            }
            return (int)mh$.invokeExact(lpBaseAddress, dwRegionSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int LowMemoryResourceNotification = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _MEMORY_RESOURCE_NOTIFICATION_TYPE.LowMemoryResourceNotification = 0
     * }
     */
    public static int LowMemoryResourceNotification() {
        return LowMemoryResourceNotification;
    }
    private static final int HighMemoryResourceNotification = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _MEMORY_RESOURCE_NOTIFICATION_TYPE.HighMemoryResourceNotification = 1
     * }
     */
    public static int HighMemoryResourceNotification() {
        return HighMemoryResourceNotification;
    }

    private static class CreateMemoryResourceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMemoryResourceNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static FunctionDescriptor CreateMemoryResourceNotification$descriptor() {
        return CreateMemoryResourceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MethodHandle CreateMemoryResourceNotification$handle() {
        return CreateMemoryResourceNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MemorySegment CreateMemoryResourceNotification$address() {
        return CreateMemoryResourceNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MemorySegment CreateMemoryResourceNotification(int NotificationType) {
        var mh$ = CreateMemoryResourceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMemoryResourceNotification", NotificationType);
            }
            return (MemorySegment)mh$.invokeExact(NotificationType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryMemoryResourceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryMemoryResourceNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static FunctionDescriptor QueryMemoryResourceNotification$descriptor() {
        return QueryMemoryResourceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static MethodHandle QueryMemoryResourceNotification$handle() {
        return QueryMemoryResourceNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static MemorySegment QueryMemoryResourceNotification$address() {
        return QueryMemoryResourceNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static int QueryMemoryResourceNotification(MemorySegment ResourceNotificationHandle, MemorySegment ResourceState) {
        var mh$ = QueryMemoryResourceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryMemoryResourceNotification", ResourceNotificationHandle, ResourceState);
            }
            return (int)mh$.invokeExact(ResourceNotificationHandle, ResourceState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemFileCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemFileCacheSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static FunctionDescriptor GetSystemFileCacheSize$descriptor() {
        return GetSystemFileCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static MethodHandle GetSystemFileCacheSize$handle() {
        return GetSystemFileCacheSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static MemorySegment GetSystemFileCacheSize$address() {
        return GetSystemFileCacheSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static int GetSystemFileCacheSize(MemorySegment lpMinimumFileCacheSize, MemorySegment lpMaximumFileCacheSize, MemorySegment lpFlags) {
        var mh$ = GetSystemFileCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemFileCacheSize", lpMinimumFileCacheSize, lpMaximumFileCacheSize, lpFlags);
            }
            return (int)mh$.invokeExact(lpMinimumFileCacheSize, lpMaximumFileCacheSize, lpFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemFileCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSystemFileCacheSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetSystemFileCacheSize$descriptor() {
        return SetSystemFileCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static MethodHandle SetSystemFileCacheSize$handle() {
        return SetSystemFileCacheSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static MemorySegment SetSystemFileCacheSize$address() {
        return SetSystemFileCacheSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static int SetSystemFileCacheSize(long MinimumFileCacheSize, long MaximumFileCacheSize, int Flags) {
        var mh$ = SetSystemFileCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemFileCacheSize", MinimumFileCacheSize, MaximumFileCacheSize, Flags);
            }
            return (int)mh$.invokeExact(MinimumFileCacheSize, MaximumFileCacheSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingNumaW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileMappingNumaW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor CreateFileMappingNumaW$descriptor() {
        return CreateFileMappingNumaW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MethodHandle CreateFileMappingNumaW$handle() {
        return CreateFileMappingNumaW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaW$address() {
        return CreateFileMappingNumaW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaW(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName, int nndPreferred) {
        var mh$ = CreateFileMappingNumaW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingNumaW", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_MEMORY_RANGE_ENTRY {
     *     PVOID VirtualAddress;
     *     SIZE_T NumberOfBytes;
     * } *PWIN32_MEMORY_RANGE_ENTRY
     * }
     */
    public static final AddressLayout PWIN32_MEMORY_RANGE_ENTRY = freeglut_h.C_POINTER;

    private static class PrefetchVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrefetchVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static FunctionDescriptor PrefetchVirtualMemory$descriptor() {
        return PrefetchVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static MethodHandle PrefetchVirtualMemory$handle() {
        return PrefetchVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static MemorySegment PrefetchVirtualMemory$address() {
        return PrefetchVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static int PrefetchVirtualMemory(MemorySegment hProcess, long NumberOfEntries, MemorySegment VirtualAddresses, int Flags) {
        var mh$ = PrefetchVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrefetchVirtualMemory", hProcess, NumberOfEntries, VirtualAddresses, Flags);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfEntries, VirtualAddresses, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileMappingFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static FunctionDescriptor CreateFileMappingFromApp$descriptor() {
        return CreateFileMappingFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MethodHandle CreateFileMappingFromApp$handle() {
        return CreateFileMappingFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MemorySegment CreateFileMappingFromApp$address() {
        return CreateFileMappingFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MemorySegment CreateFileMappingFromApp(MemorySegment hFile, MemorySegment SecurityAttributes, int PageProtection, long MaximumSize, MemorySegment Name) {
        var mh$ = CreateFileMappingFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingFromApp", hFile, SecurityAttributes, PageProtection, MaximumSize, Name);
            }
            return (MemorySegment)mh$.invokeExact(hFile, SecurityAttributes, PageProtection, MaximumSize, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapViewOfFileFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static FunctionDescriptor MapViewOfFileFromApp$descriptor() {
        return MapViewOfFileFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MethodHandle MapViewOfFileFromApp$handle() {
        return MapViewOfFileFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFileFromApp$address() {
        return MapViewOfFileFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFileFromApp(MemorySegment hFileMappingObject, int DesiredAccess, long FileOffset, long NumberOfBytesToMap) {
        var mh$ = MapViewOfFileFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileFromApp", hFileMappingObject, DesiredAccess, FileOffset, NumberOfBytesToMap);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, DesiredAccess, FileOffset, NumberOfBytesToMap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnmapViewOfFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFileEx$descriptor() {
        return UnmapViewOfFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MethodHandle UnmapViewOfFileEx$handle() {
        return UnmapViewOfFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MemorySegment UnmapViewOfFileEx$address() {
        return UnmapViewOfFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static int UnmapViewOfFileEx(MemorySegment BaseAddress, int UnmapFlags) {
        var mh$ = UnmapViewOfFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFileEx", BaseAddress, UnmapFlags);
            }
            return (int)mh$.invokeExact(BaseAddress, UnmapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AllocateUserPhysicalPages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor AllocateUserPhysicalPages$descriptor() {
        return AllocateUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle AllocateUserPhysicalPages$handle() {
        return AllocateUserPhysicalPages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment AllocateUserPhysicalPages$address() {
        return AllocateUserPhysicalPages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int AllocateUserPhysicalPages(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray) {
        var mh$ = AllocateUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateUserPhysicalPages", hProcess, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeUserPhysicalPages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor FreeUserPhysicalPages$descriptor() {
        return FreeUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle FreeUserPhysicalPages$handle() {
        return FreeUserPhysicalPages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment FreeUserPhysicalPages$address() {
        return FreeUserPhysicalPages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int FreeUserPhysicalPages(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray) {
        var mh$ = FreeUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeUserPhysicalPages", hProcess, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapUserPhysicalPages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor MapUserPhysicalPages$descriptor() {
        return MapUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle MapUserPhysicalPages$handle() {
        return MapUserPhysicalPages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MemorySegment MapUserPhysicalPages$address() {
        return MapUserPhysicalPages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int MapUserPhysicalPages(MemorySegment VirtualAddress, long NumberOfPages, MemorySegment PageArray) {
        var mh$ = MapUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapUserPhysicalPages", VirtualAddress, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(VirtualAddress, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateUserPhysicalPagesNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AllocateUserPhysicalPagesNuma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor AllocateUserPhysicalPagesNuma$descriptor() {
        return AllocateUserPhysicalPagesNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static MethodHandle AllocateUserPhysicalPagesNuma$handle() {
        return AllocateUserPhysicalPagesNuma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static MemorySegment AllocateUserPhysicalPagesNuma$address() {
        return AllocateUserPhysicalPagesNuma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static int AllocateUserPhysicalPagesNuma(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray, int nndPreferred) {
        var mh$ = AllocateUserPhysicalPagesNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateUserPhysicalPagesNuma", hProcess, NumberOfPages, PageArray, nndPreferred);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocExNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualAllocExNuma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor VirtualAllocExNuma$descriptor() {
        return VirtualAllocExNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MethodHandle VirtualAllocExNuma$handle() {
        return VirtualAllocExNuma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MemorySegment VirtualAllocExNuma$address() {
        return VirtualAllocExNuma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MemorySegment VirtualAllocExNuma(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect, int nndPreferred) {
        var mh$ = VirtualAllocExNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocExNuma", hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMemoryErrorHandlingCapabilities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMemoryErrorHandlingCapabilities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static FunctionDescriptor GetMemoryErrorHandlingCapabilities$descriptor() {
        return GetMemoryErrorHandlingCapabilities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static MethodHandle GetMemoryErrorHandlingCapabilities$handle() {
        return GetMemoryErrorHandlingCapabilities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static MemorySegment GetMemoryErrorHandlingCapabilities$address() {
        return GetMemoryErrorHandlingCapabilities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static int GetMemoryErrorHandlingCapabilities(MemorySegment Capabilities) {
        var mh$ = GetMemoryErrorHandlingCapabilities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMemoryErrorHandlingCapabilities", Capabilities);
            }
            return (int)mh$.invokeExact(Capabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterBadMemoryNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RegisterBadMemoryNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static FunctionDescriptor RegisterBadMemoryNotification$descriptor() {
        return RegisterBadMemoryNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MethodHandle RegisterBadMemoryNotification$handle() {
        return RegisterBadMemoryNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MemorySegment RegisterBadMemoryNotification$address() {
        return RegisterBadMemoryNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MemorySegment RegisterBadMemoryNotification(MemorySegment Callback) {
        var mh$ = RegisterBadMemoryNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterBadMemoryNotification", Callback);
            }
            return (MemorySegment)mh$.invokeExact(Callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterBadMemoryNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterBadMemoryNotification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static FunctionDescriptor UnregisterBadMemoryNotification$descriptor() {
        return UnregisterBadMemoryNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static MethodHandle UnregisterBadMemoryNotification$handle() {
        return UnregisterBadMemoryNotification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static MemorySegment UnregisterBadMemoryNotification$address() {
        return UnregisterBadMemoryNotification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static int UnregisterBadMemoryNotification(MemorySegment RegistrationHandle) {
        var mh$ = UnregisterBadMemoryNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterBadMemoryNotification", RegistrationHandle);
            }
            return (int)mh$.invokeExact(RegistrationHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VmOfferPriorityVeryLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityVeryLow = 1
     * }
     */
    public static int VmOfferPriorityVeryLow() {
        return VmOfferPriorityVeryLow;
    }
    private static final int VmOfferPriorityLow = (int)2L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityLow = 2
     * }
     */
    public static int VmOfferPriorityLow() {
        return VmOfferPriorityLow;
    }
    private static final int VmOfferPriorityBelowNormal = (int)3L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityBelowNormal = 3
     * }
     */
    public static int VmOfferPriorityBelowNormal() {
        return VmOfferPriorityBelowNormal;
    }
    private static final int VmOfferPriorityNormal = (int)4L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityNormal = 4
     * }
     */
    public static int VmOfferPriorityNormal() {
        return VmOfferPriorityNormal;
    }

    private static class OfferVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OfferVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static FunctionDescriptor OfferVirtualMemory$descriptor() {
        return OfferVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static MethodHandle OfferVirtualMemory$handle() {
        return OfferVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static MemorySegment OfferVirtualMemory$address() {
        return OfferVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static int OfferVirtualMemory(MemorySegment VirtualAddress, long Size, int Priority) {
        var mh$ = OfferVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OfferVirtualMemory", VirtualAddress, Size, Priority);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size, Priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReclaimVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReclaimVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor ReclaimVirtualMemory$descriptor() {
        return ReclaimVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static MethodHandle ReclaimVirtualMemory$handle() {
        return ReclaimVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static MemorySegment ReclaimVirtualMemory$address() {
        return ReclaimVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static int ReclaimVirtualMemory(MemorySegment VirtualAddress, long Size) {
        var mh$ = ReclaimVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReclaimVirtualMemory", VirtualAddress, Size);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DiscardVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DiscardVirtualMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor DiscardVirtualMemory$descriptor() {
        return DiscardVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static MethodHandle DiscardVirtualMemory$handle() {
        return DiscardVirtualMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static MemorySegment DiscardVirtualMemory$address() {
        return DiscardVirtualMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static int DiscardVirtualMemory(MemorySegment VirtualAddress, long Size) {
        var mh$ = DiscardVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DiscardVirtualMemory", VirtualAddress, Size);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessValidCallTargets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessValidCallTargets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static FunctionDescriptor SetProcessValidCallTargets$descriptor() {
        return SetProcessValidCallTargets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static MethodHandle SetProcessValidCallTargets$handle() {
        return SetProcessValidCallTargets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static MemorySegment SetProcessValidCallTargets$address() {
        return SetProcessValidCallTargets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static int SetProcessValidCallTargets(MemorySegment hProcess, MemorySegment VirtualAddress, long RegionSize, int NumberOfOffsets, MemorySegment OffsetInformation) {
        var mh$ = SetProcessValidCallTargets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessValidCallTargets", hProcess, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation);
            }
            return (int)mh$.invokeExact(hProcess, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessValidCallTargetsForMappedView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessValidCallTargetsForMappedView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static FunctionDescriptor SetProcessValidCallTargetsForMappedView$descriptor() {
        return SetProcessValidCallTargetsForMappedView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static MethodHandle SetProcessValidCallTargetsForMappedView$handle() {
        return SetProcessValidCallTargetsForMappedView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static MemorySegment SetProcessValidCallTargetsForMappedView$address() {
        return SetProcessValidCallTargetsForMappedView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static int SetProcessValidCallTargetsForMappedView(MemorySegment Process, MemorySegment VirtualAddress, long RegionSize, int NumberOfOffsets, MemorySegment OffsetInformation, MemorySegment Section, long ExpectedFileOffset) {
        var mh$ = SetProcessValidCallTargetsForMappedView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessValidCallTargetsForMappedView", Process, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation, Section, ExpectedFileOffset);
            }
            return (int)mh$.invokeExact(Process, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation, Section, ExpectedFileOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualAllocFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static FunctionDescriptor VirtualAllocFromApp$descriptor() {
        return VirtualAllocFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MethodHandle VirtualAllocFromApp$handle() {
        return VirtualAllocFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MemorySegment VirtualAllocFromApp$address() {
        return VirtualAllocFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MemorySegment VirtualAllocFromApp(MemorySegment BaseAddress, long Size, int AllocationType, int Protection) {
        var mh$ = VirtualAllocFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocFromApp", BaseAddress, Size, AllocationType, Protection);
            }
            return (MemorySegment)mh$.invokeExact(BaseAddress, Size, AllocationType, Protection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtectFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualProtectFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static FunctionDescriptor VirtualProtectFromApp$descriptor() {
        return VirtualProtectFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static MethodHandle VirtualProtectFromApp$handle() {
        return VirtualProtectFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static MemorySegment VirtualProtectFromApp$address() {
        return VirtualProtectFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static int VirtualProtectFromApp(MemorySegment Address, long Size, int NewProtection, MemorySegment OldProtection) {
        var mh$ = VirtualProtectFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtectFromApp", Address, Size, NewProtection, OldProtection);
            }
            return (int)mh$.invokeExact(Address, Size, NewProtection, OldProtection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenFileMappingFromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static FunctionDescriptor OpenFileMappingFromApp$descriptor() {
        return OpenFileMappingFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MethodHandle OpenFileMappingFromApp$handle() {
        return OpenFileMappingFromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MemorySegment OpenFileMappingFromApp$address() {
        return OpenFileMappingFromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MemorySegment OpenFileMappingFromApp(int DesiredAccess, int InheritHandle, MemorySegment Name) {
        var mh$ = OpenFileMappingFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingFromApp", DesiredAccess, InheritHandle, Name);
            }
            return (MemorySegment)mh$.invokeExact(DesiredAccess, InheritHandle, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MemoryRegionInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WIN32_MEMORY_INFORMATION_CLASS.MemoryRegionInfo = 0
     * }
     */
    public static int MemoryRegionInfo() {
        return MemoryRegionInfo;
    }

    private static class QueryVirtualMemoryInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryVirtualMemoryInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static FunctionDescriptor QueryVirtualMemoryInformation$descriptor() {
        return QueryVirtualMemoryInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static MethodHandle QueryVirtualMemoryInformation$handle() {
        return QueryVirtualMemoryInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static MemorySegment QueryVirtualMemoryInformation$address() {
        return QueryVirtualMemoryInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static int QueryVirtualMemoryInformation(MemorySegment Process, MemorySegment VirtualAddress, int MemoryInformationClass, MemorySegment MemoryInformation, long MemoryInformationSize, MemorySegment ReturnSize) {
        var mh$ = QueryVirtualMemoryInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryVirtualMemoryInformation", Process, VirtualAddress, MemoryInformationClass, MemoryInformation, MemoryInformationSize, ReturnSize);
            }
            return (int)mh$.invokeExact(Process, VirtualAddress, MemoryInformationClass, MemoryInformation, MemoryInformationSize, ReturnSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileNuma2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapViewOfFileNuma2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static FunctionDescriptor MapViewOfFileNuma2$descriptor() {
        return MapViewOfFileNuma2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MethodHandle MapViewOfFileNuma2$handle() {
        return MapViewOfFileNuma2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MemorySegment MapViewOfFileNuma2$address() {
        return MapViewOfFileNuma2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MemorySegment MapViewOfFileNuma2(MemorySegment FileMappingHandle, MemorySegment ProcessHandle, long Offset, MemorySegment BaseAddress, long ViewSize, int AllocationType, int PageProtection, int PreferredNode) {
        var mh$ = MapViewOfFileNuma2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileNuma2", FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType, PageProtection, PreferredNode);
            }
            return (MemorySegment)mh$.invokeExact(FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType, PageProtection, PreferredNode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnmapViewOfFile2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFile2$descriptor() {
        return UnmapViewOfFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MethodHandle UnmapViewOfFile2$handle() {
        return UnmapViewOfFile2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MemorySegment UnmapViewOfFile2$address() {
        return UnmapViewOfFile2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static int UnmapViewOfFile2(MemorySegment Process, MemorySegment BaseAddress, int UnmapFlags) {
        var mh$ = UnmapViewOfFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFile2", Process, BaseAddress, UnmapFlags);
            }
            return (int)mh$.invokeExact(Process, BaseAddress, UnmapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualUnlockEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualUnlockEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor VirtualUnlockEx$descriptor() {
        return VirtualUnlockEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static MethodHandle VirtualUnlockEx$handle() {
        return VirtualUnlockEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static MemorySegment VirtualUnlockEx$address() {
        return VirtualUnlockEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static int VirtualUnlockEx(MemorySegment Process, MemorySegment Address, long Size) {
        var mh$ = VirtualUnlockEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualUnlockEx", Process, Address, Size);
            }
            return (int)mh$.invokeExact(Process, Address, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualAlloc2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor VirtualAlloc2$descriptor() {
        return VirtualAlloc2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle VirtualAlloc2$handle() {
        return VirtualAlloc2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2$address() {
        return VirtualAlloc2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2(MemorySegment Process, MemorySegment BaseAddress, long Size, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = VirtualAlloc2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc2", Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapViewOfFile3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor MapViewOfFile3$descriptor() {
        return MapViewOfFile3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle MapViewOfFile3$handle() {
        return MapViewOfFile3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3$address() {
        return MapViewOfFile3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3(MemorySegment FileMapping, MemorySegment Process, MemorySegment BaseAddress, long Offset, long ViewSize, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = MapViewOfFile3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile3", FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc2FromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("VirtualAlloc2FromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor VirtualAlloc2FromApp$descriptor() {
        return VirtualAlloc2FromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle VirtualAlloc2FromApp$handle() {
        return VirtualAlloc2FromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2FromApp$address() {
        return VirtualAlloc2FromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2FromApp(MemorySegment Process, MemorySegment BaseAddress, long Size, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = VirtualAlloc2FromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc2FromApp", Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile3FromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapViewOfFile3FromApp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor MapViewOfFile3FromApp$descriptor() {
        return MapViewOfFile3FromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle MapViewOfFile3FromApp$handle() {
        return MapViewOfFile3FromApp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3FromApp$address() {
        return MapViewOfFile3FromApp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3FromApp(MemorySegment FileMapping, MemorySegment Process, MemorySegment BaseAddress, long Offset, long ViewSize, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = MapViewOfFile3FromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile3FromApp", FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMapping2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileMapping2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor CreateFileMapping2$descriptor() {
        return CreateFileMapping2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle CreateFileMapping2$handle() {
        return CreateFileMapping2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment CreateFileMapping2$address() {
        return CreateFileMapping2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment CreateFileMapping2(MemorySegment File, MemorySegment SecurityAttributes, int DesiredAccess, int PageProtection, int AllocationAttributes, long MaximumSize, MemorySegment Name, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = CreateFileMapping2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMapping2", File, SecurityAttributes, DesiredAccess, PageProtection, AllocationAttributes, MaximumSize, Name, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(File, SecurityAttributes, DesiredAccess, PageProtection, AllocationAttributes, MaximumSize, Name, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsEnclaveTypeSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsEnclaveTypeSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static FunctionDescriptor IsEnclaveTypeSupported$descriptor() {
        return IsEnclaveTypeSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static MethodHandle IsEnclaveTypeSupported$handle() {
        return IsEnclaveTypeSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static MemorySegment IsEnclaveTypeSupported$address() {
        return IsEnclaveTypeSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static int IsEnclaveTypeSupported(int flEnclaveType) {
        var mh$ = IsEnclaveTypeSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsEnclaveTypeSupported", flEnclaveType);
            }
            return (int)mh$.invokeExact(flEnclaveType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor CreateEnclave$descriptor() {
        return CreateEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle CreateEnclave$handle() {
        return CreateEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment CreateEnclave$address() {
        return CreateEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment CreateEnclave(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, long dwInitialCommitment, int flEnclaveType, MemorySegment lpEnclaveInformation, int dwInfoLength, MemorySegment lpEnclaveError) {
        var mh$ = CreateEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnclave", hProcess, lpAddress, dwSize, dwInitialCommitment, flEnclaveType, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, dwInitialCommitment, flEnclaveType, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadEnclaveData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor LoadEnclaveData$descriptor() {
        return LoadEnclaveData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle LoadEnclaveData$handle() {
        return LoadEnclaveData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment LoadEnclaveData$address() {
        return LoadEnclaveData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static int LoadEnclaveData(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpBuffer, long nSize, int flProtect, MemorySegment lpPageInformation, int dwInfoLength, MemorySegment lpNumberOfBytesWritten, MemorySegment lpEnclaveError) {
        var mh$ = LoadEnclaveData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveData", hProcess, lpAddress, lpBuffer, nSize, flProtect, lpPageInformation, dwInfoLength, lpNumberOfBytesWritten, lpEnclaveError);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, lpBuffer, nSize, flProtect, lpPageInformation, dwInfoLength, lpNumberOfBytesWritten, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor InitializeEnclave$descriptor() {
        return InitializeEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle InitializeEnclave$handle() {
        return InitializeEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment InitializeEnclave$address() {
        return InitializeEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static int InitializeEnclave(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpEnclaveInformation, int dwInfoLength, MemorySegment lpEnclaveError) {
        var mh$ = InitializeEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeEnclave", hProcess, lpAddress, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveImageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadEnclaveImageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static FunctionDescriptor LoadEnclaveImageA$descriptor() {
        return LoadEnclaveImageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static MethodHandle LoadEnclaveImageA$handle() {
        return LoadEnclaveImageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static MemorySegment LoadEnclaveImageA$address() {
        return LoadEnclaveImageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static int LoadEnclaveImageA(MemorySegment lpEnclaveAddress, MemorySegment lpImageName) {
        var mh$ = LoadEnclaveImageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveImageA", lpEnclaveAddress, lpImageName);
            }
            return (int)mh$.invokeExact(lpEnclaveAddress, lpImageName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveImageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadEnclaveImageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static FunctionDescriptor LoadEnclaveImageW$descriptor() {
        return LoadEnclaveImageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static MethodHandle LoadEnclaveImageW$handle() {
        return LoadEnclaveImageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static MemorySegment LoadEnclaveImageW$address() {
        return LoadEnclaveImageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static int LoadEnclaveImageW(MemorySegment lpEnclaveAddress, MemorySegment lpImageName) {
        var mh$ = LoadEnclaveImageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveImageW", lpEnclaveAddress, lpImageName);
            }
            return (int)mh$.invokeExact(lpEnclaveAddress, lpImageName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static FunctionDescriptor CallEnclave$descriptor() {
        return CallEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static MethodHandle CallEnclave$handle() {
        return CallEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static MemorySegment CallEnclave$address() {
        return CallEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static int CallEnclave(MemorySegment lpRoutine, MemorySegment lpParameter, int fWaitForThread, MemorySegment lpReturnValue) {
        var mh$ = CallEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallEnclave", lpRoutine, lpParameter, fWaitForThread, lpReturnValue);
            }
            return (int)mh$.invokeExact(lpRoutine, lpParameter, fWaitForThread, lpReturnValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TerminateEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static FunctionDescriptor TerminateEnclave$descriptor() {
        return TerminateEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static MethodHandle TerminateEnclave$handle() {
        return TerminateEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static MemorySegment TerminateEnclave$address() {
        return TerminateEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static int TerminateEnclave(MemorySegment lpAddress, int fWait) {
        var mh$ = TerminateEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateEnclave", lpAddress, fWait);
            }
            return (int)mh$.invokeExact(lpAddress, fWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteEnclave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static FunctionDescriptor DeleteEnclave$descriptor() {
        return DeleteEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static MethodHandle DeleteEnclave$handle() {
        return DeleteEnclave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static MemorySegment DeleteEnclave$address() {
        return DeleteEnclave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static int DeleteEnclave(MemorySegment lpAddress) {
        var mh$ = DeleteEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteEnclave", lpAddress);
            }
            return (int)mh$.invokeExact(lpAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueueUserWorkItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueueUserWorkItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static FunctionDescriptor QueueUserWorkItem$descriptor() {
        return QueueUserWorkItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static MethodHandle QueueUserWorkItem$handle() {
        return QueueUserWorkItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static MemorySegment QueueUserWorkItem$address() {
        return QueueUserWorkItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static int QueueUserWorkItem(MemorySegment Function, MemorySegment Context, int Flags) {
        var mh$ = QueueUserWorkItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserWorkItem", Function, Context, Flags);
            }
            return (int)mh$.invokeExact(Function, Context, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterWaitEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UnregisterWaitEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor UnregisterWaitEx$descriptor() {
        return UnregisterWaitEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle UnregisterWaitEx$handle() {
        return UnregisterWaitEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static MemorySegment UnregisterWaitEx$address() {
        return UnregisterWaitEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static int UnregisterWaitEx(MemorySegment WaitHandle, MemorySegment CompletionEvent) {
        var mh$ = UnregisterWaitEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterWaitEx", WaitHandle, CompletionEvent);
            }
            return (int)mh$.invokeExact(WaitHandle, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTimerQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateTimerQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static FunctionDescriptor CreateTimerQueue$descriptor() {
        return CreateTimerQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MethodHandle CreateTimerQueue$handle() {
        return CreateTimerQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MemorySegment CreateTimerQueue$address() {
        return CreateTimerQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MemorySegment CreateTimerQueue() {
        var mh$ = CreateTimerQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTimerQueue");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateTimerQueueTimer$descriptor() {
        return CreateTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static MethodHandle CreateTimerQueueTimer$handle() {
        return CreateTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static MemorySegment CreateTimerQueueTimer$address() {
        return CreateTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static int CreateTimerQueueTimer(MemorySegment phNewTimer, MemorySegment TimerQueue, MemorySegment Callback, MemorySegment Parameter, int DueTime, int Period, int Flags) {
        var mh$ = CreateTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTimerQueueTimer", phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
            }
            return (int)mh$.invokeExact(phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ChangeTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static FunctionDescriptor ChangeTimerQueueTimer$descriptor() {
        return ChangeTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static MethodHandle ChangeTimerQueueTimer$handle() {
        return ChangeTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static MemorySegment ChangeTimerQueueTimer$address() {
        return ChangeTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static int ChangeTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer, int DueTime, int Period) {
        var mh$ = ChangeTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeTimerQueueTimer", TimerQueue, Timer, DueTime, Period);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer, DueTime, Period);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteTimerQueueTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueueTimer$descriptor() {
        return DeleteTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle DeleteTimerQueueTimer$handle() {
        return DeleteTimerQueueTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static MemorySegment DeleteTimerQueueTimer$address() {
        return DeleteTimerQueueTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static int DeleteTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer, MemorySegment CompletionEvent) {
        var mh$ = DeleteTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueueTimer", TimerQueue, Timer, CompletionEvent);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueueEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteTimerQueueEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueueEx$descriptor() {
        return DeleteTimerQueueEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle DeleteTimerQueueEx$handle() {
        return DeleteTimerQueueEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static MemorySegment DeleteTimerQueueEx$address() {
        return DeleteTimerQueueEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static int DeleteTimerQueueEx(MemorySegment TimerQueue, MemorySegment CompletionEvent) {
        var mh$ = DeleteTimerQueueEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueueEx", TimerQueue, CompletionEvent);
            }
            return (int)mh$.invokeExact(TimerQueue, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateThreadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static FunctionDescriptor CreateThreadpool$descriptor() {
        return CreateThreadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MethodHandle CreateThreadpool$handle() {
        return CreateThreadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MemorySegment CreateThreadpool$address() {
        return CreateThreadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MemorySegment CreateThreadpool(MemorySegment reserved) {
        var mh$ = CreateThreadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpool", reserved);
            }
            return (MemorySegment)mh$.invokeExact(reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolThreadMaximum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadpoolThreadMaximum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static FunctionDescriptor SetThreadpoolThreadMaximum$descriptor() {
        return SetThreadpoolThreadMaximum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static MethodHandle SetThreadpoolThreadMaximum$handle() {
        return SetThreadpoolThreadMaximum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static MemorySegment SetThreadpoolThreadMaximum$address() {
        return SetThreadpoolThreadMaximum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static void SetThreadpoolThreadMaximum(MemorySegment ptpp, int cthrdMost) {
        var mh$ = SetThreadpoolThreadMaximum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolThreadMaximum", ptpp, cthrdMost);
            }
            mh$.invokeExact(ptpp, cthrdMost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolThreadMinimum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadpoolThreadMinimum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static FunctionDescriptor SetThreadpoolThreadMinimum$descriptor() {
        return SetThreadpoolThreadMinimum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static MethodHandle SetThreadpoolThreadMinimum$handle() {
        return SetThreadpoolThreadMinimum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static MemorySegment SetThreadpoolThreadMinimum$address() {
        return SetThreadpoolThreadMinimum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static int SetThreadpoolThreadMinimum(MemorySegment ptpp, int cthrdMic) {
        var mh$ = SetThreadpoolThreadMinimum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolThreadMinimum", ptpp, cthrdMic);
            }
            return (int)mh$.invokeExact(ptpp, cthrdMic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolStackInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadpoolStackInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static FunctionDescriptor SetThreadpoolStackInformation$descriptor() {
        return SetThreadpoolStackInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MethodHandle SetThreadpoolStackInformation$handle() {
        return SetThreadpoolStackInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MemorySegment SetThreadpoolStackInformation$address() {
        return SetThreadpoolStackInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static int SetThreadpoolStackInformation(MemorySegment ptpp, MemorySegment ptpsi) {
        var mh$ = SetThreadpoolStackInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolStackInformation", ptpp, ptpsi);
            }
            return (int)mh$.invokeExact(ptpp, ptpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadpoolStackInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryThreadpoolStackInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static FunctionDescriptor QueryThreadpoolStackInformation$descriptor() {
        return QueryThreadpoolStackInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MethodHandle QueryThreadpoolStackInformation$handle() {
        return QueryThreadpoolStackInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MemorySegment QueryThreadpoolStackInformation$address() {
        return QueryThreadpoolStackInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static int QueryThreadpoolStackInformation(MemorySegment ptpp, MemorySegment ptpsi) {
        var mh$ = QueryThreadpoolStackInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadpoolStackInformation", ptpp, ptpsi);
            }
            return (int)mh$.invokeExact(ptpp, ptpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseThreadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static FunctionDescriptor CloseThreadpool$descriptor() {
        return CloseThreadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static MethodHandle CloseThreadpool$handle() {
        return CloseThreadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static MemorySegment CloseThreadpool$address() {
        return CloseThreadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static void CloseThreadpool(MemorySegment ptpp) {
        var mh$ = CloseThreadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpool", ptpp);
            }
            mh$.invokeExact(ptpp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolCleanupGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateThreadpoolCleanupGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static FunctionDescriptor CreateThreadpoolCleanupGroup$descriptor() {
        return CreateThreadpoolCleanupGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MethodHandle CreateThreadpoolCleanupGroup$handle() {
        return CreateThreadpoolCleanupGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MemorySegment CreateThreadpoolCleanupGroup$address() {
        return CreateThreadpoolCleanupGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MemorySegment CreateThreadpoolCleanupGroup() {
        var mh$ = CreateThreadpoolCleanupGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolCleanupGroup");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolCleanupGroupMembers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseThreadpoolCleanupGroupMembers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolCleanupGroupMembers$descriptor() {
        return CloseThreadpoolCleanupGroupMembers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static MethodHandle CloseThreadpoolCleanupGroupMembers$handle() {
        return CloseThreadpoolCleanupGroupMembers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static MemorySegment CloseThreadpoolCleanupGroupMembers$address() {
        return CloseThreadpoolCleanupGroupMembers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static void CloseThreadpoolCleanupGroupMembers(MemorySegment ptpcg, int fCancelPendingCallbacks, MemorySegment pvCleanupContext) {
        var mh$ = CloseThreadpoolCleanupGroupMembers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolCleanupGroupMembers", ptpcg, fCancelPendingCallbacks, pvCleanupContext);
            }
            mh$.invokeExact(ptpcg, fCancelPendingCallbacks, pvCleanupContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolCleanupGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseThreadpoolCleanupGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolCleanupGroup$descriptor() {
        return CloseThreadpoolCleanupGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static MethodHandle CloseThreadpoolCleanupGroup$handle() {
        return CloseThreadpoolCleanupGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static MemorySegment CloseThreadpoolCleanupGroup$address() {
        return CloseThreadpoolCleanupGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static void CloseThreadpoolCleanupGroup(MemorySegment ptpcg) {
        var mh$ = CloseThreadpoolCleanupGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolCleanupGroup", ptpcg);
            }
            mh$.invokeExact(ptpcg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEventWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetEventWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static FunctionDescriptor SetEventWhenCallbackReturns$descriptor() {
        return SetEventWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static MethodHandle SetEventWhenCallbackReturns$handle() {
        return SetEventWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static MemorySegment SetEventWhenCallbackReturns$address() {
        return SetEventWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static void SetEventWhenCallbackReturns(MemorySegment pci, MemorySegment evt) {
        var mh$ = SetEventWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEventWhenCallbackReturns", pci, evt);
            }
            mh$.invokeExact(pci, evt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSemaphoreWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseSemaphoreWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static FunctionDescriptor ReleaseSemaphoreWhenCallbackReturns$descriptor() {
        return ReleaseSemaphoreWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static MethodHandle ReleaseSemaphoreWhenCallbackReturns$handle() {
        return ReleaseSemaphoreWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static MemorySegment ReleaseSemaphoreWhenCallbackReturns$address() {
        return ReleaseSemaphoreWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static void ReleaseSemaphoreWhenCallbackReturns(MemorySegment pci, MemorySegment sem, int crel) {
        var mh$ = ReleaseSemaphoreWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSemaphoreWhenCallbackReturns", pci, sem, crel);
            }
            mh$.invokeExact(pci, sem, crel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseMutexWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReleaseMutexWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static FunctionDescriptor ReleaseMutexWhenCallbackReturns$descriptor() {
        return ReleaseMutexWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static MethodHandle ReleaseMutexWhenCallbackReturns$handle() {
        return ReleaseMutexWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static MemorySegment ReleaseMutexWhenCallbackReturns$address() {
        return ReleaseMutexWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static void ReleaseMutexWhenCallbackReturns(MemorySegment pci, MemorySegment mut) {
        var mh$ = ReleaseMutexWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseMutexWhenCallbackReturns", pci, mut);
            }
            mh$.invokeExact(pci, mut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LeaveCriticalSectionWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LeaveCriticalSectionWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static FunctionDescriptor LeaveCriticalSectionWhenCallbackReturns$descriptor() {
        return LeaveCriticalSectionWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static MethodHandle LeaveCriticalSectionWhenCallbackReturns$handle() {
        return LeaveCriticalSectionWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static MemorySegment LeaveCriticalSectionWhenCallbackReturns$address() {
        return LeaveCriticalSectionWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static void LeaveCriticalSectionWhenCallbackReturns(MemorySegment pci, MemorySegment pcs) {
        var mh$ = LeaveCriticalSectionWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LeaveCriticalSectionWhenCallbackReturns", pci, pcs);
            }
            mh$.invokeExact(pci, pcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibraryWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeLibraryWhenCallbackReturns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static FunctionDescriptor FreeLibraryWhenCallbackReturns$descriptor() {
        return FreeLibraryWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static MethodHandle FreeLibraryWhenCallbackReturns$handle() {
        return FreeLibraryWhenCallbackReturns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static MemorySegment FreeLibraryWhenCallbackReturns$address() {
        return FreeLibraryWhenCallbackReturns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static void FreeLibraryWhenCallbackReturns(MemorySegment pci, MemorySegment mod) {
        var mh$ = FreeLibraryWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibraryWhenCallbackReturns", pci, mod);
            }
            mh$.invokeExact(pci, mod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallbackMayRunLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CallbackMayRunLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static FunctionDescriptor CallbackMayRunLong$descriptor() {
        return CallbackMayRunLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MethodHandle CallbackMayRunLong$handle() {
        return CallbackMayRunLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MemorySegment CallbackMayRunLong$address() {
        return CallbackMayRunLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static int CallbackMayRunLong(MemorySegment pci) {
        var mh$ = CallbackMayRunLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallbackMayRunLong", pci);
            }
            return (int)mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisassociateCurrentThreadFromCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DisassociateCurrentThreadFromCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static FunctionDescriptor DisassociateCurrentThreadFromCallback$descriptor() {
        return DisassociateCurrentThreadFromCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MethodHandle DisassociateCurrentThreadFromCallback$handle() {
        return DisassociateCurrentThreadFromCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MemorySegment DisassociateCurrentThreadFromCallback$address() {
        return DisassociateCurrentThreadFromCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static void DisassociateCurrentThreadFromCallback(MemorySegment pci) {
        var mh$ = DisassociateCurrentThreadFromCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisassociateCurrentThreadFromCallback", pci);
            }
            mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TrySubmitThreadpoolCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TrySubmitThreadpoolCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor TrySubmitThreadpoolCallback$descriptor() {
        return TrySubmitThreadpoolCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle TrySubmitThreadpoolCallback$handle() {
        return TrySubmitThreadpoolCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment TrySubmitThreadpoolCallback$address() {
        return TrySubmitThreadpoolCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static int TrySubmitThreadpoolCallback(MemorySegment pfns, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = TrySubmitThreadpoolCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrySubmitThreadpoolCallback", pfns, pv, pcbe);
            }
            return (int)mh$.invokeExact(pfns, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateThreadpoolWork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolWork$descriptor() {
        return CreateThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolWork$handle() {
        return CreateThreadpoolWork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWork$address() {
        return CreateThreadpoolWork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWork(MemorySegment pfnwk, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolWork", pfnwk, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnwk, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SubmitThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SubmitThreadpoolWork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static FunctionDescriptor SubmitThreadpoolWork$descriptor() {
        return SubmitThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MethodHandle SubmitThreadpoolWork$handle() {
        return SubmitThreadpoolWork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MemorySegment SubmitThreadpoolWork$address() {
        return SubmitThreadpoolWork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static void SubmitThreadpoolWork(MemorySegment pwk) {
        var mh$ = SubmitThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubmitThreadpoolWork", pwk);
            }
            mh$.invokeExact(pwk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolWorkCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForThreadpoolWorkCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolWorkCallbacks$descriptor() {
        return WaitForThreadpoolWorkCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolWorkCallbacks$handle() {
        return WaitForThreadpoolWorkCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolWorkCallbacks$address() {
        return WaitForThreadpoolWorkCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolWorkCallbacks(MemorySegment pwk, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolWorkCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolWorkCallbacks", pwk, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pwk, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseThreadpoolWork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolWork$descriptor() {
        return CloseThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MethodHandle CloseThreadpoolWork$handle() {
        return CloseThreadpoolWork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MemorySegment CloseThreadpoolWork$address() {
        return CloseThreadpoolWork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static void CloseThreadpoolWork(MemorySegment pwk) {
        var mh$ = CloseThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolWork", pwk);
            }
            mh$.invokeExact(pwk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateThreadpoolTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolTimer$descriptor() {
        return CreateThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolTimer$handle() {
        return CreateThreadpoolTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolTimer$address() {
        return CreateThreadpoolTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolTimer(MemorySegment pfnti, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolTimer", pfnti, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnti, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadpoolTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static FunctionDescriptor SetThreadpoolTimer$descriptor() {
        return SetThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MethodHandle SetThreadpoolTimer$handle() {
        return SetThreadpoolTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MemorySegment SetThreadpoolTimer$address() {
        return SetThreadpoolTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static void SetThreadpoolTimer(MemorySegment pti, MemorySegment pftDueTime, int msPeriod, int msWindowLength) {
        var mh$ = SetThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolTimer", pti, pftDueTime, msPeriod, msWindowLength);
            }
            mh$.invokeExact(pti, pftDueTime, msPeriod, msWindowLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsThreadpoolTimerSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsThreadpoolTimerSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static FunctionDescriptor IsThreadpoolTimerSet$descriptor() {
        return IsThreadpoolTimerSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static MethodHandle IsThreadpoolTimerSet$handle() {
        return IsThreadpoolTimerSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static MemorySegment IsThreadpoolTimerSet$address() {
        return IsThreadpoolTimerSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static int IsThreadpoolTimerSet(MemorySegment pti) {
        var mh$ = IsThreadpoolTimerSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsThreadpoolTimerSet", pti);
            }
            return (int)mh$.invokeExact(pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolTimerCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForThreadpoolTimerCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolTimerCallbacks$descriptor() {
        return WaitForThreadpoolTimerCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolTimerCallbacks$handle() {
        return WaitForThreadpoolTimerCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolTimerCallbacks$address() {
        return WaitForThreadpoolTimerCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolTimerCallbacks(MemorySegment pti, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolTimerCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolTimerCallbacks", pti, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pti, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseThreadpoolTimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolTimer$descriptor() {
        return CloseThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static MethodHandle CloseThreadpoolTimer$handle() {
        return CloseThreadpoolTimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static MemorySegment CloseThreadpoolTimer$address() {
        return CloseThreadpoolTimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static void CloseThreadpoolTimer(MemorySegment pti) {
        var mh$ = CloseThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolTimer", pti);
            }
            mh$.invokeExact(pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateThreadpoolWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolWait$descriptor() {
        return CreateThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolWait$handle() {
        return CreateThreadpoolWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWait$address() {
        return CreateThreadpoolWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWait(MemorySegment pfnwa, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolWait", pfnwa, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnwa, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadpoolWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static FunctionDescriptor SetThreadpoolWait$descriptor() {
        return SetThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static MethodHandle SetThreadpoolWait$handle() {
        return SetThreadpoolWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static MemorySegment SetThreadpoolWait$address() {
        return SetThreadpoolWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static void SetThreadpoolWait(MemorySegment pwa, MemorySegment h, MemorySegment pftTimeout) {
        var mh$ = SetThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolWait", pwa, h, pftTimeout);
            }
            mh$.invokeExact(pwa, h, pftTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolWaitCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForThreadpoolWaitCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolWaitCallbacks$descriptor() {
        return WaitForThreadpoolWaitCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolWaitCallbacks$handle() {
        return WaitForThreadpoolWaitCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolWaitCallbacks$address() {
        return WaitForThreadpoolWaitCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolWaitCallbacks(MemorySegment pwa, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolWaitCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolWaitCallbacks", pwa, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pwa, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseThreadpoolWait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolWait$descriptor() {
        return CloseThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static MethodHandle CloseThreadpoolWait$handle() {
        return CloseThreadpoolWait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static MemorySegment CloseThreadpoolWait$address() {
        return CloseThreadpoolWait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static void CloseThreadpoolWait(MemorySegment pwa) {
        var mh$ = CloseThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolWait", pwa);
            }
            mh$.invokeExact(pwa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolIo$descriptor() {
        return CreateThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolIo$handle() {
        return CreateThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolIo$address() {
        return CreateThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolIo(MemorySegment fl, MemorySegment pfnio, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolIo", fl, pfnio, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(fl, pfnio, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("StartThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor StartThreadpoolIo$descriptor() {
        return StartThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle StartThreadpoolIo$handle() {
        return StartThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MemorySegment StartThreadpoolIo$address() {
        return StartThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void StartThreadpoolIo(MemorySegment pio) {
        var mh$ = StartThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor CancelThreadpoolIo$descriptor() {
        return CancelThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle CancelThreadpoolIo$handle() {
        return CancelThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MemorySegment CancelThreadpoolIo$address() {
        return CancelThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void CancelThreadpoolIo(MemorySegment pio) {
        var mh$ = CancelThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolIoCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitForThreadpoolIoCallbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolIoCallbacks$descriptor() {
        return WaitForThreadpoolIoCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolIoCallbacks$handle() {
        return WaitForThreadpoolIoCallbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MemorySegment WaitForThreadpoolIoCallbacks$address() {
        return WaitForThreadpoolIoCallbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolIoCallbacks(MemorySegment pio, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolIoCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolIoCallbacks", pio, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pio, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseThreadpoolIo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolIo$descriptor() {
        return CloseThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle CloseThreadpoolIo$handle() {
        return CloseThreadpoolIo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MemorySegment CloseThreadpoolIo$address() {
        return CloseThreadpoolIo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void CloseThreadpoolIo(MemorySegment pio) {
        var mh$ = CloseThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolTimerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadpoolTimerEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static FunctionDescriptor SetThreadpoolTimerEx$descriptor() {
        return SetThreadpoolTimerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MethodHandle SetThreadpoolTimerEx$handle() {
        return SetThreadpoolTimerEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MemorySegment SetThreadpoolTimerEx$address() {
        return SetThreadpoolTimerEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static int SetThreadpoolTimerEx(MemorySegment pti, MemorySegment pftDueTime, int msPeriod, int msWindowLength) {
        var mh$ = SetThreadpoolTimerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolTimerEx", pti, pftDueTime, msPeriod, msWindowLength);
            }
            return (int)mh$.invokeExact(pti, pftDueTime, msPeriod, msWindowLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolWaitEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadpoolWaitEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static FunctionDescriptor SetThreadpoolWaitEx$descriptor() {
        return SetThreadpoolWaitEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static MethodHandle SetThreadpoolWaitEx$handle() {
        return SetThreadpoolWaitEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static MemorySegment SetThreadpoolWaitEx$address() {
        return SetThreadpoolWaitEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static int SetThreadpoolWaitEx(MemorySegment pwa, MemorySegment h, MemorySegment pftTimeout, MemorySegment Reserved) {
        var mh$ = SetThreadpoolWaitEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolWaitEx", pwa, h, pftTimeout, Reserved);
            }
            return (int)mh$.invokeExact(pwa, h, pftTimeout, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessInJob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsProcessInJob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static FunctionDescriptor IsProcessInJob$descriptor() {
        return IsProcessInJob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static MethodHandle IsProcessInJob$handle() {
        return IsProcessInJob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static MemorySegment IsProcessInJob$address() {
        return IsProcessInJob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static int IsProcessInJob(MemorySegment ProcessHandle, MemorySegment JobHandle, MemorySegment Result) {
        var mh$ = IsProcessInJob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessInJob", ProcessHandle, JobHandle, Result);
            }
            return (int)mh$.invokeExact(ProcessHandle, JobHandle, Result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateJobObjectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateJobObjectW$descriptor() {
        return CreateJobObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateJobObjectW$handle() {
        return CreateJobObjectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectW$address() {
        return CreateJobObjectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectW(MemorySegment lpJobAttributes, MemorySegment lpName) {
        var mh$ = CreateJobObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobObjectW", lpJobAttributes, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpJobAttributes, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeMemoryJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeMemoryJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static FunctionDescriptor FreeMemoryJobObject$descriptor() {
        return FreeMemoryJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static MethodHandle FreeMemoryJobObject$handle() {
        return FreeMemoryJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static MemorySegment FreeMemoryJobObject$address() {
        return FreeMemoryJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static void FreeMemoryJobObject(MemorySegment Buffer) {
        var mh$ = FreeMemoryJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeMemoryJobObject", Buffer);
            }
            mh$.invokeExact(Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenJobObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenJobObjectW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenJobObjectW$descriptor() {
        return OpenJobObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenJobObjectW$handle() {
        return OpenJobObjectW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectW$address() {
        return OpenJobObjectW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenJobObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenJobObjectW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AssignProcessToJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AssignProcessToJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor AssignProcessToJobObject$descriptor() {
        return AssignProcessToJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static MethodHandle AssignProcessToJobObject$handle() {
        return AssignProcessToJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static MemorySegment AssignProcessToJobObject$address() {
        return AssignProcessToJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static int AssignProcessToJobObject(MemorySegment hJob, MemorySegment hProcess) {
        var mh$ = AssignProcessToJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AssignProcessToJobObject", hJob, hProcess);
            }
            return (int)mh$.invokeExact(hJob, hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TerminateJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static FunctionDescriptor TerminateJobObject$descriptor() {
        return TerminateJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static MethodHandle TerminateJobObject$handle() {
        return TerminateJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static MemorySegment TerminateJobObject$address() {
        return TerminateJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static int TerminateJobObject(MemorySegment hJob, int uExitCode) {
        var mh$ = TerminateJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateJobObject", hJob, uExitCode);
            }
            return (int)mh$.invokeExact(hJob, uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static FunctionDescriptor SetInformationJobObject$descriptor() {
        return SetInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static MethodHandle SetInformationJobObject$handle() {
        return SetInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static MemorySegment SetInformationJobObject$address() {
        return SetInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static int SetInformationJobObject(MemorySegment hJob, int JobObjectInformationClass, MemorySegment lpJobObjectInformation, int cbJobObjectInformationLength) {
        var mh$ = SetInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetInformationJobObject", hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength);
            }
            return (int)mh$.invokeExact(hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetIoRateControlInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetIoRateControlInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static FunctionDescriptor SetIoRateControlInformationJobObject$descriptor() {
        return SetIoRateControlInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static MethodHandle SetIoRateControlInformationJobObject$handle() {
        return SetIoRateControlInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static MemorySegment SetIoRateControlInformationJobObject$address() {
        return SetIoRateControlInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static int SetIoRateControlInformationJobObject(MemorySegment hJob, MemorySegment IoRateControlInfo) {
        var mh$ = SetIoRateControlInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetIoRateControlInformationJobObject", hJob, IoRateControlInfo);
            }
            return (int)mh$.invokeExact(hJob, IoRateControlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static FunctionDescriptor QueryInformationJobObject$descriptor() {
        return QueryInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static MethodHandle QueryInformationJobObject$handle() {
        return QueryInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static MemorySegment QueryInformationJobObject$address() {
        return QueryInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static int QueryInformationJobObject(MemorySegment hJob, int JobObjectInformationClass, MemorySegment lpJobObjectInformation, int cbJobObjectInformationLength, MemorySegment lpReturnLength) {
        var mh$ = QueryInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInformationJobObject", hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength, lpReturnLength);
            }
            return (int)mh$.invokeExact(hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength, lpReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIoRateControlInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryIoRateControlInformationJobObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static FunctionDescriptor QueryIoRateControlInformationJobObject$descriptor() {
        return QueryIoRateControlInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static MethodHandle QueryIoRateControlInformationJobObject$handle() {
        return QueryIoRateControlInformationJobObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static MemorySegment QueryIoRateControlInformationJobObject$address() {
        return QueryIoRateControlInformationJobObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static int QueryIoRateControlInformationJobObject(MemorySegment hJob, MemorySegment VolumeName, MemorySegment InfoBlocks, MemorySegment InfoBlockCount) {
        var mh$ = QueryIoRateControlInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIoRateControlInformationJobObject", hJob, VolumeName, InfoBlocks, InfoBlockCount);
            }
            return (int)mh$.invokeExact(hJob, VolumeName, InfoBlocks, InfoBlockCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64DisableWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64DisableWow64FsRedirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static FunctionDescriptor Wow64DisableWow64FsRedirection$descriptor() {
        return Wow64DisableWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static MethodHandle Wow64DisableWow64FsRedirection$handle() {
        return Wow64DisableWow64FsRedirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static MemorySegment Wow64DisableWow64FsRedirection$address() {
        return Wow64DisableWow64FsRedirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static int Wow64DisableWow64FsRedirection(MemorySegment OldValue) {
        var mh$ = Wow64DisableWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64DisableWow64FsRedirection", OldValue);
            }
            return (int)mh$.invokeExact(OldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64RevertWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64RevertWow64FsRedirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static FunctionDescriptor Wow64RevertWow64FsRedirection$descriptor() {
        return Wow64RevertWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static MethodHandle Wow64RevertWow64FsRedirection$handle() {
        return Wow64RevertWow64FsRedirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static MemorySegment Wow64RevertWow64FsRedirection$address() {
        return Wow64RevertWow64FsRedirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static int Wow64RevertWow64FsRedirection(MemorySegment OlValue) {
        var mh$ = Wow64RevertWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64RevertWow64FsRedirection", OlValue);
            }
            return (int)mh$.invokeExact(OlValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Process {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWow64Process");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static FunctionDescriptor IsWow64Process$descriptor() {
        return IsWow64Process.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static MethodHandle IsWow64Process$handle() {
        return IsWow64Process.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static MemorySegment IsWow64Process$address() {
        return IsWow64Process.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static int IsWow64Process(MemorySegment hProcess, MemorySegment Wow64Process) {
        var mh$ = IsWow64Process.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Process", hProcess, Wow64Process);
            }
            return (int)mh$.invokeExact(hProcess, Wow64Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64DirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemWow64DirectoryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWow64DirectoryA$descriptor() {
        return GetSystemWow64DirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWow64DirectoryA$handle() {
        return GetSystemWow64DirectoryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWow64DirectoryA$address() {
        return GetSystemWow64DirectoryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWow64DirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWow64DirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64DirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64DirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemWow64DirectoryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWow64DirectoryW$descriptor() {
        return GetSystemWow64DirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWow64DirectoryW$handle() {
        return GetSystemWow64DirectoryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MemorySegment GetSystemWow64DirectoryW$address() {
        return GetSystemWow64DirectoryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWow64DirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWow64DirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64DirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SetThreadDefaultGuestMachine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64SetThreadDefaultGuestMachine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static FunctionDescriptor Wow64SetThreadDefaultGuestMachine$descriptor() {
        return Wow64SetThreadDefaultGuestMachine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static MethodHandle Wow64SetThreadDefaultGuestMachine$handle() {
        return Wow64SetThreadDefaultGuestMachine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static MemorySegment Wow64SetThreadDefaultGuestMachine$address() {
        return Wow64SetThreadDefaultGuestMachine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static short Wow64SetThreadDefaultGuestMachine(short Machine) {
        var mh$ = Wow64SetThreadDefaultGuestMachine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SetThreadDefaultGuestMachine", Machine);
            }
            return (short)mh$.invokeExact(Machine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Process2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWow64Process2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static FunctionDescriptor IsWow64Process2$descriptor() {
        return IsWow64Process2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static MethodHandle IsWow64Process2$handle() {
        return IsWow64Process2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static MemorySegment IsWow64Process2$address() {
        return IsWow64Process2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static int IsWow64Process2(MemorySegment hProcess, MemorySegment pProcessMachine, MemorySegment pNativeMachine) {
        var mh$ = IsWow64Process2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Process2", hProcess, pProcessMachine, pNativeMachine);
            }
            return (int)mh$.invokeExact(hProcess, pProcessMachine, pNativeMachine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64Directory2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemWow64Directory2A");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static FunctionDescriptor GetSystemWow64Directory2A$descriptor() {
        return GetSystemWow64Directory2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MethodHandle GetSystemWow64Directory2A$handle() {
        return GetSystemWow64Directory2A.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MemorySegment GetSystemWow64Directory2A$address() {
        return GetSystemWow64Directory2A.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static int GetSystemWow64Directory2A(MemorySegment lpBuffer, int uSize, short ImageFileMachineType) {
        var mh$ = GetSystemWow64Directory2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64Directory2A", lpBuffer, uSize, ImageFileMachineType);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize, ImageFileMachineType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64Directory2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemWow64Directory2W");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static FunctionDescriptor GetSystemWow64Directory2W$descriptor() {
        return GetSystemWow64Directory2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MethodHandle GetSystemWow64Directory2W$handle() {
        return GetSystemWow64Directory2W.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MemorySegment GetSystemWow64Directory2W$address() {
        return GetSystemWow64Directory2W.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static int GetSystemWow64Directory2W(MemorySegment lpBuffer, int uSize, short ImageFileMachineType) {
        var mh$ = GetSystemWow64Directory2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64Directory2W", lpBuffer, uSize, ImageFileMachineType);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize, ImageFileMachineType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64GuestMachineSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWow64GuestMachineSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static FunctionDescriptor IsWow64GuestMachineSupported$descriptor() {
        return IsWow64GuestMachineSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static MethodHandle IsWow64GuestMachineSupported$handle() {
        return IsWow64GuestMachineSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static MemorySegment IsWow64GuestMachineSupported$address() {
        return IsWow64GuestMachineSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static int IsWow64GuestMachineSupported(short WowGuestMachine, MemorySegment MachineIsSupported) {
        var mh$ = IsWow64GuestMachineSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64GuestMachineSupported", WowGuestMachine, MachineIsSupported);
            }
            return (int)mh$.invokeExact(WowGuestMachine, MachineIsSupported);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64GetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64GetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static FunctionDescriptor Wow64GetThreadContext$descriptor() {
        return Wow64GetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static MethodHandle Wow64GetThreadContext$handle() {
        return Wow64GetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static MemorySegment Wow64GetThreadContext$address() {
        return Wow64GetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static int Wow64GetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = Wow64GetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64GetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64SetThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static FunctionDescriptor Wow64SetThreadContext$descriptor() {
        return Wow64SetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static MethodHandle Wow64SetThreadContext$handle() {
        return Wow64SetThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static MemorySegment Wow64SetThreadContext$address() {
        return Wow64SetThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static int Wow64SetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = Wow64SetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SuspendThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64SuspendThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor Wow64SuspendThread$descriptor() {
        return Wow64SuspendThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static MethodHandle Wow64SuspendThread$handle() {
        return Wow64SuspendThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static MemorySegment Wow64SuspendThread$address() {
        return Wow64SuspendThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static int Wow64SuspendThread(MemorySegment hThread) {
        var mh$ = Wow64SuspendThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SuspendThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMUILANG {
     *     ULONG NumOfEnumUILang;
     *     ULONG SizeOfEnumUIBuffer;
     *     LANGID *pEnumUIBuffer;
     * } *PENUMUILANG
     * }
     */
    public static final AddressLayout PENUMUILANG = freeglut_h.C_POINTER;

    private static class DisableThreadLibraryCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DisableThreadLibraryCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static FunctionDescriptor DisableThreadLibraryCalls$descriptor() {
        return DisableThreadLibraryCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static MethodHandle DisableThreadLibraryCalls$handle() {
        return DisableThreadLibraryCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static MemorySegment DisableThreadLibraryCalls$address() {
        return DisableThreadLibraryCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static int DisableThreadLibraryCalls(MemorySegment hLibModule) {
        var mh$ = DisableThreadLibraryCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableThreadLibraryCalls", hLibModule);
            }
            return (int)mh$.invokeExact(hLibModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindResourceExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static FunctionDescriptor FindResourceExW$descriptor() {
        return FindResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MethodHandle FindResourceExW$handle() {
        return FindResourceExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExW$address() {
        return FindResourceExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, short wLanguage) {
        var mh$ = FindResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceExW", hModule, lpType, lpName, wLanguage);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpType, lpName, wLanguage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindStringOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindStringOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static FunctionDescriptor FindStringOrdinal$descriptor() {
        return FindStringOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static MethodHandle FindStringOrdinal$handle() {
        return FindStringOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static MemorySegment FindStringOrdinal$address() {
        return FindStringOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static int FindStringOrdinal(int dwFindStringOrdinalFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, int bIgnoreCase) {
        var mh$ = FindStringOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindStringOrdinal", dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase);
            }
            return (int)mh$.invokeExact(dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibrary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeLibrary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static FunctionDescriptor FreeLibrary$descriptor() {
        return FreeLibrary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static MethodHandle FreeLibrary$handle() {
        return FreeLibrary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static MemorySegment FreeLibrary$address() {
        return FreeLibrary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static int FreeLibrary(MemorySegment hLibModule) {
        var mh$ = FreeLibrary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibrary", hLibModule);
            }
            return (int)mh$.invokeExact(hLibModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibraryAndExitThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeLibraryAndExitThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor FreeLibraryAndExitThread$descriptor() {
        return FreeLibraryAndExitThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static MethodHandle FreeLibraryAndExitThread$handle() {
        return FreeLibraryAndExitThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static MemorySegment FreeLibraryAndExitThread$address() {
        return FreeLibraryAndExitThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static void FreeLibraryAndExitThread(MemorySegment hLibModule, int dwExitCode) {
        var mh$ = FreeLibraryAndExitThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibraryAndExitThread", hLibModule, dwExitCode);
            }
            mh$.invokeExact(hLibModule, dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static FunctionDescriptor FreeResource$descriptor() {
        return FreeResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static MethodHandle FreeResource$handle() {
        return FreeResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static MemorySegment FreeResource$address() {
        return FreeResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static int FreeResource(MemorySegment hResData) {
        var mh$ = FreeResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeResource", hResData);
            }
            return (int)mh$.invokeExact(hResData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetModuleFileNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetModuleFileNameA$descriptor() {
        return GetModuleFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static MethodHandle GetModuleFileNameA$handle() {
        return GetModuleFileNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static MemorySegment GetModuleFileNameA$address() {
        return GetModuleFileNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static int GetModuleFileNameA(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
        var mh$ = GetModuleFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleFileNameA", hModule, lpFilename, nSize);
            }
            return (int)mh$.invokeExact(hModule, lpFilename, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetModuleFileNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetModuleFileNameW$descriptor() {
        return GetModuleFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static MethodHandle GetModuleFileNameW$handle() {
        return GetModuleFileNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static MemorySegment GetModuleFileNameW$address() {
        return GetModuleFileNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static int GetModuleFileNameW(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
        var mh$ = GetModuleFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleFileNameW", hModule, lpFilename, nSize);
            }
            return (int)mh$.invokeExact(hModule, lpFilename, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetModuleHandleA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static FunctionDescriptor GetModuleHandleA$descriptor() {
        return GetModuleHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MethodHandle GetModuleHandleA$handle() {
        return GetModuleHandleA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleA$address() {
        return GetModuleHandleA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleA(MemorySegment lpModuleName) {
        var mh$ = GetModuleHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleA", lpModuleName);
            }
            return (MemorySegment)mh$.invokeExact(lpModuleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetModuleHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static FunctionDescriptor GetModuleHandleW$descriptor() {
        return GetModuleHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MethodHandle GetModuleHandleW$handle() {
        return GetModuleHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleW$address() {
        return GetModuleHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleW(MemorySegment lpModuleName) {
        var mh$ = GetModuleHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleW", lpModuleName);
            }
            return (MemorySegment)mh$.invokeExact(lpModuleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetModuleHandleExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static FunctionDescriptor GetModuleHandleExA$descriptor() {
        return GetModuleHandleExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MethodHandle GetModuleHandleExA$handle() {
        return GetModuleHandleExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MemorySegment GetModuleHandleExA$address() {
        return GetModuleHandleExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static int GetModuleHandleExA(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
        var mh$ = GetModuleHandleExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleExA", dwFlags, lpModuleName, phModule);
            }
            return (int)mh$.invokeExact(dwFlags, lpModuleName, phModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetModuleHandleExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static FunctionDescriptor GetModuleHandleExW$descriptor() {
        return GetModuleHandleExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MethodHandle GetModuleHandleExW$handle() {
        return GetModuleHandleExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MemorySegment GetModuleHandleExW$address() {
        return GetModuleHandleExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static int GetModuleHandleExW(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
        var mh$ = GetModuleHandleExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleExW", dwFlags, lpModuleName, phModule);
            }
            return (int)mh$.invokeExact(dwFlags, lpModuleName, phModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static FunctionDescriptor GetProcAddress$descriptor() {
        return GetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MethodHandle GetProcAddress$handle() {
        return GetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MemorySegment GetProcAddress$address() {
        return GetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MemorySegment GetProcAddress(MemorySegment hModule, MemorySegment lpProcName) {
        var mh$ = GetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcAddress", hModule, lpProcName);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpProcName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _REDIRECTION_FUNCTION_DESCRIPTOR {
     *     PCSTR DllName;
     *     PCSTR FunctionName;
     *     PVOID RedirectionTarget;
     * } *PREDIRECTION_FUNCTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PREDIRECTION_FUNCTION_DESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const REDIRECTION_FUNCTION_DESCRIPTOR *PCREDIRECTION_FUNCTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCREDIRECTION_FUNCTION_DESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REDIRECTION_DESCRIPTOR {
     *     ULONG Version;
     *     ULONG FunctionCount;
     *     PCREDIRECTION_FUNCTION_DESCRIPTOR Redirections;
     * } *PREDIRECTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PREDIRECTION_DESCRIPTOR = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const REDIRECTION_DESCRIPTOR *PCREDIRECTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCREDIRECTION_DESCRIPTOR = freeglut_h.C_POINTER;

    private static class LoadLibraryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadLibraryExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LoadLibraryExA$descriptor() {
        return LoadLibraryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle LoadLibraryExA$handle() {
        return LoadLibraryExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExA$address() {
        return LoadLibraryExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExA(MemorySegment lpLibFileName, MemorySegment hFile, int dwFlags) {
        var mh$ = LoadLibraryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryExA", lpLibFileName, hFile, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName, hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadLibraryExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LoadLibraryExW$descriptor() {
        return LoadLibraryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle LoadLibraryExW$handle() {
        return LoadLibraryExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExW$address() {
        return LoadLibraryExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExW(MemorySegment lpLibFileName, MemorySegment hFile, int dwFlags) {
        var mh$ = LoadLibraryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryExW", lpLibFileName, hFile, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName, hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static FunctionDescriptor LoadResource$descriptor() {
        return LoadResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MethodHandle LoadResource$handle() {
        return LoadResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MemorySegment LoadResource$address() {
        return LoadResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MemorySegment LoadResource(MemorySegment hModule, MemorySegment hResInfo) {
        var mh$ = LoadResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadResource", hModule, hResInfo);
            }
            return (MemorySegment)mh$.invokeExact(hModule, hResInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static FunctionDescriptor LoadStringA$descriptor() {
        return LoadStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MethodHandle LoadStringA$handle() {
        return LoadStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MemorySegment LoadStringA$address() {
        return LoadStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static int LoadStringA(MemorySegment hInstance, int uID, MemorySegment lpBuffer, int cchBufferMax) {
        var mh$ = LoadStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringA", hInstance, uID, lpBuffer, cchBufferMax);
            }
            return (int)mh$.invokeExact(hInstance, uID, lpBuffer, cchBufferMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static FunctionDescriptor LoadStringW$descriptor() {
        return LoadStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MethodHandle LoadStringW$handle() {
        return LoadStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MemorySegment LoadStringW$address() {
        return LoadStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static int LoadStringW(MemorySegment hInstance, int uID, MemorySegment lpBuffer, int cchBufferMax) {
        var mh$ = LoadStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringW", hInstance, uID, lpBuffer, cchBufferMax);
            }
            return (int)mh$.invokeExact(hInstance, uID, lpBuffer, cchBufferMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LockResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static FunctionDescriptor LockResource$descriptor() {
        return LockResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MethodHandle LockResource$handle() {
        return LockResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MemorySegment LockResource$address() {
        return LockResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MemorySegment LockResource(MemorySegment hResData) {
        var mh$ = LockResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockResource", hResData);
            }
            return (MemorySegment)mh$.invokeExact(hResData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SizeofResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SizeofResource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static FunctionDescriptor SizeofResource$descriptor() {
        return SizeofResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MethodHandle SizeofResource$handle() {
        return SizeofResource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MemorySegment SizeofResource$address() {
        return SizeofResource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static int SizeofResource(MemorySegment hModule, MemorySegment hResInfo) {
        var mh$ = SizeofResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SizeofResource", hModule, hResInfo);
            }
            return (int)mh$.invokeExact(hModule, hResInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID DLL_DIRECTORY_COOKIE
     * }
     */
    public static final AddressLayout DLL_DIRECTORY_COOKIE = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID *PDLL_DIRECTORY_COOKIE
     * }
     */
    public static final AddressLayout PDLL_DIRECTORY_COOKIE = freeglut_h.C_POINTER;

    private static class AddDllDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddDllDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static FunctionDescriptor AddDllDirectory$descriptor() {
        return AddDllDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MethodHandle AddDllDirectory$handle() {
        return AddDllDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MemorySegment AddDllDirectory$address() {
        return AddDllDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MemorySegment AddDllDirectory(MemorySegment NewDirectory) {
        var mh$ = AddDllDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddDllDirectory", NewDirectory);
            }
            return (MemorySegment)mh$.invokeExact(NewDirectory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDllDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RemoveDllDirectory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static FunctionDescriptor RemoveDllDirectory$descriptor() {
        return RemoveDllDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static MethodHandle RemoveDllDirectory$handle() {
        return RemoveDllDirectory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static MemorySegment RemoveDllDirectory$address() {
        return RemoveDllDirectory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static int RemoveDllDirectory(MemorySegment Cookie) {
        var mh$ = RemoveDllDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDllDirectory", Cookie);
            }
            return (int)mh$.invokeExact(Cookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultDllDirectories {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetDefaultDllDirectories");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static FunctionDescriptor SetDefaultDllDirectories$descriptor() {
        return SetDefaultDllDirectories.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static MethodHandle SetDefaultDllDirectories$handle() {
        return SetDefaultDllDirectories.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static MemorySegment SetDefaultDllDirectories$address() {
        return SetDefaultDllDirectories.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static int SetDefaultDllDirectories(int DirectoryFlags) {
        var mh$ = SetDefaultDllDirectories.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultDllDirectories", DirectoryFlags);
            }
            return (int)mh$.invokeExact(DirectoryFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceLanguagesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesExA$descriptor() {
        return EnumResourceLanguagesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceLanguagesExA$handle() {
        return EnumResourceLanguagesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceLanguagesExA$address() {
        return EnumResourceLanguagesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceLanguagesExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceLanguagesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesExA", hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceLanguagesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesExW$descriptor() {
        return EnumResourceLanguagesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceLanguagesExW$handle() {
        return EnumResourceLanguagesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceLanguagesExW$address() {
        return EnumResourceLanguagesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceLanguagesExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceLanguagesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesExW", hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceNamesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesExA$descriptor() {
        return EnumResourceNamesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceNamesExA$handle() {
        return EnumResourceNamesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceNamesExA$address() {
        return EnumResourceNamesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceNamesExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceNamesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesExA", hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceNamesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesExW$descriptor() {
        return EnumResourceNamesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceNamesExW$handle() {
        return EnumResourceNamesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceNamesExW$address() {
        return EnumResourceNamesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceNamesExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceNamesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesExW", hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceTypesExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesExA$descriptor() {
        return EnumResourceTypesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceTypesExA$handle() {
        return EnumResourceTypesExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceTypesExA$address() {
        return EnumResourceTypesExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceTypesExA(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceTypesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesExA", hModule, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceTypesExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesExW$descriptor() {
        return EnumResourceTypesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceTypesExW$handle() {
        return EnumResourceTypesExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MemorySegment EnumResourceTypesExW$address() {
        return EnumResourceTypesExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceTypesExW(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceTypesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesExW", hModule, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static FunctionDescriptor FindResourceW$descriptor() {
        return FindResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MethodHandle FindResourceW$handle() {
        return FindResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MemorySegment FindResourceW$address() {
        return FindResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MemorySegment FindResourceW(MemorySegment hModule, MemorySegment lpName, MemorySegment lpType) {
        var mh$ = FindResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceW", hModule, lpName, lpType);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpName, lpType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadLibraryA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static FunctionDescriptor LoadLibraryA$descriptor() {
        return LoadLibraryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MethodHandle LoadLibraryA$handle() {
        return LoadLibraryA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryA$address() {
        return LoadLibraryA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryA(MemorySegment lpLibFileName) {
        var mh$ = LoadLibraryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryA", lpLibFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadLibraryW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static FunctionDescriptor LoadLibraryW$descriptor() {
        return LoadLibraryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MethodHandle LoadLibraryW$handle() {
        return LoadLibraryW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryW$address() {
        return LoadLibraryW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryW(MemorySegment lpLibFileName) {
        var mh$ = LoadLibraryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryW", lpLibFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceNamesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesW$descriptor() {
        return EnumResourceNamesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceNamesW$handle() {
        return EnumResourceNamesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceNamesW$address() {
        return EnumResourceNamesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceNamesW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceNamesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesW", hModule, lpType, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static FunctionDescriptor AccessCheck$descriptor() {
        return AccessCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MethodHandle AccessCheck$handle() {
        return AccessCheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MemorySegment AccessCheck$address() {
        return AccessCheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static int AccessCheck(MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccess, MemorySegment AccessStatus) {
        var mh$ = AccessCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheck", pSecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckAndAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckAndAuditAlarmW$descriptor() {
        return AccessCheckAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckAndAuditAlarmW$handle() {
        return AccessCheckAndAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckAndAuditAlarmW$address() {
        return AccessCheckAndAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, int DesiredAccess, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static FunctionDescriptor AccessCheckByType$descriptor() {
        return AccessCheckByType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MethodHandle AccessCheckByType$handle() {
        return AccessCheckByType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MemorySegment AccessCheckByType$address() {
        return AccessCheckByType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static int AccessCheckByType(MemorySegment pSecurityDescriptor, MemorySegment PrincipalSelfSid, MemorySegment ClientToken, int DesiredAccess, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccess, MemorySegment AccessStatus) {
        var mh$ = AccessCheckByType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByType", pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByTypeResultList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultList$descriptor() {
        return AccessCheckByTypeResultList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultList$handle() {
        return AccessCheckByTypeResultList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultList$address() {
        return AccessCheckByTypeResultList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static int AccessCheckByTypeResultList(MemorySegment pSecurityDescriptor, MemorySegment PrincipalSelfSid, MemorySegment ClientToken, int DesiredAccess, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccessList, MemorySegment AccessStatusList) {
        var mh$ = AccessCheckByTypeResultList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultList", pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccessList, AccessStatusList);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccessList, AccessStatusList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByTypeAndAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeAndAuditAlarmW$descriptor() {
        return AccessCheckByTypeAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeAndAuditAlarmW$handle() {
        return AccessCheckByTypeAndAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeAndAuditAlarmW$address() {
        return AccessCheckByTypeAndAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmW$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmW$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmW$address() {
        return AccessCheckByTypeResultListAndAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccessList, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AccessCheckByTypeResultListAndAuditAlarmByHandleW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmByHandleW$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmByHandleW$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MemorySegment AccessCheckByTypeResultListAndAuditAlarmByHandleW$address() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmByHandleW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccessList, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmByHandleW", SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAccessAllowedAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedAce$descriptor() {
        return AddAccessAllowedAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedAce$handle() {
        return AddAccessAllowedAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessAllowedAce$address() {
        return AddAccessAllowedAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessAllowedAce(MemorySegment pAcl, int dwAceRevision, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessAllowedAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedAce", pAcl, dwAceRevision, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAccessAllowedAceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedAceEx$descriptor() {
        return AddAccessAllowedAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedAceEx$handle() {
        return AddAccessAllowedAceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessAllowedAceEx$address() {
        return AddAccessAllowedAceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessAllowedAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessAllowedAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedAceEx", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAccessAllowedObjectAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedObjectAce$descriptor() {
        return AddAccessAllowedObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedObjectAce$handle() {
        return AddAccessAllowedObjectAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessAllowedObjectAce$address() {
        return AddAccessAllowedObjectAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static int AddAccessAllowedObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid) {
        var mh$ = AddAccessAllowedObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAccessDeniedAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedAce$descriptor() {
        return AddAccessDeniedAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedAce$handle() {
        return AddAccessDeniedAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessDeniedAce$address() {
        return AddAccessDeniedAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessDeniedAce(MemorySegment pAcl, int dwAceRevision, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessDeniedAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedAce", pAcl, dwAceRevision, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAccessDeniedAceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedAceEx$descriptor() {
        return AddAccessDeniedAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedAceEx$handle() {
        return AddAccessDeniedAceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessDeniedAceEx$address() {
        return AddAccessDeniedAceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessDeniedAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessDeniedAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedAceEx", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAccessDeniedObjectAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedObjectAce$descriptor() {
        return AddAccessDeniedObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedObjectAce$handle() {
        return AddAccessDeniedObjectAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MemorySegment AddAccessDeniedObjectAce$address() {
        return AddAccessDeniedObjectAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static int AddAccessDeniedObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid) {
        var mh$ = AddAccessDeniedObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static FunctionDescriptor AddAce$descriptor() {
        return AddAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static MethodHandle AddAce$handle() {
        return AddAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static MemorySegment AddAce$address() {
        return AddAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static int AddAce(MemorySegment pAcl, int dwAceRevision, int dwStartingAceIndex, MemorySegment pAceList, int nAceListLength) {
        var mh$ = AddAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAce", pAcl, dwAceRevision, dwStartingAceIndex, pAceList, nAceListLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, dwStartingAceIndex, pAceList, nAceListLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAuditAccessAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessAce$descriptor() {
        return AddAuditAccessAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessAce$handle() {
        return AddAuditAccessAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MemorySegment AddAuditAccessAce$address() {
        return AddAuditAccessAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessAce(MemorySegment pAcl, int dwAceRevision, int dwAccessMask, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessAce", pAcl, dwAceRevision, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAuditAccessAceEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessAceEx$descriptor() {
        return AddAuditAccessAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessAceEx$handle() {
        return AddAuditAccessAceEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MemorySegment AddAuditAccessAceEx$address() {
        return AddAuditAccessAceEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int dwAccessMask, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessAceEx", pAcl, dwAceRevision, AceFlags, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAuditAccessObjectAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessObjectAce$descriptor() {
        return AddAuditAccessObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessObjectAce$handle() {
        return AddAuditAccessObjectAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MemorySegment AddAuditAccessObjectAce$address() {
        return AddAuditAccessObjectAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddMandatoryAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddMandatoryAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static FunctionDescriptor AddMandatoryAce$descriptor() {
        return AddMandatoryAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static MethodHandle AddMandatoryAce$handle() {
        return AddMandatoryAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static MemorySegment AddMandatoryAce$address() {
        return AddMandatoryAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static int AddMandatoryAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int MandatoryPolicy, MemorySegment pLabelSid) {
        var mh$ = AddMandatoryAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddMandatoryAce", pAcl, dwAceRevision, AceFlags, MandatoryPolicy, pLabelSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, MandatoryPolicy, pLabelSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddResourceAttributeAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddResourceAttributeAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static FunctionDescriptor AddResourceAttributeAce$descriptor() {
        return AddResourceAttributeAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static MethodHandle AddResourceAttributeAce$handle() {
        return AddResourceAttributeAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static MemorySegment AddResourceAttributeAce$address() {
        return AddResourceAttributeAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static int AddResourceAttributeAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid, MemorySegment pAttributeInfo, MemorySegment pReturnLength) {
        var mh$ = AddResourceAttributeAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddResourceAttributeAce", pAcl, dwAceRevision, AceFlags, AccessMask, pSid, pAttributeInfo, pReturnLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid, pAttributeInfo, pReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddScopedPolicyIDAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddScopedPolicyIDAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddScopedPolicyIDAce$descriptor() {
        return AddScopedPolicyIDAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddScopedPolicyIDAce$handle() {
        return AddScopedPolicyIDAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MemorySegment AddScopedPolicyIDAce$address() {
        return AddScopedPolicyIDAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddScopedPolicyIDAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddScopedPolicyIDAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddScopedPolicyIDAce", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustTokenGroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AdjustTokenGroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor AdjustTokenGroups$descriptor() {
        return AdjustTokenGroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle AdjustTokenGroups$handle() {
        return AdjustTokenGroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment AdjustTokenGroups$address() {
        return AdjustTokenGroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static int AdjustTokenGroups(MemorySegment TokenHandle, int ResetToDefault, MemorySegment NewState, int BufferLength, MemorySegment PreviousState, MemorySegment ReturnLength) {
        var mh$ = AdjustTokenGroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustTokenGroups", TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustTokenPrivileges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AdjustTokenPrivileges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor AdjustTokenPrivileges$descriptor() {
        return AdjustTokenPrivileges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle AdjustTokenPrivileges$handle() {
        return AdjustTokenPrivileges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment AdjustTokenPrivileges$address() {
        return AdjustTokenPrivileges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static int AdjustTokenPrivileges(MemorySegment TokenHandle, int DisableAllPrivileges, MemorySegment NewState, int BufferLength, MemorySegment PreviousState, MemorySegment ReturnLength) {
        var mh$ = AdjustTokenPrivileges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustTokenPrivileges", TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateAndInitializeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AllocateAndInitializeSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static FunctionDescriptor AllocateAndInitializeSid$descriptor() {
        return AllocateAndInitializeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static MethodHandle AllocateAndInitializeSid$handle() {
        return AllocateAndInitializeSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static MemorySegment AllocateAndInitializeSid$address() {
        return AllocateAndInitializeSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static int AllocateAndInitializeSid(MemorySegment pIdentifierAuthority, byte nSubAuthorityCount, int nSubAuthority0, int nSubAuthority1, int nSubAuthority2, int nSubAuthority3, int nSubAuthority4, int nSubAuthority5, int nSubAuthority6, int nSubAuthority7, MemorySegment pSid) {
        var mh$ = AllocateAndInitializeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateAndInitializeSid", pIdentifierAuthority, nSubAuthorityCount, nSubAuthority0, nSubAuthority1, nSubAuthority2, nSubAuthority3, nSubAuthority4, nSubAuthority5, nSubAuthority6, nSubAuthority7, pSid);
            }
            return (int)mh$.invokeExact(pIdentifierAuthority, nSubAuthorityCount, nSubAuthority0, nSubAuthority1, nSubAuthority2, nSubAuthority3, nSubAuthority4, nSubAuthority5, nSubAuthority6, nSubAuthority7, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateLocallyUniqueId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AllocateLocallyUniqueId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static FunctionDescriptor AllocateLocallyUniqueId$descriptor() {
        return AllocateLocallyUniqueId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static MethodHandle AllocateLocallyUniqueId$handle() {
        return AllocateLocallyUniqueId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static MemorySegment AllocateLocallyUniqueId$address() {
        return AllocateLocallyUniqueId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static int AllocateLocallyUniqueId(MemorySegment Luid) {
        var mh$ = AllocateLocallyUniqueId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateLocallyUniqueId", Luid);
            }
            return (int)mh$.invokeExact(Luid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreAllAccessesGranted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AreAllAccessesGranted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor AreAllAccessesGranted$descriptor() {
        return AreAllAccessesGranted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MethodHandle AreAllAccessesGranted$handle() {
        return AreAllAccessesGranted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MemorySegment AreAllAccessesGranted$address() {
        return AreAllAccessesGranted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static int AreAllAccessesGranted(int GrantedAccess, int DesiredAccess) {
        var mh$ = AreAllAccessesGranted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreAllAccessesGranted", GrantedAccess, DesiredAccess);
            }
            return (int)mh$.invokeExact(GrantedAccess, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreAnyAccessesGranted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AreAnyAccessesGranted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor AreAnyAccessesGranted$descriptor() {
        return AreAnyAccessesGranted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MethodHandle AreAnyAccessesGranted$handle() {
        return AreAnyAccessesGranted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MemorySegment AreAnyAccessesGranted$address() {
        return AreAnyAccessesGranted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static int AreAnyAccessesGranted(int GrantedAccess, int DesiredAccess) {
        var mh$ = AreAnyAccessesGranted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreAnyAccessesGranted", GrantedAccess, DesiredAccess);
            }
            return (int)mh$.invokeExact(GrantedAccess, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenMembership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckTokenMembership");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static FunctionDescriptor CheckTokenMembership$descriptor() {
        return CheckTokenMembership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static MethodHandle CheckTokenMembership$handle() {
        return CheckTokenMembership.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static MemorySegment CheckTokenMembership$address() {
        return CheckTokenMembership.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static int CheckTokenMembership(MemorySegment TokenHandle, MemorySegment SidToCheck, MemorySegment IsMember) {
        var mh$ = CheckTokenMembership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenMembership", TokenHandle, SidToCheck, IsMember);
            }
            return (int)mh$.invokeExact(TokenHandle, SidToCheck, IsMember);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenCapability {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckTokenCapability");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static FunctionDescriptor CheckTokenCapability$descriptor() {
        return CheckTokenCapability.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static MethodHandle CheckTokenCapability$handle() {
        return CheckTokenCapability.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static MemorySegment CheckTokenCapability$address() {
        return CheckTokenCapability.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static int CheckTokenCapability(MemorySegment TokenHandle, MemorySegment CapabilitySidToCheck, MemorySegment HasCapability) {
        var mh$ = CheckTokenCapability.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenCapability", TokenHandle, CapabilitySidToCheck, HasCapability);
            }
            return (int)mh$.invokeExact(TokenHandle, CapabilitySidToCheck, HasCapability);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAppContainerAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAppContainerAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static FunctionDescriptor GetAppContainerAce$descriptor() {
        return GetAppContainerAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static MethodHandle GetAppContainerAce$handle() {
        return GetAppContainerAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static MemorySegment GetAppContainerAce$address() {
        return GetAppContainerAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static int GetAppContainerAce(MemorySegment Acl, int StartingAceIndex, MemorySegment AppContainerAce, MemorySegment AppContainerAceIndex) {
        var mh$ = GetAppContainerAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAppContainerAce", Acl, StartingAceIndex, AppContainerAce, AppContainerAceIndex);
            }
            return (int)mh$.invokeExact(Acl, StartingAceIndex, AppContainerAce, AppContainerAceIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenMembershipEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CheckTokenMembershipEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static FunctionDescriptor CheckTokenMembershipEx$descriptor() {
        return CheckTokenMembershipEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static MethodHandle CheckTokenMembershipEx$handle() {
        return CheckTokenMembershipEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static MemorySegment CheckTokenMembershipEx$address() {
        return CheckTokenMembershipEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static int CheckTokenMembershipEx(MemorySegment TokenHandle, MemorySegment SidToCheck, int Flags, MemorySegment IsMember) {
        var mh$ = CheckTokenMembershipEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenMembershipEx", TokenHandle, SidToCheck, Flags, IsMember);
            }
            return (int)mh$.invokeExact(TokenHandle, SidToCheck, Flags, IsMember);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertToAutoInheritPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConvertToAutoInheritPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor ConvertToAutoInheritPrivateObjectSecurity$descriptor() {
        return ConvertToAutoInheritPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle ConvertToAutoInheritPrivateObjectSecurity$handle() {
        return ConvertToAutoInheritPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment ConvertToAutoInheritPrivateObjectSecurity$address() {
        return ConvertToAutoInheritPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int ConvertToAutoInheritPrivateObjectSecurity(MemorySegment ParentDescriptor, MemorySegment CurrentSecurityDescriptor, MemorySegment NewSecurityDescriptor, MemorySegment ObjectType, byte IsDirectoryObject, MemorySegment GenericMapping) {
        var mh$ = ConvertToAutoInheritPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertToAutoInheritPrivateObjectSecurity", ParentDescriptor, CurrentSecurityDescriptor, NewSecurityDescriptor, ObjectType, IsDirectoryObject, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CurrentSecurityDescriptor, NewSecurityDescriptor, ObjectType, IsDirectoryObject, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopySid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CopySid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static FunctionDescriptor CopySid$descriptor() {
        return CopySid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static MethodHandle CopySid$handle() {
        return CopySid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static MemorySegment CopySid$address() {
        return CopySid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static int CopySid(int nDestinationSidLength, MemorySegment pDestinationSid, MemorySegment pSourceSid) {
        var mh$ = CopySid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopySid", nDestinationSidLength, pDestinationSid, pSourceSid);
            }
            return (int)mh$.invokeExact(nDestinationSidLength, pDestinationSid, pSourceSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurity$descriptor() {
        return CreatePrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurity$handle() {
        return CreatePrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment CreatePrivateObjectSecurity$address() {
        return CreatePrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurity(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, int IsDirectoryObject, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurity", ParentDescriptor, CreatorDescriptor, NewDescriptor, IsDirectoryObject, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, IsDirectoryObject, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurityEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePrivateObjectSecurityEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurityEx$descriptor() {
        return CreatePrivateObjectSecurityEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurityEx$handle() {
        return CreatePrivateObjectSecurityEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment CreatePrivateObjectSecurityEx$address() {
        return CreatePrivateObjectSecurityEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurityEx(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, MemorySegment ObjectType, int IsContainerObject, int AutoInheritFlags, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurityEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurityEx", ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectType, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectType, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurityWithMultipleInheritance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePrivateObjectSecurityWithMultipleInheritance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurityWithMultipleInheritance$descriptor() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurityWithMultipleInheritance$handle() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment CreatePrivateObjectSecurityWithMultipleInheritance$address() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurityWithMultipleInheritance(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, MemorySegment ObjectTypes, int GuidCount, int IsContainerObject, int AutoInheritFlags, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurityWithMultipleInheritance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurityWithMultipleInheritance", ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectTypes, GuidCount, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectTypes, GuidCount, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRestrictedToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateRestrictedToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static FunctionDescriptor CreateRestrictedToken$descriptor() {
        return CreateRestrictedToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static MethodHandle CreateRestrictedToken$handle() {
        return CreateRestrictedToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static MemorySegment CreateRestrictedToken$address() {
        return CreateRestrictedToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static int CreateRestrictedToken(MemorySegment ExistingTokenHandle, int Flags, int DisableSidCount, MemorySegment SidsToDisable, int DeletePrivilegeCount, MemorySegment PrivilegesToDelete, int RestrictedSidCount, MemorySegment SidsToRestrict, MemorySegment NewTokenHandle) {
        var mh$ = CreateRestrictedToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRestrictedToken", ExistingTokenHandle, Flags, DisableSidCount, SidsToDisable, DeletePrivilegeCount, PrivilegesToDelete, RestrictedSidCount, SidsToRestrict, NewTokenHandle);
            }
            return (int)mh$.invokeExact(ExistingTokenHandle, Flags, DisableSidCount, SidsToDisable, DeletePrivilegeCount, PrivilegesToDelete, RestrictedSidCount, SidsToRestrict, NewTokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWellKnownSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWellKnownSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static FunctionDescriptor CreateWellKnownSid$descriptor() {
        return CreateWellKnownSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static MethodHandle CreateWellKnownSid$handle() {
        return CreateWellKnownSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static MemorySegment CreateWellKnownSid$address() {
        return CreateWellKnownSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static int CreateWellKnownSid(int WellKnownSidType, MemorySegment DomainSid, MemorySegment pSid, MemorySegment cbSid) {
        var mh$ = CreateWellKnownSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWellKnownSid", WellKnownSidType, DomainSid, pSid, cbSid);
            }
            return (int)mh$.invokeExact(WellKnownSidType, DomainSid, pSid, cbSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualDomainSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EqualDomainSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static FunctionDescriptor EqualDomainSid$descriptor() {
        return EqualDomainSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static MethodHandle EqualDomainSid$handle() {
        return EqualDomainSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static MemorySegment EqualDomainSid$address() {
        return EqualDomainSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static int EqualDomainSid(MemorySegment pSid1, MemorySegment pSid2, MemorySegment pfEqual) {
        var mh$ = EqualDomainSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualDomainSid", pSid1, pSid2, pfEqual);
            }
            return (int)mh$.invokeExact(pSid1, pSid2, pfEqual);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static FunctionDescriptor DeleteAce$descriptor() {
        return DeleteAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static MethodHandle DeleteAce$handle() {
        return DeleteAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static MemorySegment DeleteAce$address() {
        return DeleteAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static int DeleteAce(MemorySegment pAcl, int dwAceIndex) {
        var mh$ = DeleteAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteAce", pAcl, dwAceIndex);
            }
            return (int)mh$.invokeExact(pAcl, dwAceIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DestroyPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static FunctionDescriptor DestroyPrivateObjectSecurity$descriptor() {
        return DestroyPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static MethodHandle DestroyPrivateObjectSecurity$handle() {
        return DestroyPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static MemorySegment DestroyPrivateObjectSecurity$address() {
        return DestroyPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static int DestroyPrivateObjectSecurity(MemorySegment ObjectDescriptor) {
        var mh$ = DestroyPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyPrivateObjectSecurity", ObjectDescriptor);
            }
            return (int)mh$.invokeExact(ObjectDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DuplicateToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static FunctionDescriptor DuplicateToken$descriptor() {
        return DuplicateToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static MethodHandle DuplicateToken$handle() {
        return DuplicateToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static MemorySegment DuplicateToken$address() {
        return DuplicateToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static int DuplicateToken(MemorySegment ExistingTokenHandle, int ImpersonationLevel, MemorySegment DuplicateTokenHandle) {
        var mh$ = DuplicateToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateToken", ExistingTokenHandle, ImpersonationLevel, DuplicateTokenHandle);
            }
            return (int)mh$.invokeExact(ExistingTokenHandle, ImpersonationLevel, DuplicateTokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateTokenEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DuplicateTokenEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static FunctionDescriptor DuplicateTokenEx$descriptor() {
        return DuplicateTokenEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static MethodHandle DuplicateTokenEx$handle() {
        return DuplicateTokenEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static MemorySegment DuplicateTokenEx$address() {
        return DuplicateTokenEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static int DuplicateTokenEx(MemorySegment hExistingToken, int dwDesiredAccess, MemorySegment lpTokenAttributes, int ImpersonationLevel, int TokenType, MemorySegment phNewToken) {
        var mh$ = DuplicateTokenEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateTokenEx", hExistingToken, dwDesiredAccess, lpTokenAttributes, ImpersonationLevel, TokenType, phNewToken);
            }
            return (int)mh$.invokeExact(hExistingToken, dwDesiredAccess, lpTokenAttributes, ImpersonationLevel, TokenType, phNewToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualPrefixSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EqualPrefixSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static FunctionDescriptor EqualPrefixSid$descriptor() {
        return EqualPrefixSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MethodHandle EqualPrefixSid$handle() {
        return EqualPrefixSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MemorySegment EqualPrefixSid$address() {
        return EqualPrefixSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static int EqualPrefixSid(MemorySegment pSid1, MemorySegment pSid2) {
        var mh$ = EqualPrefixSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualPrefixSid", pSid1, pSid2);
            }
            return (int)mh$.invokeExact(pSid1, pSid2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EqualSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static FunctionDescriptor EqualSid$descriptor() {
        return EqualSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MethodHandle EqualSid$handle() {
        return EqualSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MemorySegment EqualSid$address() {
        return EqualSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static int EqualSid(MemorySegment pSid1, MemorySegment pSid2) {
        var mh$ = EqualSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualSid", pSid1, pSid2);
            }
            return (int)mh$.invokeExact(pSid1, pSid2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFreeAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindFirstFreeAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static FunctionDescriptor FindFirstFreeAce$descriptor() {
        return FindFirstFreeAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static MethodHandle FindFirstFreeAce$handle() {
        return FindFirstFreeAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static MemorySegment FindFirstFreeAce$address() {
        return FindFirstFreeAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static int FindFirstFreeAce(MemorySegment pAcl, MemorySegment pAce) {
        var mh$ = FindFirstFreeAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFreeAce", pAcl, pAce);
            }
            return (int)mh$.invokeExact(pAcl, pAce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FreeSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor FreeSid$descriptor() {
        return FreeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MethodHandle FreeSid$handle() {
        return FreeSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MemorySegment FreeSid$address() {
        return FreeSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MemorySegment FreeSid(MemorySegment pSid) {
        var mh$ = FreeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeSid", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static FunctionDescriptor GetAce$descriptor() {
        return GetAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static MethodHandle GetAce$handle() {
        return GetAce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static MemorySegment GetAce$address() {
        return GetAce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static int GetAce(MemorySegment pAcl, int dwAceIndex, MemorySegment pAce) {
        var mh$ = GetAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAce", pAcl, dwAceIndex, pAce);
            }
            return (int)mh$.invokeExact(pAcl, dwAceIndex, pAce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAclInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAclInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static FunctionDescriptor GetAclInformation$descriptor() {
        return GetAclInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MethodHandle GetAclInformation$handle() {
        return GetAclInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MemorySegment GetAclInformation$address() {
        return GetAclInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static int GetAclInformation(MemorySegment pAcl, MemorySegment pAclInformation, int nAclInformationLength, int dwAclInformationClass) {
        var mh$ = GetAclInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAclInformation", pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
            }
            return (int)mh$.invokeExact(pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSecurityW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFileSecurityW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetFileSecurityW$descriptor() {
        return GetFileSecurityW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetFileSecurityW$handle() {
        return GetFileSecurityW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetFileSecurityW$address() {
        return GetFileSecurityW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetFileSecurityW(MemorySegment lpFileName, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetFileSecurityW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSecurityW", lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKernelObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetKernelObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetKernelObjectSecurity$descriptor() {
        return GetKernelObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetKernelObjectSecurity$handle() {
        return GetKernelObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MemorySegment GetKernelObjectSecurity$address() {
        return GetKernelObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetKernelObjectSecurity(MemorySegment Handle, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetKernelObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKernelObjectSecurity", Handle, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(Handle, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLengthSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLengthSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetLengthSid$descriptor() {
        return GetLengthSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static MethodHandle GetLengthSid$handle() {
        return GetLengthSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static MemorySegment GetLengthSid$address() {
        return GetLengthSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static int GetLengthSid(MemorySegment pSid) {
        var mh$ = GetLengthSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLengthSid", pSid);
            }
            return (int)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor GetPrivateObjectSecurity$descriptor() {
        return GetPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle GetPrivateObjectSecurity$handle() {
        return GetPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment GetPrivateObjectSecurity$address() {
        return GetPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static int GetPrivateObjectSecurity(MemorySegment ObjectDescriptor, int SecurityInformation, MemorySegment ResultantDescriptor, int DescriptorLength, MemorySegment ReturnLength) {
        var mh$ = GetPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateObjectSecurity", ObjectDescriptor, SecurityInformation, ResultantDescriptor, DescriptorLength, ReturnLength);
            }
            return (int)mh$.invokeExact(ObjectDescriptor, SecurityInformation, ResultantDescriptor, DescriptorLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSecurityDescriptorControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorControl$descriptor() {
        return GetSecurityDescriptorControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static MethodHandle GetSecurityDescriptorControl$handle() {
        return GetSecurityDescriptorControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static MemorySegment GetSecurityDescriptorControl$address() {
        return GetSecurityDescriptorControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static int GetSecurityDescriptorControl(MemorySegment pSecurityDescriptor, MemorySegment pControl, MemorySegment lpdwRevision) {
        var mh$ = GetSecurityDescriptorControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorControl", pSecurityDescriptor, pControl, lpdwRevision);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pControl, lpdwRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorDacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSecurityDescriptorDacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorDacl$descriptor() {
        return GetSecurityDescriptorDacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorDacl$handle() {
        return GetSecurityDescriptorDacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorDacl$address() {
        return GetSecurityDescriptorDacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static int GetSecurityDescriptorDacl(MemorySegment pSecurityDescriptor, MemorySegment lpbDaclPresent, MemorySegment pDacl, MemorySegment lpbDaclDefaulted) {
        var mh$ = GetSecurityDescriptorDacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorDacl", pSecurityDescriptor, lpbDaclPresent, pDacl, lpbDaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, lpbDaclPresent, pDacl, lpbDaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSecurityDescriptorGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorGroup$descriptor() {
        return GetSecurityDescriptorGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorGroup$handle() {
        return GetSecurityDescriptorGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorGroup$address() {
        return GetSecurityDescriptorGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static int GetSecurityDescriptorGroup(MemorySegment pSecurityDescriptor, MemorySegment pGroup, MemorySegment lpbGroupDefaulted) {
        var mh$ = GetSecurityDescriptorGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorGroup", pSecurityDescriptor, pGroup, lpbGroupDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pGroup, lpbGroupDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSecurityDescriptorLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorLength$descriptor() {
        return GetSecurityDescriptorLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle GetSecurityDescriptorLength$handle() {
        return GetSecurityDescriptorLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment GetSecurityDescriptorLength$address() {
        return GetSecurityDescriptorLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int GetSecurityDescriptorLength(MemorySegment pSecurityDescriptor) {
        var mh$ = GetSecurityDescriptorLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorLength", pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSecurityDescriptorOwner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorOwner$descriptor() {
        return GetSecurityDescriptorOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorOwner$handle() {
        return GetSecurityDescriptorOwner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorOwner$address() {
        return GetSecurityDescriptorOwner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static int GetSecurityDescriptorOwner(MemorySegment pSecurityDescriptor, MemorySegment pOwner, MemorySegment lpbOwnerDefaulted) {
        var mh$ = GetSecurityDescriptorOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorOwner", pSecurityDescriptor, pOwner, lpbOwnerDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pOwner, lpbOwnerDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorRMControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSecurityDescriptorRMControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorRMControl$descriptor() {
        return GetSecurityDescriptorRMControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MethodHandle GetSecurityDescriptorRMControl$handle() {
        return GetSecurityDescriptorRMControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MemorySegment GetSecurityDescriptorRMControl$address() {
        return GetSecurityDescriptorRMControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static int GetSecurityDescriptorRMControl(MemorySegment SecurityDescriptor, MemorySegment RMControl) {
        var mh$ = GetSecurityDescriptorRMControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorRMControl", SecurityDescriptor, RMControl);
            }
            return (int)mh$.invokeExact(SecurityDescriptor, RMControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorSacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSecurityDescriptorSacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorSacl$descriptor() {
        return GetSecurityDescriptorSacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorSacl$handle() {
        return GetSecurityDescriptorSacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static MemorySegment GetSecurityDescriptorSacl$address() {
        return GetSecurityDescriptorSacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static int GetSecurityDescriptorSacl(MemorySegment pSecurityDescriptor, MemorySegment lpbSaclPresent, MemorySegment pSacl, MemorySegment lpbSaclDefaulted) {
        var mh$ = GetSecurityDescriptorSacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorSacl", pSecurityDescriptor, lpbSaclPresent, pSacl, lpbSaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, lpbSaclPresent, pSacl, lpbSaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidIdentifierAuthority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSidIdentifierAuthority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetSidIdentifierAuthority$descriptor() {
        return GetSidIdentifierAuthority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MethodHandle GetSidIdentifierAuthority$handle() {
        return GetSidIdentifierAuthority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MemorySegment GetSidIdentifierAuthority$address() {
        return GetSidIdentifierAuthority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MemorySegment GetSidIdentifierAuthority(MemorySegment pSid) {
        var mh$ = GetSidIdentifierAuthority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidIdentifierAuthority", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidLengthRequired {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSidLengthRequired");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static FunctionDescriptor GetSidLengthRequired$descriptor() {
        return GetSidLengthRequired.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static MethodHandle GetSidLengthRequired$handle() {
        return GetSidLengthRequired.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static MemorySegment GetSidLengthRequired$address() {
        return GetSidLengthRequired.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static int GetSidLengthRequired(byte nSubAuthorityCount) {
        var mh$ = GetSidLengthRequired.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidLengthRequired", nSubAuthorityCount);
            }
            return (int)mh$.invokeExact(nSubAuthorityCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidSubAuthority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSidSubAuthority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static FunctionDescriptor GetSidSubAuthority$descriptor() {
        return GetSidSubAuthority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MethodHandle GetSidSubAuthority$handle() {
        return GetSidSubAuthority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MemorySegment GetSidSubAuthority$address() {
        return GetSidSubAuthority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MemorySegment GetSidSubAuthority(MemorySegment pSid, int nSubAuthority) {
        var mh$ = GetSidSubAuthority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidSubAuthority", pSid, nSubAuthority);
            }
            return (MemorySegment)mh$.invokeExact(pSid, nSubAuthority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidSubAuthorityCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSidSubAuthorityCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetSidSubAuthorityCount$descriptor() {
        return GetSidSubAuthorityCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MethodHandle GetSidSubAuthorityCount$handle() {
        return GetSidSubAuthorityCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MemorySegment GetSidSubAuthorityCount$address() {
        return GetSidSubAuthorityCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MemorySegment GetSidSubAuthorityCount(MemorySegment pSid) {
        var mh$ = GetSidSubAuthorityCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidSubAuthorityCount", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTokenInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTokenInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor GetTokenInformation$descriptor() {
        return GetTokenInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle GetTokenInformation$handle() {
        return GetTokenInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static MemorySegment GetTokenInformation$address() {
        return GetTokenInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static int GetTokenInformation(MemorySegment TokenHandle, int TokenInformationClass, MemorySegment TokenInformation, int TokenInformationLength, MemorySegment ReturnLength) {
        var mh$ = GetTokenInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTokenInformation", TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsAccountDomainSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetWindowsAccountDomainSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static FunctionDescriptor GetWindowsAccountDomainSid$descriptor() {
        return GetWindowsAccountDomainSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static MethodHandle GetWindowsAccountDomainSid$handle() {
        return GetWindowsAccountDomainSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static MemorySegment GetWindowsAccountDomainSid$address() {
        return GetWindowsAccountDomainSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static int GetWindowsAccountDomainSid(MemorySegment pSid, MemorySegment pDomainSid, MemorySegment cbDomainSid) {
        var mh$ = GetWindowsAccountDomainSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsAccountDomainSid", pSid, pDomainSid, cbDomainSid);
            }
            return (int)mh$.invokeExact(pSid, pDomainSid, cbDomainSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateAnonymousToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImpersonateAnonymousToken");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static FunctionDescriptor ImpersonateAnonymousToken$descriptor() {
        return ImpersonateAnonymousToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static MethodHandle ImpersonateAnonymousToken$handle() {
        return ImpersonateAnonymousToken.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static MemorySegment ImpersonateAnonymousToken$address() {
        return ImpersonateAnonymousToken.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static int ImpersonateAnonymousToken(MemorySegment ThreadHandle) {
        var mh$ = ImpersonateAnonymousToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateAnonymousToken", ThreadHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateLoggedOnUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImpersonateLoggedOnUser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static FunctionDescriptor ImpersonateLoggedOnUser$descriptor() {
        return ImpersonateLoggedOnUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static MethodHandle ImpersonateLoggedOnUser$handle() {
        return ImpersonateLoggedOnUser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static MemorySegment ImpersonateLoggedOnUser$address() {
        return ImpersonateLoggedOnUser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static int ImpersonateLoggedOnUser(MemorySegment hToken) {
        var mh$ = ImpersonateLoggedOnUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateLoggedOnUser", hToken);
            }
            return (int)mh$.invokeExact(hToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ImpersonateSelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static FunctionDescriptor ImpersonateSelf$descriptor() {
        return ImpersonateSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static MethodHandle ImpersonateSelf$handle() {
        return ImpersonateSelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static MemorySegment ImpersonateSelf$address() {
        return ImpersonateSelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static int ImpersonateSelf(int ImpersonationLevel) {
        var mh$ = ImpersonateSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateSelf", ImpersonationLevel);
            }
            return (int)mh$.invokeExact(ImpersonationLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeAcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeAcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static FunctionDescriptor InitializeAcl$descriptor() {
        return InitializeAcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static MethodHandle InitializeAcl$handle() {
        return InitializeAcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static MemorySegment InitializeAcl$address() {
        return InitializeAcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static int InitializeAcl(MemorySegment pAcl, int nAclLength, int dwAclRevision) {
        var mh$ = InitializeAcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeAcl", pAcl, nAclLength, dwAclRevision);
            }
            return (int)mh$.invokeExact(pAcl, nAclLength, dwAclRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeSecurityDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static FunctionDescriptor InitializeSecurityDescriptor$descriptor() {
        return InitializeSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static MethodHandle InitializeSecurityDescriptor$handle() {
        return InitializeSecurityDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static MemorySegment InitializeSecurityDescriptor$address() {
        return InitializeSecurityDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static int InitializeSecurityDescriptor(MemorySegment pSecurityDescriptor, int dwRevision) {
        var mh$ = InitializeSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSecurityDescriptor", pSecurityDescriptor, dwRevision);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, dwRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitializeSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static FunctionDescriptor InitializeSid$descriptor() {
        return InitializeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static MethodHandle InitializeSid$handle() {
        return InitializeSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static MemorySegment InitializeSid$address() {
        return InitializeSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static int InitializeSid(MemorySegment Sid, MemorySegment pIdentifierAuthority, byte nSubAuthorityCount) {
        var mh$ = InitializeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSid", Sid, pIdentifierAuthority, nSubAuthorityCount);
            }
            return (int)mh$.invokeExact(Sid, pIdentifierAuthority, nSubAuthorityCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTokenRestricted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsTokenRestricted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor IsTokenRestricted$descriptor() {
        return IsTokenRestricted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static MethodHandle IsTokenRestricted$handle() {
        return IsTokenRestricted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static MemorySegment IsTokenRestricted$address() {
        return IsTokenRestricted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static int IsTokenRestricted(MemorySegment TokenHandle) {
        var mh$ = IsTokenRestricted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTokenRestricted", TokenHandle);
            }
            return (int)mh$.invokeExact(TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidAcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidAcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static FunctionDescriptor IsValidAcl$descriptor() {
        return IsValidAcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static MethodHandle IsValidAcl$handle() {
        return IsValidAcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static MemorySegment IsValidAcl$address() {
        return IsValidAcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static int IsValidAcl(MemorySegment pAcl) {
        var mh$ = IsValidAcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidAcl", pAcl);
            }
            return (int)mh$.invokeExact(pAcl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidSecurityDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor IsValidSecurityDescriptor$descriptor() {
        return IsValidSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle IsValidSecurityDescriptor$handle() {
        return IsValidSecurityDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment IsValidSecurityDescriptor$address() {
        return IsValidSecurityDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int IsValidSecurityDescriptor(MemorySegment pSecurityDescriptor) {
        var mh$ = IsValidSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidSecurityDescriptor", pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsValidSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor IsValidSid$descriptor() {
        return IsValidSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static MethodHandle IsValidSid$handle() {
        return IsValidSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static MemorySegment IsValidSid$address() {
        return IsValidSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static int IsValidSid(MemorySegment pSid) {
        var mh$ = IsValidSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidSid", pSid);
            }
            return (int)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWellKnownSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsWellKnownSid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static FunctionDescriptor IsWellKnownSid$descriptor() {
        return IsWellKnownSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static MethodHandle IsWellKnownSid$handle() {
        return IsWellKnownSid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static MemorySegment IsWellKnownSid$address() {
        return IsWellKnownSid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static int IsWellKnownSid(MemorySegment pSid, int WellKnownSidType) {
        var mh$ = IsWellKnownSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWellKnownSid", pSid, WellKnownSidType);
            }
            return (int)mh$.invokeExact(pSid, WellKnownSidType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MakeAbsoluteSD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MakeAbsoluteSD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static FunctionDescriptor MakeAbsoluteSD$descriptor() {
        return MakeAbsoluteSD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static MethodHandle MakeAbsoluteSD$handle() {
        return MakeAbsoluteSD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static MemorySegment MakeAbsoluteSD$address() {
        return MakeAbsoluteSD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static int MakeAbsoluteSD(MemorySegment pSelfRelativeSecurityDescriptor, MemorySegment pAbsoluteSecurityDescriptor, MemorySegment lpdwAbsoluteSecurityDescriptorSize, MemorySegment pDacl, MemorySegment lpdwDaclSize, MemorySegment pSacl, MemorySegment lpdwSaclSize, MemorySegment pOwner, MemorySegment lpdwOwnerSize, MemorySegment pPrimaryGroup, MemorySegment lpdwPrimaryGroupSize) {
        var mh$ = MakeAbsoluteSD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MakeAbsoluteSD", pSelfRelativeSecurityDescriptor, pAbsoluteSecurityDescriptor, lpdwAbsoluteSecurityDescriptorSize, pDacl, lpdwDaclSize, pSacl, lpdwSaclSize, pOwner, lpdwOwnerSize, pPrimaryGroup, lpdwPrimaryGroupSize);
            }
            return (int)mh$.invokeExact(pSelfRelativeSecurityDescriptor, pAbsoluteSecurityDescriptor, lpdwAbsoluteSecurityDescriptorSize, pDacl, lpdwDaclSize, pSacl, lpdwSaclSize, pOwner, lpdwOwnerSize, pPrimaryGroup, lpdwPrimaryGroupSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MakeSelfRelativeSD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MakeSelfRelativeSD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static FunctionDescriptor MakeSelfRelativeSD$descriptor() {
        return MakeSelfRelativeSD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static MethodHandle MakeSelfRelativeSD$handle() {
        return MakeSelfRelativeSD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static MemorySegment MakeSelfRelativeSD$address() {
        return MakeSelfRelativeSD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static int MakeSelfRelativeSD(MemorySegment pAbsoluteSecurityDescriptor, MemorySegment pSelfRelativeSecurityDescriptor, MemorySegment lpdwBufferLength) {
        var mh$ = MakeSelfRelativeSD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MakeSelfRelativeSD", pAbsoluteSecurityDescriptor, pSelfRelativeSecurityDescriptor, lpdwBufferLength);
            }
            return (int)mh$.invokeExact(pAbsoluteSecurityDescriptor, pSelfRelativeSecurityDescriptor, lpdwBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapGenericMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MapGenericMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor MapGenericMask$descriptor() {
        return MapGenericMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle MapGenericMask$handle() {
        return MapGenericMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MemorySegment MapGenericMask$address() {
        return MapGenericMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static void MapGenericMask(MemorySegment AccessMask, MemorySegment GenericMapping) {
        var mh$ = MapGenericMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapGenericMask", AccessMask, GenericMapping);
            }
            mh$.invokeExact(AccessMask, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCloseAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectCloseAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectCloseAuditAlarmW$descriptor() {
        return ObjectCloseAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectCloseAuditAlarmW$handle() {
        return ObjectCloseAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectCloseAuditAlarmW$address() {
        return ObjectCloseAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectCloseAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectCloseAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCloseAuditAlarmW", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectDeleteAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectDeleteAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectDeleteAuditAlarmW$descriptor() {
        return ObjectDeleteAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectDeleteAuditAlarmW$handle() {
        return ObjectDeleteAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectDeleteAuditAlarmW$address() {
        return ObjectDeleteAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectDeleteAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectDeleteAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectDeleteAuditAlarmW", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectOpenAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectOpenAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectOpenAuditAlarmW$descriptor() {
        return ObjectOpenAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectOpenAuditAlarmW$handle() {
        return ObjectOpenAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MemorySegment ObjectOpenAuditAlarmW$address() {
        return ObjectOpenAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static int ObjectOpenAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, int GrantedAccess, MemorySegment Privileges, int ObjectCreation, int AccessGranted, MemorySegment GenerateOnClose) {
        var mh$ = ObjectOpenAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectOpenAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectPrivilegeAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ObjectPrivilegeAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor ObjectPrivilegeAuditAlarmW$descriptor() {
        return ObjectPrivilegeAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle ObjectPrivilegeAuditAlarmW$handle() {
        return ObjectPrivilegeAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment ObjectPrivilegeAuditAlarmW$address() {
        return ObjectPrivilegeAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int ObjectPrivilegeAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, int DesiredAccess, MemorySegment Privileges, int AccessGranted) {
        var mh$ = ObjectPrivilegeAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectPrivilegeAuditAlarmW", SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegeCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrivilegeCheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static FunctionDescriptor PrivilegeCheck$descriptor() {
        return PrivilegeCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static MethodHandle PrivilegeCheck$handle() {
        return PrivilegeCheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static MemorySegment PrivilegeCheck$address() {
        return PrivilegeCheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static int PrivilegeCheck(MemorySegment ClientToken, MemorySegment RequiredPrivileges, MemorySegment pfResult) {
        var mh$ = PrivilegeCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegeCheck", ClientToken, RequiredPrivileges, pfResult);
            }
            return (int)mh$.invokeExact(ClientToken, RequiredPrivileges, pfResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegedServiceAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrivilegedServiceAuditAlarmW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor PrivilegedServiceAuditAlarmW$descriptor() {
        return PrivilegedServiceAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle PrivilegedServiceAuditAlarmW$handle() {
        return PrivilegedServiceAuditAlarmW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MemorySegment PrivilegedServiceAuditAlarmW$address() {
        return PrivilegedServiceAuditAlarmW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int PrivilegedServiceAuditAlarmW(MemorySegment SubsystemName, MemorySegment ServiceName, MemorySegment ClientToken, MemorySegment Privileges, int AccessGranted) {
        var mh$ = PrivilegedServiceAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegedServiceAuditAlarmW", SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuerySecurityAccessMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QuerySecurityAccessMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor QuerySecurityAccessMask$descriptor() {
        return QuerySecurityAccessMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MethodHandle QuerySecurityAccessMask$handle() {
        return QuerySecurityAccessMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MemorySegment QuerySecurityAccessMask$address() {
        return QuerySecurityAccessMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static void QuerySecurityAccessMask(int SecurityInformation, MemorySegment DesiredAccess) {
        var mh$ = QuerySecurityAccessMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuerySecurityAccessMask", SecurityInformation, DesiredAccess);
            }
            mh$.invokeExact(SecurityInformation, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RevertToSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RevertToSelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static FunctionDescriptor RevertToSelf$descriptor() {
        return RevertToSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static MethodHandle RevertToSelf$handle() {
        return RevertToSelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static MemorySegment RevertToSelf$address() {
        return RevertToSelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static int RevertToSelf() {
        var mh$ = RevertToSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RevertToSelf");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAclInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetAclInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static FunctionDescriptor SetAclInformation$descriptor() {
        return SetAclInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MethodHandle SetAclInformation$handle() {
        return SetAclInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MemorySegment SetAclInformation$address() {
        return SetAclInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static int SetAclInformation(MemorySegment pAcl, MemorySegment pAclInformation, int nAclInformationLength, int dwAclInformationClass) {
        var mh$ = SetAclInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAclInformation", pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
            }
            return (int)mh$.invokeExact(pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileSecurityW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileSecurityW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetFileSecurityW$descriptor() {
        return SetFileSecurityW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle SetFileSecurityW$handle() {
        return SetFileSecurityW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MemorySegment SetFileSecurityW$address() {
        return SetFileSecurityW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int SetFileSecurityW(MemorySegment lpFileName, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = SetFileSecurityW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileSecurityW", lpFileName, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(lpFileName, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetKernelObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetKernelObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetKernelObjectSecurity$descriptor() {
        return SetKernelObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static MethodHandle SetKernelObjectSecurity$handle() {
        return SetKernelObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static MemorySegment SetKernelObjectSecurity$address() {
        return SetKernelObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static int SetKernelObjectSecurity(MemorySegment Handle, int SecurityInformation, MemorySegment SecurityDescriptor) {
        var mh$ = SetKernelObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetKernelObjectSecurity", Handle, SecurityInformation, SecurityDescriptor);
            }
            return (int)mh$.invokeExact(Handle, SecurityInformation, SecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPrivateObjectSecurity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetPrivateObjectSecurity$descriptor() {
        return SetPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MethodHandle SetPrivateObjectSecurity$handle() {
        return SetPrivateObjectSecurity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MemorySegment SetPrivateObjectSecurity$address() {
        return SetPrivateObjectSecurity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static int SetPrivateObjectSecurity(int SecurityInformation, MemorySegment ModificationDescriptor, MemorySegment ObjectsSecurityDescriptor, MemorySegment GenericMapping, MemorySegment Token) {
        var mh$ = SetPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPrivateObjectSecurity", SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, GenericMapping, Token);
            }
            return (int)mh$.invokeExact(SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, GenericMapping, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPrivateObjectSecurityEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetPrivateObjectSecurityEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetPrivateObjectSecurityEx$descriptor() {
        return SetPrivateObjectSecurityEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MethodHandle SetPrivateObjectSecurityEx$handle() {
        return SetPrivateObjectSecurityEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MemorySegment SetPrivateObjectSecurityEx$address() {
        return SetPrivateObjectSecurityEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static int SetPrivateObjectSecurityEx(int SecurityInformation, MemorySegment ModificationDescriptor, MemorySegment ObjectsSecurityDescriptor, int AutoInheritFlags, MemorySegment GenericMapping, MemorySegment Token) {
        var mh$ = SetPrivateObjectSecurityEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPrivateObjectSecurityEx", SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, AutoInheritFlags, GenericMapping, Token);
            }
            return (int)mh$.invokeExact(SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, AutoInheritFlags, GenericMapping, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityAccessMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSecurityAccessMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor SetSecurityAccessMask$descriptor() {
        return SetSecurityAccessMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MethodHandle SetSecurityAccessMask$handle() {
        return SetSecurityAccessMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MemorySegment SetSecurityAccessMask$address() {
        return SetSecurityAccessMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static void SetSecurityAccessMask(int SecurityInformation, MemorySegment DesiredAccess) {
        var mh$ = SetSecurityAccessMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityAccessMask", SecurityInformation, DesiredAccess);
            }
            mh$.invokeExact(SecurityInformation, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSecurityDescriptorControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorControl$descriptor() {
        return SetSecurityDescriptorControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static MethodHandle SetSecurityDescriptorControl$handle() {
        return SetSecurityDescriptorControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static MemorySegment SetSecurityDescriptorControl$address() {
        return SetSecurityDescriptorControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static int SetSecurityDescriptorControl(MemorySegment pSecurityDescriptor, short ControlBitsOfInterest, short ControlBitsToSet) {
        var mh$ = SetSecurityDescriptorControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorControl", pSecurityDescriptor, ControlBitsOfInterest, ControlBitsToSet);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, ControlBitsOfInterest, ControlBitsToSet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorDacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSecurityDescriptorDacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorDacl$descriptor() {
        return SetSecurityDescriptorDacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorDacl$handle() {
        return SetSecurityDescriptorDacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorDacl$address() {
        return SetSecurityDescriptorDacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static int SetSecurityDescriptorDacl(MemorySegment pSecurityDescriptor, int bDaclPresent, MemorySegment pDacl, int bDaclDefaulted) {
        var mh$ = SetSecurityDescriptorDacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorDacl", pSecurityDescriptor, bDaclPresent, pDacl, bDaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, bDaclPresent, pDacl, bDaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSecurityDescriptorGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorGroup$descriptor() {
        return SetSecurityDescriptorGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorGroup$handle() {
        return SetSecurityDescriptorGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorGroup$address() {
        return SetSecurityDescriptorGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static int SetSecurityDescriptorGroup(MemorySegment pSecurityDescriptor, MemorySegment pGroup, int bGroupDefaulted) {
        var mh$ = SetSecurityDescriptorGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorGroup", pSecurityDescriptor, pGroup, bGroupDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pGroup, bGroupDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSecurityDescriptorOwner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorOwner$descriptor() {
        return SetSecurityDescriptorOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorOwner$handle() {
        return SetSecurityDescriptorOwner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorOwner$address() {
        return SetSecurityDescriptorOwner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static int SetSecurityDescriptorOwner(MemorySegment pSecurityDescriptor, MemorySegment pOwner, int bOwnerDefaulted) {
        var mh$ = SetSecurityDescriptorOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorOwner", pSecurityDescriptor, pOwner, bOwnerDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pOwner, bOwnerDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorRMControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSecurityDescriptorRMControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorRMControl$descriptor() {
        return SetSecurityDescriptorRMControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MethodHandle SetSecurityDescriptorRMControl$handle() {
        return SetSecurityDescriptorRMControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MemorySegment SetSecurityDescriptorRMControl$address() {
        return SetSecurityDescriptorRMControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static int SetSecurityDescriptorRMControl(MemorySegment SecurityDescriptor, MemorySegment RMControl) {
        var mh$ = SetSecurityDescriptorRMControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorRMControl", SecurityDescriptor, RMControl);
            }
            return (int)mh$.invokeExact(SecurityDescriptor, RMControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorSacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetSecurityDescriptorSacl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorSacl$descriptor() {
        return SetSecurityDescriptorSacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorSacl$handle() {
        return SetSecurityDescriptorSacl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static MemorySegment SetSecurityDescriptorSacl$address() {
        return SetSecurityDescriptorSacl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static int SetSecurityDescriptorSacl(MemorySegment pSecurityDescriptor, int bSaclPresent, MemorySegment pSacl, int bSaclDefaulted) {
        var mh$ = SetSecurityDescriptorSacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorSacl", pSecurityDescriptor, bSaclPresent, pSacl, bSaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, bSaclPresent, pSacl, bSaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTokenInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTokenInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static FunctionDescriptor SetTokenInformation$descriptor() {
        return SetTokenInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static MethodHandle SetTokenInformation$handle() {
        return SetTokenInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static MemorySegment SetTokenInformation$address() {
        return SetTokenInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static int SetTokenInformation(MemorySegment TokenHandle, int TokenInformationClass, MemorySegment TokenInformation, int TokenInformationLength) {
        var mh$ = SetTokenInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTokenInformation", TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
            }
            return (int)mh$.invokeExact(TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCachedSigningLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCachedSigningLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static FunctionDescriptor SetCachedSigningLevel$descriptor() {
        return SetCachedSigningLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static MethodHandle SetCachedSigningLevel$handle() {
        return SetCachedSigningLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static MemorySegment SetCachedSigningLevel$address() {
        return SetCachedSigningLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static int SetCachedSigningLevel(MemorySegment SourceFiles, int SourceFileCount, int Flags, MemorySegment TargetFile) {
        var mh$ = SetCachedSigningLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCachedSigningLevel", SourceFiles, SourceFileCount, Flags, TargetFile);
            }
            return (int)mh$.invokeExact(SourceFiles, SourceFileCount, Flags, TargetFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCachedSigningLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCachedSigningLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static FunctionDescriptor GetCachedSigningLevel$descriptor() {
        return GetCachedSigningLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static MethodHandle GetCachedSigningLevel$handle() {
        return GetCachedSigningLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static MemorySegment GetCachedSigningLevel$address() {
        return GetCachedSigningLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static int GetCachedSigningLevel(MemorySegment File, MemorySegment Flags, MemorySegment SigningLevel, MemorySegment Thumbprint, MemorySegment ThumbprintSize, MemorySegment ThumbprintAlgorithm) {
        var mh$ = GetCachedSigningLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCachedSigningLevel", File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
            }
            return (int)mh$.invokeExact(File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CveEventWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CveEventWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static FunctionDescriptor CveEventWrite$descriptor() {
        return CveEventWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static MethodHandle CveEventWrite$handle() {
        return CveEventWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static MemorySegment CveEventWrite$address() {
        return CveEventWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static int CveEventWrite(MemorySegment CveId, MemorySegment AdditionalDetails) {
        var mh$ = CveEventWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CveEventWrite", CveId, AdditionalDetails);
            }
            return (int)mh$.invokeExact(CveId, AdditionalDetails);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeriveCapabilitySidsFromName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeriveCapabilitySidsFromName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static FunctionDescriptor DeriveCapabilitySidsFromName$descriptor() {
        return DeriveCapabilitySidsFromName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static MethodHandle DeriveCapabilitySidsFromName$handle() {
        return DeriveCapabilitySidsFromName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static MemorySegment DeriveCapabilitySidsFromName$address() {
        return DeriveCapabilitySidsFromName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static int DeriveCapabilitySidsFromName(MemorySegment CapName, MemorySegment CapabilityGroupSids, MemorySegment CapabilityGroupSidCount, MemorySegment CapabilitySids, MemorySegment CapabilitySidCount) {
        var mh$ = DeriveCapabilitySidsFromName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeriveCapabilitySidsFromName", CapName, CapabilityGroupSids, CapabilityGroupSidCount, CapabilitySids, CapabilitySidCount);
            }
            return (int)mh$.invokeExact(CapName, CapabilityGroupSids, CapabilityGroupSidCount, CapabilitySids, CapabilitySidCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateNamespaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreatePrivateNamespaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor CreatePrivateNamespaceW$descriptor() {
        return CreatePrivateNamespaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle CreatePrivateNamespaceW$handle() {
        return CreatePrivateNamespaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceW$address() {
        return CreatePrivateNamespaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceW(MemorySegment lpPrivateNamespaceAttributes, MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = CreatePrivateNamespaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateNamespaceW", lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenPrivateNamespaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenPrivateNamespaceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor OpenPrivateNamespaceW$descriptor() {
        return OpenPrivateNamespaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle OpenPrivateNamespaceW$handle() {
        return OpenPrivateNamespaceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceW$address() {
        return OpenPrivateNamespaceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceW(MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = OpenPrivateNamespaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenPrivateNamespaceW", lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClosePrivateNamespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClosePrivateNamespace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static FunctionDescriptor ClosePrivateNamespace$descriptor() {
        return ClosePrivateNamespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static MethodHandle ClosePrivateNamespace$handle() {
        return ClosePrivateNamespace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static MemorySegment ClosePrivateNamespace$address() {
        return ClosePrivateNamespace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static byte ClosePrivateNamespace(MemorySegment Handle, int Flags) {
        var mh$ = ClosePrivateNamespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClosePrivateNamespace", Handle, Flags);
            }
            return (byte)mh$.invokeExact(Handle, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBoundaryDescriptorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateBoundaryDescriptorW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateBoundaryDescriptorW$descriptor() {
        return CreateBoundaryDescriptorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MethodHandle CreateBoundaryDescriptorW$handle() {
        return CreateBoundaryDescriptorW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorW$address() {
        return CreateBoundaryDescriptorW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorW(MemorySegment Name, int Flags) {
        var mh$ = CreateBoundaryDescriptorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBoundaryDescriptorW", Name, Flags);
            }
            return (MemorySegment)mh$.invokeExact(Name, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddSIDToBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddSIDToBoundaryDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static FunctionDescriptor AddSIDToBoundaryDescriptor$descriptor() {
        return AddSIDToBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static MethodHandle AddSIDToBoundaryDescriptor$handle() {
        return AddSIDToBoundaryDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static MemorySegment AddSIDToBoundaryDescriptor$address() {
        return AddSIDToBoundaryDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static int AddSIDToBoundaryDescriptor(MemorySegment BoundaryDescriptor, MemorySegment RequiredSid) {
        var mh$ = AddSIDToBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddSIDToBoundaryDescriptor", BoundaryDescriptor, RequiredSid);
            }
            return (int)mh$.invokeExact(BoundaryDescriptor, RequiredSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteBoundaryDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static FunctionDescriptor DeleteBoundaryDescriptor$descriptor() {
        return DeleteBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static MethodHandle DeleteBoundaryDescriptor$handle() {
        return DeleteBoundaryDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static MemorySegment DeleteBoundaryDescriptor$address() {
        return DeleteBoundaryDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static void DeleteBoundaryDescriptor(MemorySegment BoundaryDescriptor) {
        var mh$ = DeleteBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteBoundaryDescriptor", BoundaryDescriptor);
            }
            mh$.invokeExact(BoundaryDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaHighestNodeNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaHighestNodeNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaHighestNodeNumber$descriptor() {
        return GetNumaHighestNodeNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static MethodHandle GetNumaHighestNodeNumber$handle() {
        return GetNumaHighestNodeNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static MemorySegment GetNumaHighestNodeNumber$address() {
        return GetNumaHighestNodeNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static int GetNumaHighestNodeNumber(MemorySegment HighestNodeNumber) {
        var mh$ = GetNumaHighestNodeNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaHighestNodeNumber", HighestNodeNumber);
            }
            return (int)mh$.invokeExact(HighestNodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMaskEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaNodeProcessorMaskEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMaskEx$descriptor() {
        return GetNumaNodeProcessorMaskEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMaskEx$handle() {
        return GetNumaNodeProcessorMaskEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static MemorySegment GetNumaNodeProcessorMaskEx$address() {
        return GetNumaNodeProcessorMaskEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static int GetNumaNodeProcessorMaskEx(short Node, MemorySegment ProcessorMask) {
        var mh$ = GetNumaNodeProcessorMaskEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMaskEx", Node, ProcessorMask);
            }
            return (int)mh$.invokeExact(Node, ProcessorMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProximityNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNumaProximityNodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProximityNodeEx$descriptor() {
        return GetNumaProximityNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProximityNodeEx$handle() {
        return GetNumaProximityNodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static MemorySegment GetNumaProximityNodeEx$address() {
        return GetNumaProximityNodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaProximityNodeEx(int ProximityId, MemorySegment NodeNumber) {
        var mh$ = GetNumaProximityNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProximityNodeEx", ProximityId, NodeNumber);
            }
            return (int)mh$.invokeExact(ProximityId, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessGroupAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static FunctionDescriptor GetProcessGroupAffinity$descriptor() {
        return GetProcessGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static MethodHandle GetProcessGroupAffinity$handle() {
        return GetProcessGroupAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static MemorySegment GetProcessGroupAffinity$address() {
        return GetProcessGroupAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static int GetProcessGroupAffinity(MemorySegment hProcess, MemorySegment GroupCount, MemorySegment GroupArray) {
        var mh$ = GetProcessGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessGroupAffinity", hProcess, GroupCount, GroupArray);
            }
            return (int)mh$.invokeExact(hProcess, GroupCount, GroupArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadGroupAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static FunctionDescriptor GetThreadGroupAffinity$descriptor() {
        return GetThreadGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static MethodHandle GetThreadGroupAffinity$handle() {
        return GetThreadGroupAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static MemorySegment GetThreadGroupAffinity$address() {
        return GetThreadGroupAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static int GetThreadGroupAffinity(MemorySegment hThread, MemorySegment GroupAffinity) {
        var mh$ = GetThreadGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadGroupAffinity", hThread, GroupAffinity);
            }
            return (int)mh$.invokeExact(hThread, GroupAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadGroupAffinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static FunctionDescriptor SetThreadGroupAffinity$descriptor() {
        return SetThreadGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static MethodHandle SetThreadGroupAffinity$handle() {
        return SetThreadGroupAffinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static MemorySegment SetThreadGroupAffinity$address() {
        return SetThreadGroupAffinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static int SetThreadGroupAffinity(MemorySegment hThread, MemorySegment GroupAffinity, MemorySegment PreviousGroupAffinity) {
        var mh$ = SetThreadGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadGroupAffinity", hThread, GroupAffinity, PreviousGroupAffinity);
            }
            return (int)mh$.invokeExact(hThread, GroupAffinity, PreviousGroupAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAppContainerNamedObjectPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAppContainerNamedObjectPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static FunctionDescriptor GetAppContainerNamedObjectPath$descriptor() {
        return GetAppContainerNamedObjectPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static MethodHandle GetAppContainerNamedObjectPath$handle() {
        return GetAppContainerNamedObjectPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static MemorySegment GetAppContainerNamedObjectPath$address() {
        return GetAppContainerNamedObjectPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static int GetAppContainerNamedObjectPath(MemorySegment Token, MemorySegment AppContainerSid, int ObjectPathLength, MemorySegment ObjectPath, MemorySegment ReturnLength) {
        var mh$ = GetAppContainerNamedObjectPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAppContainerNamedObjectPath", Token, AppContainerSid, ObjectPathLength, ObjectPath, ReturnLength);
            }
            return (int)mh$.invokeExact(Token, AppContainerSid, ObjectPathLength, ObjectPath, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryThreadCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static FunctionDescriptor QueryThreadCycleTime$descriptor() {
        return QueryThreadCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static MethodHandle QueryThreadCycleTime$handle() {
        return QueryThreadCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static MemorySegment QueryThreadCycleTime$address() {
        return QueryThreadCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static int QueryThreadCycleTime(MemorySegment ThreadHandle, MemorySegment CycleTime) {
        var mh$ = QueryThreadCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadCycleTime", ThreadHandle, CycleTime);
            }
            return (int)mh$.invokeExact(ThreadHandle, CycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProcessCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryProcessCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static FunctionDescriptor QueryProcessCycleTime$descriptor() {
        return QueryProcessCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static MethodHandle QueryProcessCycleTime$handle() {
        return QueryProcessCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static MemorySegment QueryProcessCycleTime$address() {
        return QueryProcessCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static int QueryProcessCycleTime(MemorySegment ProcessHandle, MemorySegment CycleTime) {
        var mh$ = QueryProcessCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProcessCycleTime", ProcessHandle, CycleTime);
            }
            return (int)mh$.invokeExact(ProcessHandle, CycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIdleProcessorCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryIdleProcessorCycleTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static FunctionDescriptor QueryIdleProcessorCycleTime$descriptor() {
        return QueryIdleProcessorCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MethodHandle QueryIdleProcessorCycleTime$handle() {
        return QueryIdleProcessorCycleTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MemorySegment QueryIdleProcessorCycleTime$address() {
        return QueryIdleProcessorCycleTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static int QueryIdleProcessorCycleTime(MemorySegment BufferLength, MemorySegment ProcessorIdleCycleTime) {
        var mh$ = QueryIdleProcessorCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIdleProcessorCycleTime", BufferLength, ProcessorIdleCycleTime);
            }
            return (int)mh$.invokeExact(BufferLength, ProcessorIdleCycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIdleProcessorCycleTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryIdleProcessorCycleTimeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static FunctionDescriptor QueryIdleProcessorCycleTimeEx$descriptor() {
        return QueryIdleProcessorCycleTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MethodHandle QueryIdleProcessorCycleTimeEx$handle() {
        return QueryIdleProcessorCycleTimeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MemorySegment QueryIdleProcessorCycleTimeEx$address() {
        return QueryIdleProcessorCycleTimeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static int QueryIdleProcessorCycleTimeEx(short Group, MemorySegment BufferLength, MemorySegment ProcessorIdleCycleTime) {
        var mh$ = QueryIdleProcessorCycleTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIdleProcessorCycleTimeEx", Group, BufferLength, ProcessorIdleCycleTime);
            }
            return (int)mh$.invokeExact(Group, BufferLength, ProcessorIdleCycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInterruptTimePrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryInterruptTimePrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static FunctionDescriptor QueryInterruptTimePrecise$descriptor() {
        return QueryInterruptTimePrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static MethodHandle QueryInterruptTimePrecise$handle() {
        return QueryInterruptTimePrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static MemorySegment QueryInterruptTimePrecise$address() {
        return QueryInterruptTimePrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static void QueryInterruptTimePrecise(MemorySegment lpInterruptTimePrecise) {
        var mh$ = QueryInterruptTimePrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInterruptTimePrecise", lpInterruptTimePrecise);
            }
            mh$.invokeExact(lpInterruptTimePrecise);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUnbiasedInterruptTimePrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryUnbiasedInterruptTimePrecise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static FunctionDescriptor QueryUnbiasedInterruptTimePrecise$descriptor() {
        return QueryUnbiasedInterruptTimePrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static MethodHandle QueryUnbiasedInterruptTimePrecise$handle() {
        return QueryUnbiasedInterruptTimePrecise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static MemorySegment QueryUnbiasedInterruptTimePrecise$address() {
        return QueryUnbiasedInterruptTimePrecise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static void QueryUnbiasedInterruptTimePrecise(MemorySegment lpUnbiasedInterruptTimePrecise) {
        var mh$ = QueryUnbiasedInterruptTimePrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUnbiasedInterruptTimePrecise", lpUnbiasedInterruptTimePrecise);
            }
            mh$.invokeExact(lpUnbiasedInterruptTimePrecise);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInterruptTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryInterruptTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static FunctionDescriptor QueryInterruptTime$descriptor() {
        return QueryInterruptTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static MethodHandle QueryInterruptTime$handle() {
        return QueryInterruptTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static MemorySegment QueryInterruptTime$address() {
        return QueryInterruptTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static void QueryInterruptTime(MemorySegment lpInterruptTime) {
        var mh$ = QueryInterruptTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInterruptTime", lpInterruptTime);
            }
            mh$.invokeExact(lpInterruptTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUnbiasedInterruptTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryUnbiasedInterruptTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static FunctionDescriptor QueryUnbiasedInterruptTime$descriptor() {
        return QueryUnbiasedInterruptTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static MethodHandle QueryUnbiasedInterruptTime$handle() {
        return QueryUnbiasedInterruptTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static MemorySegment QueryUnbiasedInterruptTime$address() {
        return QueryUnbiasedInterruptTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static int QueryUnbiasedInterruptTime(MemorySegment UnbiasedTime) {
        var mh$ = QueryUnbiasedInterruptTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUnbiasedInterruptTime", UnbiasedTime);
            }
            return (int)mh$.invokeExact(UnbiasedTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryAuxiliaryCounterFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryAuxiliaryCounterFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static FunctionDescriptor QueryAuxiliaryCounterFrequency$descriptor() {
        return QueryAuxiliaryCounterFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static MethodHandle QueryAuxiliaryCounterFrequency$handle() {
        return QueryAuxiliaryCounterFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static MemorySegment QueryAuxiliaryCounterFrequency$address() {
        return QueryAuxiliaryCounterFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static int QueryAuxiliaryCounterFrequency(MemorySegment lpAuxiliaryCounterFrequency) {
        var mh$ = QueryAuxiliaryCounterFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryAuxiliaryCounterFrequency", lpAuxiliaryCounterFrequency);
            }
            return (int)mh$.invokeExact(lpAuxiliaryCounterFrequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertAuxiliaryCounterToPerformanceCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConvertAuxiliaryCounterToPerformanceCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static FunctionDescriptor ConvertAuxiliaryCounterToPerformanceCounter$descriptor() {
        return ConvertAuxiliaryCounterToPerformanceCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MethodHandle ConvertAuxiliaryCounterToPerformanceCounter$handle() {
        return ConvertAuxiliaryCounterToPerformanceCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MemorySegment ConvertAuxiliaryCounterToPerformanceCounter$address() {
        return ConvertAuxiliaryCounterToPerformanceCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static int ConvertAuxiliaryCounterToPerformanceCounter(long ullAuxiliaryCounterValue, MemorySegment lpPerformanceCounterValue, MemorySegment lpConversionError) {
        var mh$ = ConvertAuxiliaryCounterToPerformanceCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertAuxiliaryCounterToPerformanceCounter", ullAuxiliaryCounterValue, lpPerformanceCounterValue, lpConversionError);
            }
            return (int)mh$.invokeExact(ullAuxiliaryCounterValue, lpPerformanceCounterValue, lpConversionError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertPerformanceCounterToAuxiliaryCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConvertPerformanceCounterToAuxiliaryCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static FunctionDescriptor ConvertPerformanceCounterToAuxiliaryCounter$descriptor() {
        return ConvertPerformanceCounterToAuxiliaryCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MethodHandle ConvertPerformanceCounterToAuxiliaryCounter$handle() {
        return ConvertPerformanceCounterToAuxiliaryCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MemorySegment ConvertPerformanceCounterToAuxiliaryCounter$address() {
        return ConvertPerformanceCounterToAuxiliaryCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static int ConvertPerformanceCounterToAuxiliaryCounter(long ullPerformanceCounterValue, MemorySegment lpAuxiliaryCounterValue, MemorySegment lpConversionError) {
        var mh$ = ConvertPerformanceCounterToAuxiliaryCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertPerformanceCounterToAuxiliaryCounter", ullPerformanceCounterValue, lpAuxiliaryCounterValue, lpConversionError);
            }
            return (int)mh$.invokeExact(ullPerformanceCounterValue, lpAuxiliaryCounterValue, lpConversionError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LPVOID LPLDT_ENTRY
     * }
     */
    public static final AddressLayout LPLDT_ENTRY = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMPROP {
     *     WORD wPacketLength;
     *     WORD wPacketVersion;
     *     DWORD dwServiceMask;
     *     DWORD dwReserved1;
     *     DWORD dwMaxTxQueue;
     *     DWORD dwMaxRxQueue;
     *     DWORD dwMaxBaud;
     *     DWORD dwProvSubType;
     *     DWORD dwProvCapabilities;
     *     DWORD dwSettableParams;
     *     DWORD dwSettableBaud;
     *     WORD wSettableData;
     *     WORD wSettableStopParity;
     *     DWORD dwCurrentTxQueue;
     *     DWORD dwCurrentRxQueue;
     *     DWORD dwProvSpec1;
     *     DWORD dwProvSpec2;
     *     WCHAR wcProvChar[1];
     * } *LPCOMMPROP
     * }
     */
    public static final AddressLayout LPCOMMPROP = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMSTAT {
     *     DWORD fCtsHold : 1;
     *     DWORD fDsrHold : 1;
     *     DWORD fRlsdHold : 1;
     *     DWORD fXoffHold : 1;
     *     DWORD fXoffSent : 1;
     *     DWORD fEof : 1;
     *     DWORD fTxim : 1;
     *     DWORD fReserved : 25;
     *     DWORD cbInQue;
     *     DWORD cbOutQue;
     * } *LPCOMSTAT
     * }
     */
    public static final AddressLayout LPCOMSTAT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DCB {
     *     DWORD DCBlength;
     *     DWORD BaudRate;
     *     DWORD fBinary : 1;
     *     DWORD fParity : 1;
     *     DWORD fOutxCtsFlow : 1;
     *     DWORD fOutxDsrFlow : 1;
     *     DWORD fDtrControl : 2;
     *     DWORD fDsrSensitivity : 1;
     *     DWORD fTXContinueOnXoff : 1;
     *     DWORD fOutX : 1;
     *     DWORD fInX : 1;
     *     DWORD fErrorChar : 1;
     *     DWORD fNull : 1;
     *     DWORD fRtsControl : 2;
     *     DWORD fAbortOnError : 1;
     *     DWORD fDummy2 : 17;
     *     WORD wReserved;
     *     WORD XonLim;
     *     WORD XoffLim;
     *     BYTE ByteSize;
     *     BYTE Parity;
     *     BYTE StopBits;
     *     char XonChar;
     *     char XoffChar;
     *     char ErrorChar;
     *     char EofChar;
     *     char EvtChar;
     *     WORD wReserved1;
     * } *LPDCB
     * }
     */
    public static final AddressLayout LPDCB = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMTIMEOUTS {
     *     DWORD ReadIntervalTimeout;
     *     DWORD ReadTotalTimeoutMultiplier;
     *     DWORD ReadTotalTimeoutConstant;
     *     DWORD WriteTotalTimeoutMultiplier;
     *     DWORD WriteTotalTimeoutConstant;
     * } *LPCOMMTIMEOUTS
     * }
     */
    public static final AddressLayout LPCOMMTIMEOUTS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMCONFIG {
     *     DWORD dwSize;
     *     WORD wVersion;
     *     WORD wReserved;
     *     DCB dcb;
     *     DWORD dwProviderSubType;
     *     DWORD dwProviderOffset;
     *     DWORD dwProviderSize;
     *     WCHAR wcProviderData[1];
     * } *LPCOMMCONFIG
     * }
     */
    public static final AddressLayout LPCOMMCONFIG = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORYSTATUS {
     *     DWORD dwLength;
     *     DWORD dwMemoryLoad;
     *     SIZE_T dwTotalPhys;
     *     SIZE_T dwAvailPhys;
     *     SIZE_T dwTotalPageFile;
     *     SIZE_T dwAvailPageFile;
     *     SIZE_T dwTotalVirtual;
     *     SIZE_T dwAvailVirtual;
     * } *LPMEMORYSTATUS
     * }
     */
    public static final AddressLayout LPMEMORYSTATUS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JIT_DEBUG_INFO {
     *     DWORD dwSize;
     *     DWORD dwProcessorArchitecture;
     *     DWORD dwThreadID;
     *     DWORD dwReserved0;
     *     ULONG64 lpExceptionAddress;
     *     ULONG64 lpExceptionRecord;
     *     ULONG64 lpContextRecord;
     * } *LPJIT_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef JIT_DEBUG_INFO *LPJIT_DEBUG_INFO32
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO32 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef JIT_DEBUG_INFO *LPJIT_DEBUG_INFO64
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO64 = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD
     * }
     */
    public static final AddressLayout LPEXCEPTION_RECORD = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS
     * }
     */
    public static final AddressLayout LPEXCEPTION_POINTERS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFSTRUCT {
     *     BYTE cBytes;
     *     BYTE fFixedDisk;
     *     WORD nErrCode;
     *     WORD Reserved1;
     *     WORD Reserved2;
     *     CHAR szPathName[128];
     * } *LPOFSTRUCT
     * }
     */
    public static final AddressLayout LPOFSTRUCT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFSTRUCT {
     *     BYTE cBytes;
     *     BYTE fFixedDisk;
     *     WORD nErrCode;
     *     WORD Reserved1;
     *     WORD Reserved2;
     *     CHAR szPathName[128];
     * } *POFSTRUCT
     * }
     */
    public static final AddressLayout POFSTRUCT = freeglut_h.C_POINTER;

    private static class WinMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WinMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static FunctionDescriptor WinMain$descriptor() {
        return WinMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MethodHandle WinMain$handle() {
        return WinMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MemorySegment WinMain$address() {
        return WinMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static int WinMain(MemorySegment hInstance, MemorySegment hPrevInstance, MemorySegment lpCmdLine, int nShowCmd) {
        var mh$ = WinMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinMain", hInstance, hPrevInstance, lpCmdLine, nShowCmd);
            }
            return (int)mh$.invokeExact(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wWinMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wWinMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static FunctionDescriptor wWinMain$descriptor() {
        return wWinMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MethodHandle wWinMain$handle() {
        return wWinMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MemorySegment wWinMain$address() {
        return wWinMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static int wWinMain(MemorySegment hInstance, MemorySegment hPrevInstance, MemorySegment lpCmdLine, int nShowCmd) {
        var mh$ = wWinMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wWinMain", hInstance, hPrevInstance, lpCmdLine, nShowCmd);
            }
            return (int)mh$.invokeExact(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor GlobalAlloc$descriptor() {
        return GlobalAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle GlobalAlloc$handle() {
        return GlobalAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment GlobalAlloc$address() {
        return GlobalAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment GlobalAlloc(int uFlags, long dwBytes) {
        var mh$ = GlobalAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAlloc", uFlags, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(uFlags, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalReAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static FunctionDescriptor GlobalReAlloc$descriptor() {
        return GlobalReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MethodHandle GlobalReAlloc$handle() {
        return GlobalReAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MemorySegment GlobalReAlloc$address() {
        return GlobalReAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MemorySegment GlobalReAlloc(MemorySegment hMem, long dwBytes, int uFlags) {
        var mh$ = GlobalReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalReAlloc", hMem, dwBytes, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hMem, dwBytes, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalSize$descriptor() {
        return GlobalSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalSize$handle() {
        return GlobalSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalSize$address() {
        return GlobalSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static long GlobalSize(MemorySegment hMem) {
        var mh$ = GlobalSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalSize", hMem);
            }
            return (long)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnlock$descriptor() {
        return GlobalUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnlock$handle() {
        return GlobalUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalUnlock$address() {
        return GlobalUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static int GlobalUnlock(MemorySegment hMem) {
        var mh$ = GlobalUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnlock", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalLock$descriptor() {
        return GlobalLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalLock$handle() {
        return GlobalLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalLock$address() {
        return GlobalLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalLock(MemorySegment hMem) {
        var mh$ = GlobalLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalLock", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFlags$descriptor() {
        return GlobalFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFlags$handle() {
        return GlobalFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFlags$address() {
        return GlobalFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static int GlobalFlags(MemorySegment hMem) {
        var mh$ = GlobalFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFlags", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static FunctionDescriptor GlobalHandle$descriptor() {
        return GlobalHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MethodHandle GlobalHandle$handle() {
        return GlobalHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment GlobalHandle$address() {
        return GlobalHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment GlobalHandle(MemorySegment pMem) {
        var mh$ = GlobalHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalHandle", pMem);
            }
            return (MemorySegment)mh$.invokeExact(pMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFree$descriptor() {
        return GlobalFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFree$handle() {
        return GlobalFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFree$address() {
        return GlobalFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFree(MemorySegment hMem) {
        var mh$ = GlobalFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFree", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static FunctionDescriptor GlobalCompact$descriptor() {
        return GlobalCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static MethodHandle GlobalCompact$handle() {
        return GlobalCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static MemorySegment GlobalCompact$address() {
        return GlobalCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static long GlobalCompact(int dwMinFree) {
        var mh$ = GlobalCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalCompact", dwMinFree);
            }
            return (long)mh$.invokeExact(dwMinFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalFix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFix$descriptor() {
        return GlobalFix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFix$handle() {
        return GlobalFix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFix$address() {
        return GlobalFix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static void GlobalFix(MemorySegment hMem) {
        var mh$ = GlobalFix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFix", hMem);
            }
            mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnfix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalUnfix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnfix$descriptor() {
        return GlobalUnfix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnfix$handle() {
        return GlobalUnfix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalUnfix$address() {
        return GlobalUnfix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static void GlobalUnfix(MemorySegment hMem) {
        var mh$ = GlobalUnfix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnfix", hMem);
            }
            mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalWire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalWire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalWire$descriptor() {
        return GlobalWire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalWire$handle() {
        return GlobalWire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalWire$address() {
        return GlobalWire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalWire(MemorySegment hMem) {
        var mh$ = GlobalWire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalWire", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnWire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalUnWire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnWire$descriptor() {
        return GlobalUnWire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnWire$handle() {
        return GlobalUnWire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalUnWire$address() {
        return GlobalUnWire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static int GlobalUnWire(MemorySegment hMem) {
        var mh$ = GlobalUnWire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnWire", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalMemoryStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalMemoryStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static FunctionDescriptor GlobalMemoryStatus$descriptor() {
        return GlobalMemoryStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static MethodHandle GlobalMemoryStatus$handle() {
        return GlobalMemoryStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static MemorySegment GlobalMemoryStatus$address() {
        return GlobalMemoryStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static void GlobalMemoryStatus(MemorySegment lpBuffer) {
        var mh$ = GlobalMemoryStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalMemoryStatus", lpBuffer);
            }
            mh$.invokeExact(lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static FunctionDescriptor LocalAlloc$descriptor() {
        return LocalAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MethodHandle LocalAlloc$handle() {
        return LocalAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MemorySegment LocalAlloc$address() {
        return LocalAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MemorySegment LocalAlloc(int uFlags, long uBytes) {
        var mh$ = LocalAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalAlloc", uFlags, uBytes);
            }
            return (MemorySegment)mh$.invokeExact(uFlags, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalReAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static FunctionDescriptor LocalReAlloc$descriptor() {
        return LocalReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MethodHandle LocalReAlloc$handle() {
        return LocalReAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MemorySegment LocalReAlloc$address() {
        return LocalReAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MemorySegment LocalReAlloc(MemorySegment hMem, long uBytes, int uFlags) {
        var mh$ = LocalReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalReAlloc", hMem, uBytes, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hMem, uBytes, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalLock$descriptor() {
        return LocalLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalLock$handle() {
        return LocalLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalLock$address() {
        return LocalLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalLock(MemorySegment hMem) {
        var mh$ = LocalLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalLock", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static FunctionDescriptor LocalHandle$descriptor() {
        return LocalHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MethodHandle LocalHandle$handle() {
        return LocalHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment LocalHandle$address() {
        return LocalHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment LocalHandle(MemorySegment pMem) {
        var mh$ = LocalHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalHandle", pMem);
            }
            return (MemorySegment)mh$.invokeExact(pMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalUnlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalUnlock$descriptor() {
        return LocalUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalUnlock$handle() {
        return LocalUnlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalUnlock$address() {
        return LocalUnlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static int LocalUnlock(MemorySegment hMem) {
        var mh$ = LocalUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalUnlock", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalSize$descriptor() {
        return LocalSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalSize$handle() {
        return LocalSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalSize$address() {
        return LocalSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static long LocalSize(MemorySegment hMem) {
        var mh$ = LocalSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalSize", hMem);
            }
            return (long)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalFlags$descriptor() {
        return LocalFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalFlags$handle() {
        return LocalFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalFlags$address() {
        return LocalFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static int LocalFlags(MemorySegment hMem) {
        var mh$ = LocalFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFlags", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalFree$descriptor() {
        return LocalFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalFree$handle() {
        return LocalFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalFree$address() {
        return LocalFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalFree(MemorySegment hMem) {
        var mh$ = LocalFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFree", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalShrink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalShrink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static FunctionDescriptor LocalShrink$descriptor() {
        return LocalShrink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static MethodHandle LocalShrink$handle() {
        return LocalShrink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static MemorySegment LocalShrink$address() {
        return LocalShrink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static long LocalShrink(MemorySegment hMem, int cbNewSize) {
        var mh$ = LocalShrink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalShrink", hMem, cbNewSize);
            }
            return (long)mh$.invokeExact(hMem, cbNewSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LocalCompact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static FunctionDescriptor LocalCompact$descriptor() {
        return LocalCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static MethodHandle LocalCompact$handle() {
        return LocalCompact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static MemorySegment LocalCompact$address() {
        return LocalCompact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static long LocalCompact(int uMinFree) {
        var mh$ = LocalCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalCompact", uMinFree);
            }
            return (long)mh$.invokeExact(uMinFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBinaryTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBinaryTypeA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static FunctionDescriptor GetBinaryTypeA$descriptor() {
        return GetBinaryTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MethodHandle GetBinaryTypeA$handle() {
        return GetBinaryTypeA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MemorySegment GetBinaryTypeA$address() {
        return GetBinaryTypeA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static int GetBinaryTypeA(MemorySegment lpApplicationName, MemorySegment lpBinaryType) {
        var mh$ = GetBinaryTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBinaryTypeA", lpApplicationName, lpBinaryType);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpBinaryType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBinaryTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetBinaryTypeW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static FunctionDescriptor GetBinaryTypeW$descriptor() {
        return GetBinaryTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MethodHandle GetBinaryTypeW$handle() {
        return GetBinaryTypeW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MemorySegment GetBinaryTypeW$address() {
        return GetBinaryTypeW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static int GetBinaryTypeW(MemorySegment lpApplicationName, MemorySegment lpBinaryType) {
        var mh$ = GetBinaryTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBinaryTypeW", lpApplicationName, lpBinaryType);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpBinaryType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShortPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetShortPathNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetShortPathNameA$descriptor() {
        return GetShortPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetShortPathNameA$handle() {
        return GetShortPathNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MemorySegment GetShortPathNameA$address() {
        return GetShortPathNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static int GetShortPathNameA(MemorySegment lpszLongPath, MemorySegment lpszShortPath, int cchBuffer) {
        var mh$ = GetShortPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShortPathNameA", lpszLongPath, lpszShortPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszLongPath, lpszShortPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLongPathNameTransactedA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetLongPathNameTransactedA$descriptor() {
        return GetLongPathNameTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetLongPathNameTransactedA$handle() {
        return GetLongPathNameTransactedA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetLongPathNameTransactedA$address() {
        return GetLongPathNameTransactedA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static int GetLongPathNameTransactedA(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer, MemorySegment hTransaction) {
        var mh$ = GetLongPathNameTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameTransactedA", lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLongPathNameTransactedW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetLongPathNameTransactedW$descriptor() {
        return GetLongPathNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetLongPathNameTransactedW$handle() {
        return GetLongPathNameTransactedW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MemorySegment GetLongPathNameTransactedW$address() {
        return GetLongPathNameTransactedW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static int GetLongPathNameTransactedW(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer, MemorySegment hTransaction) {
        var mh$ = GetLongPathNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameTransactedW", lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessAffinityMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static FunctionDescriptor GetProcessAffinityMask$descriptor() {
        return GetProcessAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static MethodHandle GetProcessAffinityMask$handle() {
        return GetProcessAffinityMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static MemorySegment GetProcessAffinityMask$address() {
        return GetProcessAffinityMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static int GetProcessAffinityMask(MemorySegment hProcess, MemorySegment lpProcessAffinityMask, MemorySegment lpSystemAffinityMask) {
        var mh$ = GetProcessAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessAffinityMask", hProcess, lpProcessAffinityMask, lpSystemAffinityMask);
            }
            return (int)mh$.invokeExact(hProcess, lpProcessAffinityMask, lpSystemAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessAffinityMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static FunctionDescriptor SetProcessAffinityMask$descriptor() {
        return SetProcessAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static MethodHandle SetProcessAffinityMask$handle() {
        return SetProcessAffinityMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static MemorySegment SetProcessAffinityMask$address() {
        return SetProcessAffinityMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static int SetProcessAffinityMask(MemorySegment hProcess, long dwProcessAffinityMask) {
        var mh$ = SetProcessAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessAffinityMask", hProcess, dwProcessAffinityMask);
            }
            return (int)mh$.invokeExact(hProcess, dwProcessAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessIoCounters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessIoCounters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static FunctionDescriptor GetProcessIoCounters$descriptor() {
        return GetProcessIoCounters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static MethodHandle GetProcessIoCounters$handle() {
        return GetProcessIoCounters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static MemorySegment GetProcessIoCounters$address() {
        return GetProcessIoCounters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static int GetProcessIoCounters(MemorySegment hProcess, MemorySegment lpIoCounters) {
        var mh$ = GetProcessIoCounters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessIoCounters", hProcess, lpIoCounters);
            }
            return (int)mh$.invokeExact(hProcess, lpIoCounters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWorkingSetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessWorkingSetSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static FunctionDescriptor GetProcessWorkingSetSize$descriptor() {
        return GetProcessWorkingSetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static MethodHandle GetProcessWorkingSetSize$handle() {
        return GetProcessWorkingSetSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static MemorySegment GetProcessWorkingSetSize$address() {
        return GetProcessWorkingSetSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static int GetProcessWorkingSetSize(MemorySegment hProcess, MemorySegment lpMinimumWorkingSetSize, MemorySegment lpMaximumWorkingSetSize) {
        var mh$ = GetProcessWorkingSetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWorkingSetSize", hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize);
            }
            return (int)mh$.invokeExact(hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWorkingSetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessWorkingSetSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static FunctionDescriptor SetProcessWorkingSetSize$descriptor() {
        return SetProcessWorkingSetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static MethodHandle SetProcessWorkingSetSize$handle() {
        return SetProcessWorkingSetSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static MemorySegment SetProcessWorkingSetSize$address() {
        return SetProcessWorkingSetSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static int SetProcessWorkingSetSize(MemorySegment hProcess, long dwMinimumWorkingSetSize, long dwMaximumWorkingSetSize) {
        var mh$ = SetProcessWorkingSetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWorkingSetSize", hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize);
            }
            return (int)mh$.invokeExact(hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FatalExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static FunctionDescriptor FatalExit$descriptor() {
        return FatalExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static MethodHandle FatalExit$handle() {
        return FatalExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static MemorySegment FatalExit$address() {
        return FatalExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static void FatalExit(int ExitCode) {
        var mh$ = FatalExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalExit", ExitCode);
            }
            mh$.invokeExact(ExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetEnvironmentStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static FunctionDescriptor SetEnvironmentStringsA$descriptor() {
        return SetEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static MethodHandle SetEnvironmentStringsA$handle() {
        return SetEnvironmentStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static MemorySegment SetEnvironmentStringsA$address() {
        return SetEnvironmentStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static int SetEnvironmentStringsA(MemorySegment NewEnvironment) {
        var mh$ = SetEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentStringsA", NewEnvironment);
            }
            return (int)mh$.invokeExact(NewEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SwitchToFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static FunctionDescriptor SwitchToFiber$descriptor() {
        return SwitchToFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static MethodHandle SwitchToFiber$handle() {
        return SwitchToFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static MemorySegment SwitchToFiber$address() {
        return SwitchToFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static void SwitchToFiber(MemorySegment lpFiber) {
        var mh$ = SwitchToFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToFiber", lpFiber);
            }
            mh$.invokeExact(lpFiber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static FunctionDescriptor DeleteFiber$descriptor() {
        return DeleteFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static MethodHandle DeleteFiber$handle() {
        return DeleteFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static MemorySegment DeleteFiber$address() {
        return DeleteFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static void DeleteFiber(MemorySegment lpFiber) {
        var mh$ = DeleteFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFiber", lpFiber);
            }
            mh$.invokeExact(lpFiber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertFiberToThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConvertFiberToThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static FunctionDescriptor ConvertFiberToThread$descriptor() {
        return ConvertFiberToThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static MethodHandle ConvertFiberToThread$handle() {
        return ConvertFiberToThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static MemorySegment ConvertFiberToThread$address() {
        return ConvertFiberToThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static int ConvertFiberToThread() {
        var mh$ = ConvertFiberToThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertFiberToThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFiberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFiberEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor CreateFiberEx$descriptor() {
        return CreateFiberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MethodHandle CreateFiberEx$handle() {
        return CreateFiberEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiberEx$address() {
        return CreateFiberEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiberEx(long dwStackCommitSize, long dwStackReserveSize, int dwFlags, MemorySegment lpStartAddress, MemorySegment lpParameter) {
        var mh$ = CreateFiberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFiberEx", dwStackCommitSize, dwStackReserveSize, dwFlags, lpStartAddress, lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(dwStackCommitSize, dwStackReserveSize, dwFlags, lpStartAddress, lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertThreadToFiberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConvertThreadToFiberEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor ConvertThreadToFiberEx$descriptor() {
        return ConvertThreadToFiberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MethodHandle ConvertThreadToFiberEx$handle() {
        return ConvertThreadToFiberEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MemorySegment ConvertThreadToFiberEx$address() {
        return ConvertThreadToFiberEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MemorySegment ConvertThreadToFiberEx(MemorySegment lpParameter, int dwFlags) {
        var mh$ = ConvertThreadToFiberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertThreadToFiberEx", lpParameter, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpParameter, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor CreateFiber$descriptor() {
        return CreateFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MethodHandle CreateFiber$handle() {
        return CreateFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiber$address() {
        return CreateFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiber(long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter) {
        var mh$ = CreateFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFiber", dwStackSize, lpStartAddress, lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(dwStackSize, lpStartAddress, lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertThreadToFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ConvertThreadToFiber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor ConvertThreadToFiber$descriptor() {
        return ConvertThreadToFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MethodHandle ConvertThreadToFiber$handle() {
        return ConvertThreadToFiber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MemorySegment ConvertThreadToFiber$address() {
        return ConvertThreadToFiber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MemorySegment ConvertThreadToFiber(MemorySegment lpParameter) {
        var mh$ = ConvertThreadToFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertThreadToFiber", lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *PUMS_CONTEXT
     * }
     */
    public static final AddressLayout PUMS_CONTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *PUMS_COMPLETION_LIST
     * }
     */
    public static final AddressLayout PUMS_COMPLETION_LIST = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef enum _RTL_UMS_THREAD_INFO_CLASS {
     *     UmsThreadInvalidInfoClass = 0,
     *     UmsThreadUserContext,
     *     UmsThreadPriority,
     *     UmsThreadAffinity,
     *     UmsThreadTeb,
     *     UmsThreadIsSuspended,
     *     UmsThreadIsTerminated,
     *     UmsThreadMaxInfoClass
     * } *PUMS_THREAD_INFO_CLASS
     * }
     */
    public static final AddressLayout PUMS_THREAD_INFO_CLASS = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UMS_SCHEDULER_STARTUP_INFO {
     *     ULONG UmsVersion;
     *     PUMS_COMPLETION_LIST CompletionList;
     *     PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;
     *     PVOID SchedulerParam;
     * } *PUMS_SCHEDULER_STARTUP_INFO
     * }
     */
    public static final AddressLayout PUMS_SCHEDULER_STARTUP_INFO = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
     *     ULONG UmsVersion;
     *     union {
     *         struct {
     *             ULONG IsUmsSchedulerThread : 1;
     *             ULONG IsUmsWorkerThread : 1;
     *         };
     *         ULONG ThreadUmsFlags;
     *     };
     * } *PUMS_SYSTEM_THREAD_INFORMATION
     * }
     */
    public static final AddressLayout PUMS_SYSTEM_THREAD_INFORMATION = freeglut_h.C_POINTER;

    private static class CreateUmsCompletionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateUmsCompletionList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static FunctionDescriptor CreateUmsCompletionList$descriptor() {
        return CreateUmsCompletionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static MethodHandle CreateUmsCompletionList$handle() {
        return CreateUmsCompletionList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static MemorySegment CreateUmsCompletionList$address() {
        return CreateUmsCompletionList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static int CreateUmsCompletionList(MemorySegment UmsCompletionList) {
        var mh$ = CreateUmsCompletionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateUmsCompletionList", UmsCompletionList);
            }
            return (int)mh$.invokeExact(UmsCompletionList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DequeueUmsCompletionListItems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DequeueUmsCompletionListItems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static FunctionDescriptor DequeueUmsCompletionListItems$descriptor() {
        return DequeueUmsCompletionListItems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static MethodHandle DequeueUmsCompletionListItems$handle() {
        return DequeueUmsCompletionListItems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static MemorySegment DequeueUmsCompletionListItems$address() {
        return DequeueUmsCompletionListItems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static int DequeueUmsCompletionListItems(MemorySegment UmsCompletionList, int WaitTimeOut, MemorySegment UmsThreadList) {
        var mh$ = DequeueUmsCompletionListItems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DequeueUmsCompletionListItems", UmsCompletionList, WaitTimeOut, UmsThreadList);
            }
            return (int)mh$.invokeExact(UmsCompletionList, WaitTimeOut, UmsThreadList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUmsCompletionListEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUmsCompletionListEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static FunctionDescriptor GetUmsCompletionListEvent$descriptor() {
        return GetUmsCompletionListEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static MethodHandle GetUmsCompletionListEvent$handle() {
        return GetUmsCompletionListEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static MemorySegment GetUmsCompletionListEvent$address() {
        return GetUmsCompletionListEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static int GetUmsCompletionListEvent(MemorySegment UmsCompletionList, MemorySegment UmsCompletionEvent) {
        var mh$ = GetUmsCompletionListEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUmsCompletionListEvent", UmsCompletionList, UmsCompletionEvent);
            }
            return (int)mh$.invokeExact(UmsCompletionList, UmsCompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExecuteUmsThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ExecuteUmsThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static FunctionDescriptor ExecuteUmsThread$descriptor() {
        return ExecuteUmsThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MethodHandle ExecuteUmsThread$handle() {
        return ExecuteUmsThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MemorySegment ExecuteUmsThread$address() {
        return ExecuteUmsThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static int ExecuteUmsThread(MemorySegment UmsThread) {
        var mh$ = ExecuteUmsThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExecuteUmsThread", UmsThread);
            }
            return (int)mh$.invokeExact(UmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UmsThreadYield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UmsThreadYield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static FunctionDescriptor UmsThreadYield$descriptor() {
        return UmsThreadYield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static MethodHandle UmsThreadYield$handle() {
        return UmsThreadYield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static MemorySegment UmsThreadYield$address() {
        return UmsThreadYield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static int UmsThreadYield(MemorySegment SchedulerParam) {
        var mh$ = UmsThreadYield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UmsThreadYield", SchedulerParam);
            }
            return (int)mh$.invokeExact(SchedulerParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteUmsCompletionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteUmsCompletionList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static FunctionDescriptor DeleteUmsCompletionList$descriptor() {
        return DeleteUmsCompletionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static MethodHandle DeleteUmsCompletionList$handle() {
        return DeleteUmsCompletionList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static MemorySegment DeleteUmsCompletionList$address() {
        return DeleteUmsCompletionList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static int DeleteUmsCompletionList(MemorySegment UmsCompletionList) {
        var mh$ = DeleteUmsCompletionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteUmsCompletionList", UmsCompletionList);
            }
            return (int)mh$.invokeExact(UmsCompletionList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentUmsThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCurrentUmsThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static FunctionDescriptor GetCurrentUmsThread$descriptor() {
        return GetCurrentUmsThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MethodHandle GetCurrentUmsThread$handle() {
        return GetCurrentUmsThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MemorySegment GetCurrentUmsThread$address() {
        return GetCurrentUmsThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MemorySegment GetCurrentUmsThread() {
        var mh$ = GetCurrentUmsThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentUmsThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextUmsListItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetNextUmsListItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static FunctionDescriptor GetNextUmsListItem$descriptor() {
        return GetNextUmsListItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MethodHandle GetNextUmsListItem$handle() {
        return GetNextUmsListItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MemorySegment GetNextUmsListItem$address() {
        return GetNextUmsListItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MemorySegment GetNextUmsListItem(MemorySegment UmsContext) {
        var mh$ = GetNextUmsListItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextUmsListItem", UmsContext);
            }
            return (MemorySegment)mh$.invokeExact(UmsContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUmsThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryUmsThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static FunctionDescriptor QueryUmsThreadInformation$descriptor() {
        return QueryUmsThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static MethodHandle QueryUmsThreadInformation$handle() {
        return QueryUmsThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static MemorySegment QueryUmsThreadInformation$address() {
        return QueryUmsThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static int QueryUmsThreadInformation(MemorySegment UmsThread, int UmsThreadInfoClass, MemorySegment UmsThreadInformation, int UmsThreadInformationLength, MemorySegment ReturnLength) {
        var mh$ = QueryUmsThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUmsThreadInformation", UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUmsThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetUmsThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static FunctionDescriptor SetUmsThreadInformation$descriptor() {
        return SetUmsThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static MethodHandle SetUmsThreadInformation$handle() {
        return SetUmsThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static MemorySegment SetUmsThreadInformation$address() {
        return SetUmsThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static int SetUmsThreadInformation(MemorySegment UmsThread, int UmsThreadInfoClass, MemorySegment UmsThreadInformation, int UmsThreadInformationLength) {
        var mh$ = SetUmsThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUmsThreadInformation", UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength);
            }
            return (int)mh$.invokeExact(UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteUmsThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteUmsThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static FunctionDescriptor DeleteUmsThreadContext$descriptor() {
        return DeleteUmsThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MethodHandle DeleteUmsThreadContext$handle() {
        return DeleteUmsThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MemorySegment DeleteUmsThreadContext$address() {
        return DeleteUmsThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static int DeleteUmsThreadContext(MemorySegment UmsThread) {
        var mh$ = DeleteUmsThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteUmsThreadContext", UmsThread);
            }
            return (int)mh$.invokeExact(UmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateUmsThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateUmsThreadContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static FunctionDescriptor CreateUmsThreadContext$descriptor() {
        return CreateUmsThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static MethodHandle CreateUmsThreadContext$handle() {
        return CreateUmsThreadContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static MemorySegment CreateUmsThreadContext$address() {
        return CreateUmsThreadContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static int CreateUmsThreadContext(MemorySegment lpUmsThread) {
        var mh$ = CreateUmsThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateUmsThreadContext", lpUmsThread);
            }
            return (int)mh$.invokeExact(lpUmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnterUmsSchedulingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnterUmsSchedulingMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static FunctionDescriptor EnterUmsSchedulingMode$descriptor() {
        return EnterUmsSchedulingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static MethodHandle EnterUmsSchedulingMode$handle() {
        return EnterUmsSchedulingMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static MemorySegment EnterUmsSchedulingMode$address() {
        return EnterUmsSchedulingMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static int EnterUmsSchedulingMode(MemorySegment SchedulerStartupInfo) {
        var mh$ = EnterUmsSchedulingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterUmsSchedulingMode", SchedulerStartupInfo);
            }
            return (int)mh$.invokeExact(SchedulerStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUmsSystemThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetUmsSystemThreadInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static FunctionDescriptor GetUmsSystemThreadInformation$descriptor() {
        return GetUmsSystemThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static MethodHandle GetUmsSystemThreadInformation$handle() {
        return GetUmsSystemThreadInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static MemorySegment GetUmsSystemThreadInformation$address() {
        return GetUmsSystemThreadInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static int GetUmsSystemThreadInformation(MemorySegment ThreadHandle, MemorySegment SystemThreadInfo) {
        var mh$ = GetUmsSystemThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUmsSystemThreadInformation", ThreadHandle, SystemThreadInfo);
            }
            return (int)mh$.invokeExact(ThreadHandle, SystemThreadInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadAffinityMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static FunctionDescriptor SetThreadAffinityMask$descriptor() {
        return SetThreadAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static MethodHandle SetThreadAffinityMask$handle() {
        return SetThreadAffinityMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static MemorySegment SetThreadAffinityMask$address() {
        return SetThreadAffinityMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static long SetThreadAffinityMask(MemorySegment hThread, long dwThreadAffinityMask) {
        var mh$ = SetThreadAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadAffinityMask", hThread, dwThreadAffinityMask);
            }
            return (long)mh$.invokeExact(hThread, dwThreadAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetProcessDEPPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessDEPPolicy$descriptor() {
        return SetProcessDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessDEPPolicy$handle() {
        return SetProcessDEPPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static MemorySegment SetProcessDEPPolicy$address() {
        return SetProcessDEPPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static int SetProcessDEPPolicy(int dwFlags) {
        var mh$ = SetProcessDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDEPPolicy", dwFlags);
            }
            return (int)mh$.invokeExact(dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProcessDEPPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static FunctionDescriptor GetProcessDEPPolicy$descriptor() {
        return GetProcessDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static MethodHandle GetProcessDEPPolicy$handle() {
        return GetProcessDEPPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static MemorySegment GetProcessDEPPolicy$address() {
        return GetProcessDEPPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static int GetProcessDEPPolicy(MemorySegment hProcess, MemorySegment lpFlags, MemorySegment lpPermanent) {
        var mh$ = GetProcessDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDEPPolicy", hProcess, lpFlags, lpPermanent);
            }
            return (int)mh$.invokeExact(hProcess, lpFlags, lpPermanent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestWakeupLatency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RequestWakeupLatency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static FunctionDescriptor RequestWakeupLatency$descriptor() {
        return RequestWakeupLatency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static MethodHandle RequestWakeupLatency$handle() {
        return RequestWakeupLatency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static MemorySegment RequestWakeupLatency$address() {
        return RequestWakeupLatency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static int RequestWakeupLatency(int latency) {
        var mh$ = RequestWakeupLatency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestWakeupLatency", latency);
            }
            return (int)mh$.invokeExact(latency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSystemResumeAutomatic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsSystemResumeAutomatic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static FunctionDescriptor IsSystemResumeAutomatic$descriptor() {
        return IsSystemResumeAutomatic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static MethodHandle IsSystemResumeAutomatic$handle() {
        return IsSystemResumeAutomatic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static MemorySegment IsSystemResumeAutomatic$address() {
        return IsSystemResumeAutomatic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static int IsSystemResumeAutomatic() {
        var mh$ = IsSystemResumeAutomatic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSystemResumeAutomatic");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadSelectorEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetThreadSelectorEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static FunctionDescriptor GetThreadSelectorEntry$descriptor() {
        return GetThreadSelectorEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MethodHandle GetThreadSelectorEntry$handle() {
        return GetThreadSelectorEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MemorySegment GetThreadSelectorEntry$address() {
        return GetThreadSelectorEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static int GetThreadSelectorEntry(MemorySegment hThread, int dwSelector, MemorySegment lpSelectorEntry) {
        var mh$ = GetThreadSelectorEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadSelectorEntry", hThread, dwSelector, lpSelectorEntry);
            }
            return (int)mh$.invokeExact(hThread, dwSelector, lpSelectorEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadExecutionState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetThreadExecutionState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static FunctionDescriptor SetThreadExecutionState$descriptor() {
        return SetThreadExecutionState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static MethodHandle SetThreadExecutionState$handle() {
        return SetThreadExecutionState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static MemorySegment SetThreadExecutionState$address() {
        return SetThreadExecutionState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static int SetThreadExecutionState(int esFlags) {
        var mh$ = SetThreadExecutionState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadExecutionState", esFlags);
            }
            return (int)mh$.invokeExact(esFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef REASON_CONTEXT *PPOWER_REQUEST_CONTEXT
     * }
     */
    public static final AddressLayout PPOWER_REQUEST_CONTEXT = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef REASON_CONTEXT *LPPOWER_REQUEST_CONTEXT
     * }
     */
    public static final AddressLayout LPPOWER_REQUEST_CONTEXT = freeglut_h.C_POINTER;

    private static class PowerCreateRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PowerCreateRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static FunctionDescriptor PowerCreateRequest$descriptor() {
        return PowerCreateRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MethodHandle PowerCreateRequest$handle() {
        return PowerCreateRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MemorySegment PowerCreateRequest$address() {
        return PowerCreateRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MemorySegment PowerCreateRequest(MemorySegment Context) {
        var mh$ = PowerCreateRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerCreateRequest", Context);
            }
            return (MemorySegment)mh$.invokeExact(Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PowerSetRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PowerSetRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static FunctionDescriptor PowerSetRequest$descriptor() {
        return PowerSetRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MethodHandle PowerSetRequest$handle() {
        return PowerSetRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MemorySegment PowerSetRequest$address() {
        return PowerSetRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static int PowerSetRequest(MemorySegment PowerRequest, int RequestType) {
        var mh$ = PowerSetRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerSetRequest", PowerRequest, RequestType);
            }
            return (int)mh$.invokeExact(PowerRequest, RequestType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PowerClearRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PowerClearRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static FunctionDescriptor PowerClearRequest$descriptor() {
        return PowerClearRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MethodHandle PowerClearRequest$handle() {
        return PowerClearRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MemorySegment PowerClearRequest$address() {
        return PowerClearRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static int PowerClearRequest(MemorySegment PowerRequest, int RequestType) {
        var mh$ = PowerClearRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerClearRequest", PowerRequest, RequestType);
            }
            return (int)mh$.invokeExact(PowerRequest, RequestType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileCompletionNotificationModes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileCompletionNotificationModes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static FunctionDescriptor SetFileCompletionNotificationModes$descriptor() {
        return SetFileCompletionNotificationModes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static MethodHandle SetFileCompletionNotificationModes$handle() {
        return SetFileCompletionNotificationModes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static MemorySegment SetFileCompletionNotificationModes$address() {
        return SetFileCompletionNotificationModes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static int SetFileCompletionNotificationModes(MemorySegment FileHandle, byte Flags) {
        var mh$ = SetFileCompletionNotificationModes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileCompletionNotificationModes", FileHandle, Flags);
            }
            return (int)mh$.invokeExact(FileHandle, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64GetThreadSelectorEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("Wow64GetThreadSelectorEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static FunctionDescriptor Wow64GetThreadSelectorEntry$descriptor() {
        return Wow64GetThreadSelectorEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MethodHandle Wow64GetThreadSelectorEntry$handle() {
        return Wow64GetThreadSelectorEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MemorySegment Wow64GetThreadSelectorEntry$address() {
        return Wow64GetThreadSelectorEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static int Wow64GetThreadSelectorEntry(MemorySegment hThread, int dwSelector, MemorySegment lpSelectorEntry) {
        var mh$ = Wow64GetThreadSelectorEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64GetThreadSelectorEntry", hThread, dwSelector, lpSelectorEntry);
            }
            return (int)mh$.invokeExact(hThread, dwSelector, lpSelectorEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugSetProcessKillOnExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DebugSetProcessKillOnExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static FunctionDescriptor DebugSetProcessKillOnExit$descriptor() {
        return DebugSetProcessKillOnExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static MethodHandle DebugSetProcessKillOnExit$handle() {
        return DebugSetProcessKillOnExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static MemorySegment DebugSetProcessKillOnExit$address() {
        return DebugSetProcessKillOnExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static int DebugSetProcessKillOnExit(int KillOnExit) {
        var mh$ = DebugSetProcessKillOnExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugSetProcessKillOnExit", KillOnExit);
            }
            return (int)mh$.invokeExact(KillOnExit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugBreakProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DebugBreakProcess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static FunctionDescriptor DebugBreakProcess$descriptor() {
        return DebugBreakProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static MethodHandle DebugBreakProcess$handle() {
        return DebugBreakProcess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static MemorySegment DebugBreakProcess$address() {
        return DebugBreakProcess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static int DebugBreakProcess(MemorySegment Process) {
        var mh$ = DebugBreakProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugBreakProcess", Process);
            }
            return (int)mh$.invokeExact(Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PulseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PulseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor PulseEvent$descriptor() {
        return PulseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle PulseEvent$handle() {
        return PulseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static MemorySegment PulseEvent$address() {
        return PulseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static int PulseEvent(MemorySegment hEvent) {
        var mh$ = PulseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PulseEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalDeleteAtom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalDeleteAtom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static FunctionDescriptor GlobalDeleteAtom$descriptor() {
        return GlobalDeleteAtom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static MethodHandle GlobalDeleteAtom$handle() {
        return GlobalDeleteAtom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static MemorySegment GlobalDeleteAtom$address() {
        return GlobalDeleteAtom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static short GlobalDeleteAtom(short nAtom) {
        var mh$ = GlobalDeleteAtom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalDeleteAtom", nAtom);
            }
            return (short)mh$.invokeExact(nAtom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitAtomTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("InitAtomTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static FunctionDescriptor InitAtomTable$descriptor() {
        return InitAtomTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static MethodHandle InitAtomTable$handle() {
        return InitAtomTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static MemorySegment InitAtomTable$address() {
        return InitAtomTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static int InitAtomTable(int nSize) {
        var mh$ = InitAtomTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitAtomTable", nSize);
            }
            return (int)mh$.invokeExact(nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteAtom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DeleteAtom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static FunctionDescriptor DeleteAtom$descriptor() {
        return DeleteAtom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static MethodHandle DeleteAtom$handle() {
        return DeleteAtom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static MemorySegment DeleteAtom$address() {
        return DeleteAtom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static short DeleteAtom(short nAtom) {
        var mh$ = DeleteAtom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteAtom", nAtom);
            }
            return (short)mh$.invokeExact(nAtom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetHandleCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetHandleCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static FunctionDescriptor SetHandleCount$descriptor() {
        return SetHandleCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static MethodHandle SetHandleCount$handle() {
        return SetHandleCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static MemorySegment SetHandleCount$address() {
        return SetHandleCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static int SetHandleCount(int uNumber) {
        var mh$ = SetHandleCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetHandleCount", uNumber);
            }
            return (int)mh$.invokeExact(uNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestDeviceWakeup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("RequestDeviceWakeup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor RequestDeviceWakeup$descriptor() {
        return RequestDeviceWakeup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static MethodHandle RequestDeviceWakeup$handle() {
        return RequestDeviceWakeup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static MemorySegment RequestDeviceWakeup$address() {
        return RequestDeviceWakeup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static int RequestDeviceWakeup(MemorySegment hDevice) {
        var mh$ = RequestDeviceWakeup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestDeviceWakeup", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelDeviceWakeupRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CancelDeviceWakeupRequest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor CancelDeviceWakeupRequest$descriptor() {
        return CancelDeviceWakeupRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static MethodHandle CancelDeviceWakeupRequest$handle() {
        return CancelDeviceWakeupRequest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static MemorySegment CancelDeviceWakeupRequest$address() {
        return CancelDeviceWakeupRequest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static int CancelDeviceWakeupRequest(MemorySegment hDevice) {
        var mh$ = CancelDeviceWakeupRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelDeviceWakeupRequest", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDevicePowerState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetDevicePowerState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static FunctionDescriptor GetDevicePowerState$descriptor() {
        return GetDevicePowerState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static MethodHandle GetDevicePowerState$handle() {
        return GetDevicePowerState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static MemorySegment GetDevicePowerState$address() {
        return GetDevicePowerState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static int GetDevicePowerState(MemorySegment hDevice, MemorySegment pfOn) {
        var mh$ = GetDevicePowerState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDevicePowerState", hDevice, pfOn);
            }
            return (int)mh$.invokeExact(hDevice, pfOn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageWaitingIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMessageWaitingIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static FunctionDescriptor SetMessageWaitingIndicator$descriptor() {
        return SetMessageWaitingIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static MethodHandle SetMessageWaitingIndicator$handle() {
        return SetMessageWaitingIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static MemorySegment SetMessageWaitingIndicator$address() {
        return SetMessageWaitingIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static int SetMessageWaitingIndicator(MemorySegment hMsgIndicator, int ulMsgCount) {
        var mh$ = SetMessageWaitingIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageWaitingIndicator", hMsgIndicator, ulMsgCount);
            }
            return (int)mh$.invokeExact(hMsgIndicator, ulMsgCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileShortNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileShortNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static FunctionDescriptor SetFileShortNameA$descriptor() {
        return SetFileShortNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static MethodHandle SetFileShortNameA$handle() {
        return SetFileShortNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static MemorySegment SetFileShortNameA$address() {
        return SetFileShortNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static int SetFileShortNameA(MemorySegment hFile, MemorySegment lpShortName) {
        var mh$ = SetFileShortNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileShortNameA", hFile, lpShortName);
            }
            return (int)mh$.invokeExact(hFile, lpShortName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileShortNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFileShortNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static FunctionDescriptor SetFileShortNameW$descriptor() {
        return SetFileShortNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static MethodHandle SetFileShortNameW$handle() {
        return SetFileShortNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static MemorySegment SetFileShortNameW$address() {
        return SetFileShortNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static int SetFileShortNameW(MemorySegment hFile, MemorySegment lpShortName) {
        var mh$ = SetFileShortNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileShortNameW", hFile, lpShortName);
            }
            return (int)mh$.invokeExact(hFile, lpShortName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static FunctionDescriptor LoadModule$descriptor() {
        return LoadModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static MethodHandle LoadModule$handle() {
        return LoadModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static MemorySegment LoadModule$address() {
        return LoadModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static int LoadModule(MemorySegment lpModuleName, MemorySegment lpParameterBlock) {
        var mh$ = LoadModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModule", lpModuleName, lpParameterBlock);
            }
            return (int)mh$.invokeExact(lpModuleName, lpParameterBlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WinExec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WinExec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static FunctionDescriptor WinExec$descriptor() {
        return WinExec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static MethodHandle WinExec$handle() {
        return WinExec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static MemorySegment WinExec$address() {
        return WinExec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static int WinExec(MemorySegment lpCmdLine, int uCmdShow) {
        var mh$ = WinExec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinExec", lpCmdLine, uCmdShow);
            }
            return (int)mh$.invokeExact(lpCmdLine, uCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearCommBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClearCommBreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor ClearCommBreak$descriptor() {
        return ClearCommBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static MethodHandle ClearCommBreak$handle() {
        return ClearCommBreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static MemorySegment ClearCommBreak$address() {
        return ClearCommBreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static int ClearCommBreak(MemorySegment hFile) {
        var mh$ = ClearCommBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommBreak", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearCommError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ClearCommError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static FunctionDescriptor ClearCommError$descriptor() {
        return ClearCommError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static MethodHandle ClearCommError$handle() {
        return ClearCommError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static MemorySegment ClearCommError$address() {
        return ClearCommError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static int ClearCommError(MemorySegment hFile, MemorySegment lpErrors, MemorySegment lpStat) {
        var mh$ = ClearCommError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommError", hFile, lpErrors, lpStat);
            }
            return (int)mh$.invokeExact(hFile, lpErrors, lpStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetupComm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetupComm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static FunctionDescriptor SetupComm$descriptor() {
        return SetupComm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static MethodHandle SetupComm$handle() {
        return SetupComm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static MemorySegment SetupComm$address() {
        return SetupComm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static int SetupComm(MemorySegment hFile, int dwInQueue, int dwOutQueue) {
        var mh$ = SetupComm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetupComm", hFile, dwInQueue, dwOutQueue);
            }
            return (int)mh$.invokeExact(hFile, dwInQueue, dwOutQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EscapeCommFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EscapeCommFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static FunctionDescriptor EscapeCommFunction$descriptor() {
        return EscapeCommFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static MethodHandle EscapeCommFunction$handle() {
        return EscapeCommFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static MemorySegment EscapeCommFunction$address() {
        return EscapeCommFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static int EscapeCommFunction(MemorySegment hFile, int dwFunc) {
        var mh$ = EscapeCommFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EscapeCommFunction", hFile, dwFunc);
            }
            return (int)mh$.invokeExact(hFile, dwFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCommConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetCommConfig$descriptor() {
        return GetCommConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetCommConfig$handle() {
        return GetCommConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MemorySegment GetCommConfig$address() {
        return GetCommConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetCommConfig(MemorySegment hCommDev, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetCommConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommConfig", hCommDev, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(hCommDev, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCommMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static FunctionDescriptor GetCommMask$descriptor() {
        return GetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static MethodHandle GetCommMask$handle() {
        return GetCommMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static MemorySegment GetCommMask$address() {
        return GetCommMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static int GetCommMask(MemorySegment hFile, MemorySegment lpEvtMask) {
        var mh$ = GetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommMask", hFile, lpEvtMask);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCommProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static FunctionDescriptor GetCommProperties$descriptor() {
        return GetCommProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static MethodHandle GetCommProperties$handle() {
        return GetCommProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static MemorySegment GetCommProperties$address() {
        return GetCommProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static int GetCommProperties(MemorySegment hFile, MemorySegment lpCommProp) {
        var mh$ = GetCommProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommProperties", hFile, lpCommProp);
            }
            return (int)mh$.invokeExact(hFile, lpCommProp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommModemStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCommModemStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static FunctionDescriptor GetCommModemStatus$descriptor() {
        return GetCommModemStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static MethodHandle GetCommModemStatus$handle() {
        return GetCommModemStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static MemorySegment GetCommModemStatus$address() {
        return GetCommModemStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static int GetCommModemStatus(MemorySegment hFile, MemorySegment lpModemStat) {
        var mh$ = GetCommModemStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommModemStatus", hFile, lpModemStat);
            }
            return (int)mh$.invokeExact(hFile, lpModemStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCommState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor GetCommState$descriptor() {
        return GetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle GetCommState$handle() {
        return GetCommState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MemorySegment GetCommState$address() {
        return GetCommState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int GetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = GetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCommTimeouts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor GetCommTimeouts$descriptor() {
        return GetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle GetCommTimeouts$handle() {
        return GetCommTimeouts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment GetCommTimeouts$address() {
        return GetCommTimeouts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int GetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = GetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PurgeComm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PurgeComm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PurgeComm$descriptor() {
        return PurgeComm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle PurgeComm$handle() {
        return PurgeComm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment PurgeComm$address() {
        return PurgeComm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static int PurgeComm(MemorySegment hFile, int dwFlags) {
        var mh$ = PurgeComm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PurgeComm", hFile, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCommBreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor SetCommBreak$descriptor() {
        return SetCommBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static MethodHandle SetCommBreak$handle() {
        return SetCommBreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static MemorySegment SetCommBreak$address() {
        return SetCommBreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static int SetCommBreak(MemorySegment hFile) {
        var mh$ = SetCommBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommBreak", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCommConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetCommConfig$descriptor() {
        return SetCommConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetCommConfig$handle() {
        return SetCommConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MemorySegment SetCommConfig$address() {
        return SetCommConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetCommConfig(MemorySegment hCommDev, MemorySegment lpCC, int dwSize) {
        var mh$ = SetCommConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommConfig", hCommDev, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(hCommDev, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCommMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static FunctionDescriptor SetCommMask$descriptor() {
        return SetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static MethodHandle SetCommMask$handle() {
        return SetCommMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static MemorySegment SetCommMask$address() {
        return SetCommMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static int SetCommMask(MemorySegment hFile, int dwEvtMask) {
        var mh$ = SetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommMask", hFile, dwEvtMask);
            }
            return (int)mh$.invokeExact(hFile, dwEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCommState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor SetCommState$descriptor() {
        return SetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle SetCommState$handle() {
        return SetCommState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MemorySegment SetCommState$address() {
        return SetCommState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int SetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = SetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetCommTimeouts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor SetCommTimeouts$descriptor() {
        return SetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle SetCommTimeouts$handle() {
        return SetCommTimeouts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MemorySegment SetCommTimeouts$address() {
        return SetCommTimeouts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int SetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = SetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmitCommChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("TransmitCommChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static FunctionDescriptor TransmitCommChar$descriptor() {
        return TransmitCommChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static MethodHandle TransmitCommChar$handle() {
        return TransmitCommChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static MemorySegment TransmitCommChar$address() {
        return TransmitCommChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static int TransmitCommChar(MemorySegment hFile, byte cChar) {
        var mh$ = TransmitCommChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmitCommChar", hFile, cChar);
            }
            return (int)mh$.invokeExact(hFile, cChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitCommEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WaitCommEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WaitCommEvent$descriptor() {
        return WaitCommEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WaitCommEvent$handle() {
        return WaitCommEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MemorySegment WaitCommEvent$address() {
        return WaitCommEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WaitCommEvent(MemorySegment hFile, MemorySegment lpEvtMask, MemorySegment lpOverlapped) {
        var mh$ = WaitCommEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitCommEvent", hFile, lpEvtMask, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenCommPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenCommPort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor OpenCommPort$descriptor() {
        return OpenCommPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle OpenCommPort$handle() {
        return OpenCommPort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenCommPort$address() {
        return OpenCommPort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenCommPort(int uPortNumber, int dwDesiredAccess, int dwFlagsAndAttributes) {
        var mh$ = OpenCommPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenCommPort", uPortNumber, dwDesiredAccess, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(uPortNumber, dwDesiredAccess, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommPorts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetCommPorts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static FunctionDescriptor GetCommPorts$descriptor() {
        return GetCommPorts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static MethodHandle GetCommPorts$handle() {
        return GetCommPorts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static MemorySegment GetCommPorts$address() {
        return GetCommPorts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static int GetCommPorts(MemorySegment lpPortNumbers, int uPortNumbersCount, MemorySegment puPortNumbersFound) {
        var mh$ = GetCommPorts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommPorts", lpPortNumbers, uPortNumbersCount, puPortNumbersFound);
            }
            return (int)mh$.invokeExact(lpPortNumbers, uPortNumbersCount, puPortNumbersFound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTapePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTapePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor SetTapePosition$descriptor() {
        return SetTapePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static MethodHandle SetTapePosition$handle() {
        return SetTapePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static MemorySegment SetTapePosition$address() {
        return SetTapePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static int SetTapePosition(MemorySegment hDevice, int dwPositionMethod, int dwPartition, int dwOffsetLow, int dwOffsetHigh, int bImmediate) {
        var mh$ = SetTapePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTapePosition", hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTapePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static FunctionDescriptor GetTapePosition$descriptor() {
        return GetTapePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static MethodHandle GetTapePosition$handle() {
        return GetTapePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static MemorySegment GetTapePosition$address() {
        return GetTapePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static int GetTapePosition(MemorySegment hDevice, int dwPositionType, MemorySegment lpdwPartition, MemorySegment lpdwOffsetLow, MemorySegment lpdwOffsetHigh) {
        var mh$ = GetTapePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapePosition", hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh);
            }
            return (int)mh$.invokeExact(hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrepareTape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("PrepareTape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor PrepareTape$descriptor() {
        return PrepareTape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static MethodHandle PrepareTape$handle() {
        return PrepareTape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static MemorySegment PrepareTape$address() {
        return PrepareTape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static int PrepareTape(MemorySegment hDevice, int dwOperation, int bImmediate) {
        var mh$ = PrepareTape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrepareTape", hDevice, dwOperation, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EraseTape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EraseTape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor EraseTape$descriptor() {
        return EraseTape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static MethodHandle EraseTape$handle() {
        return EraseTape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static MemorySegment EraseTape$address() {
        return EraseTape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static int EraseTape(MemorySegment hDevice, int dwEraseType, int bImmediate) {
        var mh$ = EraseTape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EraseTape", hDevice, dwEraseType, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwEraseType, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTapePartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateTapePartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor CreateTapePartition$descriptor() {
        return CreateTapePartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static MethodHandle CreateTapePartition$handle() {
        return CreateTapePartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static MemorySegment CreateTapePartition$address() {
        return CreateTapePartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static int CreateTapePartition(MemorySegment hDevice, int dwPartitionMethod, int dwCount, int dwSize) {
        var mh$ = CreateTapePartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTapePartition", hDevice, dwPartitionMethod, dwCount, dwSize);
            }
            return (int)mh$.invokeExact(hDevice, dwPartitionMethod, dwCount, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteTapemark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteTapemark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor WriteTapemark$descriptor() {
        return WriteTapemark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static MethodHandle WriteTapemark$handle() {
        return WriteTapemark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static MemorySegment WriteTapemark$address() {
        return WriteTapemark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static int WriteTapemark(MemorySegment hDevice, int dwTapemarkType, int dwTapemarkCount, int bImmediate) {
        var mh$ = WriteTapemark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteTapemark", hDevice, dwTapemarkType, dwTapemarkCount, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwTapemarkType, dwTapemarkCount, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapeStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTapeStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor GetTapeStatus$descriptor() {
        return GetTapeStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static MethodHandle GetTapeStatus$handle() {
        return GetTapeStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static MemorySegment GetTapeStatus$address() {
        return GetTapeStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static int GetTapeStatus(MemorySegment hDevice) {
        var mh$ = GetTapeStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapeStatus", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapeParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetTapeParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static FunctionDescriptor GetTapeParameters$descriptor() {
        return GetTapeParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static MethodHandle GetTapeParameters$handle() {
        return GetTapeParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static MemorySegment GetTapeParameters$address() {
        return GetTapeParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static int GetTapeParameters(MemorySegment hDevice, int dwOperation, MemorySegment lpdwSize, MemorySegment lpTapeInformation) {
        var mh$ = GetTapeParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapeParameters", hDevice, dwOperation, lpdwSize, lpTapeInformation);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, lpdwSize, lpTapeInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTapeParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetTapeParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static FunctionDescriptor SetTapeParameters$descriptor() {
        return SetTapeParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static MethodHandle SetTapeParameters$handle() {
        return SetTapeParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static MemorySegment SetTapeParameters$address() {
        return SetTapeParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static int SetTapeParameters(MemorySegment hDevice, int dwOperation, MemorySegment lpTapeInformation) {
        var mh$ = SetTapeParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTapeParameters", hDevice, dwOperation, lpTapeInformation);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, lpTapeInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MulDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("MulDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static FunctionDescriptor MulDiv$descriptor() {
        return MulDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static MethodHandle MulDiv$handle() {
        return MulDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static MemorySegment MulDiv$address() {
        return MulDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static int MulDiv(int nNumber, int nNumerator, int nDenominator) {
        var mh$ = MulDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MulDiv", nNumber, nNumerator, nDenominator);
            }
            return (int)mh$.invokeExact(nNumber, nNumerator, nDenominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DEPPolicyAlwaysOff = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOff = 0
     * }
     */
    public static int DEPPolicyAlwaysOff() {
        return DEPPolicyAlwaysOff;
    }
    private static final int DEPPolicyAlwaysOn = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOn = 1
     * }
     */
    public static int DEPPolicyAlwaysOn() {
        return DEPPolicyAlwaysOn;
    }
    private static final int DEPPolicyOptIn = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptIn = 2
     * }
     */
    public static int DEPPolicyOptIn() {
        return DEPPolicyOptIn;
    }
    private static final int DEPPolicyOptOut = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptOut = 3
     * }
     */
    public static int DEPPolicyOptOut() {
        return DEPPolicyOptOut;
    }
    private static final int DEPTotalPolicyCount = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPTotalPolicyCount = 4
     * }
     */
    public static int DEPTotalPolicyCount() {
        return DEPTotalPolicyCount;
    }

    private static class GetSystemDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemDEPPolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static FunctionDescriptor GetSystemDEPPolicy$descriptor() {
        return GetSystemDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static MethodHandle GetSystemDEPPolicy$handle() {
        return GetSystemDEPPolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static MemorySegment GetSystemDEPPolicy$address() {
        return GetSystemDEPPolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static int GetSystemDEPPolicy() {
        var mh$ = GetSystemDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDEPPolicy");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemRegistryQuota {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetSystemRegistryQuota");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static FunctionDescriptor GetSystemRegistryQuota$descriptor() {
        return GetSystemRegistryQuota.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static MethodHandle GetSystemRegistryQuota$handle() {
        return GetSystemRegistryQuota.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static MemorySegment GetSystemRegistryQuota$address() {
        return GetSystemRegistryQuota.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static int GetSystemRegistryQuota(MemorySegment pdwQuotaAllowed, MemorySegment pdwQuotaUsed) {
        var mh$ = GetSystemRegistryQuota.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemRegistryQuota", pdwQuotaAllowed, pdwQuotaUsed);
            }
            return (int)mh$.invokeExact(pdwQuotaAllowed, pdwQuotaUsed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToDosDateTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FileTimeToDosDateTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static FunctionDescriptor FileTimeToDosDateTime$descriptor() {
        return FileTimeToDosDateTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static MethodHandle FileTimeToDosDateTime$handle() {
        return FileTimeToDosDateTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static MemorySegment FileTimeToDosDateTime$address() {
        return FileTimeToDosDateTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static int FileTimeToDosDateTime(MemorySegment lpFileTime, MemorySegment lpFatDate, MemorySegment lpFatTime) {
        var mh$ = FileTimeToDosDateTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToDosDateTime", lpFileTime, lpFatDate, lpFatTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpFatDate, lpFatTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DosDateTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DosDateTimeToFileTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor DosDateTimeToFileTime$descriptor() {
        return DosDateTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle DosDateTimeToFileTime$handle() {
        return DosDateTimeToFileTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static MemorySegment DosDateTimeToFileTime$address() {
        return DosDateTimeToFileTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static int DosDateTimeToFileTime(short wFatDate, short wFatTime, MemorySegment lpFileTime) {
        var mh$ = DosDateTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DosDateTimeToFileTime", wFatDate, wFatTime, lpFileTime);
            }
            return (int)mh$.invokeExact(wFatDate, wFatTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FormatMessageA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static FunctionDescriptor FormatMessageA$descriptor() {
        return FormatMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MethodHandle FormatMessageA$handle() {
        return FormatMessageA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MemorySegment FormatMessageA$address() {
        return FormatMessageA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageA(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageA", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FormatMessageW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static FunctionDescriptor FormatMessageW$descriptor() {
        return FormatMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MethodHandle FormatMessageW$handle() {
        return FormatMessageW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MemorySegment FormatMessageW$address() {
        return FormatMessageW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageW(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageW", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMailslotA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMailslotA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateMailslotA$descriptor() {
        return CreateMailslotA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateMailslotA$handle() {
        return CreateMailslotA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotA$address() {
        return CreateMailslotA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotA(MemorySegment lpName, int nMaxMessageSize, int lReadTimeout, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateMailslotA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMailslotA", lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMailslotW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateMailslotW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateMailslotW$descriptor() {
        return CreateMailslotW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateMailslotW$handle() {
        return CreateMailslotW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotW$address() {
        return CreateMailslotW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotW(MemorySegment lpName, int nMaxMessageSize, int lReadTimeout, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateMailslotW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMailslotW", lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMailslotInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetMailslotInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static FunctionDescriptor GetMailslotInfo$descriptor() {
        return GetMailslotInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static MethodHandle GetMailslotInfo$handle() {
        return GetMailslotInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static MemorySegment GetMailslotInfo$address() {
        return GetMailslotInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static int GetMailslotInfo(MemorySegment hMailslot, MemorySegment lpMaxMessageSize, MemorySegment lpNextSize, MemorySegment lpMessageCount, MemorySegment lpReadTimeout) {
        var mh$ = GetMailslotInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMailslotInfo", hMailslot, lpMaxMessageSize, lpNextSize, lpMessageCount, lpReadTimeout);
            }
            return (int)mh$.invokeExact(hMailslot, lpMaxMessageSize, lpNextSize, lpMessageCount, lpReadTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMailslotInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetMailslotInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static FunctionDescriptor SetMailslotInfo$descriptor() {
        return SetMailslotInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static MethodHandle SetMailslotInfo$handle() {
        return SetMailslotInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static MemorySegment SetMailslotInfo$address() {
        return SetMailslotInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static int SetMailslotInfo(MemorySegment hMailslot, int lReadTimeout) {
        var mh$ = SetMailslotInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMailslotInfo", hMailslot, lReadTimeout);
            }
            return (int)mh$.invokeExact(hMailslot, lReadTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EncryptFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor EncryptFileA$descriptor() {
        return EncryptFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle EncryptFileA$handle() {
        return EncryptFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment EncryptFileA$address() {
        return EncryptFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static int EncryptFileA(MemorySegment lpFileName) {
        var mh$ = EncryptFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptFileA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EncryptFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor EncryptFileW$descriptor() {
        return EncryptFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle EncryptFileW$handle() {
        return EncryptFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment EncryptFileW$address() {
        return EncryptFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static int EncryptFileW(MemorySegment lpFileName) {
        var mh$ = EncryptFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptFileW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecryptFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DecryptFileA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor DecryptFileA$descriptor() {
        return DecryptFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MethodHandle DecryptFileA$handle() {
        return DecryptFileA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MemorySegment DecryptFileA$address() {
        return DecryptFileA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static int DecryptFileA(MemorySegment lpFileName, int dwReserved) {
        var mh$ = DecryptFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecryptFileA", lpFileName, dwReserved);
            }
            return (int)mh$.invokeExact(lpFileName, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecryptFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("DecryptFileW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor DecryptFileW$descriptor() {
        return DecryptFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MethodHandle DecryptFileW$handle() {
        return DecryptFileW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MemorySegment DecryptFileW$address() {
        return DecryptFileW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static int DecryptFileW(MemorySegment lpFileName, int dwReserved) {
        var mh$ = DecryptFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecryptFileW", lpFileName, dwReserved);
            }
            return (int)mh$.invokeExact(lpFileName, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileEncryptionStatusA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FileEncryptionStatusA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static FunctionDescriptor FileEncryptionStatusA$descriptor() {
        return FileEncryptionStatusA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MethodHandle FileEncryptionStatusA$handle() {
        return FileEncryptionStatusA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MemorySegment FileEncryptionStatusA$address() {
        return FileEncryptionStatusA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static int FileEncryptionStatusA(MemorySegment lpFileName, MemorySegment lpStatus) {
        var mh$ = FileEncryptionStatusA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileEncryptionStatusA", lpFileName, lpStatus);
            }
            return (int)mh$.invokeExact(lpFileName, lpStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileEncryptionStatusW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FileEncryptionStatusW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static FunctionDescriptor FileEncryptionStatusW$descriptor() {
        return FileEncryptionStatusW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MethodHandle FileEncryptionStatusW$handle() {
        return FileEncryptionStatusW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MemorySegment FileEncryptionStatusW$address() {
        return FileEncryptionStatusW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static int FileEncryptionStatusW(MemorySegment lpFileName, MemorySegment lpStatus) {
        var mh$ = FileEncryptionStatusW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileEncryptionStatusW", lpFileName, lpStatus);
            }
            return (int)mh$.invokeExact(lpFileName, lpStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEncryptedFileRawA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenEncryptedFileRawA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static FunctionDescriptor OpenEncryptedFileRawA$descriptor() {
        return OpenEncryptedFileRawA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MethodHandle OpenEncryptedFileRawA$handle() {
        return OpenEncryptedFileRawA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MemorySegment OpenEncryptedFileRawA$address() {
        return OpenEncryptedFileRawA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static int OpenEncryptedFileRawA(MemorySegment lpFileName, int ulFlags, MemorySegment pvContext) {
        var mh$ = OpenEncryptedFileRawA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEncryptedFileRawA", lpFileName, ulFlags, pvContext);
            }
            return (int)mh$.invokeExact(lpFileName, ulFlags, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEncryptedFileRawW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenEncryptedFileRawW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static FunctionDescriptor OpenEncryptedFileRawW$descriptor() {
        return OpenEncryptedFileRawW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MethodHandle OpenEncryptedFileRawW$handle() {
        return OpenEncryptedFileRawW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MemorySegment OpenEncryptedFileRawW$address() {
        return OpenEncryptedFileRawW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static int OpenEncryptedFileRawW(MemorySegment lpFileName, int ulFlags, MemorySegment pvContext) {
        var mh$ = OpenEncryptedFileRawW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEncryptedFileRawW", lpFileName, ulFlags, pvContext);
            }
            return (int)mh$.invokeExact(lpFileName, ulFlags, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ReadEncryptedFileRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static FunctionDescriptor ReadEncryptedFileRaw$descriptor() {
        return ReadEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MethodHandle ReadEncryptedFileRaw$handle() {
        return ReadEncryptedFileRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MemorySegment ReadEncryptedFileRaw$address() {
        return ReadEncryptedFileRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static int ReadEncryptedFileRaw(MemorySegment pfExportCallback, MemorySegment pvCallbackContext, MemorySegment pvContext) {
        var mh$ = ReadEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEncryptedFileRaw", pfExportCallback, pvCallbackContext, pvContext);
            }
            return (int)mh$.invokeExact(pfExportCallback, pvCallbackContext, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteEncryptedFileRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static FunctionDescriptor WriteEncryptedFileRaw$descriptor() {
        return WriteEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MethodHandle WriteEncryptedFileRaw$handle() {
        return WriteEncryptedFileRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MemorySegment WriteEncryptedFileRaw$address() {
        return WriteEncryptedFileRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static int WriteEncryptedFileRaw(MemorySegment pfImportCallback, MemorySegment pvCallbackContext, MemorySegment pvContext) {
        var mh$ = WriteEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteEncryptedFileRaw", pfImportCallback, pvCallbackContext, pvContext);
            }
            return (int)mh$.invokeExact(pfImportCallback, pvCallbackContext, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CloseEncryptedFileRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static FunctionDescriptor CloseEncryptedFileRaw$descriptor() {
        return CloseEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static MethodHandle CloseEncryptedFileRaw$handle() {
        return CloseEncryptedFileRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static MemorySegment CloseEncryptedFileRaw$address() {
        return CloseEncryptedFileRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static void CloseEncryptedFileRaw(MemorySegment pvContext) {
        var mh$ = CloseEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEncryptedFileRaw", pvContext);
            }
            mh$.invokeExact(pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcmpA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpA$descriptor() {
        return lstrcmpA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpA$handle() {
        return lstrcmpA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpA$address() {
        return lstrcmpA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static int lstrcmpA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpA", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcmpW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpW$descriptor() {
        return lstrcmpW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpW$handle() {
        return lstrcmpW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpW$address() {
        return lstrcmpW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static int lstrcmpW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpW", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpiA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcmpiA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpiA$descriptor() {
        return lstrcmpiA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpiA$handle() {
        return lstrcmpiA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpiA$address() {
        return lstrcmpiA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static int lstrcmpiA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpiA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpiA", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpiW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcmpiW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpiW$descriptor() {
        return lstrcmpiW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpiW$handle() {
        return lstrcmpiW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcmpiW$address() {
        return lstrcmpiW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static int lstrcmpiW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpiW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpiW", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpynA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcpynA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static FunctionDescriptor lstrcpynA$descriptor() {
        return lstrcpynA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MethodHandle lstrcpynA$handle() {
        return lstrcpynA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynA$address() {
        return lstrcpynA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynA(MemorySegment lpString1, MemorySegment lpString2, int iMaxLength) {
        var mh$ = lstrcpynA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpynA", lpString1, lpString2, iMaxLength);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2, iMaxLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpynW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcpynW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static FunctionDescriptor lstrcpynW$descriptor() {
        return lstrcpynW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MethodHandle lstrcpynW$handle() {
        return lstrcpynW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynW$address() {
        return lstrcpynW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynW(MemorySegment lpString1, MemorySegment lpString2, int iMaxLength) {
        var mh$ = lstrcpynW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpynW", lpString1, lpString2, iMaxLength);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2, iMaxLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcpyA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcpyA$descriptor() {
        return lstrcpyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcpyA$handle() {
        return lstrcpyA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyA$address() {
        return lstrcpyA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcpyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpyA", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcpyW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcpyW$descriptor() {
        return lstrcpyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcpyW$handle() {
        return lstrcpyW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyW$address() {
        return lstrcpyW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcpyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpyW", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcatA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcatA$descriptor() {
        return lstrcatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcatA$handle() {
        return lstrcatA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatA$address() {
        return lstrcatA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcatA", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrcatW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcatW$descriptor() {
        return lstrcatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcatW$handle() {
        return lstrcatW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatW$address() {
        return lstrcatW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcatW", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrlenA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrlenA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor lstrlenA$descriptor() {
        return lstrlenA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static MethodHandle lstrlenA$handle() {
        return lstrlenA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static MemorySegment lstrlenA$address() {
        return lstrlenA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static int lstrlenA(MemorySegment lpString) {
        var mh$ = lstrlenA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrlenA", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrlenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lstrlenW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor lstrlenW$descriptor() {
        return lstrlenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle lstrlenW$handle() {
        return lstrlenW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment lstrlenW$address() {
        return lstrlenW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static int lstrlenW(MemorySegment lpString) {
        var mh$ = lstrlenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrlenW", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static FunctionDescriptor OpenFile$descriptor() {
        return OpenFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static MethodHandle OpenFile$handle() {
        return OpenFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static MemorySegment OpenFile$address() {
        return OpenFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static int OpenFile(MemorySegment lpFileName, MemorySegment lpReOpenBuff, int uStyle) {
        var mh$ = OpenFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFile", lpFileName, lpReOpenBuff, uStyle);
            }
            return (int)mh$.invokeExact(lpFileName, lpReOpenBuff, uStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static FunctionDescriptor _lopen$descriptor() {
        return _lopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static MethodHandle _lopen$handle() {
        return _lopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static MemorySegment _lopen$address() {
        return _lopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static int _lopen(MemorySegment lpPathName, int iReadWrite) {
        var mh$ = _lopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lopen", lpPathName, iReadWrite);
            }
            return (int)mh$.invokeExact(lpPathName, iReadWrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lcreat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lcreat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static FunctionDescriptor _lcreat$descriptor() {
        return _lcreat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static MethodHandle _lcreat$handle() {
        return _lcreat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static MemorySegment _lcreat$address() {
        return _lcreat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static int _lcreat(MemorySegment lpPathName, int iAttribute) {
        var mh$ = _lcreat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lcreat", lpPathName, iAttribute);
            }
            return (int)mh$.invokeExact(lpPathName, iAttribute);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static FunctionDescriptor _lread$descriptor() {
        return _lread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static MethodHandle _lread$handle() {
        return _lread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static MemorySegment _lread$address() {
        return _lread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static int _lread(int hFile, MemorySegment lpBuffer, int uBytes) {
        var mh$ = _lread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lread", hFile, lpBuffer, uBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static FunctionDescriptor _lwrite$descriptor() {
        return _lwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static MethodHandle _lwrite$handle() {
        return _lwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static MemorySegment _lwrite$address() {
        return _lwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static int _lwrite(int hFile, MemorySegment lpBuffer, int uBytes) {
        var mh$ = _lwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lwrite", hFile, lpBuffer, uBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_hread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static FunctionDescriptor _hread$descriptor() {
        return _hread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static MethodHandle _hread$handle() {
        return _hread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static MemorySegment _hread$address() {
        return _hread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static int _hread(int hFile, MemorySegment lpBuffer, int lBytes) {
        var mh$ = _hread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hread", hFile, lpBuffer, lBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, lBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_hwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static FunctionDescriptor _hwrite$descriptor() {
        return _hwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static MethodHandle _hwrite$handle() {
        return _hwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static MemorySegment _hwrite$address() {
        return _hwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static int _hwrite(int hFile, MemorySegment lpBuffer, int lBytes) {
        var mh$ = _hwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hwrite", hFile, lpBuffer, lBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, lBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_lclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static FunctionDescriptor _lclose$descriptor() {
        return _lclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static MethodHandle _lclose$handle() {
        return _lclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static MemorySegment _lclose$address() {
        return _lclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static int _lclose(int hFile) {
        var mh$ = _lclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lclose", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _llseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_llseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static FunctionDescriptor _llseek$descriptor() {
        return _llseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static MethodHandle _llseek$handle() {
        return _llseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static MemorySegment _llseek$address() {
        return _llseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static int _llseek(int hFile, int lOffset, int iOrigin) {
        var mh$ = _llseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_llseek", hFile, lOffset, iOrigin);
            }
            return (int)mh$.invokeExact(hFile, lOffset, iOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTextUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsTextUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static FunctionDescriptor IsTextUnicode$descriptor() {
        return IsTextUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static MethodHandle IsTextUnicode$handle() {
        return IsTextUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static MemorySegment IsTextUnicode$address() {
        return IsTextUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static int IsTextUnicode(MemorySegment lpv, int iSize, MemorySegment lpiResult) {
        var mh$ = IsTextUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTextUnicode", lpv, iSize, lpiResult);
            }
            return (int)mh$.invokeExact(lpv, iSize, lpiResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BackupRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupRead$descriptor() {
        return BackupRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupRead$handle() {
        return BackupRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MemorySegment BackupRead$address() {
        return BackupRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static int BackupRead(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, int bAbort, int bProcessSecurity, MemorySegment lpContext) {
        var mh$ = BackupRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupRead", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupSeek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BackupSeek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupSeek$descriptor() {
        return BackupSeek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupSeek$handle() {
        return BackupSeek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static MemorySegment BackupSeek$address() {
        return BackupSeek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static int BackupSeek(MemorySegment hFile, int dwLowBytesToSeek, int dwHighBytesToSeek, MemorySegment lpdwLowByteSeeked, MemorySegment lpdwHighByteSeeked, MemorySegment lpContext) {
        var mh$ = BackupSeek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupSeek", hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext);
            }
            return (int)mh$.invokeExact(hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BackupWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupWrite$descriptor() {
        return BackupWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupWrite$handle() {
        return BackupWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MemorySegment BackupWrite$address() {
        return BackupWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static int BackupWrite(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, int bAbort, int bProcessSecurity, MemorySegment lpContext) {
        var mh$ = BackupWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupWrite", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_STREAM_ID {
     *     DWORD dwStreamId;
     *     DWORD dwStreamAttributes;
     *     LARGE_INTEGER Size;
     *     DWORD dwStreamNameSize;
     *     WCHAR cStreamName[1];
     * } *LPWIN32_STREAM_ID
     * }
     */
    public static final AddressLayout LPWIN32_STREAM_ID = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOEXA {
     *     STARTUPINFOA StartupInfo;
     *     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
     * } *LPSTARTUPINFOEXA
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEXA = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOEXW {
     *     STARTUPINFOW StartupInfo;
     *     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
     * } *LPSTARTUPINFOEXW
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEXW = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEX = freeglut_h.C_POINTER;

    private static class OpenMutexA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenMutexA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenMutexA$descriptor() {
        return OpenMutexA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenMutexA$handle() {
        return OpenMutexA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexA$address() {
        return OpenMutexA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenMutexA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenMutexA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSemaphoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreA$descriptor() {
        return CreateSemaphoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateSemaphoreA$handle() {
        return CreateSemaphoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreA$address() {
        return CreateSemaphoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreA(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName) {
        var mh$ = CreateSemaphoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreA", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSemaphoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenSemaphoreA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenSemaphoreA$descriptor() {
        return OpenSemaphoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenSemaphoreA$handle() {
        return OpenSemaphoreA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreA$address() {
        return OpenSemaphoreA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenSemaphoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSemaphoreA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWaitableTimerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerA$descriptor() {
        return CreateWaitableTimerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MethodHandle CreateWaitableTimerA$handle() {
        return CreateWaitableTimerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerA$address() {
        return CreateWaitableTimerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerA(MemorySegment lpTimerAttributes, int bManualReset, MemorySegment lpTimerName) {
        var mh$ = CreateWaitableTimerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerA", lpTimerAttributes, bManualReset, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, bManualReset, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWaitableTimerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenWaitableTimerA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor OpenWaitableTimerA$descriptor() {
        return OpenWaitableTimerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MethodHandle OpenWaitableTimerA$handle() {
        return OpenWaitableTimerA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerA$address() {
        return OpenWaitableTimerA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpTimerName) {
        var mh$ = OpenWaitableTimerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWaitableTimerA", dwDesiredAccess, bInheritHandle, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateSemaphoreExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreExA$descriptor() {
        return CreateSemaphoreExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateSemaphoreExA$handle() {
        return CreateSemaphoreExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExA$address() {
        return CreateSemaphoreExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExA(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateSemaphoreExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreExA", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateWaitableTimerExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerExA$descriptor() {
        return CreateWaitableTimerExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateWaitableTimerExA$handle() {
        return CreateWaitableTimerExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExA$address() {
        return CreateWaitableTimerExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExA(MemorySegment lpTimerAttributes, MemorySegment lpTimerName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateWaitableTimerExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerExA", lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileMappingA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateFileMappingA$descriptor() {
        return CreateFileMappingA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateFileMappingA$handle() {
        return CreateFileMappingA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingA$address() {
        return CreateFileMappingA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingA(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName) {
        var mh$ = CreateFileMappingA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingA", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingNumaA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("CreateFileMappingNumaA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor CreateFileMappingNumaA$descriptor() {
        return CreateFileMappingNumaA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MethodHandle CreateFileMappingNumaA$handle() {
        return CreateFileMappingNumaA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaA$address() {
        return CreateFileMappingNumaA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaA(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName, int nndPreferred) {
        var mh$ = CreateFileMappingNumaA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingNumaA", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("OpenFileMappingA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenFileMappingA$descriptor() {
        return OpenFileMappingA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenFileMappingA$handle() {
        return OpenFileMappingA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingA$address() {
        return OpenFileMappingA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenFileMappingA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDriveStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetLogicalDriveStringsA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetLogicalDriveStringsA$descriptor() {
        return GetLogicalDriveStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetLogicalDriveStringsA$handle() {
        return GetLogicalDriveStringsA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MemorySegment GetLogicalDriveStringsA$address() {
        return GetLogicalDriveStringsA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetLogicalDriveStringsA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetLogicalDriveStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDriveStringsA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadPackagedLibrary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("LoadPackagedLibrary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor LoadPackagedLibrary$descriptor() {
        return LoadPackagedLibrary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MethodHandle LoadPackagedLibrary$handle() {
        return LoadPackagedLibrary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MemorySegment LoadPackagedLibrary$address() {
        return LoadPackagedLibrary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MemorySegment LoadPackagedLibrary(MemorySegment lpwLibFileName, int Reserved) {
        var mh$ = LoadPackagedLibrary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadPackagedLibrary", lpwLibFileName, Reserved);
            }
            return (MemorySegment)mh$.invokeExact(lpwLibFileName, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryFullProcessImageNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryFullProcessImageNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor QueryFullProcessImageNameA$descriptor() {
        return QueryFullProcessImageNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MethodHandle QueryFullProcessImageNameA$handle() {
        return QueryFullProcessImageNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MemorySegment QueryFullProcessImageNameA$address() {
        return QueryFullProcessImageNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static int QueryFullProcessImageNameA(MemorySegment hProcess, int dwFlags, MemorySegment lpExeName, MemorySegment lpdwSize) {
        var mh$ = QueryFullProcessImageNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryFullProcessImageNameA", hProcess, dwFlags, lpExeName, lpdwSize);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags, lpExeName, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryFullProcessImageNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("QueryFullProcessImageNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor QueryFullProcessImageNameW$descriptor() {
        return QueryFullProcessImageNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MethodHandle QueryFullProcessImageNameW$handle() {
        return QueryFullProcessImageNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MemorySegment QueryFullProcessImageNameW$address() {
        return QueryFullProcessImageNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static int QueryFullProcessImageNameW(MemorySegment hProcess, int dwFlags, MemorySegment lpExeName, MemorySegment lpdwSize) {
        var mh$ = QueryFullProcessImageNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryFullProcessImageNameW", hProcess, dwFlags, lpExeName, lpdwSize);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags, lpExeName, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ProcThreadAttributeParentProcess = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeParentProcess = 0
     * }
     */
    public static int ProcThreadAttributeParentProcess() {
        return ProcThreadAttributeParentProcess;
    }
    private static final int ProcThreadAttributeHandleList = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeHandleList = 2
     * }
     */
    public static int ProcThreadAttributeHandleList() {
        return ProcThreadAttributeHandleList;
    }
    private static final int ProcThreadAttributeGroupAffinity = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeGroupAffinity = 3
     * }
     */
    public static int ProcThreadAttributeGroupAffinity() {
        return ProcThreadAttributeGroupAffinity;
    }
    private static final int ProcThreadAttributePreferredNode = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePreferredNode = 4
     * }
     */
    public static int ProcThreadAttributePreferredNode() {
        return ProcThreadAttributePreferredNode;
    }
    private static final int ProcThreadAttributeIdealProcessor = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeIdealProcessor = 5
     * }
     */
    public static int ProcThreadAttributeIdealProcessor() {
        return ProcThreadAttributeIdealProcessor;
    }
    private static final int ProcThreadAttributeUmsThread = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeUmsThread = 6
     * }
     */
    public static int ProcThreadAttributeUmsThread() {
        return ProcThreadAttributeUmsThread;
    }
    private static final int ProcThreadAttributeMitigationPolicy = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationPolicy = 7
     * }
     */
    public static int ProcThreadAttributeMitigationPolicy() {
        return ProcThreadAttributeMitigationPolicy;
    }
    private static final int ProcThreadAttributeSecurityCapabilities = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSecurityCapabilities = 9
     * }
     */
    public static int ProcThreadAttributeSecurityCapabilities() {
        return ProcThreadAttributeSecurityCapabilities;
    }
    private static final int ProcThreadAttributeProtectionLevel = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeProtectionLevel = 11
     * }
     */
    public static int ProcThreadAttributeProtectionLevel() {
        return ProcThreadAttributeProtectionLevel;
    }
    private static final int ProcThreadAttributeJobList = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeJobList = 13
     * }
     */
    public static int ProcThreadAttributeJobList() {
        return ProcThreadAttributeJobList;
    }
    private static final int ProcThreadAttributeChildProcessPolicy = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeChildProcessPolicy = 14
     * }
     */
    public static int ProcThreadAttributeChildProcessPolicy() {
        return ProcThreadAttributeChildProcessPolicy;
    }
    private static final int ProcThreadAttributeAllApplicationPackagesPolicy = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeAllApplicationPackagesPolicy = 15
     * }
     */
    public static int ProcThreadAttributeAllApplicationPackagesPolicy() {
        return ProcThreadAttributeAllApplicationPackagesPolicy;
    }
    private static final int ProcThreadAttributeWin32kFilter = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeWin32kFilter = 16
     * }
     */
    public static int ProcThreadAttributeWin32kFilter() {
        return ProcThreadAttributeWin32kFilter;
    }
    private static final int ProcThreadAttributeSafeOpenPromptOriginClaim = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSafeOpenPromptOriginClaim = 17
     * }
     */
    public static int ProcThreadAttributeSafeOpenPromptOriginClaim() {
        return ProcThreadAttributeSafeOpenPromptOriginClaim;
    }
    private static final int ProcThreadAttributeDesktopAppPolicy = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeDesktopAppPolicy = 18
     * }
     */
    public static int ProcThreadAttributeDesktopAppPolicy() {
        return ProcThreadAttributeDesktopAppPolicy;
    }
    private static final int ProcThreadAttributePseudoConsole = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePseudoConsole = 22
     * }
     */
    public static int ProcThreadAttributePseudoConsole() {
        return ProcThreadAttributePseudoConsole;
    }
    private static final int ProcThreadAttributeMitigationAuditPolicy = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationAuditPolicy = 24
     * }
     */
    public static int ProcThreadAttributeMitigationAuditPolicy() {
        return ProcThreadAttributeMitigationAuditPolicy;
    }

    private static class GetStartupInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetStartupInfoA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static FunctionDescriptor GetStartupInfoA$descriptor() {
        return GetStartupInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static MethodHandle GetStartupInfoA$handle() {
        return GetStartupInfoA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static MemorySegment GetStartupInfoA$address() {
        return GetStartupInfoA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static void GetStartupInfoA(MemorySegment lpStartupInfo) {
        var mh$ = GetStartupInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStartupInfoA", lpStartupInfo);
            }
            mh$.invokeExact(lpStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFirmwareEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableA$descriptor() {
        return GetFirmwareEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableA$handle() {
        return GetFirmwareEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableA$address() {
        return GetFirmwareEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static int GetFirmwareEnvironmentVariableA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize) {
        var mh$ = GetFirmwareEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableA", lpName, lpGuid, pBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFirmwareEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableW$descriptor() {
        return GetFirmwareEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableW$handle() {
        return GetFirmwareEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableW$address() {
        return GetFirmwareEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static int GetFirmwareEnvironmentVariableW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize) {
        var mh$ = GetFirmwareEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableW", lpName, lpGuid, pBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFirmwareEnvironmentVariableExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableExA$descriptor() {
        return GetFirmwareEnvironmentVariableExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableExA$handle() {
        return GetFirmwareEnvironmentVariableExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableExA$address() {
        return GetFirmwareEnvironmentVariableExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static int GetFirmwareEnvironmentVariableExA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize, MemorySegment pdwAttribubutes) {
        var mh$ = GetFirmwareEnvironmentVariableExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableExA", lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFirmwareEnvironmentVariableExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableExW$descriptor() {
        return GetFirmwareEnvironmentVariableExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableExW$handle() {
        return GetFirmwareEnvironmentVariableExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MemorySegment GetFirmwareEnvironmentVariableExW$address() {
        return GetFirmwareEnvironmentVariableExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static int GetFirmwareEnvironmentVariableExW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize, MemorySegment pdwAttribubutes) {
        var mh$ = GetFirmwareEnvironmentVariableExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableExW", lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFirmwareEnvironmentVariableA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableA$descriptor() {
        return SetFirmwareEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableA$handle() {
        return SetFirmwareEnvironmentVariableA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableA$address() {
        return SetFirmwareEnvironmentVariableA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static int SetFirmwareEnvironmentVariableA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize) {
        var mh$ = SetFirmwareEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableA", lpName, lpGuid, pValue, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFirmwareEnvironmentVariableW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableW$descriptor() {
        return SetFirmwareEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableW$handle() {
        return SetFirmwareEnvironmentVariableW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableW$address() {
        return SetFirmwareEnvironmentVariableW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static int SetFirmwareEnvironmentVariableW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize) {
        var mh$ = SetFirmwareEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableW", lpName, lpGuid, pValue, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFirmwareEnvironmentVariableExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableExA$descriptor() {
        return SetFirmwareEnvironmentVariableExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableExA$handle() {
        return SetFirmwareEnvironmentVariableExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableExA$address() {
        return SetFirmwareEnvironmentVariableExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static int SetFirmwareEnvironmentVariableExA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize, int dwAttributes) {
        var mh$ = SetFirmwareEnvironmentVariableExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableExA", lpName, lpGuid, pValue, nSize, dwAttributes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize, dwAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("SetFirmwareEnvironmentVariableExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableExW$descriptor() {
        return SetFirmwareEnvironmentVariableExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableExW$handle() {
        return SetFirmwareEnvironmentVariableExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MemorySegment SetFirmwareEnvironmentVariableExW$address() {
        return SetFirmwareEnvironmentVariableExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static int SetFirmwareEnvironmentVariableExW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize, int dwAttributes) {
        var mh$ = SetFirmwareEnvironmentVariableExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableExW", lpName, lpGuid, pValue, nSize, dwAttributes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize, dwAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetFirmwareType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static FunctionDescriptor GetFirmwareType$descriptor() {
        return GetFirmwareType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static MethodHandle GetFirmwareType$handle() {
        return GetFirmwareType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static MemorySegment GetFirmwareType$address() {
        return GetFirmwareType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static int GetFirmwareType(MemorySegment FirmwareType) {
        var mh$ = GetFirmwareType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareType", FirmwareType);
            }
            return (int)mh$.invokeExact(FirmwareType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNativeVhdBoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("IsNativeVhdBoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static FunctionDescriptor IsNativeVhdBoot$descriptor() {
        return IsNativeVhdBoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static MethodHandle IsNativeVhdBoot$handle() {
        return IsNativeVhdBoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static MemorySegment IsNativeVhdBoot$address() {
        return IsNativeVhdBoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static int IsNativeVhdBoot(MemorySegment NativeVhdBoot) {
        var mh$ = IsNativeVhdBoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNativeVhdBoot", NativeVhdBoot);
            }
            return (int)mh$.invokeExact(NativeVhdBoot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static FunctionDescriptor FindResourceA$descriptor() {
        return FindResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MethodHandle FindResourceA$handle() {
        return FindResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MemorySegment FindResourceA$address() {
        return FindResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MemorySegment FindResourceA(MemorySegment hModule, MemorySegment lpName, MemorySegment lpType) {
        var mh$ = FindResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceA", hModule, lpName, lpType);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpName, lpType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindResourceExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static FunctionDescriptor FindResourceExA$descriptor() {
        return FindResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MethodHandle FindResourceExA$handle() {
        return FindResourceExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExA$address() {
        return FindResourceExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, short wLanguage) {
        var mh$ = FindResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceExA", hModule, lpType, lpName, wLanguage);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpType, lpName, wLanguage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceTypesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesA$descriptor() {
        return EnumResourceTypesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceTypesA$handle() {
        return EnumResourceTypesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceTypesA$address() {
        return EnumResourceTypesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceTypesA(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceTypesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesA", hModule, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceTypesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesW$descriptor() {
        return EnumResourceTypesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceTypesW$handle() {
        return EnumResourceTypesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceTypesW$address() {
        return EnumResourceTypesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceTypesW(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceTypesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesW", hModule, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceNamesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesA$descriptor() {
        return EnumResourceNamesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceNamesA$handle() {
        return EnumResourceNamesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceNamesA$address() {
        return EnumResourceNamesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceNamesA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceNamesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesA", hModule, lpType, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceLanguagesA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesA$descriptor() {
        return EnumResourceLanguagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceLanguagesA$handle() {
        return EnumResourceLanguagesA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceLanguagesA$address() {
        return EnumResourceLanguagesA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceLanguagesA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceLanguagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesA", hModule, lpType, lpName, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EnumResourceLanguagesW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesW$descriptor() {
        return EnumResourceLanguagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceLanguagesW$handle() {
        return EnumResourceLanguagesW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MemorySegment EnumResourceLanguagesW$address() {
        return EnumResourceLanguagesW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceLanguagesW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceLanguagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesW", hModule, lpType, lpName, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginUpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BeginUpdateResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static FunctionDescriptor BeginUpdateResourceA$descriptor() {
        return BeginUpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MethodHandle BeginUpdateResourceA$handle() {
        return BeginUpdateResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceA$address() {
        return BeginUpdateResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceA(MemorySegment pFileName, int bDeleteExistingResources) {
        var mh$ = BeginUpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginUpdateResourceA", pFileName, bDeleteExistingResources);
            }
            return (MemorySegment)mh$.invokeExact(pFileName, bDeleteExistingResources);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginUpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("BeginUpdateResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static FunctionDescriptor BeginUpdateResourceW$descriptor() {
        return BeginUpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MethodHandle BeginUpdateResourceW$handle() {
        return BeginUpdateResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceW$address() {
        return BeginUpdateResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceW(MemorySegment pFileName, int bDeleteExistingResources) {
        var mh$ = BeginUpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginUpdateResourceW", pFileName, bDeleteExistingResources);
            }
            return (MemorySegment)mh$.invokeExact(pFileName, bDeleteExistingResources);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static FunctionDescriptor UpdateResourceA$descriptor() {
        return UpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MethodHandle UpdateResourceA$handle() {
        return UpdateResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MemorySegment UpdateResourceA$address() {
        return UpdateResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static int UpdateResourceA(MemorySegment hUpdate, MemorySegment lpType, MemorySegment lpName, short wLanguage, MemorySegment lpData, int cb) {
        var mh$ = UpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateResourceA", hUpdate, lpType, lpName, wLanguage, lpData, cb);
            }
            return (int)mh$.invokeExact(hUpdate, lpType, lpName, wLanguage, lpData, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("UpdateResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static FunctionDescriptor UpdateResourceW$descriptor() {
        return UpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MethodHandle UpdateResourceW$handle() {
        return UpdateResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MemorySegment UpdateResourceW$address() {
        return UpdateResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static int UpdateResourceW(MemorySegment hUpdate, MemorySegment lpType, MemorySegment lpName, short wLanguage, MemorySegment lpData, int cb) {
        var mh$ = UpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateResourceW", hUpdate, lpType, lpName, wLanguage, lpData, cb);
            }
            return (int)mh$.invokeExact(hUpdate, lpType, lpName, wLanguage, lpData, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndUpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndUpdateResourceA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static FunctionDescriptor EndUpdateResourceA$descriptor() {
        return EndUpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MethodHandle EndUpdateResourceA$handle() {
        return EndUpdateResourceA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MemorySegment EndUpdateResourceA$address() {
        return EndUpdateResourceA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static int EndUpdateResourceA(MemorySegment hUpdate, int fDiscard) {
        var mh$ = EndUpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndUpdateResourceA", hUpdate, fDiscard);
            }
            return (int)mh$.invokeExact(hUpdate, fDiscard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndUpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("EndUpdateResourceW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static FunctionDescriptor EndUpdateResourceW$descriptor() {
        return EndUpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MethodHandle EndUpdateResourceW$handle() {
        return EndUpdateResourceW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MemorySegment EndUpdateResourceW$address() {
        return EndUpdateResourceW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static int EndUpdateResourceW(MemorySegment hUpdate, int fDiscard) {
        var mh$ = EndUpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndUpdateResourceW", hUpdate, fDiscard);
            }
            return (int)mh$.invokeExact(hUpdate, fDiscard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalAddAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomA$descriptor() {
        return GlobalAddAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle GlobalAddAtomA$handle() {
        return GlobalAddAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment GlobalAddAtomA$address() {
        return GlobalAddAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static short GlobalAddAtomA(MemorySegment lpString) {
        var mh$ = GlobalAddAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalAddAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomW$descriptor() {
        return GlobalAddAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle GlobalAddAtomW$handle() {
        return GlobalAddAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment GlobalAddAtomW$address() {
        return GlobalAddAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static short GlobalAddAtomW(MemorySegment lpString) {
        var mh$ = GlobalAddAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalAddAtomExA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomExA$descriptor() {
        return GlobalAddAtomExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static MethodHandle GlobalAddAtomExA$handle() {
        return GlobalAddAtomExA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static MemorySegment GlobalAddAtomExA$address() {
        return GlobalAddAtomExA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static short GlobalAddAtomExA(MemorySegment lpString, int Flags) {
        var mh$ = GlobalAddAtomExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomExA", lpString, Flags);
            }
            return (short)mh$.invokeExact(lpString, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalAddAtomExW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomExW$descriptor() {
        return GlobalAddAtomExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static MethodHandle GlobalAddAtomExW$handle() {
        return GlobalAddAtomExW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static MemorySegment GlobalAddAtomExW$address() {
        return GlobalAddAtomExW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static short GlobalAddAtomExW(MemorySegment lpString, int Flags) {
        var mh$ = GlobalAddAtomExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomExW", lpString, Flags);
            }
            return (short)mh$.invokeExact(lpString, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFindAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalFindAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalFindAtomA$descriptor() {
        return GlobalFindAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle GlobalFindAtomA$handle() {
        return GlobalFindAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment GlobalFindAtomA$address() {
        return GlobalFindAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static short GlobalFindAtomA(MemorySegment lpString) {
        var mh$ = GlobalFindAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFindAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFindAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalFindAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalFindAtomW$descriptor() {
        return GlobalFindAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle GlobalFindAtomW$handle() {
        return GlobalFindAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment GlobalFindAtomW$address() {
        return GlobalFindAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static short GlobalFindAtomW(MemorySegment lpString) {
        var mh$ = GlobalFindAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFindAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalGetAtomNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalGetAtomNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GlobalGetAtomNameA$descriptor() {
        return GlobalGetAtomNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GlobalGetAtomNameA$handle() {
        return GlobalGetAtomNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GlobalGetAtomNameA$address() {
        return GlobalGetAtomNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static int GlobalGetAtomNameA(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GlobalGetAtomNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalGetAtomNameA", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalGetAtomNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GlobalGetAtomNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GlobalGetAtomNameW$descriptor() {
        return GlobalGetAtomNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GlobalGetAtomNameW$handle() {
        return GlobalGetAtomNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GlobalGetAtomNameW$address() {
        return GlobalGetAtomNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static int GlobalGetAtomNameW(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GlobalGetAtomNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalGetAtomNameW", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor AddAtomA$descriptor() {
        return AddAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle AddAtomA$handle() {
        return AddAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment AddAtomA$address() {
        return AddAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static short AddAtomA(MemorySegment lpString) {
        var mh$ = AddAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("AddAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor AddAtomW$descriptor() {
        return AddAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle AddAtomW$handle() {
        return AddAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment AddAtomW$address() {
        return AddAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static short AddAtomW(MemorySegment lpString) {
        var mh$ = AddAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindAtomA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor FindAtomA$descriptor() {
        return FindAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle FindAtomA$handle() {
        return FindAtomA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static MemorySegment FindAtomA$address() {
        return FindAtomA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static short FindAtomA(MemorySegment lpString) {
        var mh$ = FindAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("FindAtomW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor FindAtomW$descriptor() {
        return FindAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle FindAtomW$handle() {
        return FindAtomW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static MemorySegment FindAtomW$address() {
        return FindAtomW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static short FindAtomW(MemorySegment lpString) {
        var mh$ = FindAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAtomNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAtomNameA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GetAtomNameA$descriptor() {
        return GetAtomNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GetAtomNameA$handle() {
        return GetAtomNameA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GetAtomNameA$address() {
        return GetAtomNameA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static int GetAtomNameA(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetAtomNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAtomNameA", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAtomNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetAtomNameW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GetAtomNameW$descriptor() {
        return GetAtomNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GetAtomNameW$handle() {
        return GetAtomNameW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MemorySegment GetAtomNameW$address() {
        return GetAtomNameW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static int GetAtomNameW(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetAtomNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAtomNameW", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileIntA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProfileIntA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static FunctionDescriptor GetProfileIntA$descriptor() {
        return GetProfileIntA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static MethodHandle GetProfileIntA$handle() {
        return GetProfileIntA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static MemorySegment GetProfileIntA$address() {
        return GetProfileIntA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static int GetProfileIntA(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault) {
        var mh$ = GetProfileIntA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileIntA", lpAppName, lpKeyName, nDefault);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileIntW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProfileIntW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static FunctionDescriptor GetProfileIntW$descriptor() {
        return GetProfileIntW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static MethodHandle GetProfileIntW$handle() {
        return GetProfileIntW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static MemorySegment GetProfileIntW$address() {
        return GetProfileIntW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static int GetProfileIntW(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault) {
        var mh$ = GetProfileIntW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileIntW", lpAppName, lpKeyName, nDefault);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileStringA$descriptor() {
        return GetProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileStringA$handle() {
        return GetProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileStringA$address() {
        return GetProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileStringA", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileStringW$descriptor() {
        return GetProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileStringW$handle() {
        return GetProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileStringW$address() {
        return GetProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileStringW", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileStringA$descriptor() {
        return WriteProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileStringA$handle() {
        return WriteProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileStringA$address() {
        return WriteProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static int WriteProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString) {
        var mh$ = WriteProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileStringA", lpAppName, lpKeyName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteProfileStringW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileStringW$descriptor() {
        return WriteProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileStringW$handle() {
        return WriteProfileStringW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileStringW$address() {
        return WriteProfileStringW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static int WriteProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString) {
        var mh$ = WriteProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileStringW", lpAppName, lpKeyName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileSectionA$descriptor() {
        return GetProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileSectionA$handle() {
        return GetProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileSectionA$address() {
        return GetProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileSectionA(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileSectionA", lpAppName, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileSectionW$descriptor() {
        return GetProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileSectionW$handle() {
        return GetProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MemorySegment GetProfileSectionW$address() {
        return GetProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileSectionW(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileSectionW", lpAppName, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteProfileSectionA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileSectionA$descriptor() {
        return WriteProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileSectionA$handle() {
        return WriteProfileSectionA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileSectionA$address() {
        return WriteProfileSectionA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static int WriteProfileSectionA(MemorySegment lpAppName, MemorySegment lpString) {
        var mh$ = WriteProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileSectionA", lpAppName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("WriteProfileSectionW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileSectionW$descriptor() {
        return WriteProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileSectionW$handle() {
        return WriteProfileSectionW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static MemorySegment WriteProfileSectionW$address() {
        return WriteProfileSectionW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static int WriteProfileSectionW(MemorySegment lpAppName, MemorySegment lpString) {
        var mh$ = WriteProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileSectionW", lpAppName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileIntA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileIntA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileIntA$descriptor() {
        return GetPrivateProfileIntA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileIntA$handle() {
        return GetPrivateProfileIntA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileIntA$address() {
        return GetPrivateProfileIntA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileIntA(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileIntA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileIntA", lpAppName, lpKeyName, nDefault, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileIntW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileIntW");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileIntW$descriptor() {
        return GetPrivateProfileIntW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileIntW$handle() {
        return GetPrivateProfileIntW.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileIntW$address() {
        return GetPrivateProfileIntW.ADDR;
    }

    /**
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileIntW(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileIntW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileIntW", lpAppName, lpKeyName, nDefault, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("GetPrivateProfileStringA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStringA$descriptor() {
        return GetPrivateProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileStringA$handle() {
        return GetPrivateProfileStringA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment GetPrivateProfileStringA$address() {
        return GetPrivateProfileStringA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStringA", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

